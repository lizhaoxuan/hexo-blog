{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpeg","path":"uploads/avatar.jpeg","modified":0,"renderable":0},{"_id":"source/uploads/github.jpg","path":"uploads/github.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1546397650904},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1470715068000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1546397650905},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1546397650906},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1470715068000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1546397650906},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1470715068000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1546397650906},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1546397650906},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1546397650906},{"_id":"themes/next/_config.yml","hash":"ec314c5e0340f9586c5915f3420700575083b038","modified":1491015355000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1470715068000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1470715068000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1546397650906},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1470715068000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1470715068000},{"_id":"source/_posts/AccessibilityService分析与防御.md","hash":"74593e7afb2ac40cf1a4fa035e716bb85091b607","modified":1546394971817},{"_id":"source/_posts/AndroidCoding-performance-specification.md","hash":"b099d84e7e1c50a8f1bfb423dc810551c01e6a5a","modified":1546394971825},{"_id":"source/_posts/Calabash探索1-Run Calabash.md","hash":"fcbf3f9b8dd2dfe2abbd1c131bfdce26a53772be","modified":1546394971826},{"_id":"source/_posts/Calabash探索2-Calabash用法详解.md","hash":"422301adf3a77404311dabab45f88bd017fb3157","modified":1546394971826},{"_id":"source/_posts/Calabash探索3-Calabash进阶.md","hash":"a59bb154f3ab38fd15cb5a63ea3c4bb132d4c3b7","modified":1546394971827},{"_id":"source/_posts/Calabash探索4-Calabash踩坑总结.md","hash":"c4941ecdd74ae5a3a4296c82c34b35921ad976ad","modified":1546394971828},{"_id":"source/_posts/Java内存管理的一些小疑问.md","hash":"257a751e2f48c5de449e24a2099bc4d21de81720","modified":1546394971828},{"_id":"source/_posts/SoftWidget.md","hash":"cee089ae1c60c54ee13550291e7ff3280c8f3a7e","modified":1546394971831},{"_id":"source/_posts/android-rendering-performance-optimization.md","hash":"c8c8cf9c0dfb2e2a53603f812349992f9e363bb5","modified":1546394971831},{"_id":"source/_posts/apt-Climbed-out-of-the-pit.md","hash":"4ec241c0a6c49c06db629e790fb328dd236b235f","modified":1546394971832},{"_id":"source/_posts/androidgcdiaoyan.md","hash":"88d98815cea4d204c5d7f87653998fa61388f81b","modified":1546394971832},{"_id":"source/_posts/apt-run_demo.md","hash":"2a6375bbd2f8a14552e2ec632fd88dbdfdffa60e","modified":1546394971833},{"_id":"source/_posts/apt-Grammar-explanation.md","hash":"018cdddc955be240a6d1b9fcb111fde60d6ae59b","modified":1546394971833},{"_id":"source/_posts/apt-run_project.md","hash":"468b287d62ba6eacbe3e367423a4ab19b00f3106","modified":1546394971834},{"_id":"source/_posts/apt-wathapt.md","hash":"97f016f5f2a1a719722a7c7b2ddec397bb20d6b9","modified":1546394971834},{"_id":"source/_posts/apt_usage_scenario.md","hash":"846e16eff14fffb52c51a33eef487b493b410614","modified":1546394971835},{"_id":"source/_posts/小微团队怎么玩转App自动化测试.md","hash":"4c9f7258b3c259fcf699b2be3c7c09d9e1958b3b","modified":1546394971836},{"_id":"source/_posts/shenyingpojie.md","hash":"1f73ade0ed54ae51b90f120f87a0a011f3e3e263","modified":1546394971835},{"_id":"source/_posts/探索Bitmap使用姿势.md","hash":"72fdfbd97fb6f587a21dfcd5eb53d6b1eb7a93e2","modified":1546394971837},{"_id":"source/uploads/avatar.jpeg","hash":"e78b5a63bb05ad5023fd7785c73dce644ab44725","modified":1546394971881},{"_id":"source/uploads/github.jpg","hash":"5847934c28a6782834aeec7d6facc03af0b12109","modified":1546394971882},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1546397650899},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1546397650900},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1546397535934},{"_id":"themes/next/.git/index","hash":"77141b1f89cfe43c7e016c42f639ebbe172640df","modified":1517070531000},{"_id":"themes/next/.git/packed-refs","hash":"c260c6d28e96faeec8fe2ead52f6103d079e2f0c","modified":1470715068000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1470715068000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1470715068000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1546397650905},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1546397650905},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1470715068000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1470715068000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1470715068000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1470715068000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1470715068000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1546397650908},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1470715068000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1546397650908},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1546397650908},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1470715068000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1470715068000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1470715068000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1546397650909},{"_id":"themes/next/languages/zh-Hans.yml","hash":"fb9e42066d94d274fa3d796212a38ea6062d336e","modified":1470722912000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1470715068000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1470715068000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1470715068000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1470715068000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1470715068000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1470715068000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1470715068000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1470715068000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1546397650922},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1470715068000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1470715068000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1546397650923},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1546397650974},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1546397650974},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1546397650974},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650940},{"_id":"source/_posts/Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg","hash":"d0b909c3eec1ee0f1287df99cf955f9be82ae2fe","modified":1546394971827},{"_id":"source/_posts/探索Bitmap使用姿势/recycle.png","hash":"0149b01745116f961275b9881c0db42a3333823e","modified":1546394971870},{"_id":"source/_posts/探索Bitmap使用姿势/un_recycle.png","hash":"6c0b396521ae70f20da6202be0d3c5de43c1a4d4","modified":1546394971881},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1546397535935},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1546397535935},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1546397535935},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1546397535936},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1546397535935},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1546397535936},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1546397535936},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1546397535935},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1546397535936},{"_id":"themes/next/.git/logs/HEAD","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1470713932000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1470715068000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1546397650910},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546397650910},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546397650910},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1470715068000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1470715068000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1470715068000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1470715068000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1470715068000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1470715068000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1470715068000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1470715068000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1546397650912},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1546397650912},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1470715068000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1546397650914},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1546397650914},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1470715068000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1546397650919},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1546397650919},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1546397650919},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1546397650919},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1546397650919},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1546397650919},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1546397650920},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1546397650924},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1546397650924},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1546397650924},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1470715068000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1546397650924},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1546397650924},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1546397650925},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1546397650925},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1546397650925},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1546397650940},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1546397650941},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1546397650941},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1546397650941},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1546397650941},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1546397650941},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1546397650941},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1546397650942},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1546397650942},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1546397650942},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1546397650942},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1546397650942},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1546397650942},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546397650942},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1546397650943},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546397650943},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1546397650943},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1546397650943},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1546397650943},{"_id":"source/_posts/AccessibilityService分析与防御/accessibility流程图.png","hash":"17bef916afc685c993fae95ca2feea4171dc5a76","modified":1546394971822},{"_id":"source/_posts/AccessibilityService分析与防御/accessibility类图.png","hash":"7856604e3ea9ff1cdc9c7f8387620c86ef0d143a","modified":1546394971823},{"_id":"source/_posts/Java内存管理的一些小疑问/method_end.png","hash":"3105d0be4550222170448b6a4bdf3d739a3a3c8b","modified":1546394971829},{"_id":"source/_posts/Java内存管理的一些小疑问/method_start.png","hash":"afd5665bf016749a1b48dbdf988bb18df59b876c","modified":1546394971830},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ALPHA_8.png","hash":"2e886eced98db81a37f092b51268fd5d6a2b0f74","modified":1546394971849},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ARGB_4444.png","hash":"3feb77364422d4dbf7c35c666da0a51aa672d207","modified":1546394971850},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ARGB_8888.png","hash":"aec6deee426b6af1f500de140bad3e7b2779a493","modified":1546394971851},{"_id":"source/_posts/探索Bitmap使用姿势/DC_RGB_565.png","hash":"ecdadbe37cf6211fa9dfe8a82f95eb8d279e8554","modified":1546394971853},{"_id":"source/_posts/探索Bitmap使用姿势/old_list_view.jpg","hash":"6d1fd79d9fe90b04cf57ff898a9f5deac2d61133","modified":1546394971869},{"_id":"source/_posts/探索Bitmap使用姿势/new_take_photo.jpg","hash":"a46fe75eb76bc41cfe90d8ffb543d503c747a2d8","modified":1546394971868},{"_id":"source/_posts/探索Bitmap使用姿势/old_take_photo.jpg","hash":"88d4cbb7a7fe13472131c91c9523efbdfd3eb4a0","modified":1546394971870},{"_id":"source/_posts/探索Bitmap使用姿势/take_photo.png","hash":"21631f7f67340ad098b17fac83cdb67c1cb77213","modified":1546394971877},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650915},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650915},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650936},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650936},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650937},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650940},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546397650940},{"_id":"source/_posts/AccessibilityService分析与防御/accessibility整体流程.png","hash":"359fd09789470b53e28b0edb225843778333378f","modified":1546394971821},{"_id":"source/_posts/AccessibilityService分析与防御/外挂简史.png","hash":"484831018a39ded3015e082abe97ce4e9d52973b","modified":1546394971825},{"_id":"themes/next/.git/refs/heads/master","hash":"283a77b25951fbb3b2f10b4be4c80b6519ac6011","modified":1470715068000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1546397650912},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1546397650912},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1470715068000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1546397650913},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1546397650913},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1546397650914},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1470715068000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1546397650914},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1546397650914},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1546397650915},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1546397650915},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1546397650915},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1546397650915},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1546397650915},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1546397650916},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1546397650917},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1546397650917},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1546397650917},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1546397650917},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1546397650917},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1546397650918},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1546397650918},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1546397650920},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1546397650921},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1546397650921},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1546397650921},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1546397650936},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1470715068000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1546397650936},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1546397650940},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1470715068000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1470715068000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1470715068000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1546397650943},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1546397650943},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1470715068000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1546397650944},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1546397650944},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1546397650944},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1470715068000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1546397650945},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1470715068000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1546397650945},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1470715068000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1546397650950},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1546397650950},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1546397650950},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1546397650951},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1546397650953},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1546397650953},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1546397650948},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1546397650953},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1546397650954},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1546397650963},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1546397650954},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1546397650953},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1546397650954},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1546397650955},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1546397650954},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1546397650964},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1546397650964},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1546397650964},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1546397650964},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1546397650964},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1546397650965},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1546397650964},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1546397650965},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1546397650965},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1546397650966},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1546397650965},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1546397650966},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1546397650967},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1546397650967},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1546397650967},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1546397650967},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1546397650968},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1546397650968},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1546397650968},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1546397650967},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1546397650971},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1546397650971},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1546397650973},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1546397650973},{"_id":"source/_posts/AccessibilityService分析与防御/AccessibilityInteractionClient.png","hash":"dc6dbe4a6579eddb52176b776327f8965c719b13","modified":1546394971819},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1546397650974},{"_id":"source/_posts/探索Bitmap使用姿势/listview.png","hash":"27fd17023f574307d67b7cbdba96749e79d947c7","modified":1546394971859},{"_id":"source/_posts/探索Bitmap使用姿势/mhdpi_xxhdpi_150.png","hash":"c4871464e116b1c69d4bdf5eb63aaec13159454c","modified":1546394971867},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546397650963},{"_id":"source/_posts/探索Bitmap使用姿势/ARGB_4444.png","hash":"f13ff05f50a891da60b609b1a4a22b71cd044c4d","modified":1546394971844},{"_id":"source/_posts/探索Bitmap使用姿势/take_photo2.png","hash":"169f4db4f59a1971ee0277f1ae4c379980432637","modified":1546394971880},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1546397650898},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1546397650920},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1546397650920},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1546397650925},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1546397650926},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1546397650932},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1546397650935},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1546397650935},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1546397650936},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1546397650936},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1546397650937},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1546397650937},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1546397650937},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1546397650937},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1546397650937},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546397650938},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1546397650938},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1546397650938},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546397650939},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1546397650939},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1546397650939},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1470715068000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1470715068000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1546397650947},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1546397650951},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1546397650953},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1546397650953},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1546397650954},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1546397650948},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1546397650947},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1546397650955},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1546397650955},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1546397650955},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1546397650952},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1546397650954},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1546397650971},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1546397650971},{"_id":"source/_posts/探索Bitmap使用姿势/ARGB_8888.png","hash":"f6369b159de47508c00b5e1ce41c3ce8dd3528f6","modified":1546394971848},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1546397650947},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546397650963},{"_id":"source/_posts/探索Bitmap使用姿势/ALPHA_8.png","hash":"b444974e1643fba7cb377cf6b830b107929d2a87","modified":1546394971841},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546397650962},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1546397650973},{"_id":"source/_posts/探索Bitmap使用姿势/RGB_565.png","hash":"bdd4fe14f6e217d6d339a0412802038c5bd40623","modified":1546394971857},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1546397650926},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1546397650926},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1546397650926},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1546397650927},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1546397650927},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1546397650927},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1546397650928},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1546397650928},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1546397650928},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1546397650929},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1546397650929},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1546397650929},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1546397650930},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1546397650930},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1546397650930},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1546397650930},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1546397650930},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1546397650931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1546397650931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1546397650931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1546397650932},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1546397650932},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1546397650932},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1546397650932},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1546397650932},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1546397650933},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1546397650933},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1546397650933},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1546397650933},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1546397650934},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1546397650934},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1546397650934},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1546397650935},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1546397650934},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1546397650934},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1546397650938},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1470715068000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1546397650945},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1546397650946},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1546397650946},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1546397650946},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1546397650952},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1546397650952},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1546397650952},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1546397650952},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1546397650952},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1546397650952},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1546397650957},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1546397650962},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546397650958},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1546397650946},{"_id":"themes/next/.git/objects/pack/pack-e78a63f3a09865e7250207b0905ffdead8aa9427.idx","hash":"65b50d2dffe1c5cf0a1417c27529d6a6ba27c485","modified":1546397650890},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1546397650950},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1546397650970},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1546397650961},{"_id":"source/_posts/探索Bitmap使用姿势/mhdpi_xxhdpi.png","hash":"26bb6bb9eca18eb28b91b1e95e506776fe1f2f83","modified":1546394971864},{"_id":"source/_posts/探索Bitmap使用姿势/resource_assets.png","hash":"0901d3244882846c1ecb83fe10ae9b0e416c91b8","modified":1546394971876},{"_id":"themes/next/.git/objects/pack/pack-e78a63f3a09865e7250207b0905ffdead8aa9427.pack","hash":"06e88ac0b8a52ad03a9c234eec5462741115eaa8","modified":1546397650886},{"_id":"public/archives/page/2/index.html","hash":"36c3847a02ef8c5270a432da138c7bd243cc4d32","modified":1546409970052},{"_id":"public/archives/2015/index.html","hash":"bef34e599ca93f88aa1c580c28b5b60ca87313d2","modified":1546409970050},{"_id":"public/archives/2015/09/index.html","hash":"37021735805e270aa2b3578abccd4650ec0f071d","modified":1546409970051},{"_id":"public/archives/2016/index.html","hash":"fbe77eef3002223b99ec21174f0dd24a4096ba70","modified":1546409970052},{"_id":"public/archives/2016/01/index.html","hash":"81563f8efbfd9e3fd99b10c59ac83276ef76115a","modified":1546409970051},{"_id":"public/archives/2016/02/index.html","hash":"c7f46ff595a8b549c33de7ae0902812c913f8f1a","modified":1546409970051},{"_id":"public/archives/2016/03/index.html","hash":"370f2efa275206dae0a7adceee9ba30bec0a5c6e","modified":1546409970051},{"_id":"public/archives/2016/07/index.html","hash":"504e34784dbd9522edfac01ef1bd17bd60e40de9","modified":1546409970053},{"_id":"public/archives/2016/08/index.html","hash":"4bf863cfbdb8891832013515f98e3ee2f4611dd7","modified":1546409970051},{"_id":"public/archives/2017/index.html","hash":"e498fac70685338f988a5aa38b89b7a532db07fc","modified":1546409970054},{"_id":"public/archives/2017/03/index.html","hash":"d9e23bc1e4923c8c595a151dd567639462fc518d","modified":1546409970054},{"_id":"public/archives/2017/05/index.html","hash":"6f864fe38536ba8c28f743e1280b5d34dfdcc9fe","modified":1546409970051},{"_id":"public/archives/2017/07/index.html","hash":"095f9ad4bafa7368173c6ab0737ee571b69605ba","modified":1546409970051},{"_id":"public/archives/2018/index.html","hash":"95f812de81bca0e12336876a4ed93b2d7fea3dc3","modified":1546409970051},{"_id":"public/archives/2018/01/index.html","hash":"dba4788743f5aaab439c8b91b505ce2d07fc0957","modified":1546409970051},{"_id":"public/tags/RTFSC/index.html","hash":"07df0506afaef810633e1aa54a78fb5dd84b30e4","modified":1546409970051},{"_id":"public/tags/测试/index.html","hash":"8a49af8e6168d67c654bdfd78089f945f68a41c3","modified":1546409970051},{"_id":"public/tags/性能优化/index.html","hash":"e0f05986438c8e50ecba8efe8cfe7026f7e475a1","modified":1546409970051},{"_id":"public/tags/APT/index.html","hash":"9276a770bbd6f8eed69676d7456dc06a594c3b79","modified":1546409970054},{"_id":"public/tags/GC/index.html","hash":"a084aff190fa9b523ab7f0b1318301d28c375ee6","modified":1546409970051},{"_id":"public/tags/开发经验/index.html","hash":"ff58ddbf7e6e1aa3b666178ad561275f0596bd39","modified":1546409970051},{"_id":"public/2018/01/27/AccessibilityService分析与防御/index.html","hash":"cff26bbe5dd8215cec6c6e5041fe98d676562580","modified":1546409970051},{"_id":"public/2017/07/11/探索Bitmap使用姿势/index.html","hash":"40fa7f629d7c09f22ccf29fa9d7c5c310c8b3960","modified":1546409970051},{"_id":"public/2017/05/08/Java内存管理的一些小疑问/index.html","hash":"267a5ca18c9b5bf952bd9baf71bafdb7b042942d","modified":1546409970051},{"_id":"public/2017/03/21/小微团队怎么玩转App自动化测试/index.html","hash":"2e37bfda93a468502cd27f3f8765c1ea64b25565","modified":1546409970051},{"_id":"public/2017/03/20/Calabash探索1-Run Calabash/index.html","hash":"ebb1959b0f002053487b3e0451dae1aed8423ddb","modified":1546409970051},{"_id":"public/2017/03/18/Calabash探索2-Calabash用法详解/index.html","hash":"bd47220e27d8c3ccdb663e3e483bb95966b4141c","modified":1546409970051},{"_id":"public/2017/03/17/Calabash探索3-Calabash进阶/index.html","hash":"c79ce863458e03d5562d690f887b07da979b5cc3","modified":1546409970051},{"_id":"public/2017/03/16/Calabash探索4-Calabash踩坑总结/index.html","hash":"a271b9532c40899772e527a99d2c0e4a04325c6e","modified":1546409970052},{"_id":"public/2016/08/26/apt_usage_scenario/index.html","hash":"1c77beba3a42398f593a6272c1a5a04167fa99c0","modified":1546409970052},{"_id":"public/2016/07/17/apt-wathapt/index.html","hash":"966af68d16d35fee60ea509f9fa7cce0dba5ff96","modified":1546409970052},{"_id":"public/2016/07/17/apt-run_demo/index.html","hash":"9863b524cef871d31d8376eb1caa778e9587466f","modified":1546409970052},{"_id":"public/2016/07/17/apt-run_project/index.html","hash":"80766972eecd03de1e7263faf80bf4d654baddb1","modified":1546409970052},{"_id":"public/2016/07/17/apt-Climbed-out-of-the-pit/index.html","hash":"11adef12032cf9cf5012752927684c6ffdb26408","modified":1546409970052},{"_id":"public/2016/07/17/apt-Grammar-explanation/index.html","hash":"460e5a55a010679e18fbbc67057c463356f9497b","modified":1546409970052},{"_id":"public/2016/03/17/AndroidCoding-performance-specification/index.html","hash":"c7af911705f6c18bf4eaccb3c8d58fad5d930943","modified":1546409970052},{"_id":"public/2016/02/17/androidgcdiaoyan/index.html","hash":"15de47ac33b801c1c6687d9d9d1970b4c0006c41","modified":1546409970052},{"_id":"public/2016/01/17/shenyingpojie/index.html","hash":"d878a863e978564f97c3ac660a18c7fa3de019e4","modified":1546409970052},{"_id":"public/2015/09/10/android-rendering-performance-optimization/index.html","hash":"4898b244a64a86d048e4e2f6406e96e6868bc088","modified":1546409970052},{"_id":"public/2015/09/09/SoftWidget/index.html","hash":"2ba5a4b7677d4cc99b6960080ca33d5b2af4fb1e","modified":1546409970052},{"_id":"public/archives/index.html","hash":"a488145e2cad8f2604435241fe3cbe5fbf9d85b8","modified":1546409970052},{"_id":"public/index.html","hash":"7def118bf45e4488e854f69e635e9873283beb77","modified":1546409970054},{"_id":"public/page/2/index.html","hash":"25c28821f2d61aede92d783b3e8b9a9a00db50c8","modified":1546409970054},{"_id":"public/uploads/avatar.jpeg","hash":"e78b5a63bb05ad5023fd7785c73dce644ab44725","modified":1546397810317},{"_id":"public/uploads/github.jpg","hash":"5847934c28a6782834aeec7d6facc03af0b12109","modified":1546397810317},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1546397810317},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1546397810317},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1546397810317},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1546397810317},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1546397810317},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1546397810317},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1546397810317},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1546397810317},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1546397810317},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1546397810317},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1546397810317},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1546397810317},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546397810317},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1546397810317},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546397810317},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1546397810317},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1546397810317},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1546397810317},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1546397810317},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1546397810317},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1546397810317},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1546397810317},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1546397810317},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1546397810317},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1546397810317},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1546397810318},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1546397810318},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1546397810318},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1546397810318},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1546397810318},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1546397810318},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1546397810318},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1546397810318},{"_id":"public/2017/03/18/Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg","hash":"d0b909c3eec1ee0f1287df99cf955f9be82ae2fe","modified":1546397810318},{"_id":"public/2017/07/11/探索Bitmap使用姿势/recycle.png","hash":"0149b01745116f961275b9881c0db42a3333823e","modified":1546397810318},{"_id":"public/2017/07/11/探索Bitmap使用姿势/un_recycle.png","hash":"6c0b396521ae70f20da6202be0d3c5de43c1a4d4","modified":1546397810318},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546397810894},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546397810913},{"_id":"public/2017/05/08/Java内存管理的一些小疑问/method_end.png","hash":"3105d0be4550222170448b6a4bdf3d739a3a3c8b","modified":1546397810917},{"_id":"public/2018/01/27/AccessibilityService分析与防御/accessibility流程图.png","hash":"17bef916afc685c993fae95ca2feea4171dc5a76","modified":1546397810918},{"_id":"public/2017/05/08/Java内存管理的一些小疑问/method_start.png","hash":"afd5665bf016749a1b48dbdf988bb18df59b876c","modified":1546397810918},{"_id":"public/2018/01/27/AccessibilityService分析与防御/accessibility类图.png","hash":"7856604e3ea9ff1cdc9c7f8387620c86ef0d143a","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/DC_RGB_565.png","hash":"ecdadbe37cf6211fa9dfe8a82f95eb8d279e8554","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/DC_ALPHA_8.png","hash":"2e886eced98db81a37f092b51268fd5d6a2b0f74","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/new_take_photo.jpg","hash":"a46fe75eb76bc41cfe90d8ffb543d503c747a2d8","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/DC_ARGB_8888.png","hash":"aec6deee426b6af1f500de140bad3e7b2779a493","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/old_list_view.jpg","hash":"6d1fd79d9fe90b04cf57ff898a9f5deac2d61133","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/old_take_photo.jpg","hash":"88d4cbb7a7fe13472131c91c9523efbdfd3eb4a0","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/take_photo.png","hash":"21631f7f67340ad098b17fac83cdb67c1cb77213","modified":1546397810918},{"_id":"public/2017/07/11/探索Bitmap使用姿势/DC_ARGB_4444.png","hash":"3feb77364422d4dbf7c35c666da0a51aa672d207","modified":1546397810918},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1546397810925},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1546397810925},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1546397810925},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1546397810925},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1546397810925},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1546397810925},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1546397810925},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1546397810925},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1546397810925},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1546397810925},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1546397810925},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1546397810925},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1546397810925},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1546397810926},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1546397810926},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1546397810926},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1546397810926},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1546397810926},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1546397810926},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1546397810926},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1546397810926},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1546397810926},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1546397810926},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1546397810926},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1546397810926},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1546397810926},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1546397810927},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1546397810927},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1546397810927},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1546397810927},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1546397810927},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1546397810927},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1546397810927},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1546397810927},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1546397810927},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1546397810927},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1546397810927},{"_id":"public/css/main.css","hash":"a16a7ca9e6652a87f22938390283983947afe040","modified":1546397810927},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1546397810927},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1546397810927},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1546397810927},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1546397810927},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1546397810927},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1546397810927},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1546397810927},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546397810927},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1546397810927},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1546397810928},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1546397810928},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1546397810928},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1546397810928},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1546397810928},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1546397810928},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1546397810928},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1546397810928},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1546397810928},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1546397810928},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1546397810928},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1546397810928},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1546397810929},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546397810929},{"_id":"public/2018/01/27/AccessibilityService分析与防御/accessibility整体流程.png","hash":"359fd09789470b53e28b0edb225843778333378f","modified":1546397810929},{"_id":"public/2018/01/27/AccessibilityService分析与防御/外挂简史.png","hash":"484831018a39ded3015e082abe97ce4e9d52973b","modified":1546397810929},{"_id":"public/2018/01/27/AccessibilityService分析与防御/AccessibilityInteractionClient.png","hash":"dc6dbe4a6579eddb52176b776327f8965c719b13","modified":1546397810937},{"_id":"public/2017/07/11/探索Bitmap使用姿势/listview.png","hash":"27fd17023f574307d67b7cbdba96749e79d947c7","modified":1546397810938},{"_id":"public/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi_150.png","hash":"c4871464e116b1c69d4bdf5eb63aaec13159454c","modified":1546397810938},{"_id":"public/2017/07/11/探索Bitmap使用姿势/ARGB_4444.png","hash":"f13ff05f50a891da60b609b1a4a22b71cd044c4d","modified":1546397810943},{"_id":"public/2017/07/11/探索Bitmap使用姿势/take_photo2.png","hash":"169f4db4f59a1971ee0277f1ae4c379980432637","modified":1546397810943},{"_id":"public/2017/07/11/探索Bitmap使用姿势/ARGB_8888.png","hash":"f6369b159de47508c00b5e1ce41c3ce8dd3528f6","modified":1546397810948},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1546397810956},{"_id":"public/2017/07/11/探索Bitmap使用姿势/ALPHA_8.png","hash":"b444974e1643fba7cb377cf6b830b107929d2a87","modified":1546397810956},{"_id":"public/2017/07/11/探索Bitmap使用姿势/RGB_565.png","hash":"bdd4fe14f6e217d6d339a0412802038c5bd40623","modified":1546397810957},{"_id":"public/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi.png","hash":"26bb6bb9eca18eb28b91b1e95e506776fe1f2f83","modified":1546397810988},{"_id":"public/2017/07/11/探索Bitmap使用姿势/resource_assets.png","hash":"0901d3244882846c1ecb83fe10ae9b0e416c91b8","modified":1546397810988},{"_id":"themes/next/.DS_Store","hash":"ab047d248de3b20b5b31a0dbca9c72121a6313b4","modified":1500107910000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1470715068000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1470715068000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1470715068000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1470715068000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1470715068000},{"_id":"themes/next/.git/objects/pack/pack-cac37be495ab9113fb6349c68fcebc6570e46a40.idx","hash":"8adeb1e30572f74956250af17ab3a24629569ea8","modified":1470715068000},{"_id":"themes/next/.git/objects/pack/pack-cac37be495ab9113fb6349c68fcebc6570e46a40.pack","hash":"cd51eed195cfe87382bd7d2c6adc4392b4f87641","modified":1470715068000},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1546409970064},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1546409970064},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1546409970064},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1546409970064},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1546409970064},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1546409970064},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1546409970064},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1546409970064},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1546409970064},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1546409970064},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1546409970064},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1546409970089},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1546409970095},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1546409970097},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1546409970100},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1546409970100},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1546409970100},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1546409970100},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1546409970100},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1546409970100},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1546409970100},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1546409970100},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1546409970100},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1546409970100},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1546409970100},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1546409970100},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1546409970100},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1546409970100},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1546409970100},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1546409970100},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1546409970100},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1546409970100},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1546409970100},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1546409970100},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1546409970100},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1546409970100},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546409970100},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1546409970100},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1546409970100},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1546409970100},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1546409970100},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1546409970100},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1546409970100},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1546409970111}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"AccessibilityService分析与防御","date":"2018-01-27T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n\n提起AccessibilityService，你最容易联想到的肯定是微信抢红包插件！但这个服务的设计初衷，是为了帮助残障人士可以更好的使用App。\n\n一些“调皮”的开发者利用AccessibilityService可以监控与操作其他App的特性加上系统远超人类的反应速度，在某些竞争类场景开发出了作弊外挂，最常见的就是你所嫉愤的微信抢红包插件了。\n\n微信抢红包插件对原本平等的竞争环境产生了不公，不过这是微信团队要操心解决的事。可万万没想到，有一天，我正在写的App也遭此毒手！！！这都欺负到头上了能忍吗？不能啊！\n\nOK，所以我们今天先来分析一下AccessibilityService运行原理，然后分享一些我在应对此类竞争场景下基于AccessibilityService等自动化作弊工具的防御措施。\n\n\n<!-- more -->\n\n## 外挂简史\n\n先说下背景：\n\n场景是和抢红包类似的另一种：抢单。用户下单后订单会经过系统，在配送端App发布，配送人员在配送端App通过距离、价钱、时间等维度进行筛选并抢单然后配送。显而易见，价高距离短的订单非常抢手，这样就形成一种竞争环境，于是，自动抢单外挂也就有了存在的理由。\n\n然后我们来看下外挂进化史：\n\n![](./AccessibilityService分析与防御/外挂简史.png)\n\n- 第一代外挂\n\n\t第一代外挂还比较粗糙，需要依赖按键精灵来实现，且需要Root权限。\n    \n    【防御】简单反编译拆包了解后，考虑暂时没有更好的办法禁止按键精灵对App的模拟点击，直接封禁Root可能会有大量误杀，第一代防御仅简单的检查是否安装了按键精灵，然后限制用户抢单。\n    \n- 第二代外挂\n\n\t可能因为第一代的防御过于粗糙，第二代外挂很快有了新的改进，不再需要单独安装按键精灵这个App，他们把按键精灵集成到了自己的app里……\n    \n    【防御】此时团队内部简单商量后决定，快刀斩乱麻，直接封禁Root权限，检测到Root后将限制抢单。\n    \n- 第三代外挂\n\n\t禁止Root后终于消停了一段时间，但显然人民群众的智慧是无限的，很快新的免Root外挂出世了……经过反编译外挂后，第三代外挂采用了AccessibilityService来实现。\n    \n    【防御】此时已知的外挂并不多，所以除了继续封禁Root以外，还建立了可远程配置的外挂package name黑名单列表，若检测到已安装app列表里存在特定外挂包名后，将会进行抢单限制。\n    package name需要先获取到安装包来查看包名，随着外挂数量逐步上涨，外挂安装包获取难度大的缺点开始暴露了。\n    \n- 【第三代防御】\n\t\n    此时针对上一个版本的防御措施做了一次优化：\n    1.优先检查外挂package name\n    2.次级检测外挂app name，加package name白名单防误判。这样就不需要再获取app的安装包了\n    3.增加骑手举报反馈入口\n    4.收集了已启动的辅助模式列表备用（本想再快到斩乱麻的禁止辅助模式的开启，但这个误杀范围实在是太大了，最终还是停留在了想一想的阶段）\n\n- 第四代外挂\n\n\t在通过app name封禁后，外挂们挣扎了几次都被即时遏制了。但很快，我们收到了最新的外挂信息：新出来的外挂没有图标，看不到名字…… （你们厉害你们厉害！！！）\n\t\n    \n**哎呀~真是活久见，两波从来没见过的人在互相进步啊这是！！！禁止外挂安装这种简单的防御措施已经挡不住这帮疯狂的人类了，我只能一头扎进了AccessibilityService的源码中，看这到底是个啥东西，然后去思考相应的防御方案。**\n\n## AccessibilityService运行原理\n\n### AccessibilityService内部运行\n\n这不是一篇AccessibilityService教程文章，没有AccessibilityService完整的使用示例代码和源码，但为了上下文不至于断档太大，我们这里还是会简单贴一些小段代码。同时需要说明的是，严谨的来说AccessibilityService只是一个Service，文本查找点击事件等操作对于一个Service来说是完全没法做到的。但为了行文方便，所以后面某些AccessibilityService代指辅助模式服务。\n\n```\npublic class MyAccessibilityService extends AccessibilityService {\n\n\t...\n    \n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent accessibilityEvent) {\n        //获取eventType\n        int eventType = accessibilityEvent.getEventType();\n        if (eventType == AccessibilityEvent.TYPE_VIEW_CLICKED) {\n            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();\n            if (nodeInfo != null) {\n                //查询文案为BUTTON3的View\n                List<AccessibilityNodeInfo> button3 = nodeInfo.findAccessibilityNodeInfosByText(\"BUTTON3\");\n                nodeInfo.recycle();\n                for (AccessibilityNodeInfo item : button3) {\n                    //对这个View执行点击操作\n                    item.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n                }\n            }\n        }\n    }\n    \n    ...\n}\n```\n\nAccessibilityService真的很简单，只要写一个Service继承AccessibilityService，然后还有其他一些配置，之后每当你监控的应用界面有变动时就会回调到这个onAccessibilityEvent这个方法，你可以在里面取得此时变动的event类型是什么，还能拿到当前这个应用可视化的View树，然后取得其中的某个View来执行某些操作。\n\n那至于其原理，用屁股想想也知道是肯定是被监控的App发生界面改变时通知了系统，然后系统又通知给了我们注册的Service。嗯……屁股想的没错……那App怎么通知系统的？系统又怎么通知我们的呢？\n\n哎呀，屁股想不出来了，没关系，屁股决定脑袋，脑袋知道怎么办。这个时候我们就该钻到源码里来一探究竟了。Emmm~就先从我们继承的这个AccessibilityService为入口进行研究吧！\n\n\n哎呀~RTFSC，这乱糟糟的一片源代码催眠的一把好手，我们还是不看了，我给你画个图吧……\n\n我理出一份AccessibilityService类图：\n\n![](./AccessibilityService分析与防御/accessibility类图.png)\n\n乍一看好像乱糟糟的，没事，我慢慢给你絮叨，肯定比直接看源码来的直观有意思。\n\n1.AccessibilityService有两个抽象方法，`onAccessibilityEvent()`和`onInterrupt()`，就是我们要自己实现的那两个，重点记`onAccessibilityEvent()`，它会出现很多次，我们姑且先命名它为`AS-onAccessibilityEvent()`.`onAccessibilityEvent()`的参数类型是`AccessibilityEvent`,这个类简而意之就是当系统中发生某些事件时，会发送这个类的对象来告知监控方，通过这个对象可以知道是什么类型的事件、什么控件发出来等等。\n\n2.另外`AccessibilityService`继承了`Service`，但它仅复写了`onBind`方法。在`onBind`方法中return了一个`IAccessibilityServiceClientWrapper`对象。\n\n```\n@Override\npublic final IBinder onBind(Intent intent) {\n        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {\n        ...\n\n        @Override\n        public void onAccessibilityEvent(AccessibilityEvent event) {\n            AccessibilityService.this.onAccessibilityEvent(event);\n        }\n\n\t\t...\n}\n```\n\n3.`IAccessibilityServiceClientWrapper`继承了`IAccessibilityServiceClient.Stub`，嗯~看到这你应该就明白一大块了，`AccessibilityService`是一个跨进程通信Service。`IAccessibilityServiceClientWrapper`是这个类的重点关注对象了，那他作为一个AIDL的一个server端，他有哪些对外提供的方法呢？\n\n```\ninterface IAccessibilityServiceClient {\n    void init(in IAccessibilityServiceConnection connection, int connectionId, IBinder windowToken);\n    void onAccessibilityEvent(in AccessibilityEvent event);\n    void onInterrupt();\n    void onGesture(int gesture);\n    void clearAccessibilityCache();\n    void onKeyEvent(in KeyEvent event, int sequence);\n    void onMagnificationChanged(in Region region, float scale, float centerX, float centerY);\n    void onSoftKeyboardShowModeChanged(int showMode);\n    void onPerformGestureResult(int sequence, boolean completedSuccessfully);\n}\n```\n这里你又看到了`onAccessibilityEvent()`,我们姑且叫他`IASC-onAccessibilityEvent()`.\n\n\n\n4.然后我们在回头看看`IAccessibilityServiceClientWrapper`的构造方法中的三个参数，`Context、 Looper 、Callbacks`。`Context`不说了，`Looper`是一个`MainLooper`,\n他们两个的作用是创建一个HandlerCaller对象,HandlerCaller你可以很粗狂的就把它当做Handler，想了解细节可以自己看一下源码：\n\n```\npublic IAccessibilityServiceClientWrapper(Context context, Looper looper,Callbacks callback) {\n            mCallback = callback;\n            mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);\n        }\n```\n\n5.然后我们来看看`Callbacks`是个啥：\n\n```\npublic interface Callbacks {\n        void onAccessibilityEvent(AccessibilityEvent event);\n        void onInterrupt();\n        void onServiceConnected();\n        void init(int connectionId, IBinder windowToken);\n        boolean onGesture(int gestureId);\n        boolean onKeyEvent(KeyEvent event);\n        void onMagnificationChanged(@NonNull Region region,\n                float scale, float centerX, float centerY);\n        void onSoftKeyboardShowModeChanged(int showMode);\n        void onPerformGestureResult(int sequence, boolean completedSuccessfully);\n        void onFingerprintCapturingGesturesChanged(boolean active);\n        void onFingerprintGesture(int gesture);\n        void onAccessibilityButtonClicked();\n        void onAccessibilityButtonAvailabilityChanged(boolean available);\n    }\n```\n这和刚才那个`IAccessibilityServiceClient`不是一样嘛？没错，是这样的，而且这里面也有一个`onAccessibilityEvent`,我们叫它`Callbacks-onAccessibilityEvent`。\n\n上面你应该看到`Callbacks`是一个匿名内部类，他实现的`Callbacks-onAccessibilityEvent`方法的就是一句：` AccessibilityService.this.onAccessibilityEvent(event);`直接调用了`AS-onAccessibilityEvent()`，先记下来哈。\n\n\n6.哦对，`IAccessibilityServiceClientWrapper`还实现了一个`HandlerCaller.Callback`接口:\n\n```\npublic interface Callback {\n    public void executeMessage(Message msg);\n}\n```\n\n7.最后我们看一下`IAccessibilityServiceClientWrapper`对两个接口`IAccessibilityServiceClient`和`HandlerCaller.Callback`的实现：\n\n```\n...\npublic void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {\n    Message message = mCaller.obtainMessageBO(\n            DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);\n    mCaller.sendMessage(message);\n}\n...\n@Override\npublic void executeMessage(Message message) {\n    switch (message.what) {\n        case DO_ON_ACCESSIBILITY_EVENT: {\n            ...\n            \tmCallback.onAccessibilityEvent(event);\n            ...\n            }\n        } return;\n        ...\n\t}\n}\n...\n```\n\n我只保留了最关键的代码，我们以`onAccessibilityEvent`为线索方法捋一遍哈。当AIDL的Client端调用了`IASC-onAccessibilityEvent`时，会通过Handler发送一个message给自己，接收到以后会调用`Callbacks-onAccessibilityEvent`，`Callbacks-onAccessibilityEvent`我们刚才看过啦，会调用`AS-onAccessibilityEvent()`,这是个抽象方法，也就是我们自己实现的MyAccessibilityService中的自定义代码。\n\n有点懵？？不明白到底在干啥？没关系，我还画了个搓搓的流程图：\n\n![](./AccessibilityService分析与防御/accessibility流程图.png)\n\n当View发生改变时，会发出一个AccessibilityEvent出来，这个Event会通过Binder驱动发送给IAccessibilityServiceClientWrapper，调用他的onAccessibilityEvent(AccessibilityEvent)方法，这个方法通过Handler发送了一个Message给自己，目的是为了从Binder线程转回主线程。然后调用了`mCallback.onAccessibilityEvent(event)`，间接的调用了`AccessibilityService.this.onAccessibilityEvent(event);`，也就是我们自己实现的。\n\n这么顺下来，AccessibilityService的内部逻辑是不就感觉很简单了？\n\n\n### AccessibilityService外部运行\n\n我们梳理了一遍AccessibilityService的内部执行逻辑后，就会触发很多新的问题，比如onBind是谁来调用的啊？为什么中间还要用Hander给自己发送一遍消息呢？当我们自己实现onAccessibilityEvent方法时会做一些点击一类的操作，这个是怎么做到的啊？\n\n哎呀，问题好多，这个源码梳理下来肯定要睡第二觉了，我们不看了不看了，直接上图吧：\n\n![](./AccessibilityService分析与防御/accessibility整体流程.png)\n\n1.一个可爱的用户在设置页面启动了某个辅助模式服务\n2.系统发送了一条广播到AccessibilityManagerService，收到广播后，AccessibilityManagerService绑定了我们写的AccessibilityService，就这样调用了onBind方法。AIDL的Server端准备好了~ AccessibilityManagerService是一个系统服务，由SystemService启动。\n\n3.受到监控的App某个View发生了改变，其内部都会调用AccessibilityManager来发送event，其具体发送的对象是ViewRootImpl类来做的。\n4.发出event后会通过Binder驱动调用到AccessibilityService，最终调用了我们复写的onAccessibilityEvent方法。\n5.每一个View在AccessibilityService中都会被映射为一个AccessibilityNodeInfo对象，我们通过这个对象去查找具体View、触发事件，其本质是调用了AccessibilityInteractionClient类的对应方法。\n6.AccessibilityInteractionClient我们在Uiautomator也经常看到。后面我们会继续单独分析，先大概说一下是个什么东西，官方注释是这样的：\n*This class is a singleton that performs accessibility interaction  which is it queries remote view hierarchies about snapshots of their views as well requests from these hierarchies to perform certain actions on their views.*\n*这个类是一个可以执行可访问性交互的单例对象，它查询远程视图层次结构，查看视图的快照，以及来自这些层次结构的请求，以便在视图上执行某些操作。*\n7.如果利用AccessibilityInteractionClient操作正在被监控的App，比如点击按钮，那么View发生变化，又发送出一个Event，这样便形成一个循环。\n\n\n\t\n\n### AccessibilityInteractionClient 操作View细节\n\n在我们了解了AccessibilitySevice从View产生event事件发出到被辅助服务接收再操作View的一个流程之后，我们仅仅知道了事件是如何通知到AccessibilityService的，而具体是如何通过文本查找View，点击View则是AccessibilityInteractionClient来做的，那么下面我们就通过AccessibilityInteractionClient 的源码探究一下里面的秘密。\n\n我们主要以findAccessibilityNodeInfosByText和performAccessibilityAction（ACTION_CLICK）两个方法往下追。\n\n整体代码较为简单，基本是一条线往下调用的逻辑，所以我又画了一张图：\n\n![](./AccessibilityService分析与防御/AccessibilityInteractionClient.png)\n\n1.AccessibilityInteractionClient没做什么操作，直接通过Binder调用了AccessibilityManagerService对应的方法。\n\n2.AccessibilityManagerService最终还是通过Binder调用了ViewRootImpl对应的方法。\n\n3.ViewRootImpl仅作为Binder中的服务端接收调用，真正的操作交给AccessibilityInteractionController来做。\n\n4.AccessibilityInteractionController对应的方法被调用之后，并没有直接进行操作，而是通过Handler做了一次转发，以便从Binder线程转到UI线程。\n\n5.以performAccessibilityAction（ACTION_CLICK）点击事件为例，最终调用的实际是View的mOnClickListener。\n\n6.以findAccessibilityNodeInfosByText为例，最终调用的实际是View的findViewsWithText方法，其方法内部实际对比的值是mContentDescription。需要特别说明的是TextView重写了该方法，其内部实际对比的值是mText。\n\n\n### 小结\n\n我们既然已经了解了AccessibilityService的运行原理，其内部就是一个跨进程通信，没什么神秘的。最终操作View的是AccessibilityInteractionClient，AccessibilityInteractionClient是怎么操作的通过源码很容易的追到了View层具体的实现，那么做防御的话简直是手到擒来！\n\n## AccessibilityService防御\n\n### 1.检测 or 禁止相关外挂的辅助模式开启\n\n之前在外挂防御上，一直困扰我的一个问题是：AccessibilityService类似一个解耦很开的观察者模式，作为被观察者无法察觉到观察者究竟有哪些，这导致我们非常的被动。\n\n不过研究过AccessibilityService源码之后，我们知道，每个AccessibilityService在都是由AccessibilityManagerService注册的，那岂不是说我们可以通过AccessibilityManagerService取得所有以安装或以启动的辅助模式应用？那么AccessibilityManagerService有提供相关方法吗？\n有的：\n\nAccessibilityManagerService.java\n\n```\npublic class AccessibilityManagerService extends IAccessibilityManager.Stub {\n\t...\n \t@Override\n    public List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList(int userId) {...}\n}\n```\n\n值得注意的是，这个方法帮我们筛去了UiAutomationService。返回值AccessibilityServiceInfo是AccessibilityService的一些配置信息，其中包含我们最关心的packageNames(AccessibilityService 监控哪些package发出的Event)\n\n这里有一个小问题，AccessibilityManagerService是com.android.server.accessibility包下的类，我们没有办法直接使用。不过没关系，你可以通过AccessibilityManager来间接的操作AccessibilityManagerService，其内部利用Binder间接的调用了AccessibilityManagerService，得到List<AccessibilityServiceInfo>之后，你可以通过遍历了解到自己的应用正在被那些辅助模式监控或“辅助”。\n\n具体方法如下：\n\n```\n\n/**\n * 取得正在监控目标包名的AccessibilityService\n */\nprivate List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList(String targetPackage) {\n    List<AccessibilityServiceInfo> result = new ArrayList<>();\n    AccessibilityManager accessibilityManager = (AccessibilityManager) getApplicationContext().getSystemService(Context.ACCESSIBILITY_SERVICE);\n    if (accessibilityManager == null) {\n        return result;\n    }\n    List<AccessibilityServiceInfo> infoList = accessibilityManager.getInstalledAccessibilityServiceList();\n    if (infoList == null || infoList.size() == 0) {\n        return result;\n    }\n    for (AccessibilityServiceInfo info : infoList) {\n        if (info.packageNames == null) {\n            result.add(info);\n        } else {\n            for (String packageName : info.packageNames) {\n                if (targetPackage.equals(packageName)) {\n                    result.add(info);\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n- **需要特别说明的是：**当info.packageNames为null时，表示监控所有包名。外挂有可能蒙混其中，但如果一刀切，也有可能误杀正常软件。\n- getInstalledAccessibilityServiceList获取所有已安装的AccessibilityService,AccessibilityManager还有一个方法getEnabledAccessibilityServiceList,取得所有已经开启的AccessibilityService，用法同上。但要注意的是。检测外挂肯定是在某个节点进行，比如我们的App初次启动，那么用户可以在启动App后再启动外挂，这将是一个漏洞。\n\n### 2.Event干扰\n\n我们一直知道AccessibilityServices在监控目标app发出的AccessibilityEvent，从而对应的作出某些操作。\n\n例如某些微信红包插件会监控Notification的弹出，那么我们是否可以随意发送这样的Event出来，从而混干扰外挂插件的运行逻辑？\n\n没错，可以这样做的，具体方式如下：\n\n``` \ntextView.sendAccessibilityEvent(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);\n\n```\n\n但这个方案的缺陷是，大部分的外挂插件对特定类型的事件并不是特别感兴趣，他们仅在收到Event后检查页面上是否有某些特定的元素，从而决定是否进行下一步操作。\n\n大部分情况下是一个比较鸡肋的措施，但也许会在某些场景起到意想不到的作用！\n\n### 3.屏蔽AccessibilityServices文案检查\n\n在没有探究AccessibilityServices源码之前，不了解AccessibilityServices检索文本信息原理的我们可能唯一能想到的应对措施就是将关键问题替换为图片。\n\n这可以解决问题，但是问题替换为图片不但会有性能上的损耗，而且会丢失大部分原本TextView的兼容特性。\n\n不过在了解AccessibilityServices源码之后，我们知道其内部核心原理就是调用TextView的findViewsWithText方法，不再需要费劲心思将文本转为图片，你需要做的仅仅是复写这个方法就够了：\n\n```\npublic class DefensiveTextView extends android.support.v7.widget.AppCompatTextView {\n    ...\n    @Override\n    public void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags) {\n        outViews.remove(this);\n    }\n}\n\n```\n\n这样AccessibilityServices文案检查将会在这个View上失效。\n\n\n### 4.屏蔽AccessibilityServices点击事件\n\n像上面一样，通过源码了解原理之后，我们知道AccessibilityServices执行点击事件最终在调用View的mOnClickListener。\n\n那我们只需要在这上面做文章就好了，最快捷的办法是利用onTouch代替onClick。\n\n\n### 5.检测 or 禁止相关外挂软件安装\n\n上述方式无论是检测已安装的AccessibilityServices列表还是屏蔽AccessibilityServices的文本检查和点击事件，针对的都是AccessibilityServices本身。当你出台这样的方式后，确实后会让现有的外挂消停一段时间，但可以预见，很快会有基于其他自动化措施的外挂面世，比如类似按键精力一样的模拟Touch事件，图像识别等，在出现应对这些手段之前，你还是需要一些笨笨的老办法，收集已知外挂，禁止其安装。\n\n检查方法非常简单，一句带过：设立黑名单，遍历系统内部所有已安装的app，鉴别package name 和app name。\n\n\n\n\n\n## 结语\n\n在拨开了AccessibilityServices源码的外衣之后，我们会发现其实它的原理真的很简单，唯一的核心是在Client  - System - Server三者之间利用Binder做跨进程通信，几乎没有太多的逻辑操作，一直在互相调用。\n\n所以看着神奇且神秘的AccessibilityServices其实并没有什么了不起。\n\n另外要说的是，在没了解AccessibilityServices源码之前，我们能想到的防御措施可能非常少且低效，比如原本只用复写一个方法，你却需要动态生成图片。了解源码之后，你便可以单刀直入，直切重点用最有效最简单的方式实现你想要的东西，所以阅读源码真的很重要！\n\n最后先总结一下防御措施吧。\n\n- 通过AccessibilityManager检测 or 禁止相关外挂的辅助模式开启\n- 自定义TextView复写findViewsWithText方法，屏蔽文案检查\n- onTouch替换onClick，屏蔽点击事件\n- 随机发送Event干扰\n- 通过PackageManager检测 or 禁止相关外挂软件安装\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/AccessibilityService分析与防御.md","raw":"\n---\ntitle: AccessibilityService分析与防御\ndate: 2018-1-27 16:20:58\nauthor : 暴打小女孩\n\ntags: RTFSC\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n\n提起AccessibilityService，你最容易联想到的肯定是微信抢红包插件！但这个服务的设计初衷，是为了帮助残障人士可以更好的使用App。\n\n一些“调皮”的开发者利用AccessibilityService可以监控与操作其他App的特性加上系统远超人类的反应速度，在某些竞争类场景开发出了作弊外挂，最常见的就是你所嫉愤的微信抢红包插件了。\n\n微信抢红包插件对原本平等的竞争环境产生了不公，不过这是微信团队要操心解决的事。可万万没想到，有一天，我正在写的App也遭此毒手！！！这都欺负到头上了能忍吗？不能啊！\n\nOK，所以我们今天先来分析一下AccessibilityService运行原理，然后分享一些我在应对此类竞争场景下基于AccessibilityService等自动化作弊工具的防御措施。\n\n\n<!-- more -->\n\n## 外挂简史\n\n先说下背景：\n\n场景是和抢红包类似的另一种：抢单。用户下单后订单会经过系统，在配送端App发布，配送人员在配送端App通过距离、价钱、时间等维度进行筛选并抢单然后配送。显而易见，价高距离短的订单非常抢手，这样就形成一种竞争环境，于是，自动抢单外挂也就有了存在的理由。\n\n然后我们来看下外挂进化史：\n\n![](./AccessibilityService分析与防御/外挂简史.png)\n\n- 第一代外挂\n\n\t第一代外挂还比较粗糙，需要依赖按键精灵来实现，且需要Root权限。\n    \n    【防御】简单反编译拆包了解后，考虑暂时没有更好的办法禁止按键精灵对App的模拟点击，直接封禁Root可能会有大量误杀，第一代防御仅简单的检查是否安装了按键精灵，然后限制用户抢单。\n    \n- 第二代外挂\n\n\t可能因为第一代的防御过于粗糙，第二代外挂很快有了新的改进，不再需要单独安装按键精灵这个App，他们把按键精灵集成到了自己的app里……\n    \n    【防御】此时团队内部简单商量后决定，快刀斩乱麻，直接封禁Root权限，检测到Root后将限制抢单。\n    \n- 第三代外挂\n\n\t禁止Root后终于消停了一段时间，但显然人民群众的智慧是无限的，很快新的免Root外挂出世了……经过反编译外挂后，第三代外挂采用了AccessibilityService来实现。\n    \n    【防御】此时已知的外挂并不多，所以除了继续封禁Root以外，还建立了可远程配置的外挂package name黑名单列表，若检测到已安装app列表里存在特定外挂包名后，将会进行抢单限制。\n    package name需要先获取到安装包来查看包名，随着外挂数量逐步上涨，外挂安装包获取难度大的缺点开始暴露了。\n    \n- 【第三代防御】\n\t\n    此时针对上一个版本的防御措施做了一次优化：\n    1.优先检查外挂package name\n    2.次级检测外挂app name，加package name白名单防误判。这样就不需要再获取app的安装包了\n    3.增加骑手举报反馈入口\n    4.收集了已启动的辅助模式列表备用（本想再快到斩乱麻的禁止辅助模式的开启，但这个误杀范围实在是太大了，最终还是停留在了想一想的阶段）\n\n- 第四代外挂\n\n\t在通过app name封禁后，外挂们挣扎了几次都被即时遏制了。但很快，我们收到了最新的外挂信息：新出来的外挂没有图标，看不到名字…… （你们厉害你们厉害！！！）\n\t\n    \n**哎呀~真是活久见，两波从来没见过的人在互相进步啊这是！！！禁止外挂安装这种简单的防御措施已经挡不住这帮疯狂的人类了，我只能一头扎进了AccessibilityService的源码中，看这到底是个啥东西，然后去思考相应的防御方案。**\n\n## AccessibilityService运行原理\n\n### AccessibilityService内部运行\n\n这不是一篇AccessibilityService教程文章，没有AccessibilityService完整的使用示例代码和源码，但为了上下文不至于断档太大，我们这里还是会简单贴一些小段代码。同时需要说明的是，严谨的来说AccessibilityService只是一个Service，文本查找点击事件等操作对于一个Service来说是完全没法做到的。但为了行文方便，所以后面某些AccessibilityService代指辅助模式服务。\n\n```\npublic class MyAccessibilityService extends AccessibilityService {\n\n\t...\n    \n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent accessibilityEvent) {\n        //获取eventType\n        int eventType = accessibilityEvent.getEventType();\n        if (eventType == AccessibilityEvent.TYPE_VIEW_CLICKED) {\n            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();\n            if (nodeInfo != null) {\n                //查询文案为BUTTON3的View\n                List<AccessibilityNodeInfo> button3 = nodeInfo.findAccessibilityNodeInfosByText(\"BUTTON3\");\n                nodeInfo.recycle();\n                for (AccessibilityNodeInfo item : button3) {\n                    //对这个View执行点击操作\n                    item.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n                }\n            }\n        }\n    }\n    \n    ...\n}\n```\n\nAccessibilityService真的很简单，只要写一个Service继承AccessibilityService，然后还有其他一些配置，之后每当你监控的应用界面有变动时就会回调到这个onAccessibilityEvent这个方法，你可以在里面取得此时变动的event类型是什么，还能拿到当前这个应用可视化的View树，然后取得其中的某个View来执行某些操作。\n\n那至于其原理，用屁股想想也知道是肯定是被监控的App发生界面改变时通知了系统，然后系统又通知给了我们注册的Service。嗯……屁股想的没错……那App怎么通知系统的？系统又怎么通知我们的呢？\n\n哎呀，屁股想不出来了，没关系，屁股决定脑袋，脑袋知道怎么办。这个时候我们就该钻到源码里来一探究竟了。Emmm~就先从我们继承的这个AccessibilityService为入口进行研究吧！\n\n\n哎呀~RTFSC，这乱糟糟的一片源代码催眠的一把好手，我们还是不看了，我给你画个图吧……\n\n我理出一份AccessibilityService类图：\n\n![](./AccessibilityService分析与防御/accessibility类图.png)\n\n乍一看好像乱糟糟的，没事，我慢慢给你絮叨，肯定比直接看源码来的直观有意思。\n\n1.AccessibilityService有两个抽象方法，`onAccessibilityEvent()`和`onInterrupt()`，就是我们要自己实现的那两个，重点记`onAccessibilityEvent()`，它会出现很多次，我们姑且先命名它为`AS-onAccessibilityEvent()`.`onAccessibilityEvent()`的参数类型是`AccessibilityEvent`,这个类简而意之就是当系统中发生某些事件时，会发送这个类的对象来告知监控方，通过这个对象可以知道是什么类型的事件、什么控件发出来等等。\n\n2.另外`AccessibilityService`继承了`Service`，但它仅复写了`onBind`方法。在`onBind`方法中return了一个`IAccessibilityServiceClientWrapper`对象。\n\n```\n@Override\npublic final IBinder onBind(Intent intent) {\n        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {\n        ...\n\n        @Override\n        public void onAccessibilityEvent(AccessibilityEvent event) {\n            AccessibilityService.this.onAccessibilityEvent(event);\n        }\n\n\t\t...\n}\n```\n\n3.`IAccessibilityServiceClientWrapper`继承了`IAccessibilityServiceClient.Stub`，嗯~看到这你应该就明白一大块了，`AccessibilityService`是一个跨进程通信Service。`IAccessibilityServiceClientWrapper`是这个类的重点关注对象了，那他作为一个AIDL的一个server端，他有哪些对外提供的方法呢？\n\n```\ninterface IAccessibilityServiceClient {\n    void init(in IAccessibilityServiceConnection connection, int connectionId, IBinder windowToken);\n    void onAccessibilityEvent(in AccessibilityEvent event);\n    void onInterrupt();\n    void onGesture(int gesture);\n    void clearAccessibilityCache();\n    void onKeyEvent(in KeyEvent event, int sequence);\n    void onMagnificationChanged(in Region region, float scale, float centerX, float centerY);\n    void onSoftKeyboardShowModeChanged(int showMode);\n    void onPerformGestureResult(int sequence, boolean completedSuccessfully);\n}\n```\n这里你又看到了`onAccessibilityEvent()`,我们姑且叫他`IASC-onAccessibilityEvent()`.\n\n\n\n4.然后我们在回头看看`IAccessibilityServiceClientWrapper`的构造方法中的三个参数，`Context、 Looper 、Callbacks`。`Context`不说了，`Looper`是一个`MainLooper`,\n他们两个的作用是创建一个HandlerCaller对象,HandlerCaller你可以很粗狂的就把它当做Handler，想了解细节可以自己看一下源码：\n\n```\npublic IAccessibilityServiceClientWrapper(Context context, Looper looper,Callbacks callback) {\n            mCallback = callback;\n            mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);\n        }\n```\n\n5.然后我们来看看`Callbacks`是个啥：\n\n```\npublic interface Callbacks {\n        void onAccessibilityEvent(AccessibilityEvent event);\n        void onInterrupt();\n        void onServiceConnected();\n        void init(int connectionId, IBinder windowToken);\n        boolean onGesture(int gestureId);\n        boolean onKeyEvent(KeyEvent event);\n        void onMagnificationChanged(@NonNull Region region,\n                float scale, float centerX, float centerY);\n        void onSoftKeyboardShowModeChanged(int showMode);\n        void onPerformGestureResult(int sequence, boolean completedSuccessfully);\n        void onFingerprintCapturingGesturesChanged(boolean active);\n        void onFingerprintGesture(int gesture);\n        void onAccessibilityButtonClicked();\n        void onAccessibilityButtonAvailabilityChanged(boolean available);\n    }\n```\n这和刚才那个`IAccessibilityServiceClient`不是一样嘛？没错，是这样的，而且这里面也有一个`onAccessibilityEvent`,我们叫它`Callbacks-onAccessibilityEvent`。\n\n上面你应该看到`Callbacks`是一个匿名内部类，他实现的`Callbacks-onAccessibilityEvent`方法的就是一句：` AccessibilityService.this.onAccessibilityEvent(event);`直接调用了`AS-onAccessibilityEvent()`，先记下来哈。\n\n\n6.哦对，`IAccessibilityServiceClientWrapper`还实现了一个`HandlerCaller.Callback`接口:\n\n```\npublic interface Callback {\n    public void executeMessage(Message msg);\n}\n```\n\n7.最后我们看一下`IAccessibilityServiceClientWrapper`对两个接口`IAccessibilityServiceClient`和`HandlerCaller.Callback`的实现：\n\n```\n...\npublic void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) {\n    Message message = mCaller.obtainMessageBO(\n            DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);\n    mCaller.sendMessage(message);\n}\n...\n@Override\npublic void executeMessage(Message message) {\n    switch (message.what) {\n        case DO_ON_ACCESSIBILITY_EVENT: {\n            ...\n            \tmCallback.onAccessibilityEvent(event);\n            ...\n            }\n        } return;\n        ...\n\t}\n}\n...\n```\n\n我只保留了最关键的代码，我们以`onAccessibilityEvent`为线索方法捋一遍哈。当AIDL的Client端调用了`IASC-onAccessibilityEvent`时，会通过Handler发送一个message给自己，接收到以后会调用`Callbacks-onAccessibilityEvent`，`Callbacks-onAccessibilityEvent`我们刚才看过啦，会调用`AS-onAccessibilityEvent()`,这是个抽象方法，也就是我们自己实现的MyAccessibilityService中的自定义代码。\n\n有点懵？？不明白到底在干啥？没关系，我还画了个搓搓的流程图：\n\n![](./AccessibilityService分析与防御/accessibility流程图.png)\n\n当View发生改变时，会发出一个AccessibilityEvent出来，这个Event会通过Binder驱动发送给IAccessibilityServiceClientWrapper，调用他的onAccessibilityEvent(AccessibilityEvent)方法，这个方法通过Handler发送了一个Message给自己，目的是为了从Binder线程转回主线程。然后调用了`mCallback.onAccessibilityEvent(event)`，间接的调用了`AccessibilityService.this.onAccessibilityEvent(event);`，也就是我们自己实现的。\n\n这么顺下来，AccessibilityService的内部逻辑是不就感觉很简单了？\n\n\n### AccessibilityService外部运行\n\n我们梳理了一遍AccessibilityService的内部执行逻辑后，就会触发很多新的问题，比如onBind是谁来调用的啊？为什么中间还要用Hander给自己发送一遍消息呢？当我们自己实现onAccessibilityEvent方法时会做一些点击一类的操作，这个是怎么做到的啊？\n\n哎呀，问题好多，这个源码梳理下来肯定要睡第二觉了，我们不看了不看了，直接上图吧：\n\n![](./AccessibilityService分析与防御/accessibility整体流程.png)\n\n1.一个可爱的用户在设置页面启动了某个辅助模式服务\n2.系统发送了一条广播到AccessibilityManagerService，收到广播后，AccessibilityManagerService绑定了我们写的AccessibilityService，就这样调用了onBind方法。AIDL的Server端准备好了~ AccessibilityManagerService是一个系统服务，由SystemService启动。\n\n3.受到监控的App某个View发生了改变，其内部都会调用AccessibilityManager来发送event，其具体发送的对象是ViewRootImpl类来做的。\n4.发出event后会通过Binder驱动调用到AccessibilityService，最终调用了我们复写的onAccessibilityEvent方法。\n5.每一个View在AccessibilityService中都会被映射为一个AccessibilityNodeInfo对象，我们通过这个对象去查找具体View、触发事件，其本质是调用了AccessibilityInteractionClient类的对应方法。\n6.AccessibilityInteractionClient我们在Uiautomator也经常看到。后面我们会继续单独分析，先大概说一下是个什么东西，官方注释是这样的：\n*This class is a singleton that performs accessibility interaction  which is it queries remote view hierarchies about snapshots of their views as well requests from these hierarchies to perform certain actions on their views.*\n*这个类是一个可以执行可访问性交互的单例对象，它查询远程视图层次结构，查看视图的快照，以及来自这些层次结构的请求，以便在视图上执行某些操作。*\n7.如果利用AccessibilityInteractionClient操作正在被监控的App，比如点击按钮，那么View发生变化，又发送出一个Event，这样便形成一个循环。\n\n\n\t\n\n### AccessibilityInteractionClient 操作View细节\n\n在我们了解了AccessibilitySevice从View产生event事件发出到被辅助服务接收再操作View的一个流程之后，我们仅仅知道了事件是如何通知到AccessibilityService的，而具体是如何通过文本查找View，点击View则是AccessibilityInteractionClient来做的，那么下面我们就通过AccessibilityInteractionClient 的源码探究一下里面的秘密。\n\n我们主要以findAccessibilityNodeInfosByText和performAccessibilityAction（ACTION_CLICK）两个方法往下追。\n\n整体代码较为简单，基本是一条线往下调用的逻辑，所以我又画了一张图：\n\n![](./AccessibilityService分析与防御/AccessibilityInteractionClient.png)\n\n1.AccessibilityInteractionClient没做什么操作，直接通过Binder调用了AccessibilityManagerService对应的方法。\n\n2.AccessibilityManagerService最终还是通过Binder调用了ViewRootImpl对应的方法。\n\n3.ViewRootImpl仅作为Binder中的服务端接收调用，真正的操作交给AccessibilityInteractionController来做。\n\n4.AccessibilityInteractionController对应的方法被调用之后，并没有直接进行操作，而是通过Handler做了一次转发，以便从Binder线程转到UI线程。\n\n5.以performAccessibilityAction（ACTION_CLICK）点击事件为例，最终调用的实际是View的mOnClickListener。\n\n6.以findAccessibilityNodeInfosByText为例，最终调用的实际是View的findViewsWithText方法，其方法内部实际对比的值是mContentDescription。需要特别说明的是TextView重写了该方法，其内部实际对比的值是mText。\n\n\n### 小结\n\n我们既然已经了解了AccessibilityService的运行原理，其内部就是一个跨进程通信，没什么神秘的。最终操作View的是AccessibilityInteractionClient，AccessibilityInteractionClient是怎么操作的通过源码很容易的追到了View层具体的实现，那么做防御的话简直是手到擒来！\n\n## AccessibilityService防御\n\n### 1.检测 or 禁止相关外挂的辅助模式开启\n\n之前在外挂防御上，一直困扰我的一个问题是：AccessibilityService类似一个解耦很开的观察者模式，作为被观察者无法察觉到观察者究竟有哪些，这导致我们非常的被动。\n\n不过研究过AccessibilityService源码之后，我们知道，每个AccessibilityService在都是由AccessibilityManagerService注册的，那岂不是说我们可以通过AccessibilityManagerService取得所有以安装或以启动的辅助模式应用？那么AccessibilityManagerService有提供相关方法吗？\n有的：\n\nAccessibilityManagerService.java\n\n```\npublic class AccessibilityManagerService extends IAccessibilityManager.Stub {\n\t...\n \t@Override\n    public List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList(int userId) {...}\n}\n```\n\n值得注意的是，这个方法帮我们筛去了UiAutomationService。返回值AccessibilityServiceInfo是AccessibilityService的一些配置信息，其中包含我们最关心的packageNames(AccessibilityService 监控哪些package发出的Event)\n\n这里有一个小问题，AccessibilityManagerService是com.android.server.accessibility包下的类，我们没有办法直接使用。不过没关系，你可以通过AccessibilityManager来间接的操作AccessibilityManagerService，其内部利用Binder间接的调用了AccessibilityManagerService，得到List<AccessibilityServiceInfo>之后，你可以通过遍历了解到自己的应用正在被那些辅助模式监控或“辅助”。\n\n具体方法如下：\n\n```\n\n/**\n * 取得正在监控目标包名的AccessibilityService\n */\nprivate List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList(String targetPackage) {\n    List<AccessibilityServiceInfo> result = new ArrayList<>();\n    AccessibilityManager accessibilityManager = (AccessibilityManager) getApplicationContext().getSystemService(Context.ACCESSIBILITY_SERVICE);\n    if (accessibilityManager == null) {\n        return result;\n    }\n    List<AccessibilityServiceInfo> infoList = accessibilityManager.getInstalledAccessibilityServiceList();\n    if (infoList == null || infoList.size() == 0) {\n        return result;\n    }\n    for (AccessibilityServiceInfo info : infoList) {\n        if (info.packageNames == null) {\n            result.add(info);\n        } else {\n            for (String packageName : info.packageNames) {\n                if (targetPackage.equals(packageName)) {\n                    result.add(info);\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n- **需要特别说明的是：**当info.packageNames为null时，表示监控所有包名。外挂有可能蒙混其中，但如果一刀切，也有可能误杀正常软件。\n- getInstalledAccessibilityServiceList获取所有已安装的AccessibilityService,AccessibilityManager还有一个方法getEnabledAccessibilityServiceList,取得所有已经开启的AccessibilityService，用法同上。但要注意的是。检测外挂肯定是在某个节点进行，比如我们的App初次启动，那么用户可以在启动App后再启动外挂，这将是一个漏洞。\n\n### 2.Event干扰\n\n我们一直知道AccessibilityServices在监控目标app发出的AccessibilityEvent，从而对应的作出某些操作。\n\n例如某些微信红包插件会监控Notification的弹出，那么我们是否可以随意发送这样的Event出来，从而混干扰外挂插件的运行逻辑？\n\n没错，可以这样做的，具体方式如下：\n\n``` \ntextView.sendAccessibilityEvent(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);\n\n```\n\n但这个方案的缺陷是，大部分的外挂插件对特定类型的事件并不是特别感兴趣，他们仅在收到Event后检查页面上是否有某些特定的元素，从而决定是否进行下一步操作。\n\n大部分情况下是一个比较鸡肋的措施，但也许会在某些场景起到意想不到的作用！\n\n### 3.屏蔽AccessibilityServices文案检查\n\n在没有探究AccessibilityServices源码之前，不了解AccessibilityServices检索文本信息原理的我们可能唯一能想到的应对措施就是将关键问题替换为图片。\n\n这可以解决问题，但是问题替换为图片不但会有性能上的损耗，而且会丢失大部分原本TextView的兼容特性。\n\n不过在了解AccessibilityServices源码之后，我们知道其内部核心原理就是调用TextView的findViewsWithText方法，不再需要费劲心思将文本转为图片，你需要做的仅仅是复写这个方法就够了：\n\n```\npublic class DefensiveTextView extends android.support.v7.widget.AppCompatTextView {\n    ...\n    @Override\n    public void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags) {\n        outViews.remove(this);\n    }\n}\n\n```\n\n这样AccessibilityServices文案检查将会在这个View上失效。\n\n\n### 4.屏蔽AccessibilityServices点击事件\n\n像上面一样，通过源码了解原理之后，我们知道AccessibilityServices执行点击事件最终在调用View的mOnClickListener。\n\n那我们只需要在这上面做文章就好了，最快捷的办法是利用onTouch代替onClick。\n\n\n### 5.检测 or 禁止相关外挂软件安装\n\n上述方式无论是检测已安装的AccessibilityServices列表还是屏蔽AccessibilityServices的文本检查和点击事件，针对的都是AccessibilityServices本身。当你出台这样的方式后，确实后会让现有的外挂消停一段时间，但可以预见，很快会有基于其他自动化措施的外挂面世，比如类似按键精力一样的模拟Touch事件，图像识别等，在出现应对这些手段之前，你还是需要一些笨笨的老办法，收集已知外挂，禁止其安装。\n\n检查方法非常简单，一句带过：设立黑名单，遍历系统内部所有已安装的app，鉴别package name 和app name。\n\n\n\n\n\n## 结语\n\n在拨开了AccessibilityServices源码的外衣之后，我们会发现其实它的原理真的很简单，唯一的核心是在Client  - System - Server三者之间利用Binder做跨进程通信，几乎没有太多的逻辑操作，一直在互相调用。\n\n所以看着神奇且神秘的AccessibilityServices其实并没有什么了不起。\n\n另外要说的是，在没了解AccessibilityServices源码之前，我们能想到的防御措施可能非常少且低效，比如原本只用复写一个方法，你却需要动态生成图片。了解源码之后，你便可以单刀直入，直切重点用最有效最简单的方式实现你想要的东西，所以阅读源码真的很重要！\n\n最后先总结一下防御措施吧。\n\n- 通过AccessibilityManager检测 or 禁止相关外挂的辅助模式开启\n- 自定义TextView复写findViewsWithText方法，屏蔽文案检查\n- onTouch替换onClick，屏蔽点击事件\n- 随机发送Event干扰\n- 通过PackageManager检测 or 禁止相关外挂软件安装\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"AccessibilityService分析与防御","published":1,"updated":"2019-01-02T02:09:31.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbso90000yo9s1cydiys5","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>提起AccessibilityService，你最容易联想到的肯定是微信抢红包插件！但这个服务的设计初衷，是为了帮助残障人士可以更好的使用App。</p>\n<p>一些“调皮”的开发者利用AccessibilityService可以监控与操作其他App的特性加上系统远超人类的反应速度，在某些竞争类场景开发出了作弊外挂，最常见的就是你所嫉愤的微信抢红包插件了。</p>\n<p>微信抢红包插件对原本平等的竞争环境产生了不公，不过这是微信团队要操心解决的事。可万万没想到，有一天，我正在写的App也遭此毒手！！！这都欺负到头上了能忍吗？不能啊！</p>\n<p>OK，所以我们今天先来分析一下AccessibilityService运行原理，然后分享一些我在应对此类竞争场景下基于AccessibilityService等自动化作弊工具的防御措施。</p>\n<a id=\"more\"></a>\n<h2 id=\"外挂简史\"><a href=\"#外挂简史\" class=\"headerlink\" title=\"外挂简史\"></a>外挂简史</h2><p>先说下背景：</p>\n<p>场景是和抢红包类似的另一种：抢单。用户下单后订单会经过系统，在配送端App发布，配送人员在配送端App通过距离、价钱、时间等维度进行筛选并抢单然后配送。显而易见，价高距离短的订单非常抢手，这样就形成一种竞争环境，于是，自动抢单外挂也就有了存在的理由。</p>\n<p>然后我们来看下外挂进化史：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/外挂简史.png\" alt=\"\"></p>\n<ul>\n<li><p>第一代外挂</p>\n<p>  第一代外挂还比较粗糙，需要依赖按键精灵来实现，且需要Root权限。</p>\n<p>  【防御】简单反编译拆包了解后，考虑暂时没有更好的办法禁止按键精灵对App的模拟点击，直接封禁Root可能会有大量误杀，第一代防御仅简单的检查是否安装了按键精灵，然后限制用户抢单。</p>\n</li>\n<li><p>第二代外挂</p>\n<p>  可能因为第一代的防御过于粗糙，第二代外挂很快有了新的改进，不再需要单独安装按键精灵这个App，他们把按键精灵集成到了自己的app里……</p>\n<p>  【防御】此时团队内部简单商量后决定，快刀斩乱麻，直接封禁Root权限，检测到Root后将限制抢单。</p>\n</li>\n<li><p>第三代外挂</p>\n<p>  禁止Root后终于消停了一段时间，但显然人民群众的智慧是无限的，很快新的免Root外挂出世了……经过反编译外挂后，第三代外挂采用了AccessibilityService来实现。</p>\n<p>  【防御】此时已知的外挂并不多，所以除了继续封禁Root以外，还建立了可远程配置的外挂package name黑名单列表，若检测到已安装app列表里存在特定外挂包名后，将会进行抢单限制。<br>  package name需要先获取到安装包来查看包名，随着外挂数量逐步上涨，外挂安装包获取难度大的缺点开始暴露了。</p>\n</li>\n<li><p>【第三代防御】</p>\n<p>  此时针对上一个版本的防御措施做了一次优化：<br>  1.优先检查外挂package name<br>  2.次级检测外挂app name，加package name白名单防误判。这样就不需要再获取app的安装包了<br>  3.增加骑手举报反馈入口<br>  4.收集了已启动的辅助模式列表备用（本想再快到斩乱麻的禁止辅助模式的开启，但这个误杀范围实在是太大了，最终还是停留在了想一想的阶段）</p>\n</li>\n<li><p>第四代外挂</p>\n<p>  在通过app name封禁后，外挂们挣扎了几次都被即时遏制了。但很快，我们收到了最新的外挂信息：新出来的外挂没有图标，看不到名字…… （你们厉害你们厉害！！！）</p>\n</li>\n</ul>\n<p><strong>哎呀~真是活久见，两波从来没见过的人在互相进步啊这是！！！禁止外挂安装这种简单的防御措施已经挡不住这帮疯狂的人类了，我只能一头扎进了AccessibilityService的源码中，看这到底是个啥东西，然后去思考相应的防御方案。</strong></p>\n<h2 id=\"AccessibilityService运行原理\"><a href=\"#AccessibilityService运行原理\" class=\"headerlink\" title=\"AccessibilityService运行原理\"></a>AccessibilityService运行原理</h2><h3 id=\"AccessibilityService内部运行\"><a href=\"#AccessibilityService内部运行\" class=\"headerlink\" title=\"AccessibilityService内部运行\"></a>AccessibilityService内部运行</h3><p>这不是一篇AccessibilityService教程文章，没有AccessibilityService完整的使用示例代码和源码，但为了上下文不至于断档太大，我们这里还是会简单贴一些小段代码。同时需要说明的是，严谨的来说AccessibilityService只是一个Service，文本查找点击事件等操作对于一个Service来说是完全没法做到的。但为了行文方便，所以后面某些AccessibilityService代指辅助模式服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyAccessibilityService extends AccessibilityService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onAccessibilityEvent(AccessibilityEvent accessibilityEvent) &#123;</span><br><span class=\"line\">        //获取eventType</span><br><span class=\"line\">        int eventType = accessibilityEvent.getEventType();</span><br><span class=\"line\">        if (eventType == AccessibilityEvent.TYPE_VIEW_CLICKED) &#123;</span><br><span class=\"line\">            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();</span><br><span class=\"line\">            if (nodeInfo != null) &#123;</span><br><span class=\"line\">                //查询文案为BUTTON3的View</span><br><span class=\"line\">                List&lt;AccessibilityNodeInfo&gt; button3 = nodeInfo.findAccessibilityNodeInfosByText(&quot;BUTTON3&quot;);</span><br><span class=\"line\">                nodeInfo.recycle();</span><br><span class=\"line\">                for (AccessibilityNodeInfo item : button3) &#123;</span><br><span class=\"line\">                    //对这个View执行点击操作</span><br><span class=\"line\">                    item.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AccessibilityService真的很简单，只要写一个Service继承AccessibilityService，然后还有其他一些配置，之后每当你监控的应用界面有变动时就会回调到这个onAccessibilityEvent这个方法，你可以在里面取得此时变动的event类型是什么，还能拿到当前这个应用可视化的View树，然后取得其中的某个View来执行某些操作。</p>\n<p>那至于其原理，用屁股想想也知道是肯定是被监控的App发生界面改变时通知了系统，然后系统又通知给了我们注册的Service。嗯……屁股想的没错……那App怎么通知系统的？系统又怎么通知我们的呢？</p>\n<p>哎呀，屁股想不出来了，没关系，屁股决定脑袋，脑袋知道怎么办。这个时候我们就该钻到源码里来一探究竟了。Emmm~就先从我们继承的这个AccessibilityService为入口进行研究吧！</p>\n<p>哎呀~RTFSC，这乱糟糟的一片源代码催眠的一把好手，我们还是不看了，我给你画个图吧……</p>\n<p>我理出一份AccessibilityService类图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility类图.png\" alt=\"\"></p>\n<p>乍一看好像乱糟糟的，没事，我慢慢给你絮叨，肯定比直接看源码来的直观有意思。</p>\n<p>1.AccessibilityService有两个抽象方法，<code>onAccessibilityEvent()</code>和<code>onInterrupt()</code>，就是我们要自己实现的那两个，重点记<code>onAccessibilityEvent()</code>，它会出现很多次，我们姑且先命名它为<code>AS-onAccessibilityEvent()</code>.<code>onAccessibilityEvent()</code>的参数类型是<code>AccessibilityEvent</code>,这个类简而意之就是当系统中发生某些事件时，会发送这个类的对象来告知监控方，通过这个对象可以知道是什么类型的事件、什么控件发出来等等。</p>\n<p>2.另外<code>AccessibilityService</code>继承了<code>Service</code>，但它仅复写了<code>onBind</code>方法。在<code>onBind</code>方法中return了一个<code>IAccessibilityServiceClientWrapper</code>对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public final IBinder onBind(Intent intent) &#123;</span><br><span class=\"line\">        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAccessibilityEvent(AccessibilityEvent event) &#123;</span><br><span class=\"line\">            AccessibilityService.this.onAccessibilityEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.<code>IAccessibilityServiceClientWrapper</code>继承了<code>IAccessibilityServiceClient.Stub</code>，嗯~看到这你应该就明白一大块了，<code>AccessibilityService</code>是一个跨进程通信Service。<code>IAccessibilityServiceClientWrapper</code>是这个类的重点关注对象了，那他作为一个AIDL的一个server端，他有哪些对外提供的方法呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IAccessibilityServiceClient &#123;</span><br><span class=\"line\">    void init(in IAccessibilityServiceConnection connection, int connectionId, IBinder windowToken);</span><br><span class=\"line\">    void onAccessibilityEvent(in AccessibilityEvent event);</span><br><span class=\"line\">    void onInterrupt();</span><br><span class=\"line\">    void onGesture(int gesture);</span><br><span class=\"line\">    void clearAccessibilityCache();</span><br><span class=\"line\">    void onKeyEvent(in KeyEvent event, int sequence);</span><br><span class=\"line\">    void onMagnificationChanged(in Region region, float scale, float centerX, float centerY);</span><br><span class=\"line\">    void onSoftKeyboardShowModeChanged(int showMode);</span><br><span class=\"line\">    void onPerformGestureResult(int sequence, boolean completedSuccessfully);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里你又看到了<code>onAccessibilityEvent()</code>,我们姑且叫他<code>IASC-onAccessibilityEvent()</code>.</p>\n<p>4.然后我们在回头看看<code>IAccessibilityServiceClientWrapper</code>的构造方法中的三个参数，<code>Context、 Looper 、Callbacks</code>。<code>Context</code>不说了，<code>Looper</code>是一个<code>MainLooper</code>,<br>他们两个的作用是创建一个HandlerCaller对象,HandlerCaller你可以很粗狂的就把它当做Handler，想了解细节可以自己看一下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public IAccessibilityServiceClientWrapper(Context context, Looper looper,Callbacks callback) &#123;</span><br><span class=\"line\">            mCallback = callback;</span><br><span class=\"line\">            mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>5.然后我们来看看<code>Callbacks</code>是个啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callbacks &#123;</span><br><span class=\"line\">        void onAccessibilityEvent(AccessibilityEvent event);</span><br><span class=\"line\">        void onInterrupt();</span><br><span class=\"line\">        void onServiceConnected();</span><br><span class=\"line\">        void init(int connectionId, IBinder windowToken);</span><br><span class=\"line\">        boolean onGesture(int gestureId);</span><br><span class=\"line\">        boolean onKeyEvent(KeyEvent event);</span><br><span class=\"line\">        void onMagnificationChanged(@NonNull Region region,</span><br><span class=\"line\">                float scale, float centerX, float centerY);</span><br><span class=\"line\">        void onSoftKeyboardShowModeChanged(int showMode);</span><br><span class=\"line\">        void onPerformGestureResult(int sequence, boolean completedSuccessfully);</span><br><span class=\"line\">        void onFingerprintCapturingGesturesChanged(boolean active);</span><br><span class=\"line\">        void onFingerprintGesture(int gesture);</span><br><span class=\"line\">        void onAccessibilityButtonClicked();</span><br><span class=\"line\">        void onAccessibilityButtonAvailabilityChanged(boolean available);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这和刚才那个<code>IAccessibilityServiceClient</code>不是一样嘛？没错，是这样的，而且这里面也有一个<code>onAccessibilityEvent</code>,我们叫它<code>Callbacks-onAccessibilityEvent</code>。</p>\n<p>上面你应该看到<code>Callbacks</code>是一个匿名内部类，他实现的<code>Callbacks-onAccessibilityEvent</code>方法的就是一句：<code>AccessibilityService.this.onAccessibilityEvent(event);</code>直接调用了<code>AS-onAccessibilityEvent()</code>，先记下来哈。</p>\n<p>6.哦对，<code>IAccessibilityServiceClientWrapper</code>还实现了一个<code>HandlerCaller.Callback</code>接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callback &#123;</span><br><span class=\"line\">    public void executeMessage(Message msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.最后我们看一下<code>IAccessibilityServiceClientWrapper</code>对两个接口<code>IAccessibilityServiceClient</code>和<code>HandlerCaller.Callback</code>的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) &#123;</span><br><span class=\"line\">    Message message = mCaller.obtainMessageBO(</span><br><span class=\"line\">            DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);</span><br><span class=\"line\">    mCaller.sendMessage(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void executeMessage(Message message) &#123;</span><br><span class=\"line\">    switch (message.what) &#123;</span><br><span class=\"line\">        case DO_ON_ACCESSIBILITY_EVENT: &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            \tmCallback.onAccessibilityEvent(event);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; return;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我只保留了最关键的代码，我们以<code>onAccessibilityEvent</code>为线索方法捋一遍哈。当AIDL的Client端调用了<code>IASC-onAccessibilityEvent</code>时，会通过Handler发送一个message给自己，接收到以后会调用<code>Callbacks-onAccessibilityEvent</code>，<code>Callbacks-onAccessibilityEvent</code>我们刚才看过啦，会调用<code>AS-onAccessibilityEvent()</code>,这是个抽象方法，也就是我们自己实现的MyAccessibilityService中的自定义代码。</p>\n<p>有点懵？？不明白到底在干啥？没关系，我还画了个搓搓的流程图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility流程图.png\" alt=\"\"></p>\n<p>当View发生改变时，会发出一个AccessibilityEvent出来，这个Event会通过Binder驱动发送给IAccessibilityServiceClientWrapper，调用他的onAccessibilityEvent(AccessibilityEvent)方法，这个方法通过Handler发送了一个Message给自己，目的是为了从Binder线程转回主线程。然后调用了<code>mCallback.onAccessibilityEvent(event)</code>，间接的调用了<code>AccessibilityService.this.onAccessibilityEvent(event);</code>，也就是我们自己实现的。</p>\n<p>这么顺下来，AccessibilityService的内部逻辑是不就感觉很简单了？</p>\n<h3 id=\"AccessibilityService外部运行\"><a href=\"#AccessibilityService外部运行\" class=\"headerlink\" title=\"AccessibilityService外部运行\"></a>AccessibilityService外部运行</h3><p>我们梳理了一遍AccessibilityService的内部执行逻辑后，就会触发很多新的问题，比如onBind是谁来调用的啊？为什么中间还要用Hander给自己发送一遍消息呢？当我们自己实现onAccessibilityEvent方法时会做一些点击一类的操作，这个是怎么做到的啊？</p>\n<p>哎呀，问题好多，这个源码梳理下来肯定要睡第二觉了，我们不看了不看了，直接上图吧：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility整体流程.png\" alt=\"\"></p>\n<p>1.一个可爱的用户在设置页面启动了某个辅助模式服务<br>2.系统发送了一条广播到AccessibilityManagerService，收到广播后，AccessibilityManagerService绑定了我们写的AccessibilityService，就这样调用了onBind方法。AIDL的Server端准备好了~ AccessibilityManagerService是一个系统服务，由SystemService启动。</p>\n<p>3.受到监控的App某个View发生了改变，其内部都会调用AccessibilityManager来发送event，其具体发送的对象是ViewRootImpl类来做的。<br>4.发出event后会通过Binder驱动调用到AccessibilityService，最终调用了我们复写的onAccessibilityEvent方法。<br>5.每一个View在AccessibilityService中都会被映射为一个AccessibilityNodeInfo对象，我们通过这个对象去查找具体View、触发事件，其本质是调用了AccessibilityInteractionClient类的对应方法。<br>6.AccessibilityInteractionClient我们在Uiautomator也经常看到。后面我们会继续单独分析，先大概说一下是个什么东西，官方注释是这样的：<br><em>This class is a singleton that performs accessibility interaction  which is it queries remote view hierarchies about snapshots of their views as well requests from these hierarchies to perform certain actions on their views.</em><br><em>这个类是一个可以执行可访问性交互的单例对象，它查询远程视图层次结构，查看视图的快照，以及来自这些层次结构的请求，以便在视图上执行某些操作。</em><br>7.如果利用AccessibilityInteractionClient操作正在被监控的App，比如点击按钮，那么View发生变化，又发送出一个Event，这样便形成一个循环。</p>\n<h3 id=\"AccessibilityInteractionClient-操作View细节\"><a href=\"#AccessibilityInteractionClient-操作View细节\" class=\"headerlink\" title=\"AccessibilityInteractionClient 操作View细节\"></a>AccessibilityInteractionClient 操作View细节</h3><p>在我们了解了AccessibilitySevice从View产生event事件发出到被辅助服务接收再操作View的一个流程之后，我们仅仅知道了事件是如何通知到AccessibilityService的，而具体是如何通过文本查找View，点击View则是AccessibilityInteractionClient来做的，那么下面我们就通过AccessibilityInteractionClient 的源码探究一下里面的秘密。</p>\n<p>我们主要以findAccessibilityNodeInfosByText和performAccessibilityAction（ACTION_CLICK）两个方法往下追。</p>\n<p>整体代码较为简单，基本是一条线往下调用的逻辑，所以我又画了一张图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/AccessibilityInteractionClient.png\" alt=\"\"></p>\n<p>1.AccessibilityInteractionClient没做什么操作，直接通过Binder调用了AccessibilityManagerService对应的方法。</p>\n<p>2.AccessibilityManagerService最终还是通过Binder调用了ViewRootImpl对应的方法。</p>\n<p>3.ViewRootImpl仅作为Binder中的服务端接收调用，真正的操作交给AccessibilityInteractionController来做。</p>\n<p>4.AccessibilityInteractionController对应的方法被调用之后，并没有直接进行操作，而是通过Handler做了一次转发，以便从Binder线程转到UI线程。</p>\n<p>5.以performAccessibilityAction（ACTION_CLICK）点击事件为例，最终调用的实际是View的mOnClickListener。</p>\n<p>6.以findAccessibilityNodeInfosByText为例，最终调用的实际是View的findViewsWithText方法，其方法内部实际对比的值是mContentDescription。需要特别说明的是TextView重写了该方法，其内部实际对比的值是mText。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>我们既然已经了解了AccessibilityService的运行原理，其内部就是一个跨进程通信，没什么神秘的。最终操作View的是AccessibilityInteractionClient，AccessibilityInteractionClient是怎么操作的通过源码很容易的追到了View层具体的实现，那么做防御的话简直是手到擒来！</p>\n<h2 id=\"AccessibilityService防御\"><a href=\"#AccessibilityService防御\" class=\"headerlink\" title=\"AccessibilityService防御\"></a>AccessibilityService防御</h2><h3 id=\"1-检测-or-禁止相关外挂的辅助模式开启\"><a href=\"#1-检测-or-禁止相关外挂的辅助模式开启\" class=\"headerlink\" title=\"1.检测 or 禁止相关外挂的辅助模式开启\"></a>1.检测 or 禁止相关外挂的辅助模式开启</h3><p>之前在外挂防御上，一直困扰我的一个问题是：AccessibilityService类似一个解耦很开的观察者模式，作为被观察者无法察觉到观察者究竟有哪些，这导致我们非常的被动。</p>\n<p>不过研究过AccessibilityService源码之后，我们知道，每个AccessibilityService在都是由AccessibilityManagerService注册的，那岂不是说我们可以通过AccessibilityManagerService取得所有以安装或以启动的辅助模式应用？那么AccessibilityManagerService有提供相关方法吗？<br>有的：</p>\n<p>AccessibilityManagerService.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccessibilityManagerService extends IAccessibilityManager.Stub &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"> \t@Override</span><br><span class=\"line\">    public List&lt;AccessibilityServiceInfo&gt; getInstalledAccessibilityServiceList(int userId) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，这个方法帮我们筛去了UiAutomationService。返回值AccessibilityServiceInfo是AccessibilityService的一些配置信息，其中包含我们最关心的packageNames(AccessibilityService 监控哪些package发出的Event)</p>\n<p>这里有一个小问题，AccessibilityManagerService是com.android.server.accessibility包下的类，我们没有办法直接使用。不过没关系，你可以通过AccessibilityManager来间接的操作AccessibilityManagerService，其内部利用Binder间接的调用了AccessibilityManagerService，得到List<accessibilityserviceinfo>之后，你可以通过遍历了解到自己的应用正在被那些辅助模式监控或“辅助”。</accessibilityserviceinfo></p>\n<p>具体方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 取得正在监控目标包名的AccessibilityService</span><br><span class=\"line\"> */</span><br><span class=\"line\">private List&lt;AccessibilityServiceInfo&gt; getInstalledAccessibilityServiceList(String targetPackage) &#123;</span><br><span class=\"line\">    List&lt;AccessibilityServiceInfo&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    AccessibilityManager accessibilityManager = (AccessibilityManager) getApplicationContext().getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class=\"line\">    if (accessibilityManager == null) &#123;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;AccessibilityServiceInfo&gt; infoList = accessibilityManager.getInstalledAccessibilityServiceList();</span><br><span class=\"line\">    if (infoList == null || infoList.size() == 0) &#123;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (AccessibilityServiceInfo info : infoList) &#123;</span><br><span class=\"line\">        if (info.packageNames == null) &#123;</span><br><span class=\"line\">            result.add(info);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            for (String packageName : info.packageNames) &#123;</span><br><span class=\"line\">                if (targetPackage.equals(packageName)) &#123;</span><br><span class=\"line\">                    result.add(info);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>需要特别说明的是：</strong>当info.packageNames为null时，表示监控所有包名。外挂有可能蒙混其中，但如果一刀切，也有可能误杀正常软件。</li>\n<li>getInstalledAccessibilityServiceList获取所有已安装的AccessibilityService,AccessibilityManager还有一个方法getEnabledAccessibilityServiceList,取得所有已经开启的AccessibilityService，用法同上。但要注意的是。检测外挂肯定是在某个节点进行，比如我们的App初次启动，那么用户可以在启动App后再启动外挂，这将是一个漏洞。</li>\n</ul>\n<h3 id=\"2-Event干扰\"><a href=\"#2-Event干扰\" class=\"headerlink\" title=\"2.Event干扰\"></a>2.Event干扰</h3><p>我们一直知道AccessibilityServices在监控目标app发出的AccessibilityEvent，从而对应的作出某些操作。</p>\n<p>例如某些微信红包插件会监控Notification的弹出，那么我们是否可以随意发送这样的Event出来，从而混干扰外挂插件的运行逻辑？</p>\n<p>没错，可以这样做的，具体方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textView.sendAccessibilityEvent(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</span><br></pre></td></tr></table></figure>\n<p>但这个方案的缺陷是，大部分的外挂插件对特定类型的事件并不是特别感兴趣，他们仅在收到Event后检查页面上是否有某些特定的元素，从而决定是否进行下一步操作。</p>\n<p>大部分情况下是一个比较鸡肋的措施，但也许会在某些场景起到意想不到的作用！</p>\n<h3 id=\"3-屏蔽AccessibilityServices文案检查\"><a href=\"#3-屏蔽AccessibilityServices文案检查\" class=\"headerlink\" title=\"3.屏蔽AccessibilityServices文案检查\"></a>3.屏蔽AccessibilityServices文案检查</h3><p>在没有探究AccessibilityServices源码之前，不了解AccessibilityServices检索文本信息原理的我们可能唯一能想到的应对措施就是将关键问题替换为图片。</p>\n<p>这可以解决问题，但是问题替换为图片不但会有性能上的损耗，而且会丢失大部分原本TextView的兼容特性。</p>\n<p>不过在了解AccessibilityServices源码之后，我们知道其内部核心原理就是调用TextView的findViewsWithText方法，不再需要费劲心思将文本转为图片，你需要做的仅仅是复写这个方法就够了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefensiveTextView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags) &#123;</span><br><span class=\"line\">        outViews.remove(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样AccessibilityServices文案检查将会在这个View上失效。</p>\n<h3 id=\"4-屏蔽AccessibilityServices点击事件\"><a href=\"#4-屏蔽AccessibilityServices点击事件\" class=\"headerlink\" title=\"4.屏蔽AccessibilityServices点击事件\"></a>4.屏蔽AccessibilityServices点击事件</h3><p>像上面一样，通过源码了解原理之后，我们知道AccessibilityServices执行点击事件最终在调用View的mOnClickListener。</p>\n<p>那我们只需要在这上面做文章就好了，最快捷的办法是利用onTouch代替onClick。</p>\n<h3 id=\"5-检测-or-禁止相关外挂软件安装\"><a href=\"#5-检测-or-禁止相关外挂软件安装\" class=\"headerlink\" title=\"5.检测 or 禁止相关外挂软件安装\"></a>5.检测 or 禁止相关外挂软件安装</h3><p>上述方式无论是检测已安装的AccessibilityServices列表还是屏蔽AccessibilityServices的文本检查和点击事件，针对的都是AccessibilityServices本身。当你出台这样的方式后，确实后会让现有的外挂消停一段时间，但可以预见，很快会有基于其他自动化措施的外挂面世，比如类似按键精力一样的模拟Touch事件，图像识别等，在出现应对这些手段之前，你还是需要一些笨笨的老办法，收集已知外挂，禁止其安装。</p>\n<p>检查方法非常简单，一句带过：设立黑名单，遍历系统内部所有已安装的app，鉴别package name 和app name。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>在拨开了AccessibilityServices源码的外衣之后，我们会发现其实它的原理真的很简单，唯一的核心是在Client  - System - Server三者之间利用Binder做跨进程通信，几乎没有太多的逻辑操作，一直在互相调用。</p>\n<p>所以看着神奇且神秘的AccessibilityServices其实并没有什么了不起。</p>\n<p>另外要说的是，在没了解AccessibilityServices源码之前，我们能想到的防御措施可能非常少且低效，比如原本只用复写一个方法，你却需要动态生成图片。了解源码之后，你便可以单刀直入，直切重点用最有效最简单的方式实现你想要的东西，所以阅读源码真的很重要！</p>\n<p>最后先总结一下防御措施吧。</p>\n<ul>\n<li>通过AccessibilityManager检测 or 禁止相关外挂的辅助模式开启</li>\n<li>自定义TextView复写findViewsWithText方法，屏蔽文案检查</li>\n<li>onTouch替换onClick，屏蔽点击事件</li>\n<li>随机发送Event干扰</li>\n<li>通过PackageManager检测 or 禁止相关外挂软件安装</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>提起AccessibilityService，你最容易联想到的肯定是微信抢红包插件！但这个服务的设计初衷，是为了帮助残障人士可以更好的使用App。</p>\n<p>一些“调皮”的开发者利用AccessibilityService可以监控与操作其他App的特性加上系统远超人类的反应速度，在某些竞争类场景开发出了作弊外挂，最常见的就是你所嫉愤的微信抢红包插件了。</p>\n<p>微信抢红包插件对原本平等的竞争环境产生了不公，不过这是微信团队要操心解决的事。可万万没想到，有一天，我正在写的App也遭此毒手！！！这都欺负到头上了能忍吗？不能啊！</p>\n<p>OK，所以我们今天先来分析一下AccessibilityService运行原理，然后分享一些我在应对此类竞争场景下基于AccessibilityService等自动化作弊工具的防御措施。</p>","more":"<h2 id=\"外挂简史\"><a href=\"#外挂简史\" class=\"headerlink\" title=\"外挂简史\"></a>外挂简史</h2><p>先说下背景：</p>\n<p>场景是和抢红包类似的另一种：抢单。用户下单后订单会经过系统，在配送端App发布，配送人员在配送端App通过距离、价钱、时间等维度进行筛选并抢单然后配送。显而易见，价高距离短的订单非常抢手，这样就形成一种竞争环境，于是，自动抢单外挂也就有了存在的理由。</p>\n<p>然后我们来看下外挂进化史：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/外挂简史.png\" alt=\"\"></p>\n<ul>\n<li><p>第一代外挂</p>\n<p>  第一代外挂还比较粗糙，需要依赖按键精灵来实现，且需要Root权限。</p>\n<p>  【防御】简单反编译拆包了解后，考虑暂时没有更好的办法禁止按键精灵对App的模拟点击，直接封禁Root可能会有大量误杀，第一代防御仅简单的检查是否安装了按键精灵，然后限制用户抢单。</p>\n</li>\n<li><p>第二代外挂</p>\n<p>  可能因为第一代的防御过于粗糙，第二代外挂很快有了新的改进，不再需要单独安装按键精灵这个App，他们把按键精灵集成到了自己的app里……</p>\n<p>  【防御】此时团队内部简单商量后决定，快刀斩乱麻，直接封禁Root权限，检测到Root后将限制抢单。</p>\n</li>\n<li><p>第三代外挂</p>\n<p>  禁止Root后终于消停了一段时间，但显然人民群众的智慧是无限的，很快新的免Root外挂出世了……经过反编译外挂后，第三代外挂采用了AccessibilityService来实现。</p>\n<p>  【防御】此时已知的外挂并不多，所以除了继续封禁Root以外，还建立了可远程配置的外挂package name黑名单列表，若检测到已安装app列表里存在特定外挂包名后，将会进行抢单限制。<br>  package name需要先获取到安装包来查看包名，随着外挂数量逐步上涨，外挂安装包获取难度大的缺点开始暴露了。</p>\n</li>\n<li><p>【第三代防御】</p>\n<p>  此时针对上一个版本的防御措施做了一次优化：<br>  1.优先检查外挂package name<br>  2.次级检测外挂app name，加package name白名单防误判。这样就不需要再获取app的安装包了<br>  3.增加骑手举报反馈入口<br>  4.收集了已启动的辅助模式列表备用（本想再快到斩乱麻的禁止辅助模式的开启，但这个误杀范围实在是太大了，最终还是停留在了想一想的阶段）</p>\n</li>\n<li><p>第四代外挂</p>\n<p>  在通过app name封禁后，外挂们挣扎了几次都被即时遏制了。但很快，我们收到了最新的外挂信息：新出来的外挂没有图标，看不到名字…… （你们厉害你们厉害！！！）</p>\n</li>\n</ul>\n<p><strong>哎呀~真是活久见，两波从来没见过的人在互相进步啊这是！！！禁止外挂安装这种简单的防御措施已经挡不住这帮疯狂的人类了，我只能一头扎进了AccessibilityService的源码中，看这到底是个啥东西，然后去思考相应的防御方案。</strong></p>\n<h2 id=\"AccessibilityService运行原理\"><a href=\"#AccessibilityService运行原理\" class=\"headerlink\" title=\"AccessibilityService运行原理\"></a>AccessibilityService运行原理</h2><h3 id=\"AccessibilityService内部运行\"><a href=\"#AccessibilityService内部运行\" class=\"headerlink\" title=\"AccessibilityService内部运行\"></a>AccessibilityService内部运行</h3><p>这不是一篇AccessibilityService教程文章，没有AccessibilityService完整的使用示例代码和源码，但为了上下文不至于断档太大，我们这里还是会简单贴一些小段代码。同时需要说明的是，严谨的来说AccessibilityService只是一个Service，文本查找点击事件等操作对于一个Service来说是完全没法做到的。但为了行文方便，所以后面某些AccessibilityService代指辅助模式服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyAccessibilityService extends AccessibilityService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onAccessibilityEvent(AccessibilityEvent accessibilityEvent) &#123;</span><br><span class=\"line\">        //获取eventType</span><br><span class=\"line\">        int eventType = accessibilityEvent.getEventType();</span><br><span class=\"line\">        if (eventType == AccessibilityEvent.TYPE_VIEW_CLICKED) &#123;</span><br><span class=\"line\">            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();</span><br><span class=\"line\">            if (nodeInfo != null) &#123;</span><br><span class=\"line\">                //查询文案为BUTTON3的View</span><br><span class=\"line\">                List&lt;AccessibilityNodeInfo&gt; button3 = nodeInfo.findAccessibilityNodeInfosByText(&quot;BUTTON3&quot;);</span><br><span class=\"line\">                nodeInfo.recycle();</span><br><span class=\"line\">                for (AccessibilityNodeInfo item : button3) &#123;</span><br><span class=\"line\">                    //对这个View执行点击操作</span><br><span class=\"line\">                    item.performAction(AccessibilityNodeInfo.ACTION_CLICK);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AccessibilityService真的很简单，只要写一个Service继承AccessibilityService，然后还有其他一些配置，之后每当你监控的应用界面有变动时就会回调到这个onAccessibilityEvent这个方法，你可以在里面取得此时变动的event类型是什么，还能拿到当前这个应用可视化的View树，然后取得其中的某个View来执行某些操作。</p>\n<p>那至于其原理，用屁股想想也知道是肯定是被监控的App发生界面改变时通知了系统，然后系统又通知给了我们注册的Service。嗯……屁股想的没错……那App怎么通知系统的？系统又怎么通知我们的呢？</p>\n<p>哎呀，屁股想不出来了，没关系，屁股决定脑袋，脑袋知道怎么办。这个时候我们就该钻到源码里来一探究竟了。Emmm~就先从我们继承的这个AccessibilityService为入口进行研究吧！</p>\n<p>哎呀~RTFSC，这乱糟糟的一片源代码催眠的一把好手，我们还是不看了，我给你画个图吧……</p>\n<p>我理出一份AccessibilityService类图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility类图.png\" alt=\"\"></p>\n<p>乍一看好像乱糟糟的，没事，我慢慢给你絮叨，肯定比直接看源码来的直观有意思。</p>\n<p>1.AccessibilityService有两个抽象方法，<code>onAccessibilityEvent()</code>和<code>onInterrupt()</code>，就是我们要自己实现的那两个，重点记<code>onAccessibilityEvent()</code>，它会出现很多次，我们姑且先命名它为<code>AS-onAccessibilityEvent()</code>.<code>onAccessibilityEvent()</code>的参数类型是<code>AccessibilityEvent</code>,这个类简而意之就是当系统中发生某些事件时，会发送这个类的对象来告知监控方，通过这个对象可以知道是什么类型的事件、什么控件发出来等等。</p>\n<p>2.另外<code>AccessibilityService</code>继承了<code>Service</code>，但它仅复写了<code>onBind</code>方法。在<code>onBind</code>方法中return了一个<code>IAccessibilityServiceClientWrapper</code>对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public final IBinder onBind(Intent intent) &#123;</span><br><span class=\"line\">        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAccessibilityEvent(AccessibilityEvent event) &#123;</span><br><span class=\"line\">            AccessibilityService.this.onAccessibilityEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.<code>IAccessibilityServiceClientWrapper</code>继承了<code>IAccessibilityServiceClient.Stub</code>，嗯~看到这你应该就明白一大块了，<code>AccessibilityService</code>是一个跨进程通信Service。<code>IAccessibilityServiceClientWrapper</code>是这个类的重点关注对象了，那他作为一个AIDL的一个server端，他有哪些对外提供的方法呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IAccessibilityServiceClient &#123;</span><br><span class=\"line\">    void init(in IAccessibilityServiceConnection connection, int connectionId, IBinder windowToken);</span><br><span class=\"line\">    void onAccessibilityEvent(in AccessibilityEvent event);</span><br><span class=\"line\">    void onInterrupt();</span><br><span class=\"line\">    void onGesture(int gesture);</span><br><span class=\"line\">    void clearAccessibilityCache();</span><br><span class=\"line\">    void onKeyEvent(in KeyEvent event, int sequence);</span><br><span class=\"line\">    void onMagnificationChanged(in Region region, float scale, float centerX, float centerY);</span><br><span class=\"line\">    void onSoftKeyboardShowModeChanged(int showMode);</span><br><span class=\"line\">    void onPerformGestureResult(int sequence, boolean completedSuccessfully);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里你又看到了<code>onAccessibilityEvent()</code>,我们姑且叫他<code>IASC-onAccessibilityEvent()</code>.</p>\n<p>4.然后我们在回头看看<code>IAccessibilityServiceClientWrapper</code>的构造方法中的三个参数，<code>Context、 Looper 、Callbacks</code>。<code>Context</code>不说了，<code>Looper</code>是一个<code>MainLooper</code>,<br>他们两个的作用是创建一个HandlerCaller对象,HandlerCaller你可以很粗狂的就把它当做Handler，想了解细节可以自己看一下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public IAccessibilityServiceClientWrapper(Context context, Looper looper,Callbacks callback) &#123;</span><br><span class=\"line\">            mCallback = callback;</span><br><span class=\"line\">            mCaller = new HandlerCaller(context, looper, this, true /*asyncHandler*/);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>5.然后我们来看看<code>Callbacks</code>是个啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callbacks &#123;</span><br><span class=\"line\">        void onAccessibilityEvent(AccessibilityEvent event);</span><br><span class=\"line\">        void onInterrupt();</span><br><span class=\"line\">        void onServiceConnected();</span><br><span class=\"line\">        void init(int connectionId, IBinder windowToken);</span><br><span class=\"line\">        boolean onGesture(int gestureId);</span><br><span class=\"line\">        boolean onKeyEvent(KeyEvent event);</span><br><span class=\"line\">        void onMagnificationChanged(@NonNull Region region,</span><br><span class=\"line\">                float scale, float centerX, float centerY);</span><br><span class=\"line\">        void onSoftKeyboardShowModeChanged(int showMode);</span><br><span class=\"line\">        void onPerformGestureResult(int sequence, boolean completedSuccessfully);</span><br><span class=\"line\">        void onFingerprintCapturingGesturesChanged(boolean active);</span><br><span class=\"line\">        void onFingerprintGesture(int gesture);</span><br><span class=\"line\">        void onAccessibilityButtonClicked();</span><br><span class=\"line\">        void onAccessibilityButtonAvailabilityChanged(boolean available);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这和刚才那个<code>IAccessibilityServiceClient</code>不是一样嘛？没错，是这样的，而且这里面也有一个<code>onAccessibilityEvent</code>,我们叫它<code>Callbacks-onAccessibilityEvent</code>。</p>\n<p>上面你应该看到<code>Callbacks</code>是一个匿名内部类，他实现的<code>Callbacks-onAccessibilityEvent</code>方法的就是一句：<code>AccessibilityService.this.onAccessibilityEvent(event);</code>直接调用了<code>AS-onAccessibilityEvent()</code>，先记下来哈。</p>\n<p>6.哦对，<code>IAccessibilityServiceClientWrapper</code>还实现了一个<code>HandlerCaller.Callback</code>接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callback &#123;</span><br><span class=\"line\">    public void executeMessage(Message msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.最后我们看一下<code>IAccessibilityServiceClientWrapper</code>对两个接口<code>IAccessibilityServiceClient</code>和<code>HandlerCaller.Callback</code>的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">public void onAccessibilityEvent(AccessibilityEvent event, boolean serviceWantsEvent) &#123;</span><br><span class=\"line\">    Message message = mCaller.obtainMessageBO(</span><br><span class=\"line\">            DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);</span><br><span class=\"line\">    mCaller.sendMessage(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void executeMessage(Message message) &#123;</span><br><span class=\"line\">    switch (message.what) &#123;</span><br><span class=\"line\">        case DO_ON_ACCESSIBILITY_EVENT: &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            \tmCallback.onAccessibilityEvent(event);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; return;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>我只保留了最关键的代码，我们以<code>onAccessibilityEvent</code>为线索方法捋一遍哈。当AIDL的Client端调用了<code>IASC-onAccessibilityEvent</code>时，会通过Handler发送一个message给自己，接收到以后会调用<code>Callbacks-onAccessibilityEvent</code>，<code>Callbacks-onAccessibilityEvent</code>我们刚才看过啦，会调用<code>AS-onAccessibilityEvent()</code>,这是个抽象方法，也就是我们自己实现的MyAccessibilityService中的自定义代码。</p>\n<p>有点懵？？不明白到底在干啥？没关系，我还画了个搓搓的流程图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility流程图.png\" alt=\"\"></p>\n<p>当View发生改变时，会发出一个AccessibilityEvent出来，这个Event会通过Binder驱动发送给IAccessibilityServiceClientWrapper，调用他的onAccessibilityEvent(AccessibilityEvent)方法，这个方法通过Handler发送了一个Message给自己，目的是为了从Binder线程转回主线程。然后调用了<code>mCallback.onAccessibilityEvent(event)</code>，间接的调用了<code>AccessibilityService.this.onAccessibilityEvent(event);</code>，也就是我们自己实现的。</p>\n<p>这么顺下来，AccessibilityService的内部逻辑是不就感觉很简单了？</p>\n<h3 id=\"AccessibilityService外部运行\"><a href=\"#AccessibilityService外部运行\" class=\"headerlink\" title=\"AccessibilityService外部运行\"></a>AccessibilityService外部运行</h3><p>我们梳理了一遍AccessibilityService的内部执行逻辑后，就会触发很多新的问题，比如onBind是谁来调用的啊？为什么中间还要用Hander给自己发送一遍消息呢？当我们自己实现onAccessibilityEvent方法时会做一些点击一类的操作，这个是怎么做到的啊？</p>\n<p>哎呀，问题好多，这个源码梳理下来肯定要睡第二觉了，我们不看了不看了，直接上图吧：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/accessibility整体流程.png\" alt=\"\"></p>\n<p>1.一个可爱的用户在设置页面启动了某个辅助模式服务<br>2.系统发送了一条广播到AccessibilityManagerService，收到广播后，AccessibilityManagerService绑定了我们写的AccessibilityService，就这样调用了onBind方法。AIDL的Server端准备好了~ AccessibilityManagerService是一个系统服务，由SystemService启动。</p>\n<p>3.受到监控的App某个View发生了改变，其内部都会调用AccessibilityManager来发送event，其具体发送的对象是ViewRootImpl类来做的。<br>4.发出event后会通过Binder驱动调用到AccessibilityService，最终调用了我们复写的onAccessibilityEvent方法。<br>5.每一个View在AccessibilityService中都会被映射为一个AccessibilityNodeInfo对象，我们通过这个对象去查找具体View、触发事件，其本质是调用了AccessibilityInteractionClient类的对应方法。<br>6.AccessibilityInteractionClient我们在Uiautomator也经常看到。后面我们会继续单独分析，先大概说一下是个什么东西，官方注释是这样的：<br><em>This class is a singleton that performs accessibility interaction  which is it queries remote view hierarchies about snapshots of their views as well requests from these hierarchies to perform certain actions on their views.</em><br><em>这个类是一个可以执行可访问性交互的单例对象，它查询远程视图层次结构，查看视图的快照，以及来自这些层次结构的请求，以便在视图上执行某些操作。</em><br>7.如果利用AccessibilityInteractionClient操作正在被监控的App，比如点击按钮，那么View发生变化，又发送出一个Event，这样便形成一个循环。</p>\n<h3 id=\"AccessibilityInteractionClient-操作View细节\"><a href=\"#AccessibilityInteractionClient-操作View细节\" class=\"headerlink\" title=\"AccessibilityInteractionClient 操作View细节\"></a>AccessibilityInteractionClient 操作View细节</h3><p>在我们了解了AccessibilitySevice从View产生event事件发出到被辅助服务接收再操作View的一个流程之后，我们仅仅知道了事件是如何通知到AccessibilityService的，而具体是如何通过文本查找View，点击View则是AccessibilityInteractionClient来做的，那么下面我们就通过AccessibilityInteractionClient 的源码探究一下里面的秘密。</p>\n<p>我们主要以findAccessibilityNodeInfosByText和performAccessibilityAction（ACTION_CLICK）两个方法往下追。</p>\n<p>整体代码较为简单，基本是一条线往下调用的逻辑，所以我又画了一张图：</p>\n<p><img src=\"/2018/01/27/AccessibilityService分析与防御/AccessibilityInteractionClient.png\" alt=\"\"></p>\n<p>1.AccessibilityInteractionClient没做什么操作，直接通过Binder调用了AccessibilityManagerService对应的方法。</p>\n<p>2.AccessibilityManagerService最终还是通过Binder调用了ViewRootImpl对应的方法。</p>\n<p>3.ViewRootImpl仅作为Binder中的服务端接收调用，真正的操作交给AccessibilityInteractionController来做。</p>\n<p>4.AccessibilityInteractionController对应的方法被调用之后，并没有直接进行操作，而是通过Handler做了一次转发，以便从Binder线程转到UI线程。</p>\n<p>5.以performAccessibilityAction（ACTION_CLICK）点击事件为例，最终调用的实际是View的mOnClickListener。</p>\n<p>6.以findAccessibilityNodeInfosByText为例，最终调用的实际是View的findViewsWithText方法，其方法内部实际对比的值是mContentDescription。需要特别说明的是TextView重写了该方法，其内部实际对比的值是mText。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>我们既然已经了解了AccessibilityService的运行原理，其内部就是一个跨进程通信，没什么神秘的。最终操作View的是AccessibilityInteractionClient，AccessibilityInteractionClient是怎么操作的通过源码很容易的追到了View层具体的实现，那么做防御的话简直是手到擒来！</p>\n<h2 id=\"AccessibilityService防御\"><a href=\"#AccessibilityService防御\" class=\"headerlink\" title=\"AccessibilityService防御\"></a>AccessibilityService防御</h2><h3 id=\"1-检测-or-禁止相关外挂的辅助模式开启\"><a href=\"#1-检测-or-禁止相关外挂的辅助模式开启\" class=\"headerlink\" title=\"1.检测 or 禁止相关外挂的辅助模式开启\"></a>1.检测 or 禁止相关外挂的辅助模式开启</h3><p>之前在外挂防御上，一直困扰我的一个问题是：AccessibilityService类似一个解耦很开的观察者模式，作为被观察者无法察觉到观察者究竟有哪些，这导致我们非常的被动。</p>\n<p>不过研究过AccessibilityService源码之后，我们知道，每个AccessibilityService在都是由AccessibilityManagerService注册的，那岂不是说我们可以通过AccessibilityManagerService取得所有以安装或以启动的辅助模式应用？那么AccessibilityManagerService有提供相关方法吗？<br>有的：</p>\n<p>AccessibilityManagerService.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AccessibilityManagerService extends IAccessibilityManager.Stub &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"> \t@Override</span><br><span class=\"line\">    public List&lt;AccessibilityServiceInfo&gt; getInstalledAccessibilityServiceList(int userId) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，这个方法帮我们筛去了UiAutomationService。返回值AccessibilityServiceInfo是AccessibilityService的一些配置信息，其中包含我们最关心的packageNames(AccessibilityService 监控哪些package发出的Event)</p>\n<p>这里有一个小问题，AccessibilityManagerService是com.android.server.accessibility包下的类，我们没有办法直接使用。不过没关系，你可以通过AccessibilityManager来间接的操作AccessibilityManagerService，其内部利用Binder间接的调用了AccessibilityManagerService，得到List<accessibilityserviceinfo>之后，你可以通过遍历了解到自己的应用正在被那些辅助模式监控或“辅助”。</accessibilityserviceinfo></p>\n<p>具体方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 取得正在监控目标包名的AccessibilityService</span><br><span class=\"line\"> */</span><br><span class=\"line\">private List&lt;AccessibilityServiceInfo&gt; getInstalledAccessibilityServiceList(String targetPackage) &#123;</span><br><span class=\"line\">    List&lt;AccessibilityServiceInfo&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    AccessibilityManager accessibilityManager = (AccessibilityManager) getApplicationContext().getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class=\"line\">    if (accessibilityManager == null) &#123;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;AccessibilityServiceInfo&gt; infoList = accessibilityManager.getInstalledAccessibilityServiceList();</span><br><span class=\"line\">    if (infoList == null || infoList.size() == 0) &#123;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (AccessibilityServiceInfo info : infoList) &#123;</span><br><span class=\"line\">        if (info.packageNames == null) &#123;</span><br><span class=\"line\">            result.add(info);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            for (String packageName : info.packageNames) &#123;</span><br><span class=\"line\">                if (targetPackage.equals(packageName)) &#123;</span><br><span class=\"line\">                    result.add(info);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>需要特别说明的是：</strong>当info.packageNames为null时，表示监控所有包名。外挂有可能蒙混其中，但如果一刀切，也有可能误杀正常软件。</li>\n<li>getInstalledAccessibilityServiceList获取所有已安装的AccessibilityService,AccessibilityManager还有一个方法getEnabledAccessibilityServiceList,取得所有已经开启的AccessibilityService，用法同上。但要注意的是。检测外挂肯定是在某个节点进行，比如我们的App初次启动，那么用户可以在启动App后再启动外挂，这将是一个漏洞。</li>\n</ul>\n<h3 id=\"2-Event干扰\"><a href=\"#2-Event干扰\" class=\"headerlink\" title=\"2.Event干扰\"></a>2.Event干扰</h3><p>我们一直知道AccessibilityServices在监控目标app发出的AccessibilityEvent，从而对应的作出某些操作。</p>\n<p>例如某些微信红包插件会监控Notification的弹出，那么我们是否可以随意发送这样的Event出来，从而混干扰外挂插件的运行逻辑？</p>\n<p>没错，可以这样做的，具体方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textView.sendAccessibilityEvent(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</span><br></pre></td></tr></table></figure>\n<p>但这个方案的缺陷是，大部分的外挂插件对特定类型的事件并不是特别感兴趣，他们仅在收到Event后检查页面上是否有某些特定的元素，从而决定是否进行下一步操作。</p>\n<p>大部分情况下是一个比较鸡肋的措施，但也许会在某些场景起到意想不到的作用！</p>\n<h3 id=\"3-屏蔽AccessibilityServices文案检查\"><a href=\"#3-屏蔽AccessibilityServices文案检查\" class=\"headerlink\" title=\"3.屏蔽AccessibilityServices文案检查\"></a>3.屏蔽AccessibilityServices文案检查</h3><p>在没有探究AccessibilityServices源码之前，不了解AccessibilityServices检索文本信息原理的我们可能唯一能想到的应对措施就是将关键问题替换为图片。</p>\n<p>这可以解决问题，但是问题替换为图片不但会有性能上的损耗，而且会丢失大部分原本TextView的兼容特性。</p>\n<p>不过在了解AccessibilityServices源码之后，我们知道其内部核心原理就是调用TextView的findViewsWithText方法，不再需要费劲心思将文本转为图片，你需要做的仅仅是复写这个方法就够了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefensiveTextView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags) &#123;</span><br><span class=\"line\">        outViews.remove(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样AccessibilityServices文案检查将会在这个View上失效。</p>\n<h3 id=\"4-屏蔽AccessibilityServices点击事件\"><a href=\"#4-屏蔽AccessibilityServices点击事件\" class=\"headerlink\" title=\"4.屏蔽AccessibilityServices点击事件\"></a>4.屏蔽AccessibilityServices点击事件</h3><p>像上面一样，通过源码了解原理之后，我们知道AccessibilityServices执行点击事件最终在调用View的mOnClickListener。</p>\n<p>那我们只需要在这上面做文章就好了，最快捷的办法是利用onTouch代替onClick。</p>\n<h3 id=\"5-检测-or-禁止相关外挂软件安装\"><a href=\"#5-检测-or-禁止相关外挂软件安装\" class=\"headerlink\" title=\"5.检测 or 禁止相关外挂软件安装\"></a>5.检测 or 禁止相关外挂软件安装</h3><p>上述方式无论是检测已安装的AccessibilityServices列表还是屏蔽AccessibilityServices的文本检查和点击事件，针对的都是AccessibilityServices本身。当你出台这样的方式后，确实后会让现有的外挂消停一段时间，但可以预见，很快会有基于其他自动化措施的外挂面世，比如类似按键精力一样的模拟Touch事件，图像识别等，在出现应对这些手段之前，你还是需要一些笨笨的老办法，收集已知外挂，禁止其安装。</p>\n<p>检查方法非常简单，一句带过：设立黑名单，遍历系统内部所有已安装的app，鉴别package name 和app name。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>在拨开了AccessibilityServices源码的外衣之后，我们会发现其实它的原理真的很简单，唯一的核心是在Client  - System - Server三者之间利用Binder做跨进程通信，几乎没有太多的逻辑操作，一直在互相调用。</p>\n<p>所以看着神奇且神秘的AccessibilityServices其实并没有什么了不起。</p>\n<p>另外要说的是，在没了解AccessibilityServices源码之前，我们能想到的防御措施可能非常少且低效，比如原本只用复写一个方法，你却需要动态生成图片。了解源码之后，你便可以单刀直入，直切重点用最有效最简单的方式实现你想要的东西，所以阅读源码真的很重要！</p>\n<p>最后先总结一下防御措施吧。</p>\n<ul>\n<li>通过AccessibilityManager检测 or 禁止相关外挂的辅助模式开启</li>\n<li>自定义TextView复写findViewsWithText方法，屏蔽文案检查</li>\n<li>onTouch替换onClick，屏蔽点击事件</li>\n<li>随机发送Event干扰</li>\n<li>通过PackageManager检测 or 禁止相关外挂软件安装</li>\n</ul>"},{"title":"Calabash探索1-Run Calabash","date":"2017-03-20T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n作为这个系列的第一篇，先介绍一下大纲：\n\n- 《Run Calabash》简单介绍Calabash环境搭建及基本运行，然你给对Calabash有一个基础认识\n- 《Calabash用法详解》认识Calabash后介绍Calabash的基础用法，从而可以快速上手\n- 《Calabash进阶》介绍一些特殊或不常用到的技巧，对Calabash有更深的认识\n- 《Calabash踩坑》为不影响文章阅读的连贯性，相关异常解决的内容单列一章\n\n<!-- more -->\n\n看了一些Calabash入门的文章，便准备开始实践。但在最开始时，真的好气啊。 \n从来没人告诉我Mac安装Calabash需要xcode支持！\n大部分的入门demo止步于一个简单的case，从来没人告诉我后续的case需要怎么继续执行！！！\n一条怎么看怎么没毛病的语句，怎么就无脑报错呢？\n...\n\n其实这些都是开发中的一些意外情况，但就是这些意外情况，让好多人就此止步了。其实如果耐心一点，在官方文档深挖一下，把十几篇几十篇博客参照着一起看，再或者辛苦一点，多多试错，这些坑其实都能踩平。\n但是这种方法代价太大了，作为一个教程博客，我想把我从最开始一直到最后经历所有,以初学者的角度记下来，让后来者可以更轻松一点。\n\n\n\nOK，下面我们就从零Run起来！\n\n\n<!-- more -->\n\n## Calabash环境搭建\n\n（之后环境搭建及使用均为Mac环境下，且基于Calabash-Android）\n\n### 环境及依赖配置\n\n这一部分有大量的入门文章进行了详细的讲解，这里就不在重复叙述了，我们直接引用官方说明：\n\n*You need to have Ruby installed. Verify your installation by running ruby -v in a terminal - it should print “ruby 2.0.0” (or higher). We recommend using a managed version of Ruby like rbenv or rvm.*\n*If you are on Windows you can get Ruby from RubyInstaller.org*\n*You’ll also need to have the Java Development Kit (JDK) installed and available. Calabash will attempt to automatically find this from registry keys on windows, or monodroid config elsewhere, but you can also specify it explicitly by setting the JAVA_HOME environment variable to its location (e.g. C:\\Program Files\\Java\\jdk1.8.0_20), or having the JDK binaries themselves (i.e. C:\\Program Files\\Java\\jdk1.8.0_20\\bin) in your path.*\n*You should have the Android SDK installed. You can download it from here. Create an environment variable with the name : ANDROID_HOME and its value pointing to the location of the unzipped downloaded SDK.*\n*To compile Calabash-Android from source, you will also need to have Ant installed and added to your path. It can be downloaded from here.*\n\n简单来说，就是首先你需要保证你的电脑安装了Ruby，这个大部分Mac电脑都已经安装，可以在终端中使用命令``ruby -v``检查是否已成功安装。\n\n然后你还需要保证电脑中安装了JDK，并且配置好java环境变量。\n再然后你需要保证电脑中安装了Android SDK和 Ant，并且成功配置了环境变量。\n\n如此，依照官网所说，你的Calabash的环境依赖配置基本已经完成。\n（关于Ruby安装、JDK SDK ANT的安装及环境变量配置，网上有很多资料哦~）\n### Calabash安装\n\n依照官网步骤安装Calabash可能稍有繁琐，这里我们直接使用一行命令搞定：\n\n执行命令：\n\n\tsudo gem install calabash-android\n    \n然后按照提示，输入开机密码即可。\n\n如果你的网络没有翻墙，且出现很长时间都安装不了，参照别的博客给出的提示，可以切换到淘宝源，在终端下执行如下的三句命令即可：\n\n\tgem sources --remove https://rubygems.org/\n\tgem sources -a http://ruby.taobao.org/\n\tgem sources -l\n\n然后重新执行命令：\n\n\tsudo gem install calabash-android\n    \n就此，如无意外，Calabash安装成功。也有可能你遇到了我曾遇到的问题： **坑1：Calabash安装时Ruby报错**（因为这次分享的特殊性，超链无法使用，关于踩坑内容在第四篇文章）\n\n### 创建Cucumber项目结构\n\nCalabash安装成功后，使用终端切换到你准备写测试case的目录执行命令：\n\n\tcalabash-android gen\n    \n执行成功后，将会在该目录下生成如下文件：\n\n```\nfeatures  \n|_support  \n| |_app_installation_hooks.rb  \n| |_app_life_cycle_hooks.rb  \n| |_env.rb  \n| |_hooks.rb  \n|_step_definitions  \n| |_calabash_steps.rb  \n|_my_first.feature \n```\n\n#### features主文件夹\nfeatures 是主文件夹，一般情况，你的自动化脚本执行，都是在这个文件夹下编写操作的了。\n\n#### .feature文件\n**my_first.feature** 是默认生成的第一个测试脚本文件。通常每一个.feature文件中只能写一个Feature,所以每一个Feature文件都是一个测试用例集，在不指定具体的.feature文件夹的情况下，Calabash会按照随机顺序执行所有.feature文件。（.feature文件并不是必须在features根目录下，为了便于管理，你可以在根目录下随意创建文件夹存放.feature文件，Calabash会自动进行查找并执行）\n\n#### step_definitions文件夹\nstep_definitions文件夹里存放着自定义的step,之前我们看到的大白话，就是在这里定义的，里面已经有一个默认生成的**calabash_steps.rb** 文件，它引用了Calabash预定义的Steps，以让我们直接使用：\n\n\trequire 'calabash-android/calabash_steps'\n\n我们也可以在这个文件夹下创建自己的.rb文件来自定义steps。这是后续我们会深入讲解的一个部分。[App自动化测试探索3-Calabash语法及策略详解](https://lizhaoxuan.github.io/2017/02/13/App自动化测试探索3-Calabash用法详解/)\n\n#### support文件夹\nsupport文件夹存放着一些依赖文件\n先看**env.rb**:\n\n\trequire 'calabash-android/cucumber'\n    \n所以为什么说cucumber是Calabash的核心呢~  [Cucumber-github](https://github.com/cucumber/cucumber)\n上一篇我们看的脚本的几个关键字：Feature，Scenario，When，Then，在Calabash的官方文档并没有对他们着重进行介绍，因为它们其实是属于cucumber的部分，Calabash的资料稀少,所以很多资料我们需要去看cucumber。不过没关系，一些基础的，必然会用到的内容后续博客会讲到。\n\n**app_installation_hooks.rb** 和 **app_life_cycle_hooks.rb**\n两个文件所起到的作用分别是 对app安装hooks,和对app生命周期进行hooks。简单来说就是在app安装过程中和生命周期过程中的某些阶段做些什么事情。\n\n所以到这里你也发现了，Calabash其实是一个很轻量级，透明的框架，这些文件你完全可以自己进行修改，添加自己想要的操作。\n\n还有一个**hooks.rb**文件：\n这是一个空文件，你可以在这里添加自己想要的hooks操作，我们在下一章会简单介绍一下。\n\n\n上面说了很多可以自定义的文件夹，所有以.rb为文件后缀的文件，使用的语言都是Ruby，对Ruby陌生没关系，Ruby其实很简单的，这里安利一个[Ruby教程](http://www.runoob.com/ruby/ruby-tutorial.html)。\n\n## 运行你的第一个自动化测试用例\n\n环境配置结束，文件结构也介绍完了。按照我一直以来的习惯，不管三七二十一，我们先把demo跑起来，中间细节通通忽略，先看看是怎么回事，有了成就感我们再逐步深入！\n\n修改**my_first.feature**\n\n```\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例\n\n\t#左划\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I wait for 5 seconds  \n\tThen I take a screenshot \n\n```\n（这里我已蜂鸟众包App为例进行测试，你也可以选择从应用市场下载蜂鸟众包进行同步测试，或修改脚本在自己的app进行测试，反正脚本很简单的啦）\n\n简单解释一下\n第一行Feature 表示功能测试的名称\n第二行Scenario 表示应用场景\n内容完全是给人看，所以写什么都无所谓，但这两个关键字可不简单，它们是你搭建自动化测试功能的重要策略。当然我们先卖个关子继续往后看。\n\n第三到第五行 从坐标90:50 移动到坐标 20:50，做左划操作，20表示拖动速度，翻过三个页面后等待5秒然后截屏。\n\n执行命令 \n\n\tcalabash-android run test.apk\n    \n\n按照正常情况应用程序会安装到手机上或虚拟机上，启动并执行脚本命令。但你也可能会遇到问题：**坑2：Could not find an Android SDK please make it is install**\n**坑3：App did not start 或 WARN:Did not find 'android.jar'...**\n**坑4：\\*\\*.apk is not signed with any of the available keystores**\n\n最终截屏图片保存在当前目录下，也可以自定义保存目录，这个我们后面的文章会讲到。\n\n脚本执行过程中控制台会输出如下内容和结果：\n\n```\nCrowdsource-android git:(feature/testing) ✗ calabash-android run debug.apk\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例    \n\t#左划\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I wait for 5 seconds  \n\t\n    Then I take a screenshot \n    \n1 scenario (1 passed)\n5 steps (5 passed)\n```\n\n每执行一个Step就会在控制台上输出，包括注释内容，所以这里你完全可以在脚本中添加一些说明性的注释或在自定义的Steps中使用ruby输出语句来增强提示。这些后面我们也会详细讲。\n\n上一篇文章我们也提到过Calabash支持三种不同程度的自定义Steps，按照实际的业务需求，自定义一些更简洁的更符合自然语言的Steps。\n比如，我们使用ruby重新自定义一个Step,将上面三个左划操作集合成一句命令：在step_definitions文件夹中创建一个drag_steps.rb文件，分别修改drag_steps.rb文件和my_first.feature文件：\n\n*drag_steps.rb:*\n```\nThen /^I through welcomePages$/ do\n\tperform_action('drag', 90, 20, 50, 50, 20) \n\tperform_action('drag', 90, 20, 50, 50, 20) \n\tperform_action('drag', 90, 20, 50, 50, 20) \nend\n```\n*my_first.feature：*\n\n```\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例\n\n\tThen I through welcomePages\n\tThen I wait for 5 seconds  \n\tThen I take a screenshot \n```\n\n这就是自定义setp，但是！当然，这只是Demo，我们为了方便这样去写，在实际开发中，这个Steps开发应该更规范严谨，我们会在下一章详细对这个问题进行说明。\n\n## 总结\n\n总结下来，Calabash真的是一个非常轻量级，且脚本维护成本很低的一个自动化测试框架。后面几章我们将从以下几个方面对Calabash深入：\n\n- Feature、Scenario等关键字使用策略。\n- Calabash预定义Steps的使用。\n- 自定义Steps\n- 使用Ruby语法编写带逻辑判断的Steps。\n- 自定义Steps的使用策略。\n- Ruby Query的使用。\n- view定位技巧。\n\n进阶\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n恩，这么看下来，是不感觉Calabash虽然很轻量，但还是很强大的吧？\n\n\n</br>\n \n------\n\n《Calabash探索1-Run Calabash》\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Calabash探索1-Run Calabash.md","raw":"---\ntitle: Calabash探索1-Run Calabash\ndate: 2017-3-20 16:20:58\nauthor : 暴打小女孩\n\ntags: 测试\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n作为这个系列的第一篇，先介绍一下大纲：\n\n- 《Run Calabash》简单介绍Calabash环境搭建及基本运行，然你给对Calabash有一个基础认识\n- 《Calabash用法详解》认识Calabash后介绍Calabash的基础用法，从而可以快速上手\n- 《Calabash进阶》介绍一些特殊或不常用到的技巧，对Calabash有更深的认识\n- 《Calabash踩坑》为不影响文章阅读的连贯性，相关异常解决的内容单列一章\n\n<!-- more -->\n\n看了一些Calabash入门的文章，便准备开始实践。但在最开始时，真的好气啊。 \n从来没人告诉我Mac安装Calabash需要xcode支持！\n大部分的入门demo止步于一个简单的case，从来没人告诉我后续的case需要怎么继续执行！！！\n一条怎么看怎么没毛病的语句，怎么就无脑报错呢？\n...\n\n其实这些都是开发中的一些意外情况，但就是这些意外情况，让好多人就此止步了。其实如果耐心一点，在官方文档深挖一下，把十几篇几十篇博客参照着一起看，再或者辛苦一点，多多试错，这些坑其实都能踩平。\n但是这种方法代价太大了，作为一个教程博客，我想把我从最开始一直到最后经历所有,以初学者的角度记下来，让后来者可以更轻松一点。\n\n\n\nOK，下面我们就从零Run起来！\n\n\n<!-- more -->\n\n## Calabash环境搭建\n\n（之后环境搭建及使用均为Mac环境下，且基于Calabash-Android）\n\n### 环境及依赖配置\n\n这一部分有大量的入门文章进行了详细的讲解，这里就不在重复叙述了，我们直接引用官方说明：\n\n*You need to have Ruby installed. Verify your installation by running ruby -v in a terminal - it should print “ruby 2.0.0” (or higher). We recommend using a managed version of Ruby like rbenv or rvm.*\n*If you are on Windows you can get Ruby from RubyInstaller.org*\n*You’ll also need to have the Java Development Kit (JDK) installed and available. Calabash will attempt to automatically find this from registry keys on windows, or monodroid config elsewhere, but you can also specify it explicitly by setting the JAVA_HOME environment variable to its location (e.g. C:\\Program Files\\Java\\jdk1.8.0_20), or having the JDK binaries themselves (i.e. C:\\Program Files\\Java\\jdk1.8.0_20\\bin) in your path.*\n*You should have the Android SDK installed. You can download it from here. Create an environment variable with the name : ANDROID_HOME and its value pointing to the location of the unzipped downloaded SDK.*\n*To compile Calabash-Android from source, you will also need to have Ant installed and added to your path. It can be downloaded from here.*\n\n简单来说，就是首先你需要保证你的电脑安装了Ruby，这个大部分Mac电脑都已经安装，可以在终端中使用命令``ruby -v``检查是否已成功安装。\n\n然后你还需要保证电脑中安装了JDK，并且配置好java环境变量。\n再然后你需要保证电脑中安装了Android SDK和 Ant，并且成功配置了环境变量。\n\n如此，依照官网所说，你的Calabash的环境依赖配置基本已经完成。\n（关于Ruby安装、JDK SDK ANT的安装及环境变量配置，网上有很多资料哦~）\n### Calabash安装\n\n依照官网步骤安装Calabash可能稍有繁琐，这里我们直接使用一行命令搞定：\n\n执行命令：\n\n\tsudo gem install calabash-android\n    \n然后按照提示，输入开机密码即可。\n\n如果你的网络没有翻墙，且出现很长时间都安装不了，参照别的博客给出的提示，可以切换到淘宝源，在终端下执行如下的三句命令即可：\n\n\tgem sources --remove https://rubygems.org/\n\tgem sources -a http://ruby.taobao.org/\n\tgem sources -l\n\n然后重新执行命令：\n\n\tsudo gem install calabash-android\n    \n就此，如无意外，Calabash安装成功。也有可能你遇到了我曾遇到的问题： **坑1：Calabash安装时Ruby报错**（因为这次分享的特殊性，超链无法使用，关于踩坑内容在第四篇文章）\n\n### 创建Cucumber项目结构\n\nCalabash安装成功后，使用终端切换到你准备写测试case的目录执行命令：\n\n\tcalabash-android gen\n    \n执行成功后，将会在该目录下生成如下文件：\n\n```\nfeatures  \n|_support  \n| |_app_installation_hooks.rb  \n| |_app_life_cycle_hooks.rb  \n| |_env.rb  \n| |_hooks.rb  \n|_step_definitions  \n| |_calabash_steps.rb  \n|_my_first.feature \n```\n\n#### features主文件夹\nfeatures 是主文件夹，一般情况，你的自动化脚本执行，都是在这个文件夹下编写操作的了。\n\n#### .feature文件\n**my_first.feature** 是默认生成的第一个测试脚本文件。通常每一个.feature文件中只能写一个Feature,所以每一个Feature文件都是一个测试用例集，在不指定具体的.feature文件夹的情况下，Calabash会按照随机顺序执行所有.feature文件。（.feature文件并不是必须在features根目录下，为了便于管理，你可以在根目录下随意创建文件夹存放.feature文件，Calabash会自动进行查找并执行）\n\n#### step_definitions文件夹\nstep_definitions文件夹里存放着自定义的step,之前我们看到的大白话，就是在这里定义的，里面已经有一个默认生成的**calabash_steps.rb** 文件，它引用了Calabash预定义的Steps，以让我们直接使用：\n\n\trequire 'calabash-android/calabash_steps'\n\n我们也可以在这个文件夹下创建自己的.rb文件来自定义steps。这是后续我们会深入讲解的一个部分。[App自动化测试探索3-Calabash语法及策略详解](https://lizhaoxuan.github.io/2017/02/13/App自动化测试探索3-Calabash用法详解/)\n\n#### support文件夹\nsupport文件夹存放着一些依赖文件\n先看**env.rb**:\n\n\trequire 'calabash-android/cucumber'\n    \n所以为什么说cucumber是Calabash的核心呢~  [Cucumber-github](https://github.com/cucumber/cucumber)\n上一篇我们看的脚本的几个关键字：Feature，Scenario，When，Then，在Calabash的官方文档并没有对他们着重进行介绍，因为它们其实是属于cucumber的部分，Calabash的资料稀少,所以很多资料我们需要去看cucumber。不过没关系，一些基础的，必然会用到的内容后续博客会讲到。\n\n**app_installation_hooks.rb** 和 **app_life_cycle_hooks.rb**\n两个文件所起到的作用分别是 对app安装hooks,和对app生命周期进行hooks。简单来说就是在app安装过程中和生命周期过程中的某些阶段做些什么事情。\n\n所以到这里你也发现了，Calabash其实是一个很轻量级，透明的框架，这些文件你完全可以自己进行修改，添加自己想要的操作。\n\n还有一个**hooks.rb**文件：\n这是一个空文件，你可以在这里添加自己想要的hooks操作，我们在下一章会简单介绍一下。\n\n\n上面说了很多可以自定义的文件夹，所有以.rb为文件后缀的文件，使用的语言都是Ruby，对Ruby陌生没关系，Ruby其实很简单的，这里安利一个[Ruby教程](http://www.runoob.com/ruby/ruby-tutorial.html)。\n\n## 运行你的第一个自动化测试用例\n\n环境配置结束，文件结构也介绍完了。按照我一直以来的习惯，不管三七二十一，我们先把demo跑起来，中间细节通通忽略，先看看是怎么回事，有了成就感我们再逐步深入！\n\n修改**my_first.feature**\n\n```\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例\n\n\t#左划\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\tThen I wait for 5 seconds  \n\tThen I take a screenshot \n\n```\n（这里我已蜂鸟众包App为例进行测试，你也可以选择从应用市场下载蜂鸟众包进行同步测试，或修改脚本在自己的app进行测试，反正脚本很简单的啦）\n\n简单解释一下\n第一行Feature 表示功能测试的名称\n第二行Scenario 表示应用场景\n内容完全是给人看，所以写什么都无所谓，但这两个关键字可不简单，它们是你搭建自动化测试功能的重要策略。当然我们先卖个关子继续往后看。\n\n第三到第五行 从坐标90:50 移动到坐标 20:50，做左划操作，20表示拖动速度，翻过三个页面后等待5秒然后截屏。\n\n执行命令 \n\n\tcalabash-android run test.apk\n    \n\n按照正常情况应用程序会安装到手机上或虚拟机上，启动并执行脚本命令。但你也可能会遇到问题：**坑2：Could not find an Android SDK please make it is install**\n**坑3：App did not start 或 WARN:Did not find 'android.jar'...**\n**坑4：\\*\\*.apk is not signed with any of the available keystores**\n\n最终截屏图片保存在当前目录下，也可以自定义保存目录，这个我们后面的文章会讲到。\n\n脚本执行过程中控制台会输出如下内容和结果：\n\n```\nCrowdsource-android git:(feature/testing) ✗ calabash-android run debug.apk\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例    \n\t#左划\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I drag from 90:50 to 20:50 moving with 20 steps \n\t\n    Then I wait for 5 seconds  \n\t\n    Then I take a screenshot \n    \n1 scenario (1 passed)\n5 steps (5 passed)\n```\n\n每执行一个Step就会在控制台上输出，包括注释内容，所以这里你完全可以在脚本中添加一些说明性的注释或在自定义的Steps中使用ruby输出语句来增强提示。这些后面我们也会详细讲。\n\n上一篇文章我们也提到过Calabash支持三种不同程度的自定义Steps，按照实际的业务需求，自定义一些更简洁的更符合自然语言的Steps。\n比如，我们使用ruby重新自定义一个Step,将上面三个左划操作集合成一句命令：在step_definitions文件夹中创建一个drag_steps.rb文件，分别修改drag_steps.rb文件和my_first.feature文件：\n\n*drag_steps.rb:*\n```\nThen /^I through welcomePages$/ do\n\tperform_action('drag', 90, 20, 50, 50, 20) \n\tperform_action('drag', 90, 20, 50, 50, 20) \n\tperform_action('drag', 90, 20, 50, 50, 20) \nend\n```\n*my_first.feature：*\n\n```\nFeature: Welcome feature\n\n  Scenario: 欢迎页面测试用例\n\n\tThen I through welcomePages\n\tThen I wait for 5 seconds  \n\tThen I take a screenshot \n```\n\n这就是自定义setp，但是！当然，这只是Demo，我们为了方便这样去写，在实际开发中，这个Steps开发应该更规范严谨，我们会在下一章详细对这个问题进行说明。\n\n## 总结\n\n总结下来，Calabash真的是一个非常轻量级，且脚本维护成本很低的一个自动化测试框架。后面几章我们将从以下几个方面对Calabash深入：\n\n- Feature、Scenario等关键字使用策略。\n- Calabash预定义Steps的使用。\n- 自定义Steps\n- 使用Ruby语法编写带逻辑判断的Steps。\n- 自定义Steps的使用策略。\n- Ruby Query的使用。\n- view定位技巧。\n\n进阶\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n恩，这么看下来，是不感觉Calabash虽然很轻量，但还是很强大的吧？\n\n\n</br>\n \n------\n\n《Calabash探索1-Run Calabash》\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Calabash探索1-Run Calabash","published":1,"updated":"2019-01-02T02:09:31.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsoe0001yo9s874rlrqp","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为这个系列的第一篇，先介绍一下大纲：</p>\n<ul>\n<li>《Run Calabash》简单介绍Calabash环境搭建及基本运行，然你给对Calabash有一个基础认识</li>\n<li>《Calabash用法详解》认识Calabash后介绍Calabash的基础用法，从而可以快速上手</li>\n<li>《Calabash进阶》介绍一些特殊或不常用到的技巧，对Calabash有更深的认识</li>\n<li>《Calabash踩坑》为不影响文章阅读的连贯性，相关异常解决的内容单列一章</li>\n</ul>\n<a id=\"more\"></a>\n<p>看了一些Calabash入门的文章，便准备开始实践。但在最开始时，真的好气啊。<br>从来没人告诉我Mac安装Calabash需要xcode支持！<br>大部分的入门demo止步于一个简单的case，从来没人告诉我后续的case需要怎么继续执行！！！<br>一条怎么看怎么没毛病的语句，怎么就无脑报错呢？<br>…</p>\n<p>其实这些都是开发中的一些意外情况，但就是这些意外情况，让好多人就此止步了。其实如果耐心一点，在官方文档深挖一下，把十几篇几十篇博客参照着一起看，再或者辛苦一点，多多试错，这些坑其实都能踩平。<br>但是这种方法代价太大了，作为一个教程博客，我想把我从最开始一直到最后经历所有,以初学者的角度记下来，让后来者可以更轻松一点。</p>\n<p>OK，下面我们就从零Run起来！</p>\n<!-- more -->\n<h2 id=\"Calabash环境搭建\"><a href=\"#Calabash环境搭建\" class=\"headerlink\" title=\"Calabash环境搭建\"></a>Calabash环境搭建</h2><p>（之后环境搭建及使用均为Mac环境下，且基于Calabash-Android）</p>\n<h3 id=\"环境及依赖配置\"><a href=\"#环境及依赖配置\" class=\"headerlink\" title=\"环境及依赖配置\"></a>环境及依赖配置</h3><p>这一部分有大量的入门文章进行了详细的讲解，这里就不在重复叙述了，我们直接引用官方说明：</p>\n<p><em>You need to have Ruby installed. Verify your installation by running ruby -v in a terminal - it should print “ruby 2.0.0” (or higher). We recommend using a managed version of Ruby like rbenv or rvm.</em><br><em>If you are on Windows you can get Ruby from RubyInstaller.org</em><br><em>You’ll also need to have the Java Development Kit (JDK) installed and available. Calabash will attempt to automatically find this from registry keys on windows, or monodroid config elsewhere, but you can also specify it explicitly by setting the JAVA_HOME environment variable to its location (e.g. C:\\Program Files\\Java\\jdk1.8.0_20), or having the JDK binaries themselves (i.e. C:\\Program Files\\Java\\jdk1.8.0_20\\bin) in your path.</em><br><em>You should have the Android SDK installed. You can download it from here. Create an environment variable with the name : ANDROID_HOME and its value pointing to the location of the unzipped downloaded SDK.</em><br><em>To compile Calabash-Android from source, you will also need to have Ant installed and added to your path. It can be downloaded from here.</em></p>\n<p>简单来说，就是首先你需要保证你的电脑安装了Ruby，这个大部分Mac电脑都已经安装，可以在终端中使用命令<code>ruby -v</code>检查是否已成功安装。</p>\n<p>然后你还需要保证电脑中安装了JDK，并且配置好java环境变量。<br>再然后你需要保证电脑中安装了Android SDK和 Ant，并且成功配置了环境变量。</p>\n<p>如此，依照官网所说，你的Calabash的环境依赖配置基本已经完成。<br>（关于Ruby安装、JDK SDK ANT的安装及环境变量配置，网上有很多资料哦~）</p>\n<h3 id=\"Calabash安装\"><a href=\"#Calabash安装\" class=\"headerlink\" title=\"Calabash安装\"></a>Calabash安装</h3><p>依照官网步骤安装Calabash可能稍有繁琐，这里我们直接使用一行命令搞定：</p>\n<p>执行命令：</p>\n<pre><code>sudo gem install calabash-android\n</code></pre><p>然后按照提示，输入开机密码即可。</p>\n<p>如果你的网络没有翻墙，且出现很长时间都安装不了，参照别的博客给出的提示，可以切换到淘宝源，在终端下执行如下的三句命令即可：</p>\n<pre><code>gem sources --remove https://rubygems.org/\ngem sources -a http://ruby.taobao.org/\ngem sources -l\n</code></pre><p>然后重新执行命令：</p>\n<pre><code>sudo gem install calabash-android\n</code></pre><p>就此，如无意外，Calabash安装成功。也有可能你遇到了我曾遇到的问题： <strong>坑1：Calabash安装时Ruby报错</strong>（因为这次分享的特殊性，超链无法使用，关于踩坑内容在第四篇文章）</p>\n<h3 id=\"创建Cucumber项目结构\"><a href=\"#创建Cucumber项目结构\" class=\"headerlink\" title=\"创建Cucumber项目结构\"></a>创建Cucumber项目结构</h3><p>Calabash安装成功后，使用终端切换到你准备写测试case的目录执行命令：</p>\n<pre><code>calabash-android gen\n</code></pre><p>执行成功后，将会在该目录下生成如下文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">features  </span><br><span class=\"line\">|_support  </span><br><span class=\"line\">| |_app_installation_hooks.rb  </span><br><span class=\"line\">| |_app_life_cycle_hooks.rb  </span><br><span class=\"line\">| |_env.rb  </span><br><span class=\"line\">| |_hooks.rb  </span><br><span class=\"line\">|_step_definitions  </span><br><span class=\"line\">| |_calabash_steps.rb  </span><br><span class=\"line\">|_my_first.feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"features主文件夹\"><a href=\"#features主文件夹\" class=\"headerlink\" title=\"features主文件夹\"></a>features主文件夹</h4><p>features 是主文件夹，一般情况，你的自动化脚本执行，都是在这个文件夹下编写操作的了。</p>\n<h4 id=\"feature文件\"><a href=\"#feature文件\" class=\"headerlink\" title=\".feature文件\"></a>.feature文件</h4><p><strong>my_first.feature</strong> 是默认生成的第一个测试脚本文件。通常每一个.feature文件中只能写一个Feature,所以每一个Feature文件都是一个测试用例集，在不指定具体的.feature文件夹的情况下，Calabash会按照随机顺序执行所有.feature文件。（.feature文件并不是必须在features根目录下，为了便于管理，你可以在根目录下随意创建文件夹存放.feature文件，Calabash会自动进行查找并执行）</p>\n<h4 id=\"step-definitions文件夹\"><a href=\"#step-definitions文件夹\" class=\"headerlink\" title=\"step_definitions文件夹\"></a>step_definitions文件夹</h4><p>step_definitions文件夹里存放着自定义的step,之前我们看到的大白话，就是在这里定义的，里面已经有一个默认生成的<strong>calabash_steps.rb</strong> 文件，它引用了Calabash预定义的Steps，以让我们直接使用：</p>\n<pre><code>require &apos;calabash-android/calabash_steps&apos;\n</code></pre><p>我们也可以在这个文件夹下创建自己的.rb文件来自定义steps。这是后续我们会深入讲解的一个部分。<a href=\"https://lizhaoxuan.github.io/2017/02/13/App自动化测试探索3-Calabash用法详解/\">App自动化测试探索3-Calabash语法及策略详解</a></p>\n<h4 id=\"support文件夹\"><a href=\"#support文件夹\" class=\"headerlink\" title=\"support文件夹\"></a>support文件夹</h4><p>support文件夹存放着一些依赖文件<br>先看<strong>env.rb</strong>:</p>\n<pre><code>require &apos;calabash-android/cucumber&apos;\n</code></pre><p>所以为什么说cucumber是Calabash的核心呢~  <a href=\"https://github.com/cucumber/cucumber\" target=\"_blank\" rel=\"noopener\">Cucumber-github</a><br>上一篇我们看的脚本的几个关键字：Feature，Scenario，When，Then，在Calabash的官方文档并没有对他们着重进行介绍，因为它们其实是属于cucumber的部分，Calabash的资料稀少,所以很多资料我们需要去看cucumber。不过没关系，一些基础的，必然会用到的内容后续博客会讲到。</p>\n<p><strong>app_installation_hooks.rb</strong> 和 <strong>app_life_cycle_hooks.rb</strong><br>两个文件所起到的作用分别是 对app安装hooks,和对app生命周期进行hooks。简单来说就是在app安装过程中和生命周期过程中的某些阶段做些什么事情。</p>\n<p>所以到这里你也发现了，Calabash其实是一个很轻量级，透明的框架，这些文件你完全可以自己进行修改，添加自己想要的操作。</p>\n<p>还有一个<strong>hooks.rb</strong>文件：<br>这是一个空文件，你可以在这里添加自己想要的hooks操作，我们在下一章会简单介绍一下。</p>\n<p>上面说了很多可以自定义的文件夹，所有以.rb为文件后缀的文件，使用的语言都是Ruby，对Ruby陌生没关系，Ruby其实很简单的，这里安利一个<a href=\"http://www.runoob.com/ruby/ruby-tutorial.html\" target=\"_blank\" rel=\"noopener\">Ruby教程</a>。</p>\n<h2 id=\"运行你的第一个自动化测试用例\"><a href=\"#运行你的第一个自动化测试用例\" class=\"headerlink\" title=\"运行你的第一个自动化测试用例\"></a>运行你的第一个自动化测试用例</h2><p>环境配置结束，文件结构也介绍完了。按照我一直以来的习惯，不管三七二十一，我们先把demo跑起来，中间细节通通忽略，先看看是怎么回事，有了成就感我们再逐步深入！</p>\n<p>修改<strong>my_first.feature</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">\t#左划</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I wait for 5 seconds  </span><br><span class=\"line\">\tThen I take a screenshot</span><br></pre></td></tr></table></figure>\n<p>（这里我已蜂鸟众包App为例进行测试，你也可以选择从应用市场下载蜂鸟众包进行同步测试，或修改脚本在自己的app进行测试，反正脚本很简单的啦）</p>\n<p>简单解释一下<br>第一行Feature 表示功能测试的名称<br>第二行Scenario 表示应用场景<br>内容完全是给人看，所以写什么都无所谓，但这两个关键字可不简单，它们是你搭建自动化测试功能的重要策略。当然我们先卖个关子继续往后看。</p>\n<p>第三到第五行 从坐标90:50 移动到坐标 20:50，做左划操作，20表示拖动速度，翻过三个页面后等待5秒然后截屏。</p>\n<p>执行命令 </p>\n<pre><code>calabash-android run test.apk\n</code></pre><p>按照正常情况应用程序会安装到手机上或虚拟机上，启动并执行脚本命令。但你也可能会遇到问题：<strong>坑2：Could not find an Android SDK please make it is install</strong><br><strong>坑3：App did not start 或 WARN:Did not find ‘android.jar’…</strong><br><strong>坑4：**.apk is not signed with any of the available keystores</strong></p>\n<p>最终截屏图片保存在当前目录下，也可以自定义保存目录，这个我们后面的文章会讲到。</p>\n<p>脚本执行过程中控制台会输出如下内容和结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Crowdsource-android git:(feature/testing) ✗ calabash-android run debug.apk</span><br><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例    </span><br><span class=\"line\">\t#左划</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I wait for 5 seconds  </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I take a screenshot </span><br><span class=\"line\">    </span><br><span class=\"line\">1 scenario (1 passed)</span><br><span class=\"line\">5 steps (5 passed)</span><br></pre></td></tr></table></figure>\n<p>每执行一个Step就会在控制台上输出，包括注释内容，所以这里你完全可以在脚本中添加一些说明性的注释或在自定义的Steps中使用ruby输出语句来增强提示。这些后面我们也会详细讲。</p>\n<p>上一篇文章我们也提到过Calabash支持三种不同程度的自定义Steps，按照实际的业务需求，自定义一些更简洁的更符合自然语言的Steps。<br>比如，我们使用ruby重新自定义一个Step,将上面三个左划操作集合成一句命令：在step_definitions文件夹中创建一个drag_steps.rb文件，分别修改drag_steps.rb文件和my_first.feature文件：</p>\n<p><em>drag_steps.rb:</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p><em>my_first.feature：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">\tThen I through welcomePages</span><br><span class=\"line\">\tThen I wait for 5 seconds  </span><br><span class=\"line\">\tThen I take a screenshot</span><br></pre></td></tr></table></figure>\n<p>这就是自定义setp，但是！当然，这只是Demo，我们为了方便这样去写，在实际开发中，这个Steps开发应该更规范严谨，我们会在下一章详细对这个问题进行说明。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结下来，Calabash真的是一个非常轻量级，且脚本维护成本很低的一个自动化测试框架。后面几章我们将从以下几个方面对Calabash深入：</p>\n<ul>\n<li>Feature、Scenario等关键字使用策略。</li>\n<li>Calabash预定义Steps的使用。</li>\n<li>自定义Steps</li>\n<li>使用Ruby语法编写带逻辑判断的Steps。</li>\n<li>自定义Steps的使用策略。</li>\n<li>Ruby Query的使用。</li>\n<li>view定位技巧。</li>\n</ul>\n<p>进阶</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>\n<p>恩，这么看下来，是不感觉Calabash虽然很轻量，但还是很强大的吧？</p>\n<p><br></p>\n<hr>\n<p>《Calabash探索1-Run Calabash》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为这个系列的第一篇，先介绍一下大纲：</p>\n<ul>\n<li>《Run Calabash》简单介绍Calabash环境搭建及基本运行，然你给对Calabash有一个基础认识</li>\n<li>《Calabash用法详解》认识Calabash后介绍Calabash的基础用法，从而可以快速上手</li>\n<li>《Calabash进阶》介绍一些特殊或不常用到的技巧，对Calabash有更深的认识</li>\n<li>《Calabash踩坑》为不影响文章阅读的连贯性，相关异常解决的内容单列一章</li>\n</ul>","more":"<p>看了一些Calabash入门的文章，便准备开始实践。但在最开始时，真的好气啊。<br>从来没人告诉我Mac安装Calabash需要xcode支持！<br>大部分的入门demo止步于一个简单的case，从来没人告诉我后续的case需要怎么继续执行！！！<br>一条怎么看怎么没毛病的语句，怎么就无脑报错呢？<br>…</p>\n<p>其实这些都是开发中的一些意外情况，但就是这些意外情况，让好多人就此止步了。其实如果耐心一点，在官方文档深挖一下，把十几篇几十篇博客参照着一起看，再或者辛苦一点，多多试错，这些坑其实都能踩平。<br>但是这种方法代价太大了，作为一个教程博客，我想把我从最开始一直到最后经历所有,以初学者的角度记下来，让后来者可以更轻松一点。</p>\n<p>OK，下面我们就从零Run起来！</p>\n<!-- more -->\n<h2 id=\"Calabash环境搭建\"><a href=\"#Calabash环境搭建\" class=\"headerlink\" title=\"Calabash环境搭建\"></a>Calabash环境搭建</h2><p>（之后环境搭建及使用均为Mac环境下，且基于Calabash-Android）</p>\n<h3 id=\"环境及依赖配置\"><a href=\"#环境及依赖配置\" class=\"headerlink\" title=\"环境及依赖配置\"></a>环境及依赖配置</h3><p>这一部分有大量的入门文章进行了详细的讲解，这里就不在重复叙述了，我们直接引用官方说明：</p>\n<p><em>You need to have Ruby installed. Verify your installation by running ruby -v in a terminal - it should print “ruby 2.0.0” (or higher). We recommend using a managed version of Ruby like rbenv or rvm.</em><br><em>If you are on Windows you can get Ruby from RubyInstaller.org</em><br><em>You’ll also need to have the Java Development Kit (JDK) installed and available. Calabash will attempt to automatically find this from registry keys on windows, or monodroid config elsewhere, but you can also specify it explicitly by setting the JAVA_HOME environment variable to its location (e.g. C:\\Program Files\\Java\\jdk1.8.0_20), or having the JDK binaries themselves (i.e. C:\\Program Files\\Java\\jdk1.8.0_20\\bin) in your path.</em><br><em>You should have the Android SDK installed. You can download it from here. Create an environment variable with the name : ANDROID_HOME and its value pointing to the location of the unzipped downloaded SDK.</em><br><em>To compile Calabash-Android from source, you will also need to have Ant installed and added to your path. It can be downloaded from here.</em></p>\n<p>简单来说，就是首先你需要保证你的电脑安装了Ruby，这个大部分Mac电脑都已经安装，可以在终端中使用命令<code>ruby -v</code>检查是否已成功安装。</p>\n<p>然后你还需要保证电脑中安装了JDK，并且配置好java环境变量。<br>再然后你需要保证电脑中安装了Android SDK和 Ant，并且成功配置了环境变量。</p>\n<p>如此，依照官网所说，你的Calabash的环境依赖配置基本已经完成。<br>（关于Ruby安装、JDK SDK ANT的安装及环境变量配置，网上有很多资料哦~）</p>\n<h3 id=\"Calabash安装\"><a href=\"#Calabash安装\" class=\"headerlink\" title=\"Calabash安装\"></a>Calabash安装</h3><p>依照官网步骤安装Calabash可能稍有繁琐，这里我们直接使用一行命令搞定：</p>\n<p>执行命令：</p>\n<pre><code>sudo gem install calabash-android\n</code></pre><p>然后按照提示，输入开机密码即可。</p>\n<p>如果你的网络没有翻墙，且出现很长时间都安装不了，参照别的博客给出的提示，可以切换到淘宝源，在终端下执行如下的三句命令即可：</p>\n<pre><code>gem sources --remove https://rubygems.org/\ngem sources -a http://ruby.taobao.org/\ngem sources -l\n</code></pre><p>然后重新执行命令：</p>\n<pre><code>sudo gem install calabash-android\n</code></pre><p>就此，如无意外，Calabash安装成功。也有可能你遇到了我曾遇到的问题： <strong>坑1：Calabash安装时Ruby报错</strong>（因为这次分享的特殊性，超链无法使用，关于踩坑内容在第四篇文章）</p>\n<h3 id=\"创建Cucumber项目结构\"><a href=\"#创建Cucumber项目结构\" class=\"headerlink\" title=\"创建Cucumber项目结构\"></a>创建Cucumber项目结构</h3><p>Calabash安装成功后，使用终端切换到你准备写测试case的目录执行命令：</p>\n<pre><code>calabash-android gen\n</code></pre><p>执行成功后，将会在该目录下生成如下文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">features  </span><br><span class=\"line\">|_support  </span><br><span class=\"line\">| |_app_installation_hooks.rb  </span><br><span class=\"line\">| |_app_life_cycle_hooks.rb  </span><br><span class=\"line\">| |_env.rb  </span><br><span class=\"line\">| |_hooks.rb  </span><br><span class=\"line\">|_step_definitions  </span><br><span class=\"line\">| |_calabash_steps.rb  </span><br><span class=\"line\">|_my_first.feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"features主文件夹\"><a href=\"#features主文件夹\" class=\"headerlink\" title=\"features主文件夹\"></a>features主文件夹</h4><p>features 是主文件夹，一般情况，你的自动化脚本执行，都是在这个文件夹下编写操作的了。</p>\n<h4 id=\"feature文件\"><a href=\"#feature文件\" class=\"headerlink\" title=\".feature文件\"></a>.feature文件</h4><p><strong>my_first.feature</strong> 是默认生成的第一个测试脚本文件。通常每一个.feature文件中只能写一个Feature,所以每一个Feature文件都是一个测试用例集，在不指定具体的.feature文件夹的情况下，Calabash会按照随机顺序执行所有.feature文件。（.feature文件并不是必须在features根目录下，为了便于管理，你可以在根目录下随意创建文件夹存放.feature文件，Calabash会自动进行查找并执行）</p>\n<h4 id=\"step-definitions文件夹\"><a href=\"#step-definitions文件夹\" class=\"headerlink\" title=\"step_definitions文件夹\"></a>step_definitions文件夹</h4><p>step_definitions文件夹里存放着自定义的step,之前我们看到的大白话，就是在这里定义的，里面已经有一个默认生成的<strong>calabash_steps.rb</strong> 文件，它引用了Calabash预定义的Steps，以让我们直接使用：</p>\n<pre><code>require &apos;calabash-android/calabash_steps&apos;\n</code></pre><p>我们也可以在这个文件夹下创建自己的.rb文件来自定义steps。这是后续我们会深入讲解的一个部分。<a href=\"https://lizhaoxuan.github.io/2017/02/13/App自动化测试探索3-Calabash用法详解/\">App自动化测试探索3-Calabash语法及策略详解</a></p>\n<h4 id=\"support文件夹\"><a href=\"#support文件夹\" class=\"headerlink\" title=\"support文件夹\"></a>support文件夹</h4><p>support文件夹存放着一些依赖文件<br>先看<strong>env.rb</strong>:</p>\n<pre><code>require &apos;calabash-android/cucumber&apos;\n</code></pre><p>所以为什么说cucumber是Calabash的核心呢~  <a href=\"https://github.com/cucumber/cucumber\" target=\"_blank\" rel=\"noopener\">Cucumber-github</a><br>上一篇我们看的脚本的几个关键字：Feature，Scenario，When，Then，在Calabash的官方文档并没有对他们着重进行介绍，因为它们其实是属于cucumber的部分，Calabash的资料稀少,所以很多资料我们需要去看cucumber。不过没关系，一些基础的，必然会用到的内容后续博客会讲到。</p>\n<p><strong>app_installation_hooks.rb</strong> 和 <strong>app_life_cycle_hooks.rb</strong><br>两个文件所起到的作用分别是 对app安装hooks,和对app生命周期进行hooks。简单来说就是在app安装过程中和生命周期过程中的某些阶段做些什么事情。</p>\n<p>所以到这里你也发现了，Calabash其实是一个很轻量级，透明的框架，这些文件你完全可以自己进行修改，添加自己想要的操作。</p>\n<p>还有一个<strong>hooks.rb</strong>文件：<br>这是一个空文件，你可以在这里添加自己想要的hooks操作，我们在下一章会简单介绍一下。</p>\n<p>上面说了很多可以自定义的文件夹，所有以.rb为文件后缀的文件，使用的语言都是Ruby，对Ruby陌生没关系，Ruby其实很简单的，这里安利一个<a href=\"http://www.runoob.com/ruby/ruby-tutorial.html\" target=\"_blank\" rel=\"noopener\">Ruby教程</a>。</p>\n<h2 id=\"运行你的第一个自动化测试用例\"><a href=\"#运行你的第一个自动化测试用例\" class=\"headerlink\" title=\"运行你的第一个自动化测试用例\"></a>运行你的第一个自动化测试用例</h2><p>环境配置结束，文件结构也介绍完了。按照我一直以来的习惯，不管三七二十一，我们先把demo跑起来，中间细节通通忽略，先看看是怎么回事，有了成就感我们再逐步深入！</p>\n<p>修改<strong>my_first.feature</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">\t#左划</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\tThen I wait for 5 seconds  </span><br><span class=\"line\">\tThen I take a screenshot</span><br></pre></td></tr></table></figure>\n<p>（这里我已蜂鸟众包App为例进行测试，你也可以选择从应用市场下载蜂鸟众包进行同步测试，或修改脚本在自己的app进行测试，反正脚本很简单的啦）</p>\n<p>简单解释一下<br>第一行Feature 表示功能测试的名称<br>第二行Scenario 表示应用场景<br>内容完全是给人看，所以写什么都无所谓，但这两个关键字可不简单，它们是你搭建自动化测试功能的重要策略。当然我们先卖个关子继续往后看。</p>\n<p>第三到第五行 从坐标90:50 移动到坐标 20:50，做左划操作，20表示拖动速度，翻过三个页面后等待5秒然后截屏。</p>\n<p>执行命令 </p>\n<pre><code>calabash-android run test.apk\n</code></pre><p>按照正常情况应用程序会安装到手机上或虚拟机上，启动并执行脚本命令。但你也可能会遇到问题：<strong>坑2：Could not find an Android SDK please make it is install</strong><br><strong>坑3：App did not start 或 WARN:Did not find ‘android.jar’…</strong><br><strong>坑4：**.apk is not signed with any of the available keystores</strong></p>\n<p>最终截屏图片保存在当前目录下，也可以自定义保存目录，这个我们后面的文章会讲到。</p>\n<p>脚本执行过程中控制台会输出如下内容和结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Crowdsource-android git:(feature/testing) ✗ calabash-android run debug.apk</span><br><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例    </span><br><span class=\"line\">\t#左划</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I wait for 5 seconds  </span><br><span class=\"line\">\t</span><br><span class=\"line\">    Then I take a screenshot </span><br><span class=\"line\">    </span><br><span class=\"line\">1 scenario (1 passed)</span><br><span class=\"line\">5 steps (5 passed)</span><br></pre></td></tr></table></figure>\n<p>每执行一个Step就会在控制台上输出，包括注释内容，所以这里你完全可以在脚本中添加一些说明性的注释或在自定义的Steps中使用ruby输出语句来增强提示。这些后面我们也会详细讲。</p>\n<p>上一篇文章我们也提到过Calabash支持三种不同程度的自定义Steps，按照实际的业务需求，自定义一些更简洁的更符合自然语言的Steps。<br>比如，我们使用ruby重新自定义一个Step,将上面三个左划操作集合成一句命令：在step_definitions文件夹中创建一个drag_steps.rb文件，分别修改drag_steps.rb文件和my_first.feature文件：</p>\n<p><em>drag_steps.rb:</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p><em>my_first.feature：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Welcome feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 欢迎页面测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">\tThen I through welcomePages</span><br><span class=\"line\">\tThen I wait for 5 seconds  </span><br><span class=\"line\">\tThen I take a screenshot</span><br></pre></td></tr></table></figure>\n<p>这就是自定义setp，但是！当然，这只是Demo，我们为了方便这样去写，在实际开发中，这个Steps开发应该更规范严谨，我们会在下一章详细对这个问题进行说明。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结下来，Calabash真的是一个非常轻量级，且脚本维护成本很低的一个自动化测试框架。后面几章我们将从以下几个方面对Calabash深入：</p>\n<ul>\n<li>Feature、Scenario等关键字使用策略。</li>\n<li>Calabash预定义Steps的使用。</li>\n<li>自定义Steps</li>\n<li>使用Ruby语法编写带逻辑判断的Steps。</li>\n<li>自定义Steps的使用策略。</li>\n<li>Ruby Query的使用。</li>\n<li>view定位技巧。</li>\n</ul>\n<p>进阶</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>\n<p>恩，这么看下来，是不感觉Calabash虽然很轻量，但还是很强大的吧？</p>\n<p><br></p>\n<hr>\n<p>《Calabash探索1-Run Calabash》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>"},{"title":"Android性能编码规范","date":"2016-03-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 前言\n\n一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。\n\n但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。\n\n<!-- more -->\n\n传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。\n\n本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。\n\n值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。\n\n<br/>\n\n### 编码之初\n\n#### 对于布局内容的数量要求\n\t\t\n单个Activity显示的视图一般情况少于20，层数少于4。\n对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。\n\t\t\n\n**Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单**\n\n#### 将Acitivity 中的Window 的背景图设置为空。\n\ngetWindow().setBackgroundDrawable(null); \n\nandroid的默认背景不为空。\n\n#### 将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\n\nTheme设置属性\n\n\t\t<item name=\"android:windowBackground\">src_image</item>\n\n#### ~~采用硬件加速~~\n\nandroidmanifest.xml中application添加 \n\n\t\tandroid:hardwareAccelerated=\"true\"。\n需要注意的是：android 3.0以上才可以使用。\n\n\n\t\t\n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。\n\t\t\n我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。\n\n<br/><br/>\n\n### 禁止（避免）操作\n\n**核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为**\n\n\n\n\n\n#### 禁止在单例模式中引用Activity的context。使用Application。\n\n如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。\n\n\t\tSingleton instance = Singleton.getInstance(this); // 禁止操作\n\t\t\n是使用 getApplicationContext()  这样就能避免内存泄露。\n\n\t\tSingleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n\t\t\n\n\n#### 禁止使用枚举\n\n枚举将造成大量的内存浪费\n\n\n#### 禁止使用异步回调，\n\n异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。\n\n\n#### 禁止static引用资源耗费过多的实例\n\n例如：context  , Activity\n\t\t\n对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；\n\t\t\n\t\t\n#### ~~禁止内部的Getters/Setters~~\n\n~~对于类的成员我们需要提供Get和Set方法~~\n\n~~但在类内部，应该避免使用Get和Set方法~~\n\t\t\n#### 禁止在非常复杂的布局上使用动画\n\n#### 避免在循环（for、while、listView - getView方法、onDraw）里创建对象\n\n#### 避免在onDraw里创建对象 \n\n对于onDraw中 Paint 我们可以这样优化\n\t\t\n\t\tprivate Paint paint = new Paint();\n\t\t\n\t\tpublic on Draw(){\n\t\t\tpaint.setColor(mBorderColor);\n\t\t}\t\t\n\n#### 避免使用static成员对象\n\nstatic生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)\n\n#### 避免使用浮点数\n\n浮点数会比整型慢两倍\n\n#### 避免Timer.schedule，对于延时操作，可用以下方式代替\n\t\t\n\t\tScheduledExecutorService, \n\t\thandler.postDelayed, \n\t\thandler.postAtTime , \n\t\thandler.sendMessageDelayed ,  \n\t\tView.postDelayed，      \n\t\tAlarmManager\n\n\n#### 避免加载过大图片。压缩或者使用对象池后再使用\n\n\n#### 慎用异常\n\t\t\n原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。\n\n构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。\n\n\t\t\n#### 避免使用递归\n\n\n#### 避免使用轮询\n\n如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。\n\n#### 避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\n\n### 优化操作\n\n\n  <最优替换/>\n  \n#### 当数据量在100以内时，使用ArrayMap代替HashMap\n\n#### 为了避免自动装箱，当数量在1000以下时，使用如下容器\n\t\t\n\t\ta)SparseBoolMap <bool , obj>\n\t\tb)SparseIntMap <int , obj>\n\t\tc)SparseLongMap <long , obj>\n\t\td)LongSparseMap <long ,obj>\n\n#### 字符串拼接用StringBuilder或StringBuffer\n\n\t\t//这种string第一次初始化的情况下，下面得效率更高\n\t\tString str1 = \"abc\"+“def”+\"hij\";\n\t\t//非并发情况 ， StringBuilder效率更优\n\t\tStringBuilder str2 = str3 + str1 + \"builder\" ;\n\t\t//并发情况使用 StringBuffer\n\t\tStringBuffer str2 = str1 + \"buffer\" ;\n  \n#### 文件、网络IO缓存，使用有缓存机制的输入流\n\n\t\tBufferedInputStream替代InputStream\n\t\tBufferedReader替代Reader\n\t\tBufferedReader替代BufferedInputStream. \n \n \n#### 用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\n\n两个平行数组一定比一个对象数组的效率高。\n但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好\n \n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n#### 在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\n\n因为⼦子类会有⾃自⼰己的属性创建需要更多开销。\n\n#### 在使用Factory或类似Factory模式的情况。\n\n少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。\n\t\t\n\t\tpublic static Credit createCredit(){\n\t\t\treturn new Credit();\n\t\t}\n\t\t\n改写为：\n\t\t\n\t\tprivate static Credit BaseCredit = new Credit();\n\t\tpublic static Credit createCredit(){\n\t\t\treturn (Credit)BaseCredit.clone();\n\t\t}\n\n**你必须要注意的：clone是浅拷贝。**\n \n <优化操作/>\n \n#### 尽量使用局部变量  \n\n#### for循环要求 \n\n禁止在for循环的第二个条件中调用任何方法，应这样做\n\n\t\tint size = array.length;\n\t\tfor(int i = 0; i< size;i++)\n\t\t//替代：\n\t\tfor(int i =0;i < array.length;i++)\n\t\t\n在不需要使用下标的情况下，建议使用for_each循环\n\t\t\n\t\t\n#### 如果没有特殊需求，使用基本数据类型，而非对象类型。\n\n基本类似指：int , double , char等。\n\t\t\n\t\t\n#### 静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\n\n如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。\n\t\t\n\t\t\n#### 对于使用超过两次的对象成员， 将成员缓存到本地。\n\t\t\n反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中\n\n例：多次比较目标时间和当前时间差。\t\t\n\t\t\n#### 当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\n\n\t\tObject ob = new Object();\n\t\tint value;\n\t\tif(i>0)\n\t\t\tvalue = ob.getVlaue();\n\t\t\n\t\t改写为：\n\t\tint value;\n\t\t\n\t\tif(i>0){\n\t\t\tObject ob = new Object();   //用到时加载\n\t\t\tvalue = ob.getVlaue();\n\t\t}\n\n#### 不在使用的变量，手动置为null\n\t\t\n通常对于对象成员如此使用，局部变量不需要\n\t\t\n\t\tthis.object = null；\n\t\t\n\n#### 常量用 static final修饰\t\n\t\n<缓存/> \n\n#### 消息缓存，从handler消息池中取预存的Message\n\n\t\thandler.sendMessage(handler.obtainMessage(0, object)); \n   \n#### 尽量使用对象池机制\n\n对象池机制可以有效避免内存抖动提升性能\n\t\t\n优化：我们可以对对象进行预加载，有效提高程序首次运行速度\n\t\t\n警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系\n\n#### 使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\n\t\t\n通常，我们可以通过 objcet = null ; 来去掉对象的引用。\n\t\t\n\n\n#### 禁止将View添加到没有清除机制的容器里\n\n\t\t如：WeakHashMap，没有清除机制，易引起内存溢出\n\n<图片/>\n\n#### 对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\n\n\t\titmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\n\t\tscaledSrcBmp.getHeight(),Config.ARGB_8888);\n\t\t\n- ARGB_8888\t\t32Bit\t\t\n\n\t(这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)\n\t\n- RGB_565\t\t16Bit\t\n\n\t(对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的 \n从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)\n\t\n- ARGB_4444\t\t16Bit\t\t\n\n\t(这种格式的图片，看起来质量太差，已经不推荐使用)\n\t\n- ALPHA_8\t\t8Bit  \t\t\n\n\t(此时图片只有alpha值，没有RGB值， )\n\t\n\t\t\n\t\t\t\n\t\t\n#### 对于图片缩放，提供一下几种方式和其各自优缺点。\n\n\t\t/* \n\t\t *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n\t\t*/\n\t\tcreateScaleBitmap(inBmp , 64 , 128);\n\t\t/*\n\t\t *2.\t inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n\t\t*/\n\t\tmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \n\t\tmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n\n  \n\n#### Bitmap使用结束后，recycle（）释放内存\n\n\t\tBitmap.recycle();\n\n#### 相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\n\nBitmap提供了对图片更多的操作。\n同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。\n\n<布局/>\n\n#### 慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\n\n#### 避免多个线性布局嵌套，使用相对布局减少层级\n\n#### 对于TextView和ImageView组成的Layout，直接使用TextView替换\n\n\t\t<TextView\n    \t\tandroid:id=\"@+id/nameText\"\n    \t\tandroid:layout_width=\"wrap_content\"\n    \t\tandroid:layout_height=\"wrap_content\"\n    \t\tandroid:text=\"暴打小女孩\"\n    \t\tandroid:layout_marginBottom=\"center\"\n    \t\tandroid:gravity=\"center\"\n  \t \t\tandroid:drawableTop=\"@drawable/icon\"/>  //将图片置于上方  \n  \t\n  \t \t\t\n#### 默认不会显示的布局使用 viewstub 标签\n\n**但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE**\n\n\t\t<ViewStub\n\t\t\tandroid:id=\"@+id/network_error_layout\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\"\n\t\t\tandroid:layout=\"@layout/network_error\" />\n\t\t\t\n\t\t//非显示的转换ViewStub 获取\n\t\tView viewStub = findViewById(R.id.network_error_layout);\n\t\tviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\n\t\tnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局    \t\t\n#### 对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\n\n\t\tclass test{\n\t\t\tprivate View view = null;\n\t\t\tpublic void getView(){\n\t\t\t\tview = findViewById(R.id.network_error_layout);\n\t\t\t}\n\t\t\tpubli void showView(){\n\t\t\t\tview.setVisiblity(View.VIWIBLE);\n\t\t\t}\n\t\t}\n\t\t\n#### 对于重复出现超过2-3次的子布局，用 include 实现复用。\n\t\t\n\t\t<include layout=\"@layout/foot.xml\" />\n\n#### 当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\n\n要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少\n\n\t\t<merge xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\" >\n\t\t\t<Button\n\t\t\t\tandroid:id=\"@+id/button\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_above=\"@+id/text\"/>\n\t\t\t<TextView\n\t\t\t\tandroid:id=\"@+id/text\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_alignParentBottom=\"true\"\n\t\t\t\tandroid:text=\"@string/app_name\" />\n\t\t</merge>\n\n\n\n\n\n<br/><br/>\n\n### 性能优化策略\n\n- 减少过渡绘制，可以极大提高动画效率\n- 使用简单的动画效果，如：位置移动，慎用改变内容的动画效率\n\n\t\t动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n\t\t（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\t\t\n\t\t不改变内容，DsiplayList不会重建，提高动画效率\n\n- 捆绑非及时的网络请求，统一执行。\n- 网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。\n- 回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输\n\n### 性能优化心得\n\n<br/>\n\n在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。\n\n其实这是一个不那么准确的误区。\n\n手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）\n\n那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。\n\n世上没有免费得午餐，对象创建后总是要回收的---GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。\n\n所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。\n\n\n\n<br/><br/>\n### 参考资料\n<br/>\n\n[Android性能优化典范（一)](http://www.cnblogs.com/hanyonglu/p/4244035.html)\n\n[Android性能优化典范（二)](http://hukai.me/android-performance-patterns-season-2/)\n\n[Android性能优化典范（三)](http://hukai.me/android-performance-patterns-season-3/)\n\n\n\n<br/><br/>\n\n\n\n### 相关知识详述   \n\n#### 为什么将背景设置在主题可以减少加载时间？\n回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？\n\t\t\nResterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。\n\t\t\nCPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。\n\t\t\n然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。\n\t\t\n在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。\n\n\n\n#### 为什么禁止onDraw创建对象？\n\n首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。\n\t\t\n如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n\n\n#### 为什么要尽量使用局部变量？\n\nAndroid系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，\n\t\t\n同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。\n\n\n![image](http://images.cnitblog.com/blog/56846/201501/231407350162907.png)\n\n\n\n\n\n\n\n\n\n\t\t\n","source":"_posts/AndroidCoding-performance-specification.md","raw":"---\ntitle: Android性能编码规范\ndate: 2016-03-17 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 前言\n\n一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。\n\n但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。\n\n<!-- more -->\n\n传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。\n\n本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。\n\n值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。\n\n<br/>\n\n### 编码之初\n\n#### 对于布局内容的数量要求\n\t\t\n单个Activity显示的视图一般情况少于20，层数少于4。\n对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。\n\t\t\n\n**Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单**\n\n#### 将Acitivity 中的Window 的背景图设置为空。\n\ngetWindow().setBackgroundDrawable(null); \n\nandroid的默认背景不为空。\n\n#### 将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\n\nTheme设置属性\n\n\t\t<item name=\"android:windowBackground\">src_image</item>\n\n#### ~~采用硬件加速~~\n\nandroidmanifest.xml中application添加 \n\n\t\tandroid:hardwareAccelerated=\"true\"。\n需要注意的是：android 3.0以上才可以使用。\n\n\n\t\t\n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。\n\t\t\n我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。\n\n<br/><br/>\n\n### 禁止（避免）操作\n\n**核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为**\n\n\n\n\n\n#### 禁止在单例模式中引用Activity的context。使用Application。\n\n如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。\n\n\t\tSingleton instance = Singleton.getInstance(this); // 禁止操作\n\t\t\n是使用 getApplicationContext()  这样就能避免内存泄露。\n\n\t\tSingleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n\t\t\n\n\n#### 禁止使用枚举\n\n枚举将造成大量的内存浪费\n\n\n#### 禁止使用异步回调，\n\n异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。\n\n\n#### 禁止static引用资源耗费过多的实例\n\n例如：context  , Activity\n\t\t\n对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；\n\t\t\n\t\t\n#### ~~禁止内部的Getters/Setters~~\n\n~~对于类的成员我们需要提供Get和Set方法~~\n\n~~但在类内部，应该避免使用Get和Set方法~~\n\t\t\n#### 禁止在非常复杂的布局上使用动画\n\n#### 避免在循环（for、while、listView - getView方法、onDraw）里创建对象\n\n#### 避免在onDraw里创建对象 \n\n对于onDraw中 Paint 我们可以这样优化\n\t\t\n\t\tprivate Paint paint = new Paint();\n\t\t\n\t\tpublic on Draw(){\n\t\t\tpaint.setColor(mBorderColor);\n\t\t}\t\t\n\n#### 避免使用static成员对象\n\nstatic生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)\n\n#### 避免使用浮点数\n\n浮点数会比整型慢两倍\n\n#### 避免Timer.schedule，对于延时操作，可用以下方式代替\n\t\t\n\t\tScheduledExecutorService, \n\t\thandler.postDelayed, \n\t\thandler.postAtTime , \n\t\thandler.sendMessageDelayed ,  \n\t\tView.postDelayed，      \n\t\tAlarmManager\n\n\n#### 避免加载过大图片。压缩或者使用对象池后再使用\n\n\n#### 慎用异常\n\t\t\n原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。\n\n构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。\n\n\t\t\n#### 避免使用递归\n\n\n#### 避免使用轮询\n\n如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。\n\n#### 避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\n\n### 优化操作\n\n\n  <最优替换/>\n  \n#### 当数据量在100以内时，使用ArrayMap代替HashMap\n\n#### 为了避免自动装箱，当数量在1000以下时，使用如下容器\n\t\t\n\t\ta)SparseBoolMap <bool , obj>\n\t\tb)SparseIntMap <int , obj>\n\t\tc)SparseLongMap <long , obj>\n\t\td)LongSparseMap <long ,obj>\n\n#### 字符串拼接用StringBuilder或StringBuffer\n\n\t\t//这种string第一次初始化的情况下，下面得效率更高\n\t\tString str1 = \"abc\"+“def”+\"hij\";\n\t\t//非并发情况 ， StringBuilder效率更优\n\t\tStringBuilder str2 = str3 + str1 + \"builder\" ;\n\t\t//并发情况使用 StringBuffer\n\t\tStringBuffer str2 = str1 + \"buffer\" ;\n  \n#### 文件、网络IO缓存，使用有缓存机制的输入流\n\n\t\tBufferedInputStream替代InputStream\n\t\tBufferedReader替代Reader\n\t\tBufferedReader替代BufferedInputStream. \n \n \n#### 用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\n\n两个平行数组一定比一个对象数组的效率高。\n但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好\n \n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n#### 在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\n\n因为⼦子类会有⾃自⼰己的属性创建需要更多开销。\n\n#### 在使用Factory或类似Factory模式的情况。\n\n少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。\n\t\t\n\t\tpublic static Credit createCredit(){\n\t\t\treturn new Credit();\n\t\t}\n\t\t\n改写为：\n\t\t\n\t\tprivate static Credit BaseCredit = new Credit();\n\t\tpublic static Credit createCredit(){\n\t\t\treturn (Credit)BaseCredit.clone();\n\t\t}\n\n**你必须要注意的：clone是浅拷贝。**\n \n <优化操作/>\n \n#### 尽量使用局部变量  \n\n#### for循环要求 \n\n禁止在for循环的第二个条件中调用任何方法，应这样做\n\n\t\tint size = array.length;\n\t\tfor(int i = 0; i< size;i++)\n\t\t//替代：\n\t\tfor(int i =0;i < array.length;i++)\n\t\t\n在不需要使用下标的情况下，建议使用for_each循环\n\t\t\n\t\t\n#### 如果没有特殊需求，使用基本数据类型，而非对象类型。\n\n基本类似指：int , double , char等。\n\t\t\n\t\t\n#### 静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\n\n如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。\n\t\t\n\t\t\n#### 对于使用超过两次的对象成员， 将成员缓存到本地。\n\t\t\n反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中\n\n例：多次比较目标时间和当前时间差。\t\t\n\t\t\n#### 当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\n\n\t\tObject ob = new Object();\n\t\tint value;\n\t\tif(i>0)\n\t\t\tvalue = ob.getVlaue();\n\t\t\n\t\t改写为：\n\t\tint value;\n\t\t\n\t\tif(i>0){\n\t\t\tObject ob = new Object();   //用到时加载\n\t\t\tvalue = ob.getVlaue();\n\t\t}\n\n#### 不在使用的变量，手动置为null\n\t\t\n通常对于对象成员如此使用，局部变量不需要\n\t\t\n\t\tthis.object = null；\n\t\t\n\n#### 常量用 static final修饰\t\n\t\n<缓存/> \n\n#### 消息缓存，从handler消息池中取预存的Message\n\n\t\thandler.sendMessage(handler.obtainMessage(0, object)); \n   \n#### 尽量使用对象池机制\n\n对象池机制可以有效避免内存抖动提升性能\n\t\t\n优化：我们可以对对象进行预加载，有效提高程序首次运行速度\n\t\t\n警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系\n\n#### 使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\n\t\t\n通常，我们可以通过 objcet = null ; 来去掉对象的引用。\n\t\t\n\n\n#### 禁止将View添加到没有清除机制的容器里\n\n\t\t如：WeakHashMap，没有清除机制，易引起内存溢出\n\n<图片/>\n\n#### 对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\n\n\t\titmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\n\t\tscaledSrcBmp.getHeight(),Config.ARGB_8888);\n\t\t\n- ARGB_8888\t\t32Bit\t\t\n\n\t(这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)\n\t\n- RGB_565\t\t16Bit\t\n\n\t(对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的 \n从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)\n\t\n- ARGB_4444\t\t16Bit\t\t\n\n\t(这种格式的图片，看起来质量太差，已经不推荐使用)\n\t\n- ALPHA_8\t\t8Bit  \t\t\n\n\t(此时图片只有alpha值，没有RGB值， )\n\t\n\t\t\n\t\t\t\n\t\t\n#### 对于图片缩放，提供一下几种方式和其各自优缺点。\n\n\t\t/* \n\t\t *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n\t\t*/\n\t\tcreateScaleBitmap(inBmp , 64 , 128);\n\t\t/*\n\t\t *2.\t inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n\t\t*/\n\t\tmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \n\t\tmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n\n  \n\n#### Bitmap使用结束后，recycle（）释放内存\n\n\t\tBitmap.recycle();\n\n#### 相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\n\nBitmap提供了对图片更多的操作。\n同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。\n\n<布局/>\n\n#### 慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\n\n#### 避免多个线性布局嵌套，使用相对布局减少层级\n\n#### 对于TextView和ImageView组成的Layout，直接使用TextView替换\n\n\t\t<TextView\n    \t\tandroid:id=\"@+id/nameText\"\n    \t\tandroid:layout_width=\"wrap_content\"\n    \t\tandroid:layout_height=\"wrap_content\"\n    \t\tandroid:text=\"暴打小女孩\"\n    \t\tandroid:layout_marginBottom=\"center\"\n    \t\tandroid:gravity=\"center\"\n  \t \t\tandroid:drawableTop=\"@drawable/icon\"/>  //将图片置于上方  \n  \t\n  \t \t\t\n#### 默认不会显示的布局使用 viewstub 标签\n\n**但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE**\n\n\t\t<ViewStub\n\t\t\tandroid:id=\"@+id/network_error_layout\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\"\n\t\t\tandroid:layout=\"@layout/network_error\" />\n\t\t\t\n\t\t//非显示的转换ViewStub 获取\n\t\tView viewStub = findViewById(R.id.network_error_layout);\n\t\tviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\n\t\tnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局    \t\t\n#### 对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\n\n\t\tclass test{\n\t\t\tprivate View view = null;\n\t\t\tpublic void getView(){\n\t\t\t\tview = findViewById(R.id.network_error_layout);\n\t\t\t}\n\t\t\tpubli void showView(){\n\t\t\t\tview.setVisiblity(View.VIWIBLE);\n\t\t\t}\n\t\t}\n\t\t\n#### 对于重复出现超过2-3次的子布局，用 include 实现复用。\n\t\t\n\t\t<include layout=\"@layout/foot.xml\" />\n\n#### 当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\n\n要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少\n\n\t\t<merge xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\" >\n\t\t\t<Button\n\t\t\t\tandroid:id=\"@+id/button\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_above=\"@+id/text\"/>\n\t\t\t<TextView\n\t\t\t\tandroid:id=\"@+id/text\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_alignParentBottom=\"true\"\n\t\t\t\tandroid:text=\"@string/app_name\" />\n\t\t</merge>\n\n\n\n\n\n<br/><br/>\n\n### 性能优化策略\n\n- 减少过渡绘制，可以极大提高动画效率\n- 使用简单的动画效果，如：位置移动，慎用改变内容的动画效率\n\n\t\t动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n\t\t（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\t\t\n\t\t不改变内容，DsiplayList不会重建，提高动画效率\n\n- 捆绑非及时的网络请求，统一执行。\n- 网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。\n- 回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输\n\n### 性能优化心得\n\n<br/>\n\n在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。\n\n其实这是一个不那么准确的误区。\n\n手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）\n\n那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。\n\n世上没有免费得午餐，对象创建后总是要回收的---GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。\n\n所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。\n\n\n\n<br/><br/>\n### 参考资料\n<br/>\n\n[Android性能优化典范（一)](http://www.cnblogs.com/hanyonglu/p/4244035.html)\n\n[Android性能优化典范（二)](http://hukai.me/android-performance-patterns-season-2/)\n\n[Android性能优化典范（三)](http://hukai.me/android-performance-patterns-season-3/)\n\n\n\n<br/><br/>\n\n\n\n### 相关知识详述   \n\n#### 为什么将背景设置在主题可以减少加载时间？\n回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？\n\t\t\nResterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。\n\t\t\nCPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。\n\t\t\n然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。\n\t\t\n在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。\n\n\n\n#### 为什么禁止onDraw创建对象？\n\n首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。\n\t\t\n如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n\n\n#### 为什么要尽量使用局部变量？\n\nAndroid系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，\n\t\t\n同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。\n\n\n![image](http://images.cnitblog.com/blog/56846/201501/231407350162907.png)\n\n\n\n\n\n\n\n\n\n\t\t\n","slug":"AndroidCoding-performance-specification","published":1,"updated":"2019-01-02T02:09:31.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsom0003yo9sal2fisf2","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。</p>\n<p>但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。</p>\n<a id=\"more\"></a>\n<p>传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。</p>\n<p>本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。</p>\n<p>值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。</p>\n<p><br></p>\n<h3 id=\"编码之初\"><a href=\"#编码之初\" class=\"headerlink\" title=\"编码之初\"></a>编码之初</h3><h4 id=\"对于布局内容的数量要求\"><a href=\"#对于布局内容的数量要求\" class=\"headerlink\" title=\"对于布局内容的数量要求\"></a>对于布局内容的数量要求</h4><p>单个Activity显示的视图一般情况少于20，层数少于4。<br>对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。</p>\n<p><strong>Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单</strong></p>\n<h4 id=\"将Acitivity-中的Window-的背景图设置为空。\"><a href=\"#将Acitivity-中的Window-的背景图设置为空。\" class=\"headerlink\" title=\"将Acitivity 中的Window 的背景图设置为空。\"></a>将Acitivity 中的Window 的背景图设置为空。</h4><p>getWindow().setBackgroundDrawable(null); </p>\n<p>android的默认背景不为空。</p>\n<h4 id=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"><a href=\"#将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\" class=\"headerlink\" title=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"></a>将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。</h4><p>Theme设置属性</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;src_image&lt;/item&gt;\n</code></pre><h4 id=\"采用硬件加速\"><a href=\"#采用硬件加速\" class=\"headerlink\" title=\"采用硬件加速\"></a><del>采用硬件加速</del></h4><p>androidmanifest.xml中application添加 </p>\n<pre><code>android:hardwareAccelerated=&quot;true&quot;。\n</code></pre><p>需要注意的是：android 3.0以上才可以使用。</p>\n<h4 id=\"考虑使用Webp代替传统png图片。\"><a href=\"#考虑使用Webp代替传统png图片。\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<p>但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。</p>\n<p>我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。</p>\n<p><br><br></p>\n<h3 id=\"禁止（避免）操作\"><a href=\"#禁止（避免）操作\" class=\"headerlink\" title=\"禁止（避免）操作\"></a>禁止（避免）操作</h3><p><strong>核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为</strong></p>\n<h4 id=\"禁止在单例模式中引用Activity的context。使用Application。\"><a href=\"#禁止在单例模式中引用Activity的context。使用Application。\" class=\"headerlink\" title=\"禁止在单例模式中引用Activity的context。使用Application。\"></a>禁止在单例模式中引用Activity的context。使用Application。</h4><p>如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。</p>\n<pre><code>Singleton instance = Singleton.getInstance(this); // 禁止操作\n</code></pre><p>是使用 getApplicationContext()  这样就能避免内存泄露。</p>\n<pre><code>Singleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n</code></pre><h4 id=\"禁止使用枚举\"><a href=\"#禁止使用枚举\" class=\"headerlink\" title=\"禁止使用枚举\"></a>禁止使用枚举</h4><p>枚举将造成大量的内存浪费</p>\n<h4 id=\"禁止使用异步回调，\"><a href=\"#禁止使用异步回调，\" class=\"headerlink\" title=\"禁止使用异步回调，\"></a>禁止使用异步回调，</h4><p>异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。</p>\n<h4 id=\"禁止static引用资源耗费过多的实例\"><a href=\"#禁止static引用资源耗费过多的实例\" class=\"headerlink\" title=\"禁止static引用资源耗费过多的实例\"></a>禁止static引用资源耗费过多的实例</h4><p>例如：context  , Activity</p>\n<p>对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；</p>\n<h4 id=\"禁止内部的Getters-Setters\"><a href=\"#禁止内部的Getters-Setters\" class=\"headerlink\" title=\"禁止内部的Getters/Setters\"></a><del>禁止内部的Getters/Setters</del></h4><p><del>对于类的成员我们需要提供Get和Set方法</del></p>\n<p><del>但在类内部，应该避免使用Get和Set方法</del></p>\n<h4 id=\"禁止在非常复杂的布局上使用动画\"><a href=\"#禁止在非常复杂的布局上使用动画\" class=\"headerlink\" title=\"禁止在非常复杂的布局上使用动画\"></a>禁止在非常复杂的布局上使用动画</h4><h4 id=\"避免在循环（for、while、listView-getView方法、onDraw）里创建对象\"><a href=\"#避免在循环（for、while、listView-getView方法、onDraw）里创建对象\" class=\"headerlink\" title=\"避免在循环（for、while、listView - getView方法、onDraw）里创建对象\"></a>避免在循环（for、while、listView - getView方法、onDraw）里创建对象</h4><h4 id=\"避免在onDraw里创建对象\"><a href=\"#避免在onDraw里创建对象\" class=\"headerlink\" title=\"避免在onDraw里创建对象\"></a>避免在onDraw里创建对象</h4><p>对于onDraw中 Paint 我们可以这样优化</p>\n<pre><code>private Paint paint = new Paint();\n\npublic on Draw(){\n    paint.setColor(mBorderColor);\n}        \n</code></pre><h4 id=\"避免使用static成员对象\"><a href=\"#避免使用static成员对象\" class=\"headerlink\" title=\"避免使用static成员对象\"></a>避免使用static成员对象</h4><p>static生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)</p>\n<h4 id=\"避免使用浮点数\"><a href=\"#避免使用浮点数\" class=\"headerlink\" title=\"避免使用浮点数\"></a>避免使用浮点数</h4><p>浮点数会比整型慢两倍</p>\n<h4 id=\"避免Timer-schedule，对于延时操作，可用以下方式代替\"><a href=\"#避免Timer-schedule，对于延时操作，可用以下方式代替\" class=\"headerlink\" title=\"避免Timer.schedule，对于延时操作，可用以下方式代替\"></a>避免Timer.schedule，对于延时操作，可用以下方式代替</h4><pre><code>ScheduledExecutorService, \nhandler.postDelayed, \nhandler.postAtTime , \nhandler.sendMessageDelayed ,  \nView.postDelayed，      \nAlarmManager\n</code></pre><h4 id=\"避免加载过大图片。压缩或者使用对象池后再使用\"><a href=\"#避免加载过大图片。压缩或者使用对象池后再使用\" class=\"headerlink\" title=\"避免加载过大图片。压缩或者使用对象池后再使用\"></a>避免加载过大图片。压缩或者使用对象池后再使用</h4><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。</p>\n<p>构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。</p>\n<h4 id=\"避免使用递归\"><a href=\"#避免使用递归\" class=\"headerlink\" title=\"避免使用递归\"></a>避免使用递归</h4><h4 id=\"避免使用轮询\"><a href=\"#避免使用轮询\" class=\"headerlink\" title=\"避免使用轮询\"></a>避免使用轮询</h4><p>如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。</p>\n<h4 id=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\"><a href=\"#避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\" class=\"headerlink\" title=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\"></a>避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask</h4><h3 id=\"优化操作\"><a href=\"#优化操作\" class=\"headerlink\" title=\"优化操作\"></a>优化操作</h3><p>  &lt;最优替换/&gt;</p>\n<h4 id=\"当数据量在100以内时，使用ArrayMap代替HashMap\"><a href=\"#当数据量在100以内时，使用ArrayMap代替HashMap\" class=\"headerlink\" title=\"当数据量在100以内时，使用ArrayMap代替HashMap\"></a>当数据量在100以内时，使用ArrayMap代替HashMap</h4><h4 id=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"><a href=\"#为了避免自动装箱，当数量在1000以下时，使用如下容器\" class=\"headerlink\" title=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"></a>为了避免自动装箱，当数量在1000以下时，使用如下容器</h4><pre><code>a)SparseBoolMap &lt;bool , obj&gt;\nb)SparseIntMap &lt;int , obj&gt;\nc)SparseLongMap &lt;long , obj&gt;\nd)LongSparseMap &lt;long ,obj&gt;\n</code></pre><h4 id=\"字符串拼接用StringBuilder或StringBuffer\"><a href=\"#字符串拼接用StringBuilder或StringBuffer\" class=\"headerlink\" title=\"字符串拼接用StringBuilder或StringBuffer\"></a>字符串拼接用StringBuilder或StringBuffer</h4><pre><code>//这种string第一次初始化的情况下，下面得效率更高\nString str1 = &quot;abc&quot;+“def”+&quot;hij&quot;;\n//非并发情况 ， StringBuilder效率更优\nStringBuilder str2 = str3 + str1 + &quot;builder&quot; ;\n//并发情况使用 StringBuffer\nStringBuffer str2 = str1 + &quot;buffer&quot; ;\n</code></pre><h4 id=\"文件、网络IO缓存，使用有缓存机制的输入流\"><a href=\"#文件、网络IO缓存，使用有缓存机制的输入流\" class=\"headerlink\" title=\"文件、网络IO缓存，使用有缓存机制的输入流\"></a>文件、网络IO缓存，使用有缓存机制的输入流</h4><pre><code>BufferedInputStream替代InputStream\nBufferedReader替代Reader\nBufferedReader替代BufferedInputStream. \n</code></pre><h4 id=\"用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\"><a href=\"#用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\" class=\"headerlink\" title=\"用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\"></a>用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)</h4><p>两个平行数组一定比一个对象数组的效率高。<br>但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好</p>\n<h4 id=\"考虑使用Webp代替传统png图片。-1\"><a href=\"#考虑使用Webp代替传统png图片。-1\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<h4 id=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\"><a href=\"#在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\" class=\"headerlink\" title=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\"></a>在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。</h4><p>因为⼦子类会有⾃自⼰己的属性创建需要更多开销。</p>\n<h4 id=\"在使用Factory或类似Factory模式的情况。\"><a href=\"#在使用Factory或类似Factory模式的情况。\" class=\"headerlink\" title=\"在使用Factory或类似Factory模式的情况。\"></a>在使用Factory或类似Factory模式的情况。</h4><p>少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。</p>\n<pre><code>public static Credit createCredit(){\n    return new Credit();\n}\n</code></pre><p>改写为：</p>\n<pre><code>private static Credit BaseCredit = new Credit();\npublic static Credit createCredit(){\n    return (Credit)BaseCredit.clone();\n}\n</code></pre><p><strong>你必须要注意的：clone是浅拷贝。</strong></p>\n<p> &lt;优化操作/&gt;</p>\n<h4 id=\"尽量使用局部变量\"><a href=\"#尽量使用局部变量\" class=\"headerlink\" title=\"尽量使用局部变量\"></a>尽量使用局部变量</h4><h4 id=\"for循环要求\"><a href=\"#for循环要求\" class=\"headerlink\" title=\"for循环要求\"></a>for循环要求</h4><p>禁止在for循环的第二个条件中调用任何方法，应这样做</p>\n<pre><code>int size = array.length;\nfor(int i = 0; i&lt; size;i++)\n//替代：\nfor(int i =0;i &lt; array.length;i++)\n</code></pre><p>在不需要使用下标的情况下，建议使用for_each循环</p>\n<h4 id=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"><a href=\"#如果没有特殊需求，使用基本数据类型，而非对象类型。\" class=\"headerlink\" title=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"></a>如果没有特殊需求，使用基本数据类型，而非对象类型。</h4><p>基本类似指：int , double , char等。</p>\n<h4 id=\"静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\"><a href=\"#静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\" class=\"headerlink\" title=\"静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\"></a>静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）</h4><p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。</p>\n<h4 id=\"对于使用超过两次的对象成员，-将成员缓存到本地。\"><a href=\"#对于使用超过两次的对象成员，-将成员缓存到本地。\" class=\"headerlink\" title=\"对于使用超过两次的对象成员， 将成员缓存到本地。\"></a>对于使用超过两次的对象成员， 将成员缓存到本地。</h4><p>反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中</p>\n<p>例：多次比较目标时间和当前时间差。        </p>\n<h4 id=\"当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\"><a href=\"#当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\" class=\"headerlink\" title=\"当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\"></a>当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成</h4><pre><code>Object ob = new Object();\nint value;\nif(i&gt;0)\n    value = ob.getVlaue();\n\n改写为：\nint value;\n\nif(i&gt;0){\n    Object ob = new Object();   //用到时加载\n    value = ob.getVlaue();\n}\n</code></pre><h4 id=\"不在使用的变量，手动置为null\"><a href=\"#不在使用的变量，手动置为null\" class=\"headerlink\" title=\"不在使用的变量，手动置为null\"></a>不在使用的变量，手动置为null</h4><p>通常对于对象成员如此使用，局部变量不需要</p>\n<pre><code>this.object = null；\n</code></pre><h4 id=\"常量用-static-final修饰\"><a href=\"#常量用-static-final修饰\" class=\"headerlink\" title=\"常量用 static final修饰\"></a>常量用 static final修饰</h4><p>&lt;缓存/&gt; </p>\n<h4 id=\"消息缓存，从handler消息池中取预存的Message\"><a href=\"#消息缓存，从handler消息池中取预存的Message\" class=\"headerlink\" title=\"消息缓存，从handler消息池中取预存的Message\"></a>消息缓存，从handler消息池中取预存的Message</h4><pre><code>handler.sendMessage(handler.obtainMessage(0, object)); \n</code></pre><h4 id=\"尽量使用对象池机制\"><a href=\"#尽量使用对象池机制\" class=\"headerlink\" title=\"尽量使用对象池机制\"></a>尽量使用对象池机制</h4><p>对象池机制可以有效避免内存抖动提升性能</p>\n<p>优化：我们可以对对象进行预加载，有效提高程序首次运行速度</p>\n<p>警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系</p>\n<h4 id=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"><a href=\"#使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\" class=\"headerlink\" title=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"></a>使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系</h4><p>通常，我们可以通过 objcet = null ; 来去掉对象的引用。</p>\n<h4 id=\"禁止将View添加到没有清除机制的容器里\"><a href=\"#禁止将View添加到没有清除机制的容器里\" class=\"headerlink\" title=\"禁止将View添加到没有清除机制的容器里\"></a>禁止将View添加到没有清除机制的容器里</h4><pre><code>如：WeakHashMap，没有清除机制，易引起内存溢出\n</code></pre><p>&lt;图片/&gt;</p>\n<h4 id=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"><a href=\"#对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\" class=\"headerlink\" title=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"></a>对于不同目的的图片需求（Bitmap），使用不同的图片解码格式</h4><pre><code>itmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\nscaledSrcBmp.getHeight(),Config.ARGB_8888);\n</code></pre><ul>\n<li><p>ARGB_8888        32Bit        </p>\n<p>  (这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)</p>\n</li>\n<li><p>RGB_565        16Bit    </p>\n<p>  (对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的<br>从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)</p>\n</li>\n<li><p>ARGB_4444        16Bit        </p>\n<p>  (这种格式的图片，看起来质量太差，已经不推荐使用)</p>\n</li>\n<li><p>ALPHA_8        8Bit          </p>\n<p>  (此时图片只有alpha值，没有RGB值， )</p>\n</li>\n</ul>\n<h4 id=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"><a href=\"#对于图片缩放，提供一下几种方式和其各自优缺点。\" class=\"headerlink\" title=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"></a>对于图片缩放，提供一下几种方式和其各自优缺点。</h4><pre><code>/* \n *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n*/\ncreateScaleBitmap(inBmp , 64 , 128);\n/*\n *2.     inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n*/\nmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \nmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n</code></pre><h4 id=\"Bitmap使用结束后，recycle（）释放内存\"><a href=\"#Bitmap使用结束后，recycle（）释放内存\" class=\"headerlink\" title=\"Bitmap使用结束后，recycle（）释放内存\"></a>Bitmap使用结束后，recycle（）释放内存</h4><pre><code>Bitmap.recycle();\n</code></pre><h4 id=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"><a href=\"#相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\" class=\"headerlink\" title=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"></a>相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable</h4><p>Bitmap提供了对图片更多的操作。<br>同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。</p>\n<p>&lt;布局/&gt;</p>\n<h4 id=\"慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\"><a href=\"#慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\" class=\"headerlink\" title=\"慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\"></a>慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果</h4><h4 id=\"避免多个线性布局嵌套，使用相对布局减少层级\"><a href=\"#避免多个线性布局嵌套，使用相对布局减少层级\" class=\"headerlink\" title=\"避免多个线性布局嵌套，使用相对布局减少层级\"></a>避免多个线性布局嵌套，使用相对布局减少层级</h4><h4 id=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"><a href=\"#对于TextView和ImageView组成的Layout，直接使用TextView替换\" class=\"headerlink\" title=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"></a>对于TextView和ImageView组成的Layout，直接使用TextView替换</h4><pre><code>&lt;TextView\n    android:id=&quot;@+id/nameText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;暴打小女孩&quot;\n    android:layout_marginBottom=&quot;center&quot;\n    android:gravity=&quot;center&quot;\n       android:drawableTop=&quot;@drawable/icon&quot;/&gt;  //将图片置于上方  \n</code></pre><h4 id=\"默认不会显示的布局使用-viewstub-标签\"><a href=\"#默认不会显示的布局使用-viewstub-标签\" class=\"headerlink\" title=\"默认不会显示的布局使用 viewstub 标签\"></a>默认不会显示的布局使用 viewstub 标签</h4><p><strong>但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE</strong></p>\n<pre><code>&lt;ViewStub\n    android:id=&quot;@+id/network_error_layout&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:layout=&quot;@layout/network_error&quot; /&gt;\n\n//非显示的转换ViewStub 获取\nView viewStub = findViewById(R.id.network_error_layout);\nviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\nnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局            \n</code></pre><h4 id=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"><a href=\"#对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\" class=\"headerlink\" title=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"></a>对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载</h4><pre><code>class test{\n    private View view = null;\n    public void getView(){\n        view = findViewById(R.id.network_error_layout);\n    }\n    publi void showView(){\n        view.setVisiblity(View.VIWIBLE);\n    }\n}\n</code></pre><h4 id=\"对于重复出现超过2-3次的子布局，用-include-实现复用。\"><a href=\"#对于重复出现超过2-3次的子布局，用-include-实现复用。\" class=\"headerlink\" title=\"对于重复出现超过2-3次的子布局，用 include 实现复用。\"></a>对于重复出现超过2-3次的子布局，用 include 实现复用。</h4><pre><code>&lt;include layout=&quot;@layout/foot.xml&quot; /&gt;\n</code></pre><h4 id=\"当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\"><a href=\"#当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\" class=\"headerlink\" title=\"当复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\"></a>当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点</include></h4><p>要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少</p>\n<pre><code>&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot; &gt;\n    &lt;Button\n        android:id=&quot;@+id/button&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_above=&quot;@+id/text&quot;/&gt;\n    &lt;TextView\n        android:id=&quot;@+id/text&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:text=&quot;@string/app_name&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p><br><br></p>\n<h3 id=\"性能优化策略\"><a href=\"#性能优化策略\" class=\"headerlink\" title=\"性能优化策略\"></a>性能优化策略</h3><ul>\n<li>减少过渡绘制，可以极大提高动画效率</li>\n<li><p>使用简单的动画效果，如：位置移动，慎用改变内容的动画效率</p>\n<pre><code>动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\n不改变内容，DsiplayList不会重建，提高动画效率\n</code></pre></li>\n<li><p>捆绑非及时的网络请求，统一执行。</p>\n</li>\n<li>网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。</li>\n<li>回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输</li>\n</ul>\n<h3 id=\"性能优化心得\"><a href=\"#性能优化心得\" class=\"headerlink\" title=\"性能优化心得\"></a>性能优化心得</h3><p><br></p>\n<p>在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。</p>\n<p>其实这是一个不那么准确的误区。</p>\n<p>手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）</p>\n<p>那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。</p>\n<p>世上没有免费得午餐，对象创建后总是要回收的—GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。</p>\n<p>所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。</p>\n<p><br><br></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><br></p>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/p/4244035.html\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（一)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-2/\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（二)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-3/\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（三)</a></p>\n<p><br><br></p>\n<h3 id=\"相关知识详述\"><a href=\"#相关知识详述\" class=\"headerlink\" title=\"相关知识详述\"></a>相关知识详述</h3><h4 id=\"为什么将背景设置在主题可以减少加载时间？\"><a href=\"#为什么将背景设置在主题可以减少加载时间？\" class=\"headerlink\" title=\"为什么将背景设置在主题可以减少加载时间？\"></a>为什么将背景设置在主题可以减少加载时间？</h4><p>回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？</p>\n<p>Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>\n<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>\n<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>\n<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。</p>\n<h4 id=\"为什么禁止onDraw创建对象？\"><a href=\"#为什么禁止onDraw创建对象？\" class=\"headerlink\" title=\"为什么禁止onDraw创建对象？\"></a>为什么禁止onDraw创建对象？</h4><p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>\n<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>\n<h4 id=\"为什么要尽量使用局部变量？\"><a href=\"#为什么要尽量使用局部变量？\" class=\"headerlink\" title=\"为什么要尽量使用局部变量？\"></a>为什么要尽量使用局部变量？</h4><p>Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，</p>\n<p>同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>\n<p><img src=\"http://images.cnitblog.com/blog/56846/201501/231407350162907.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。</p>\n<p>但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。</p>","more":"<p>传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。</p>\n<p>本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。</p>\n<p>值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。</p>\n<p><br></p>\n<h3 id=\"编码之初\"><a href=\"#编码之初\" class=\"headerlink\" title=\"编码之初\"></a>编码之初</h3><h4 id=\"对于布局内容的数量要求\"><a href=\"#对于布局内容的数量要求\" class=\"headerlink\" title=\"对于布局内容的数量要求\"></a>对于布局内容的数量要求</h4><p>单个Activity显示的视图一般情况少于20，层数少于4。<br>对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。</p>\n<p><strong>Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单</strong></p>\n<h4 id=\"将Acitivity-中的Window-的背景图设置为空。\"><a href=\"#将Acitivity-中的Window-的背景图设置为空。\" class=\"headerlink\" title=\"将Acitivity 中的Window 的背景图设置为空。\"></a>将Acitivity 中的Window 的背景图设置为空。</h4><p>getWindow().setBackgroundDrawable(null); </p>\n<p>android的默认背景不为空。</p>\n<h4 id=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"><a href=\"#将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\" class=\"headerlink\" title=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"></a>将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。</h4><p>Theme设置属性</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;src_image&lt;/item&gt;\n</code></pre><h4 id=\"采用硬件加速\"><a href=\"#采用硬件加速\" class=\"headerlink\" title=\"采用硬件加速\"></a><del>采用硬件加速</del></h4><p>androidmanifest.xml中application添加 </p>\n<pre><code>android:hardwareAccelerated=&quot;true&quot;。\n</code></pre><p>需要注意的是：android 3.0以上才可以使用。</p>\n<h4 id=\"考虑使用Webp代替传统png图片。\"><a href=\"#考虑使用Webp代替传统png图片。\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<p>但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。</p>\n<p>我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。</p>\n<p><br><br></p>\n<h3 id=\"禁止（避免）操作\"><a href=\"#禁止（避免）操作\" class=\"headerlink\" title=\"禁止（避免）操作\"></a>禁止（避免）操作</h3><p><strong>核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为</strong></p>\n<h4 id=\"禁止在单例模式中引用Activity的context。使用Application。\"><a href=\"#禁止在单例模式中引用Activity的context。使用Application。\" class=\"headerlink\" title=\"禁止在单例模式中引用Activity的context。使用Application。\"></a>禁止在单例模式中引用Activity的context。使用Application。</h4><p>如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。</p>\n<pre><code>Singleton instance = Singleton.getInstance(this); // 禁止操作\n</code></pre><p>是使用 getApplicationContext()  这样就能避免内存泄露。</p>\n<pre><code>Singleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n</code></pre><h4 id=\"禁止使用枚举\"><a href=\"#禁止使用枚举\" class=\"headerlink\" title=\"禁止使用枚举\"></a>禁止使用枚举</h4><p>枚举将造成大量的内存浪费</p>\n<h4 id=\"禁止使用异步回调，\"><a href=\"#禁止使用异步回调，\" class=\"headerlink\" title=\"禁止使用异步回调，\"></a>禁止使用异步回调，</h4><p>异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。</p>\n<h4 id=\"禁止static引用资源耗费过多的实例\"><a href=\"#禁止static引用资源耗费过多的实例\" class=\"headerlink\" title=\"禁止static引用资源耗费过多的实例\"></a>禁止static引用资源耗费过多的实例</h4><p>例如：context  , Activity</p>\n<p>对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；</p>\n<h4 id=\"禁止内部的Getters-Setters\"><a href=\"#禁止内部的Getters-Setters\" class=\"headerlink\" title=\"禁止内部的Getters/Setters\"></a><del>禁止内部的Getters/Setters</del></h4><p><del>对于类的成员我们需要提供Get和Set方法</del></p>\n<p><del>但在类内部，应该避免使用Get和Set方法</del></p>\n<h4 id=\"禁止在非常复杂的布局上使用动画\"><a href=\"#禁止在非常复杂的布局上使用动画\" class=\"headerlink\" title=\"禁止在非常复杂的布局上使用动画\"></a>禁止在非常复杂的布局上使用动画</h4><h4 id=\"避免在循环（for、while、listView-getView方法、onDraw）里创建对象\"><a href=\"#避免在循环（for、while、listView-getView方法、onDraw）里创建对象\" class=\"headerlink\" title=\"避免在循环（for、while、listView - getView方法、onDraw）里创建对象\"></a>避免在循环（for、while、listView - getView方法、onDraw）里创建对象</h4><h4 id=\"避免在onDraw里创建对象\"><a href=\"#避免在onDraw里创建对象\" class=\"headerlink\" title=\"避免在onDraw里创建对象\"></a>避免在onDraw里创建对象</h4><p>对于onDraw中 Paint 我们可以这样优化</p>\n<pre><code>private Paint paint = new Paint();\n\npublic on Draw(){\n    paint.setColor(mBorderColor);\n}        \n</code></pre><h4 id=\"避免使用static成员对象\"><a href=\"#避免使用static成员对象\" class=\"headerlink\" title=\"避免使用static成员对象\"></a>避免使用static成员对象</h4><p>static生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)</p>\n<h4 id=\"避免使用浮点数\"><a href=\"#避免使用浮点数\" class=\"headerlink\" title=\"避免使用浮点数\"></a>避免使用浮点数</h4><p>浮点数会比整型慢两倍</p>\n<h4 id=\"避免Timer-schedule，对于延时操作，可用以下方式代替\"><a href=\"#避免Timer-schedule，对于延时操作，可用以下方式代替\" class=\"headerlink\" title=\"避免Timer.schedule，对于延时操作，可用以下方式代替\"></a>避免Timer.schedule，对于延时操作，可用以下方式代替</h4><pre><code>ScheduledExecutorService, \nhandler.postDelayed, \nhandler.postAtTime , \nhandler.sendMessageDelayed ,  \nView.postDelayed，      \nAlarmManager\n</code></pre><h4 id=\"避免加载过大图片。压缩或者使用对象池后再使用\"><a href=\"#避免加载过大图片。压缩或者使用对象池后再使用\" class=\"headerlink\" title=\"避免加载过大图片。压缩或者使用对象池后再使用\"></a>避免加载过大图片。压缩或者使用对象池后再使用</h4><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。</p>\n<p>构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。</p>\n<h4 id=\"避免使用递归\"><a href=\"#避免使用递归\" class=\"headerlink\" title=\"避免使用递归\"></a>避免使用递归</h4><h4 id=\"避免使用轮询\"><a href=\"#避免使用轮询\" class=\"headerlink\" title=\"避免使用轮询\"></a>避免使用轮询</h4><p>如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。</p>\n<h4 id=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\"><a href=\"#避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\" class=\"headerlink\" title=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\"></a>避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask</h4><h3 id=\"优化操作\"><a href=\"#优化操作\" class=\"headerlink\" title=\"优化操作\"></a>优化操作</h3><p>  &lt;最优替换/&gt;</p>\n<h4 id=\"当数据量在100以内时，使用ArrayMap代替HashMap\"><a href=\"#当数据量在100以内时，使用ArrayMap代替HashMap\" class=\"headerlink\" title=\"当数据量在100以内时，使用ArrayMap代替HashMap\"></a>当数据量在100以内时，使用ArrayMap代替HashMap</h4><h4 id=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"><a href=\"#为了避免自动装箱，当数量在1000以下时，使用如下容器\" class=\"headerlink\" title=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"></a>为了避免自动装箱，当数量在1000以下时，使用如下容器</h4><pre><code>a)SparseBoolMap &lt;bool , obj&gt;\nb)SparseIntMap &lt;int , obj&gt;\nc)SparseLongMap &lt;long , obj&gt;\nd)LongSparseMap &lt;long ,obj&gt;\n</code></pre><h4 id=\"字符串拼接用StringBuilder或StringBuffer\"><a href=\"#字符串拼接用StringBuilder或StringBuffer\" class=\"headerlink\" title=\"字符串拼接用StringBuilder或StringBuffer\"></a>字符串拼接用StringBuilder或StringBuffer</h4><pre><code>//这种string第一次初始化的情况下，下面得效率更高\nString str1 = &quot;abc&quot;+“def”+&quot;hij&quot;;\n//非并发情况 ， StringBuilder效率更优\nStringBuilder str2 = str3 + str1 + &quot;builder&quot; ;\n//并发情况使用 StringBuffer\nStringBuffer str2 = str1 + &quot;buffer&quot; ;\n</code></pre><h4 id=\"文件、网络IO缓存，使用有缓存机制的输入流\"><a href=\"#文件、网络IO缓存，使用有缓存机制的输入流\" class=\"headerlink\" title=\"文件、网络IO缓存，使用有缓存机制的输入流\"></a>文件、网络IO缓存，使用有缓存机制的输入流</h4><pre><code>BufferedInputStream替代InputStream\nBufferedReader替代Reader\nBufferedReader替代BufferedInputStream. \n</code></pre><h4 id=\"用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\"><a href=\"#用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\" class=\"headerlink\" title=\"用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\"></a>用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)</h4><p>两个平行数组一定比一个对象数组的效率高。<br>但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好</p>\n<h4 id=\"考虑使用Webp代替传统png图片。-1\"><a href=\"#考虑使用Webp代替传统png图片。-1\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<h4 id=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\"><a href=\"#在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\" class=\"headerlink\" title=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\"></a>在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。</h4><p>因为⼦子类会有⾃自⼰己的属性创建需要更多开销。</p>\n<h4 id=\"在使用Factory或类似Factory模式的情况。\"><a href=\"#在使用Factory或类似Factory模式的情况。\" class=\"headerlink\" title=\"在使用Factory或类似Factory模式的情况。\"></a>在使用Factory或类似Factory模式的情况。</h4><p>少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。</p>\n<pre><code>public static Credit createCredit(){\n    return new Credit();\n}\n</code></pre><p>改写为：</p>\n<pre><code>private static Credit BaseCredit = new Credit();\npublic static Credit createCredit(){\n    return (Credit)BaseCredit.clone();\n}\n</code></pre><p><strong>你必须要注意的：clone是浅拷贝。</strong></p>\n<p> &lt;优化操作/&gt;</p>\n<h4 id=\"尽量使用局部变量\"><a href=\"#尽量使用局部变量\" class=\"headerlink\" title=\"尽量使用局部变量\"></a>尽量使用局部变量</h4><h4 id=\"for循环要求\"><a href=\"#for循环要求\" class=\"headerlink\" title=\"for循环要求\"></a>for循环要求</h4><p>禁止在for循环的第二个条件中调用任何方法，应这样做</p>\n<pre><code>int size = array.length;\nfor(int i = 0; i&lt; size;i++)\n//替代：\nfor(int i =0;i &lt; array.length;i++)\n</code></pre><p>在不需要使用下标的情况下，建议使用for_each循环</p>\n<h4 id=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"><a href=\"#如果没有特殊需求，使用基本数据类型，而非对象类型。\" class=\"headerlink\" title=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"></a>如果没有特殊需求，使用基本数据类型，而非对象类型。</h4><p>基本类似指：int , double , char等。</p>\n<h4 id=\"静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\"><a href=\"#静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\" class=\"headerlink\" title=\"静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\"></a>静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）</h4><p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。</p>\n<h4 id=\"对于使用超过两次的对象成员，-将成员缓存到本地。\"><a href=\"#对于使用超过两次的对象成员，-将成员缓存到本地。\" class=\"headerlink\" title=\"对于使用超过两次的对象成员， 将成员缓存到本地。\"></a>对于使用超过两次的对象成员， 将成员缓存到本地。</h4><p>反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中</p>\n<p>例：多次比较目标时间和当前时间差。        </p>\n<h4 id=\"当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\"><a href=\"#当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\" class=\"headerlink\" title=\"当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\"></a>当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成</h4><pre><code>Object ob = new Object();\nint value;\nif(i&gt;0)\n    value = ob.getVlaue();\n\n改写为：\nint value;\n\nif(i&gt;0){\n    Object ob = new Object();   //用到时加载\n    value = ob.getVlaue();\n}\n</code></pre><h4 id=\"不在使用的变量，手动置为null\"><a href=\"#不在使用的变量，手动置为null\" class=\"headerlink\" title=\"不在使用的变量，手动置为null\"></a>不在使用的变量，手动置为null</h4><p>通常对于对象成员如此使用，局部变量不需要</p>\n<pre><code>this.object = null；\n</code></pre><h4 id=\"常量用-static-final修饰\"><a href=\"#常量用-static-final修饰\" class=\"headerlink\" title=\"常量用 static final修饰\"></a>常量用 static final修饰</h4><p>&lt;缓存/&gt; </p>\n<h4 id=\"消息缓存，从handler消息池中取预存的Message\"><a href=\"#消息缓存，从handler消息池中取预存的Message\" class=\"headerlink\" title=\"消息缓存，从handler消息池中取预存的Message\"></a>消息缓存，从handler消息池中取预存的Message</h4><pre><code>handler.sendMessage(handler.obtainMessage(0, object)); \n</code></pre><h4 id=\"尽量使用对象池机制\"><a href=\"#尽量使用对象池机制\" class=\"headerlink\" title=\"尽量使用对象池机制\"></a>尽量使用对象池机制</h4><p>对象池机制可以有效避免内存抖动提升性能</p>\n<p>优化：我们可以对对象进行预加载，有效提高程序首次运行速度</p>\n<p>警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系</p>\n<h4 id=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"><a href=\"#使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\" class=\"headerlink\" title=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"></a>使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系</h4><p>通常，我们可以通过 objcet = null ; 来去掉对象的引用。</p>\n<h4 id=\"禁止将View添加到没有清除机制的容器里\"><a href=\"#禁止将View添加到没有清除机制的容器里\" class=\"headerlink\" title=\"禁止将View添加到没有清除机制的容器里\"></a>禁止将View添加到没有清除机制的容器里</h4><pre><code>如：WeakHashMap，没有清除机制，易引起内存溢出\n</code></pre><p>&lt;图片/&gt;</p>\n<h4 id=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"><a href=\"#对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\" class=\"headerlink\" title=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"></a>对于不同目的的图片需求（Bitmap），使用不同的图片解码格式</h4><pre><code>itmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\nscaledSrcBmp.getHeight(),Config.ARGB_8888);\n</code></pre><ul>\n<li><p>ARGB_8888        32Bit        </p>\n<p>  (这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)</p>\n</li>\n<li><p>RGB_565        16Bit    </p>\n<p>  (对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的<br>从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)</p>\n</li>\n<li><p>ARGB_4444        16Bit        </p>\n<p>  (这种格式的图片，看起来质量太差，已经不推荐使用)</p>\n</li>\n<li><p>ALPHA_8        8Bit          </p>\n<p>  (此时图片只有alpha值，没有RGB值， )</p>\n</li>\n</ul>\n<h4 id=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"><a href=\"#对于图片缩放，提供一下几种方式和其各自优缺点。\" class=\"headerlink\" title=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"></a>对于图片缩放，提供一下几种方式和其各自优缺点。</h4><pre><code>/* \n *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n*/\ncreateScaleBitmap(inBmp , 64 , 128);\n/*\n *2.     inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n*/\nmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \nmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n</code></pre><h4 id=\"Bitmap使用结束后，recycle（）释放内存\"><a href=\"#Bitmap使用结束后，recycle（）释放内存\" class=\"headerlink\" title=\"Bitmap使用结束后，recycle（）释放内存\"></a>Bitmap使用结束后，recycle（）释放内存</h4><pre><code>Bitmap.recycle();\n</code></pre><h4 id=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"><a href=\"#相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\" class=\"headerlink\" title=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"></a>相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable</h4><p>Bitmap提供了对图片更多的操作。<br>同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。</p>\n<p>&lt;布局/&gt;</p>\n<h4 id=\"慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\"><a href=\"#慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\" class=\"headerlink\" title=\"慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\"></a>慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果</h4><h4 id=\"避免多个线性布局嵌套，使用相对布局减少层级\"><a href=\"#避免多个线性布局嵌套，使用相对布局减少层级\" class=\"headerlink\" title=\"避免多个线性布局嵌套，使用相对布局减少层级\"></a>避免多个线性布局嵌套，使用相对布局减少层级</h4><h4 id=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"><a href=\"#对于TextView和ImageView组成的Layout，直接使用TextView替换\" class=\"headerlink\" title=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"></a>对于TextView和ImageView组成的Layout，直接使用TextView替换</h4><pre><code>&lt;TextView\n    android:id=&quot;@+id/nameText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;暴打小女孩&quot;\n    android:layout_marginBottom=&quot;center&quot;\n    android:gravity=&quot;center&quot;\n       android:drawableTop=&quot;@drawable/icon&quot;/&gt;  //将图片置于上方  \n</code></pre><h4 id=\"默认不会显示的布局使用-viewstub-标签\"><a href=\"#默认不会显示的布局使用-viewstub-标签\" class=\"headerlink\" title=\"默认不会显示的布局使用 viewstub 标签\"></a>默认不会显示的布局使用 viewstub 标签</h4><p><strong>但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE</strong></p>\n<pre><code>&lt;ViewStub\n    android:id=&quot;@+id/network_error_layout&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:layout=&quot;@layout/network_error&quot; /&gt;\n\n//非显示的转换ViewStub 获取\nView viewStub = findViewById(R.id.network_error_layout);\nviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\nnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局            \n</code></pre><h4 id=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"><a href=\"#对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\" class=\"headerlink\" title=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"></a>对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载</h4><pre><code>class test{\n    private View view = null;\n    public void getView(){\n        view = findViewById(R.id.network_error_layout);\n    }\n    publi void showView(){\n        view.setVisiblity(View.VIWIBLE);\n    }\n}\n</code></pre><h4 id=\"对于重复出现超过2-3次的子布局，用-include-实现复用。\"><a href=\"#对于重复出现超过2-3次的子布局，用-include-实现复用。\" class=\"headerlink\" title=\"对于重复出现超过2-3次的子布局，用 include 实现复用。\"></a>对于重复出现超过2-3次的子布局，用 include 实现复用。</h4><pre><code>&lt;include layout=&quot;@layout/foot.xml&quot; /&gt;\n</code></pre><h4 id=\"当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\"><a href=\"#当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\" class=\"headerlink\" title=\"当复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\"></a>当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点</include></h4><p>要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少</p>\n<pre><code>&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot; &gt;\n    &lt;Button\n        android:id=&quot;@+id/button&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_above=&quot;@+id/text&quot;/&gt;\n    &lt;TextView\n        android:id=&quot;@+id/text&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:text=&quot;@string/app_name&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p><br><br></p>\n<h3 id=\"性能优化策略\"><a href=\"#性能优化策略\" class=\"headerlink\" title=\"性能优化策略\"></a>性能优化策略</h3><ul>\n<li>减少过渡绘制，可以极大提高动画效率</li>\n<li><p>使用简单的动画效果，如：位置移动，慎用改变内容的动画效率</p>\n<pre><code>动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\n不改变内容，DsiplayList不会重建，提高动画效率\n</code></pre></li>\n<li><p>捆绑非及时的网络请求，统一执行。</p>\n</li>\n<li>网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。</li>\n<li>回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输</li>\n</ul>\n<h3 id=\"性能优化心得\"><a href=\"#性能优化心得\" class=\"headerlink\" title=\"性能优化心得\"></a>性能优化心得</h3><p><br></p>\n<p>在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。</p>\n<p>其实这是一个不那么准确的误区。</p>\n<p>手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）</p>\n<p>那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。</p>\n<p>世上没有免费得午餐，对象创建后总是要回收的—GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。</p>\n<p>所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。</p>\n<p><br><br></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><br></p>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/p/4244035.html\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（一)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-2/\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（二)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-3/\" target=\"_blank\" rel=\"noopener\">Android性能优化典范（三)</a></p>\n<p><br><br></p>\n<h3 id=\"相关知识详述\"><a href=\"#相关知识详述\" class=\"headerlink\" title=\"相关知识详述\"></a>相关知识详述</h3><h4 id=\"为什么将背景设置在主题可以减少加载时间？\"><a href=\"#为什么将背景设置在主题可以减少加载时间？\" class=\"headerlink\" title=\"为什么将背景设置在主题可以减少加载时间？\"></a>为什么将背景设置在主题可以减少加载时间？</h4><p>回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？</p>\n<p>Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>\n<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>\n<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>\n<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。</p>\n<h4 id=\"为什么禁止onDraw创建对象？\"><a href=\"#为什么禁止onDraw创建对象？\" class=\"headerlink\" title=\"为什么禁止onDraw创建对象？\"></a>为什么禁止onDraw创建对象？</h4><p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>\n<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>\n<h4 id=\"为什么要尽量使用局部变量？\"><a href=\"#为什么要尽量使用局部变量？\" class=\"headerlink\" title=\"为什么要尽量使用局部变量？\"></a>为什么要尽量使用局部变量？</h4><p>Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，</p>\n<p>同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>\n<p><img src=\"http://images.cnitblog.com/blog/56846/201501/231407350162907.png\" alt=\"image\"></p>"},{"title":"Calabash探索2-Calabash用法详解","date":"2017-03-18T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n上一篇Calabash Run起来以后，如果你立刻在自己的项目上进行尝试，我相信你一定会像我之前一样，一头雾水，那么从这篇开始，我们来对Calabash深挖。 大概从这几个方向开始：\n\n- Feature、Scenario等关键字使用策略。\n- Calabash预定义Steps的使用。\n- 自定义Steps。\n- 使用Ruby语法编写带逻辑判断的Steps。\n- 自定义Steps的使用策略。\n- Ruby Query的使用。\n\n<!-- more -->\n\n## Feature、Scenario等关键字使用策略\n\n主要的关键字如下Feature、Scenario、Given、When、Then。前面我们也说了，其实这几个关键字实际是Cucumber体系下的，如果你想更进一步的了解，请查询[Cucumber相关资料](https://github.com/cucumber/cucumber)。\n我们重点讲Feature、Scenario两个。\n\n一个.feature文件只能含有一个Feature，以此作为一个测试用例集，一个测试用例集（Feature）可以包含多个场景（Scenario）。\n\n在不指定具体的.feature文件及其顺序的情况下，Calabash会遍历features根目录下的所有Feature按随机顺序执行。\n每执行一个Feature都会卸载重新安装App，而执行Scenario则不会重新卸载安装App，而是重新启动。\n\n举例我有以下两个文件：\n\n*login.feature* ： 测试登录和注册两个业务\n\n```\nFeature: Login 测试\n\n\tScenario: 使用无效手机号注册\n\n\t\tThen I...\n    \t...\n    \n\tScenario: 使用正确手机号、无效验证码注册\n  \n\t\tThen I...\n\t\t...\n    \n\tScenario: 使用正确手机号、正确验证码注册\n   \n        Then I...\n        ...\n\t\n    Scenario: 使用错误手机号登录\n   \n        Then I...\n        ...\n    Scenario: 使用正确手机号登录\n   \n        Then I...\n        ...\n\t\n```\n\n*health.feature* ： 测试上传健康证业务\n\n```\nFeature: Health 测试\n\n\tScenario: 登录\n\n\t\tThen I...\n    \t...\n    \n\tScenario: 使用错误健康证号码上传\n  \n\t\tThen I...\n\t\t...\n    \n\tScenario: 使用正确健康证号码上传\n   \n        Then I...\n        ...\n\t\n```\n\n**切记：在设计时，每个Feature都应该是完全独立，他们之间不能有任何耦合（App都卸载了，你互相依赖还有啥用）**\n因为每个Feature都是独立的，所以完全不必在意他们的执行顺序。\n\n使用命令 ``calabash-android run test.apk`` 执行时，Calabash会遍历features主目录下所有的.feature文件进行执行。\n当你只想执行某一个或某几个Feature时，直接在该命令后加Feature文件路径即可\n\n```\ncalabash-android run test.apk ./login.feature ./health.feature\n\n```\n值的一提的是，当你指定执行哪些Feature时,Calabash会按照你指定的顺序进行执行。\n    \n那么当我执行``calabash-android run test.apk`` 会发生什么呢？\n\n```\n1.安装App\n2.执行Feature: Login 测试\n3.启动App\n4.执行Scenario: 使用无效手机号注册\n5.关闭App,重启App\n6.执行Scenario: 使用正确手机号、无效验证码注册\n7.关闭App,重启App\n8.执行Scenario: 使用正确手机号、正确验证码注册\n9.关闭App,重启App\n10.执行Scenario: 使用错误手机号登录\n11.关闭App,重启App\n12.执行Scenario: 使用正确手机号登录\n13.卸载并重新安装App\n14.执行Feature: Health 测试\n15.启动App\n16.执行Scenario: 登录\n17.关闭App,重启App\n18.执行Scenario: 使用错误健康证号码上传\n19.关闭App,重启App\n20.执行Scenario: 使用正确健康证号码上传\n21.关闭App\n```\n\n基本上Calabash大的框框就是这样，所以我们在设计编写测试用例时，要按照这个框框来做。考虑什么情况分Feature,什么情况分Scenario，什么情况不能分，需要整体一大串的往下写。\n\n然后是Given、When、Then三个关键字，其实我并没有太搞明白他们之间的区别，似乎只是在概念上做了区分，实际的使用中并没有什么明显的区别，以我暂时的理解就是：在写法上，你用Then和用When都可以执行。只是理解上有区别。\n\n下面是Cucumber给出的定义：\n\n*  Feature（功能）— test suite （测试用例集）\n*  Scenario（情景） — test case （测试用例）\n*  Given（给定）— setup（创建测试所需环境）\n*  When（当）— test（触发被测事件）\n*  Then（则）— assert(断言，验证结果)\n\n虽然Then是用来验证结果的，但当When无法执行时，也会报错。我有怀疑过他们的超时时间不同，但经测试发现，他们超时时间也是一样的。这个还待深究……\n虽然暂时认为他们在使用上是一样的，但我还是建议你在编写测试用例时，**按照上面的区分进行编写，毕竟测试脚本还是需要有很强可读性的，你可以用对应关键字来区分哪些步骤是需要测试验证的重点。**\n\n\n## Calabash 预定义的Steps使用\n\n我只能说，Calabash最全的文档，除了安装步骤以外就是这套预定义的Steps了，虽然这个最全的指令也写的不那么友好。 [轻戳跳转到Calabash 预定义Steps](https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md)\n\n简单解释一下，看懂一两条基本上其他照着下面的说明看，用起来就没问题了。\n\n\tThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n\n以这个Step为例。\n我忍不住要吐槽了，首先要承认我正则表达式接触的很少，为了这个我还去恶补了一下，因为第一次看到上面这个我都不知道怎么用，/^是啥？要不要写上去？  那个 do 要不要加上？ 后面|text, index|看着应该是参数名，要不要也上去？ 好烦好烦~\n\n好了吐槽结束，开讲：\n\n正确的使用方法是： `` Then I enter \"你好世界\" into input field number 1``\n其含义是在第一个输入框里输入 你好世界。\n这里的1是指当前界面第一个输入框，至于为什么不像是数组一样，是从0开始的问题，我们在下一节讲**自定义Steps**时，会分析这条Steps的源码，到时候你就明白了。\n\n文档给出的写法实际是Step的定义写法，前面Then是关键字，我们不管它，所以 /^ $/  do |text, index| 通通都是定义语法，在使用中都是不用写上去的。这个等我们看到后面自定义Steps时就能理解了。\n中间\"([^\\\"]*)\"  (\\d+) 这两个就很简单了，就是两个正则表达式参数，正则所修饰的就是该参数所能接收的类型。\n\n## 自定义Steps\n\n这一章我们暂只聊Calabash三种自定义Steps中的两种，第三种放到下一章进阶中讲。\n\n### 自定义Steps\n\nCalabash提供的预定义Steps很明显不够用的嘛，那么就需要我们自己进行扩展。怎么扩展呢？\n\n在step_definitions文件夹下新建一个文件：first_steps.rb,然后进行修改：（这里我偷个懒，直接拿Calabash源码用来讲自定义方法）\n\n```\nThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n```\n\nThen是前面的修饰符，这个没啥好说的\n/^ $/ 成对出现，用来表示Steps方法名的开始和结尾\n中间内容理解为方法名，随便写。可以在任意位置插入参数，参数用正在表达式表示\n$/一个空格后 加关键字 do 开始定义方法体\n如果有参数便按照|text, index| 格式添加参数，参数数目要和前面对应上，否则会报错\n换行后就是真正的方法体，``enter_text()`` 是Calabash基于Ruby编写的库方法。关于这些方法的文档我还没有找到，初期，你可以对照Calabash预定义的Steps源码找到可用的ruby库方法。\n最后以end结尾。\nsteps定义结束。\n\n哦，还要解释一下上一节我们提到的：**为什么这条指令的这里的1是指当前界面第一个输入框，而不像是数组一样，是从0开始的问题。**\n\n看下面的定义 ``enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)``\n**{index.to_i-1}** 这里传参中，做了一个减1的操作，calabash在实际的处理上，还是从0开始的，但是Calabash为了最大程度保证语义的自然程度，做了这样的修改，（在自然语言中，我们从头数的话，说的都是第一个，而不是第零个）这也是我们在自定义指令时可以借鉴的一个地方。\n\n为什么说Calabash学起来很简单呢？因为他的语法简单，你完全可以照猫画虎的学。你可以在这个目录下\n`` ./Library/Ruby/Gems/2.0.0/gems/calabash-android-0.9.0/lib/calabash-android/steps``\n\n找到Calabash预定义的Steps源码，通过对比源码来学习Steps的使用和自定义，同时寻找可用的ruby库方法。\n\n可以先看一下enter_text_steps.rb文件下的内容：\n\n```\nThen /^I enter \"([^\\\"]*)\" as \"([^\\\"]*)\"$/ do |text, content_description|\n  enter_text(\"android.widget.EditText {contentDescription LIKE[c] '#{content_description}'}\", text)\nend\n\nThen /^I enter \"([^\\\"]*)\" into \"([^\\\"]*)\"$/ do |text, content_description|\n  enter_text(\"android.widget.EditText {contentDescription LIKE[c] '#{content_description}'}\", text)\nend\n\nThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n\nThen /^I enter text \"([^\\\"]*)\" into field with id \"([^\\\"]*)\"$/ do |text, id|\n  enter_text(\"android.widget.EditText id:'#{id}'\", text)\nend\n\nThen /^I clear \"([^\\\"]*)\"$/ do |identifier|\n  clear_text_in(\"android.widget.EditText marked:'#{identifier}'}\")\nend\n\nThen /^I clear input field number (\\d+)$/ do |index|\n  clear_text_in(\"android.widget.EditText index:#{index.to_i-1}\")\nend\n\nThen /^I clear input field with id \"([^\\\"]*)\"$/ do |id|\n  clear_text_in(\"android.widget.EditText id:'#{id}'\")\nend\n```\n\n大概就长这样，稍微有点编程基础的，照猫画虎没啥问题。\n\n### 封装以定义的Steps\n\n以上面我们看到的health.feature为例，我只写了两个场景，因为细分的边界case会很多，所以实际过程中我可能要写很多个场景，那么每一个场景 进入到健康证上传页面这个步骤都是一模一样的，难道我要复制粘贴这么多下么？ 不不~，一个有追求的程序猿是百分百拒绝复制粘贴的！那么我就要把进入健康证上传页面这些个步骤封装起来变成一个命令，用起来省事，修改也简单！\n\n需要说一下的是，如果你用上面自定义Steps的方法直接在方法体中写自定义Steps的话，是不可行的，就像这样：\n\n```\nThen /^I through welcomePages$/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n上面的代码是无法执行的。想要封装已定义的Steps你需要这样做：\n\n```\nThen /^I through welcomePages with (\\d+) steps$/ do |steps|\n\tsteps %{\n    \tThen I drag from 90:50 to 20:50 moving with #{steps} steps\n        Then I drag from 90:50 to 20:50 moving with #{steps} steps\n        Then I drag from 90:50 to 20:50 moving with #{steps} steps\n\t}\nend\n```\n\n``%{}`` 是ruby中表示多行字符串的格式，一对大括号之间的所有换行符和空格符都会原原本本的输出。\n\n如果需要再``%{}`` 内部使用参数，直接写参数名是不会被识别的，需要使用``#{}``包裹。\n\n在自定义Steps时，你可能会遇到**坑5：Calabash自定义的Steps,执行过程中提示未定义**\n\n## 使用Ruby语法编写带逻辑判断的Steps\n\n上面只是介绍了Steps的自定义方法，简单的对原有库方法或命令进行封装，修改方面名或参数值。扩展的能力有限，Calabash当然不会如此的初级，.rb是Ruby文件，所以这里使用的都是Ruby语法，你也当然可以通过Ruby语法为你的Steps添加各种逻辑。\n\n**Steps的定义不只是已有库方法和以后Steps的封装，他的内部定义同样可以非常丰富。**\n\n例如上一节我们封装的三行左划命令，如果我想增加一个扩展，通过传入的参数来控制左划的次数：\n\n```\nThen /^I drag toLeft (\\d+) times$/ do |times|\n\t$num = times.to_i\n\twhile $num > 0 do\n\t\tperform_action('drag', 90, 20, 50, 50, 20) \n\t\t$num = $num-1\n\tend\n    puts \"循环结束\"\nend\n```\n即使你没有接触过Ruby，但是这个代码也应该可以大致看懂。\n``$num`` 是Ruby定义变量的方法。\n``times.to_i`` 是Ruby提供的类型转换函数\n\n```\nwhile conditional [do]\n   code\nend\n```\n是Ruby的循环语法。\n\n前面一章我们还提到除了feature中编写的注释可以在执行中输出以外，你还可以使用ruby的输出语句``puts \"\"``来输出一些提示性语句。\n\nRuby的语法真的非常简单，这里再次推荐[Ruby的学习网站](http://www.runoob.com/ruby/ruby-loop.html)。\n\n## 自定义Steps的使用策略\n\n自定义Steps是Calabash测试脚本的基石，就像砖块一样，只有齐整的砖块盖起房子来才会更容易，所以为了保证后期脚本维护的方便，以及让测试脚本的编写变得越来越轻松容易，接纳更多的人员参与，应该建立一套Steps规范，并建立一个Steps文档。\n\n下面是我的建议：\n\n### 与业务完全解耦的自定义Steps：\n该种类型应该像Calabash预定义的Steps一样，完全与业务解耦，只是不同类型的动作及检查，开放有更多的参数，有很好的灵活性，复用性很强。同时**每一个新建的Steps都要加入Steps库中，一直累加，禁止或尽量避免对原有Steps进行修改。对于这样的库我们称为：Steps库**\n这类型自定义Steps更多的是使用Ruby函数库定义的Step,因为使用Ruby函数库定义的Step需要设计到很多Ruby语言，增加了学习树，所以这类型Steps应该保持更高的稳定性。\n\n**未来的展望：** 中期Calabash测试脚本的开发将分为两个梯队，一个是Steps的开发，一个是测试用例开发，测试用例开发不需要对Calabash有过深入的了解，只需要对照着Steps文档即可编写测试脚本。如果需要新的Steps,就像Steps开发提需求即可。\n到后期Steps库逐步完善，可能很久才会有新的Steps需求，那么这个时候Calabash自动化测试脚本就真的是谁都可以编写的了，BDD将不再是乌邦托。\n\n此类型的Steps建议以 `` *_steps.rb`` 格式建立文件。\n\n### 与业务耦合的自定义Steps:\n为了保证Steps复用，不写大量重复代码，一些经常被使用、稳定性较高的操作应该封装起来作为一个Steps语句进行使用。\n例如每次重新安装App后，都需要左划三次跳过欢迎界面，那么这样的操作，我们应该封装起来作为一个Step。\n我们将这样的Steps库称为：Enca库\n\n毕竟与业务耦合，所以变动的可能性非常大，管理难度同样会跟着上升。\n同一个Enca Steps可能在很多个场景中使用，如果因某个场景变更，而需要修改这个Steps的话，很容易导致其他场景出错，但像Steps库一样有变更就单纯累加Steps的方式显然也不明智，会导致后期Enca库存在大量以废弃但又不敢删除的Steps。\n所以Enca库中Steps的设计原则应该高度耦合于固定的界面，每一个Step都应对应且只对应一个页面的一个操作，即使两个页面的某个操作高度类似，也应该编写两个Steps，保证在某个页面逻辑修改时不会因为这样的耦合关系而影响其他页面。\n\n### 合适的语法糖\n\n自然语言很强的可读性副带的缺点便是记忆与编写速度的下降，过于松散的语法结构将会对脚本编写带来很大的困扰，所以你需要自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。可能说的不太明白，举个例子吧\n\n\t#我跳过欢迎界面\n\tThen I skip welcome page\n    #我完成登录操作\n\tThen I have finished the login\n\n上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：\n\n\n\t#我跳过欢迎界面\n\tThen I pass \"welcome\" scenario\n    #我完成登录操作\n\tThen I pass \"login\" scenario\n\n两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。\n\n如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？\n\n### 严格的文档管理\n\n无论是Stepks库还是Enca库，一定要建立完善的API文档，每一个入库的Steps一定要在文档中记录。添加新的Steps时需要现在Steps文档中查看是否已存在同样的Steps。\n\n## Ruby Query的使用。\n\n编写Calabash测试脚本，最大的难题在于定位到对应的元素。虽然预定的Steps中提供了通过文字、ID、Index的方式定位元素，但真实情况往往更加复杂。单纯通过肉眼的话，文字匹配对于图标无能为力，很多控件没有ID，也有很多控件你并不能很好的判断其类型，和其Index。\n\n元素定位很困难，但我们可以通过Ruby Query等命令帮助我们编写测试用例。\n\n首先第一步在终端中执行命令：``calabash-android console **.apk  ``\n\n接下来会进入calabash命令行，提示符变为了 irb(main):001:0>\n\n如果app未安装，先执行 ``reinstall_apps``\n已安装直接执行 ``start_test_server_in_background ``\n\n下面，先执行一个最简单的Query命令 ``query(\"*\")  `` 返回该页面所有view元素\n\n```\nirb(main):021:0> query(\"*\")\n[\n    [ 0] {\n                     \"class\" => \"com.android.internal.policy.impl.PhoneWindow$DecorView\",\n                       \"tag\" => nil,\n               \"description\" => \"com.android.internal.policy.impl.PhoneWindow$DecorView{ebb9e78 V.E..... R....... 0,0-1080,1920}\",\n                        \"id\" => nil,\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 1920,\n               \"width\" => 1080,\n                   \"y\" => 0,\n                   \"x\" => 0,\n            \"center_x\" => 540,\n            \"center_y\" => 960\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [ 1] {\n                     \"class\" => \"android.widget.LinearLayout\",\n                       \"tag\" => nil,\n               \"description\" => \"android.widget.LinearLayout{27f6d6c3 V.E..... ........ 0,0-1080,1920}\",\n                        \"id\" => nil,\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 1920,\n               \"width\" => 1080,\n                   \"y\" => 0,\n                   \"x\" => 0,\n            \"center_x\" => 540,\n            \"center_y\" => 960\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [ 2] {\n           \n    \n    ...\n    \n    [38] {\n                     \"class\" => \"me.ele.crowdsource.components.RedPacketView\",\n                       \"tag\" => nil,\n               \"description\" => \"me.ele.crowdsource.components.RedPacketView{1df1f92a V.ED..C. ........ 880,1531-1080,1710 #7f0d02e1 app:id/red_packet_view}\",\n                        \"id\" => \"red_packet_view\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 179,\n               \"width\" => 200,\n                   \"y\" => 1531,\n                   \"x\" => 880,\n            \"center_x\" => 980,\n            \"center_y\" => 1620\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    }\n]\n```\n\n返回数据是数组格式。里面的index,class，id都是编写测试用例的重要依据。\n\n查找某一类型的控件。 ``query(\"android.support.v7.widget.AppCompatEditText\")`` 我们查到2个EditText。\n```\nirb(main):025:0> query(\"android.support.v7.widget.AppCompatEditText\")\n[\n    [0] {\n                     \"class\" => \"android.support.v7.widget.AppCompatEditText\",\n                       \"tag\" => nil,\n               \"description\" => \"android.support.v7.widget.AppCompatEditText{1006278d VFED..CL ........ 45,0-720,153 #7f0d02cf app:id/phone_verify_sheet_phone_number}\",\n                        \"id\" => \"phone_verify_sheet_phone_number\",\n                      \"text\" => \"\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 153,\n               \"width\" => 675,\n                   \"y\" => 666,\n                   \"x\" => 90,\n            \"center_x\" => 427,\n            \"center_y\" => 742\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [1] {\n                     \"class\" => \"android.support.v7.widget.AppCompatEditText\",\n                       \"tag\" => nil,\n               \"description\" => \"android.support.v7.widget.AppCompatEditText{1042aa90 VFED..CL ........ 0,155-990,308 #7f0d02d2 app:id/phone_verify_sheet_verifying_code}\",\n                        \"id\" => \"phone_verify_sheet_verifying_code\",\n                      \"text\" => \"\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 153,\n               \"width\" => 990,\n                   \"y\" => 821,\n                   \"x\" => 45,\n            \"center_x\" => 540,\n            \"center_y\" => 897\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    }\n]\n```\n\n假设这两个输入框都没有id，也没有文字可以匹配，你可以使用它们的下标进行定位。比如我要对下标为1的输入框进行输入，使用上面我们两次提到的Step: ``Then I enter 输入密码 into input field number 2`` \n下标为1的输入框在自然语言中是指第二个输入框，上面我们也分析了这条Step的源码，对传入的参数做了减1操作，所以这里传入2。\n\n当然我们同样可以执行这样的命令\n\n```\n查询id等于phone_verify_sheet_verifying_code的ImageView\nirb(main):018:0> query(\"android.widget.ImageView id:'img1'\")  \n\n其他一些属性均可\nquery(\"* visible:true\")  \n```\n\n同时你还可以指定返回的结果``query(\"*\", :id)``\n```\nirb(main):031:0> query(\"*\", :id)\n[\n    [ 0] nil,\n    [ 1] nil,\n    [ 2] nil,\n    [ 3] \"action_bar_root\",\n    [ 4] \"content\",\n    [ 5] nil,\n    [ 6] \"login_login_text\",\n    [ 7] \"login_logo\",\n    [ 8] \"login_sheet\",\n    [ 9] nil,\n    [10] \"phone_verify_sheet_phone_number\",\n    [11] \"phone_verify_sheet_send_code\",\n    [12] \"phone_verify_sheet_divider\",\n    [13] \"phone_verify_sheet_verifying_code\",\n    [14] \"login_login\",\n    [15] \"login_audio\",\n    [16] \"login_register\",\n    [17] \"statusBarBackground\"\n]\n```\n\n上面我们简单的使用了Quewy查询，更详细的介绍可以参考下面两篇文章：\n\n[https://github.com/calabash/calabash-android/wiki/05-Query-Syntax](https://github.com/calabash/calabash-android/wiki/05-Query-Syntax)\n[http://blog.csdn.net/bigconvience/article/details/39182161](http://blog.csdn.net/bigconvience/article/details/39182161)\n\n\n## View定位技巧\n\nCalabash定位的主要方式有三种：文字、id、index。\n\n文字是最简单的一种定位方式，但也有缺点，那就是文字的非唯一性。\n以Step:``Then /^I press \"([^\\\"]*)\"$/ do |identifier|`` 为例，当一个界面同时存在两个以上的目标文字时，按照这条命令的定义，Calabash会默认点击第一个符合条件的view。如果你想要可以选择下标的Step，就需要自定义了。\n同时，如果有些纯图标的View，文字定位就无用了。\n\nId虽然是唯一性的，但同样缺陷明显：1.有很多View没有ID,这个我们在上一节Query语句的结果中就可以看到了，这种情况不止存在于根布局，很多需要操作的View都存在这样的问题！\n2.如果id的定义并不人性化，那么同样会导致脚本的可读性下降。\n3.debug包和混淆过的release包ID往往不同，因为ID名也被混淆了，所以Debug包和relase包无法同用一套脚本。\n\nView下标是指：把当前页面的所有View当做一个数组，每一个View都有一个下标。通常这种排列都有迹可循，比如从上到下，从左到右，从深到浅。如果布局非常复杂，可以借助Query语句查询。\n\n基本原理知道了，从这几个方面找方法就很容易了。\n\n### 肉眼\n\nCalabash最大的魅力在于其自然语言一样的脚本，如果可以，我还是建议尽量使用肉眼识别文字与下标的方式进行编写Calabash脚本，点击登录按钮，在第2个输入框中输入XXX，通过这样的方式保持测试脚本的自然性。毕竟奇奇怪怪的ID和奇奇怪怪的下标，尤其混淆以后的ID，和下标上升到十几位数以后，比如下面这种尴尬：\n\n```\nWhen I press view with id \"c2\"\nThen I enter \"1\" into input field number 13\n```\nc2是什么鬼，第13个输入框？？？\n\n但毕竟人力有穷尽，很多view的定位并不是很容易。这只是建议。\n\n### Android uiautomatorviewer\n\nuiautomatorviewer工具位于Android SDK目录下,在终端中切换到Android SDK的目录下，在tools目录下可以看到uiautomatorviewer工具，运行./uiautomatorviewer就可以打开uiautomatorviewer了。\n\n连接手机，打开要查看的页面，点击uiautomatorviewer左上角第二个按钮（Device Screenshot(uiautomator dump)），将会在屏幕上出现该页面，并在右上角的窗口中显示该页面的层级结构，点击页面上的View元素，会在右下角Node Detail窗口中出现该View的基本信息，包括ID，文字等等信息。\n\n![uiautomatorviewer](Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg)\n\nuiautomatorviewer的优点在于可以在不查看代码的情况下知道View的ID。对比Query查询，其优点在于更加直观，且不需要任何编程基础。毕竟Query是以数组形式返回，如果一个页面View特别多的话，将数组中的View与页面的View做对应是很麻烦的。\n\n**需要提醒的是：这里的index和我们用Query查到的数组下标并不是一回事，所以这里的index不可用**\n\n### Query\n\nuiautomatorviewer虽然可以看到View的ID，但没有办法看到View的下标。Query的查询更加精确一点但不够直观。\n\n所以最好的办法应该是肉眼、uiautomatorviewer、Query三者结合。当然前期可能会显得比较繁琐，但熟练了之后就会很简单了。\n\n### 不定位了，找不到，直接点击屏幕吧\n\n正常来说，所有的View都是可以定位到的，只是难易程度罢了，如果你要操作的View真的特别特别难以定位，直接点击屏幕也是办法。\n\n调用下面这条预定义Step即可\n\n```\nThen /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|     \n\nuse:\nThen I click on screen 23% from the left and 34% from the top     \n```\n这里非常非常要注意的是，这条命令后面的``%``不可以省略，他是按照当前屏幕的百分比位置来点击的。\n\n但无论通过uiautomatorviewer还是Query命令，你都只能查到View的像素坐标，暂时还没有发现好的工具来查询百分比坐标。不过你可以使用像素坐标除以当前手机分辨率来计算百分比坐标。\n看到这里，你也许会想，我根本不需要手动计算，直接把计算写在脚本里不就好了嘛：\n\n```\nThen /^I click login button $/ do \n  %{\n  \tThen I click on screen 1323 from the left and 568 from the top for 1920x1080\n  }\nend\n\nThen /^I click on screen (\\d+) from the left and (\\d+) from the top for 1920x1080$/ do |x, y|\n  perform_action('click_on_screen', x/1080, y/1920)\nend\n```\n\n但我并不建议你这样去做，上面的自定义Step只适用于1920x1080的手机，在实际测试中，一定会涉及到替换不同手机跑case的，换一个手机就修改一下脚本明显不适用，尤其发展到云测阶段。这也是为什么预定义的Steps只提供了百分比坐标的点击事件。\n\n\n## 总结\n\n基本上了解上面的内容，就已经可以开始编写Calabash测试脚本进行测试了。当然Calabash还不止这些，我们将在下一章进阶中继续为你介绍Calabash使用技巧：\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n</br>\n \n------\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n《Calabash探索2-Calabash用法详解》\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Calabash探索2-Calabash用法详解.md","raw":"\n---\ntitle: Calabash探索2-Calabash用法详解\ndate: 2017-3-18 16:20:58\nauthor : 暴打小女孩\n\ntags: 测试\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n上一篇Calabash Run起来以后，如果你立刻在自己的项目上进行尝试，我相信你一定会像我之前一样，一头雾水，那么从这篇开始，我们来对Calabash深挖。 大概从这几个方向开始：\n\n- Feature、Scenario等关键字使用策略。\n- Calabash预定义Steps的使用。\n- 自定义Steps。\n- 使用Ruby语法编写带逻辑判断的Steps。\n- 自定义Steps的使用策略。\n- Ruby Query的使用。\n\n<!-- more -->\n\n## Feature、Scenario等关键字使用策略\n\n主要的关键字如下Feature、Scenario、Given、When、Then。前面我们也说了，其实这几个关键字实际是Cucumber体系下的，如果你想更进一步的了解，请查询[Cucumber相关资料](https://github.com/cucumber/cucumber)。\n我们重点讲Feature、Scenario两个。\n\n一个.feature文件只能含有一个Feature，以此作为一个测试用例集，一个测试用例集（Feature）可以包含多个场景（Scenario）。\n\n在不指定具体的.feature文件及其顺序的情况下，Calabash会遍历features根目录下的所有Feature按随机顺序执行。\n每执行一个Feature都会卸载重新安装App，而执行Scenario则不会重新卸载安装App，而是重新启动。\n\n举例我有以下两个文件：\n\n*login.feature* ： 测试登录和注册两个业务\n\n```\nFeature: Login 测试\n\n\tScenario: 使用无效手机号注册\n\n\t\tThen I...\n    \t...\n    \n\tScenario: 使用正确手机号、无效验证码注册\n  \n\t\tThen I...\n\t\t...\n    \n\tScenario: 使用正确手机号、正确验证码注册\n   \n        Then I...\n        ...\n\t\n    Scenario: 使用错误手机号登录\n   \n        Then I...\n        ...\n    Scenario: 使用正确手机号登录\n   \n        Then I...\n        ...\n\t\n```\n\n*health.feature* ： 测试上传健康证业务\n\n```\nFeature: Health 测试\n\n\tScenario: 登录\n\n\t\tThen I...\n    \t...\n    \n\tScenario: 使用错误健康证号码上传\n  \n\t\tThen I...\n\t\t...\n    \n\tScenario: 使用正确健康证号码上传\n   \n        Then I...\n        ...\n\t\n```\n\n**切记：在设计时，每个Feature都应该是完全独立，他们之间不能有任何耦合（App都卸载了，你互相依赖还有啥用）**\n因为每个Feature都是独立的，所以完全不必在意他们的执行顺序。\n\n使用命令 ``calabash-android run test.apk`` 执行时，Calabash会遍历features主目录下所有的.feature文件进行执行。\n当你只想执行某一个或某几个Feature时，直接在该命令后加Feature文件路径即可\n\n```\ncalabash-android run test.apk ./login.feature ./health.feature\n\n```\n值的一提的是，当你指定执行哪些Feature时,Calabash会按照你指定的顺序进行执行。\n    \n那么当我执行``calabash-android run test.apk`` 会发生什么呢？\n\n```\n1.安装App\n2.执行Feature: Login 测试\n3.启动App\n4.执行Scenario: 使用无效手机号注册\n5.关闭App,重启App\n6.执行Scenario: 使用正确手机号、无效验证码注册\n7.关闭App,重启App\n8.执行Scenario: 使用正确手机号、正确验证码注册\n9.关闭App,重启App\n10.执行Scenario: 使用错误手机号登录\n11.关闭App,重启App\n12.执行Scenario: 使用正确手机号登录\n13.卸载并重新安装App\n14.执行Feature: Health 测试\n15.启动App\n16.执行Scenario: 登录\n17.关闭App,重启App\n18.执行Scenario: 使用错误健康证号码上传\n19.关闭App,重启App\n20.执行Scenario: 使用正确健康证号码上传\n21.关闭App\n```\n\n基本上Calabash大的框框就是这样，所以我们在设计编写测试用例时，要按照这个框框来做。考虑什么情况分Feature,什么情况分Scenario，什么情况不能分，需要整体一大串的往下写。\n\n然后是Given、When、Then三个关键字，其实我并没有太搞明白他们之间的区别，似乎只是在概念上做了区分，实际的使用中并没有什么明显的区别，以我暂时的理解就是：在写法上，你用Then和用When都可以执行。只是理解上有区别。\n\n下面是Cucumber给出的定义：\n\n*  Feature（功能）— test suite （测试用例集）\n*  Scenario（情景） — test case （测试用例）\n*  Given（给定）— setup（创建测试所需环境）\n*  When（当）— test（触发被测事件）\n*  Then（则）— assert(断言，验证结果)\n\n虽然Then是用来验证结果的，但当When无法执行时，也会报错。我有怀疑过他们的超时时间不同，但经测试发现，他们超时时间也是一样的。这个还待深究……\n虽然暂时认为他们在使用上是一样的，但我还是建议你在编写测试用例时，**按照上面的区分进行编写，毕竟测试脚本还是需要有很强可读性的，你可以用对应关键字来区分哪些步骤是需要测试验证的重点。**\n\n\n## Calabash 预定义的Steps使用\n\n我只能说，Calabash最全的文档，除了安装步骤以外就是这套预定义的Steps了，虽然这个最全的指令也写的不那么友好。 [轻戳跳转到Calabash 预定义Steps](https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md)\n\n简单解释一下，看懂一两条基本上其他照着下面的说明看，用起来就没问题了。\n\n\tThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n\n以这个Step为例。\n我忍不住要吐槽了，首先要承认我正则表达式接触的很少，为了这个我还去恶补了一下，因为第一次看到上面这个我都不知道怎么用，/^是啥？要不要写上去？  那个 do 要不要加上？ 后面|text, index|看着应该是参数名，要不要也上去？ 好烦好烦~\n\n好了吐槽结束，开讲：\n\n正确的使用方法是： `` Then I enter \"你好世界\" into input field number 1``\n其含义是在第一个输入框里输入 你好世界。\n这里的1是指当前界面第一个输入框，至于为什么不像是数组一样，是从0开始的问题，我们在下一节讲**自定义Steps**时，会分析这条Steps的源码，到时候你就明白了。\n\n文档给出的写法实际是Step的定义写法，前面Then是关键字，我们不管它，所以 /^ $/  do |text, index| 通通都是定义语法，在使用中都是不用写上去的。这个等我们看到后面自定义Steps时就能理解了。\n中间\"([^\\\"]*)\"  (\\d+) 这两个就很简单了，就是两个正则表达式参数，正则所修饰的就是该参数所能接收的类型。\n\n## 自定义Steps\n\n这一章我们暂只聊Calabash三种自定义Steps中的两种，第三种放到下一章进阶中讲。\n\n### 自定义Steps\n\nCalabash提供的预定义Steps很明显不够用的嘛，那么就需要我们自己进行扩展。怎么扩展呢？\n\n在step_definitions文件夹下新建一个文件：first_steps.rb,然后进行修改：（这里我偷个懒，直接拿Calabash源码用来讲自定义方法）\n\n```\nThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n```\n\nThen是前面的修饰符，这个没啥好说的\n/^ $/ 成对出现，用来表示Steps方法名的开始和结尾\n中间内容理解为方法名，随便写。可以在任意位置插入参数，参数用正在表达式表示\n$/一个空格后 加关键字 do 开始定义方法体\n如果有参数便按照|text, index| 格式添加参数，参数数目要和前面对应上，否则会报错\n换行后就是真正的方法体，``enter_text()`` 是Calabash基于Ruby编写的库方法。关于这些方法的文档我还没有找到，初期，你可以对照Calabash预定义的Steps源码找到可用的ruby库方法。\n最后以end结尾。\nsteps定义结束。\n\n哦，还要解释一下上一节我们提到的：**为什么这条指令的这里的1是指当前界面第一个输入框，而不像是数组一样，是从0开始的问题。**\n\n看下面的定义 ``enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)``\n**{index.to_i-1}** 这里传参中，做了一个减1的操作，calabash在实际的处理上，还是从0开始的，但是Calabash为了最大程度保证语义的自然程度，做了这样的修改，（在自然语言中，我们从头数的话，说的都是第一个，而不是第零个）这也是我们在自定义指令时可以借鉴的一个地方。\n\n为什么说Calabash学起来很简单呢？因为他的语法简单，你完全可以照猫画虎的学。你可以在这个目录下\n`` ./Library/Ruby/Gems/2.0.0/gems/calabash-android-0.9.0/lib/calabash-android/steps``\n\n找到Calabash预定义的Steps源码，通过对比源码来学习Steps的使用和自定义，同时寻找可用的ruby库方法。\n\n可以先看一下enter_text_steps.rb文件下的内容：\n\n```\nThen /^I enter \"([^\\\"]*)\" as \"([^\\\"]*)\"$/ do |text, content_description|\n  enter_text(\"android.widget.EditText {contentDescription LIKE[c] '#{content_description}'}\", text)\nend\n\nThen /^I enter \"([^\\\"]*)\" into \"([^\\\"]*)\"$/ do |text, content_description|\n  enter_text(\"android.widget.EditText {contentDescription LIKE[c] '#{content_description}'}\", text)\nend\n\nThen /^I enter \"([^\\\"]*)\" into input field number (\\d+)$/ do |text, index|\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n\nThen /^I enter text \"([^\\\"]*)\" into field with id \"([^\\\"]*)\"$/ do |text, id|\n  enter_text(\"android.widget.EditText id:'#{id}'\", text)\nend\n\nThen /^I clear \"([^\\\"]*)\"$/ do |identifier|\n  clear_text_in(\"android.widget.EditText marked:'#{identifier}'}\")\nend\n\nThen /^I clear input field number (\\d+)$/ do |index|\n  clear_text_in(\"android.widget.EditText index:#{index.to_i-1}\")\nend\n\nThen /^I clear input field with id \"([^\\\"]*)\"$/ do |id|\n  clear_text_in(\"android.widget.EditText id:'#{id}'\")\nend\n```\n\n大概就长这样，稍微有点编程基础的，照猫画虎没啥问题。\n\n### 封装以定义的Steps\n\n以上面我们看到的health.feature为例，我只写了两个场景，因为细分的边界case会很多，所以实际过程中我可能要写很多个场景，那么每一个场景 进入到健康证上传页面这个步骤都是一模一样的，难道我要复制粘贴这么多下么？ 不不~，一个有追求的程序猿是百分百拒绝复制粘贴的！那么我就要把进入健康证上传页面这些个步骤封装起来变成一个命令，用起来省事，修改也简单！\n\n需要说一下的是，如果你用上面自定义Steps的方法直接在方法体中写自定义Steps的话，是不可行的，就像这样：\n\n```\nThen /^I through welcomePages$/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n上面的代码是无法执行的。想要封装已定义的Steps你需要这样做：\n\n```\nThen /^I through welcomePages with (\\d+) steps$/ do |steps|\n\tsteps %{\n    \tThen I drag from 90:50 to 20:50 moving with #{steps} steps\n        Then I drag from 90:50 to 20:50 moving with #{steps} steps\n        Then I drag from 90:50 to 20:50 moving with #{steps} steps\n\t}\nend\n```\n\n``%{}`` 是ruby中表示多行字符串的格式，一对大括号之间的所有换行符和空格符都会原原本本的输出。\n\n如果需要再``%{}`` 内部使用参数，直接写参数名是不会被识别的，需要使用``#{}``包裹。\n\n在自定义Steps时，你可能会遇到**坑5：Calabash自定义的Steps,执行过程中提示未定义**\n\n## 使用Ruby语法编写带逻辑判断的Steps\n\n上面只是介绍了Steps的自定义方法，简单的对原有库方法或命令进行封装，修改方面名或参数值。扩展的能力有限，Calabash当然不会如此的初级，.rb是Ruby文件，所以这里使用的都是Ruby语法，你也当然可以通过Ruby语法为你的Steps添加各种逻辑。\n\n**Steps的定义不只是已有库方法和以后Steps的封装，他的内部定义同样可以非常丰富。**\n\n例如上一节我们封装的三行左划命令，如果我想增加一个扩展，通过传入的参数来控制左划的次数：\n\n```\nThen /^I drag toLeft (\\d+) times$/ do |times|\n\t$num = times.to_i\n\twhile $num > 0 do\n\t\tperform_action('drag', 90, 20, 50, 50, 20) \n\t\t$num = $num-1\n\tend\n    puts \"循环结束\"\nend\n```\n即使你没有接触过Ruby，但是这个代码也应该可以大致看懂。\n``$num`` 是Ruby定义变量的方法。\n``times.to_i`` 是Ruby提供的类型转换函数\n\n```\nwhile conditional [do]\n   code\nend\n```\n是Ruby的循环语法。\n\n前面一章我们还提到除了feature中编写的注释可以在执行中输出以外，你还可以使用ruby的输出语句``puts \"\"``来输出一些提示性语句。\n\nRuby的语法真的非常简单，这里再次推荐[Ruby的学习网站](http://www.runoob.com/ruby/ruby-loop.html)。\n\n## 自定义Steps的使用策略\n\n自定义Steps是Calabash测试脚本的基石，就像砖块一样，只有齐整的砖块盖起房子来才会更容易，所以为了保证后期脚本维护的方便，以及让测试脚本的编写变得越来越轻松容易，接纳更多的人员参与，应该建立一套Steps规范，并建立一个Steps文档。\n\n下面是我的建议：\n\n### 与业务完全解耦的自定义Steps：\n该种类型应该像Calabash预定义的Steps一样，完全与业务解耦，只是不同类型的动作及检查，开放有更多的参数，有很好的灵活性，复用性很强。同时**每一个新建的Steps都要加入Steps库中，一直累加，禁止或尽量避免对原有Steps进行修改。对于这样的库我们称为：Steps库**\n这类型自定义Steps更多的是使用Ruby函数库定义的Step,因为使用Ruby函数库定义的Step需要设计到很多Ruby语言，增加了学习树，所以这类型Steps应该保持更高的稳定性。\n\n**未来的展望：** 中期Calabash测试脚本的开发将分为两个梯队，一个是Steps的开发，一个是测试用例开发，测试用例开发不需要对Calabash有过深入的了解，只需要对照着Steps文档即可编写测试脚本。如果需要新的Steps,就像Steps开发提需求即可。\n到后期Steps库逐步完善，可能很久才会有新的Steps需求，那么这个时候Calabash自动化测试脚本就真的是谁都可以编写的了，BDD将不再是乌邦托。\n\n此类型的Steps建议以 `` *_steps.rb`` 格式建立文件。\n\n### 与业务耦合的自定义Steps:\n为了保证Steps复用，不写大量重复代码，一些经常被使用、稳定性较高的操作应该封装起来作为一个Steps语句进行使用。\n例如每次重新安装App后，都需要左划三次跳过欢迎界面，那么这样的操作，我们应该封装起来作为一个Step。\n我们将这样的Steps库称为：Enca库\n\n毕竟与业务耦合，所以变动的可能性非常大，管理难度同样会跟着上升。\n同一个Enca Steps可能在很多个场景中使用，如果因某个场景变更，而需要修改这个Steps的话，很容易导致其他场景出错，但像Steps库一样有变更就单纯累加Steps的方式显然也不明智，会导致后期Enca库存在大量以废弃但又不敢删除的Steps。\n所以Enca库中Steps的设计原则应该高度耦合于固定的界面，每一个Step都应对应且只对应一个页面的一个操作，即使两个页面的某个操作高度类似，也应该编写两个Steps，保证在某个页面逻辑修改时不会因为这样的耦合关系而影响其他页面。\n\n### 合适的语法糖\n\n自然语言很强的可读性副带的缺点便是记忆与编写速度的下降，过于松散的语法结构将会对脚本编写带来很大的困扰，所以你需要自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。可能说的不太明白，举个例子吧\n\n\t#我跳过欢迎界面\n\tThen I skip welcome page\n    #我完成登录操作\n\tThen I have finished the login\n\n上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：\n\n\n\t#我跳过欢迎界面\n\tThen I pass \"welcome\" scenario\n    #我完成登录操作\n\tThen I pass \"login\" scenario\n\n两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。\n\n如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？\n\n### 严格的文档管理\n\n无论是Stepks库还是Enca库，一定要建立完善的API文档，每一个入库的Steps一定要在文档中记录。添加新的Steps时需要现在Steps文档中查看是否已存在同样的Steps。\n\n## Ruby Query的使用。\n\n编写Calabash测试脚本，最大的难题在于定位到对应的元素。虽然预定的Steps中提供了通过文字、ID、Index的方式定位元素，但真实情况往往更加复杂。单纯通过肉眼的话，文字匹配对于图标无能为力，很多控件没有ID，也有很多控件你并不能很好的判断其类型，和其Index。\n\n元素定位很困难，但我们可以通过Ruby Query等命令帮助我们编写测试用例。\n\n首先第一步在终端中执行命令：``calabash-android console **.apk  ``\n\n接下来会进入calabash命令行，提示符变为了 irb(main):001:0>\n\n如果app未安装，先执行 ``reinstall_apps``\n已安装直接执行 ``start_test_server_in_background ``\n\n下面，先执行一个最简单的Query命令 ``query(\"*\")  `` 返回该页面所有view元素\n\n```\nirb(main):021:0> query(\"*\")\n[\n    [ 0] {\n                     \"class\" => \"com.android.internal.policy.impl.PhoneWindow$DecorView\",\n                       \"tag\" => nil,\n               \"description\" => \"com.android.internal.policy.impl.PhoneWindow$DecorView{ebb9e78 V.E..... R....... 0,0-1080,1920}\",\n                        \"id\" => nil,\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 1920,\n               \"width\" => 1080,\n                   \"y\" => 0,\n                   \"x\" => 0,\n            \"center_x\" => 540,\n            \"center_y\" => 960\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [ 1] {\n                     \"class\" => \"android.widget.LinearLayout\",\n                       \"tag\" => nil,\n               \"description\" => \"android.widget.LinearLayout{27f6d6c3 V.E..... ........ 0,0-1080,1920}\",\n                        \"id\" => nil,\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 1920,\n               \"width\" => 1080,\n                   \"y\" => 0,\n                   \"x\" => 0,\n            \"center_x\" => 540,\n            \"center_y\" => 960\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [ 2] {\n           \n    \n    ...\n    \n    [38] {\n                     \"class\" => \"me.ele.crowdsource.components.RedPacketView\",\n                       \"tag\" => nil,\n               \"description\" => \"me.ele.crowdsource.components.RedPacketView{1df1f92a V.ED..C. ........ 880,1531-1080,1710 #7f0d02e1 app:id/red_packet_view}\",\n                        \"id\" => \"red_packet_view\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 179,\n               \"width\" => 200,\n                   \"y\" => 1531,\n                   \"x\" => 880,\n            \"center_x\" => 980,\n            \"center_y\" => 1620\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    }\n]\n```\n\n返回数据是数组格式。里面的index,class，id都是编写测试用例的重要依据。\n\n查找某一类型的控件。 ``query(\"android.support.v7.widget.AppCompatEditText\")`` 我们查到2个EditText。\n```\nirb(main):025:0> query(\"android.support.v7.widget.AppCompatEditText\")\n[\n    [0] {\n                     \"class\" => \"android.support.v7.widget.AppCompatEditText\",\n                       \"tag\" => nil,\n               \"description\" => \"android.support.v7.widget.AppCompatEditText{1006278d VFED..CL ........ 45,0-720,153 #7f0d02cf app:id/phone_verify_sheet_phone_number}\",\n                        \"id\" => \"phone_verify_sheet_phone_number\",\n                      \"text\" => \"\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 153,\n               \"width\" => 675,\n                   \"y\" => 666,\n                   \"x\" => 90,\n            \"center_x\" => 427,\n            \"center_y\" => 742\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    },\n    [1] {\n                     \"class\" => \"android.support.v7.widget.AppCompatEditText\",\n                       \"tag\" => nil,\n               \"description\" => \"android.support.v7.widget.AppCompatEditText{1042aa90 VFED..CL ........ 0,155-990,308 #7f0d02d2 app:id/phone_verify_sheet_verifying_code}\",\n                        \"id\" => \"phone_verify_sheet_verifying_code\",\n                      \"text\" => \"\",\n                   \"visible\" => true,\n                      \"rect\" => {\n              \"height\" => 153,\n               \"width\" => 990,\n                   \"y\" => 821,\n                   \"x\" => 45,\n            \"center_x\" => 540,\n            \"center_y\" => 897\n        },\n                   \"enabled\" => true,\n        \"contentDescription\" => nil\n    }\n]\n```\n\n假设这两个输入框都没有id，也没有文字可以匹配，你可以使用它们的下标进行定位。比如我要对下标为1的输入框进行输入，使用上面我们两次提到的Step: ``Then I enter 输入密码 into input field number 2`` \n下标为1的输入框在自然语言中是指第二个输入框，上面我们也分析了这条Step的源码，对传入的参数做了减1操作，所以这里传入2。\n\n当然我们同样可以执行这样的命令\n\n```\n查询id等于phone_verify_sheet_verifying_code的ImageView\nirb(main):018:0> query(\"android.widget.ImageView id:'img1'\")  \n\n其他一些属性均可\nquery(\"* visible:true\")  \n```\n\n同时你还可以指定返回的结果``query(\"*\", :id)``\n```\nirb(main):031:0> query(\"*\", :id)\n[\n    [ 0] nil,\n    [ 1] nil,\n    [ 2] nil,\n    [ 3] \"action_bar_root\",\n    [ 4] \"content\",\n    [ 5] nil,\n    [ 6] \"login_login_text\",\n    [ 7] \"login_logo\",\n    [ 8] \"login_sheet\",\n    [ 9] nil,\n    [10] \"phone_verify_sheet_phone_number\",\n    [11] \"phone_verify_sheet_send_code\",\n    [12] \"phone_verify_sheet_divider\",\n    [13] \"phone_verify_sheet_verifying_code\",\n    [14] \"login_login\",\n    [15] \"login_audio\",\n    [16] \"login_register\",\n    [17] \"statusBarBackground\"\n]\n```\n\n上面我们简单的使用了Quewy查询，更详细的介绍可以参考下面两篇文章：\n\n[https://github.com/calabash/calabash-android/wiki/05-Query-Syntax](https://github.com/calabash/calabash-android/wiki/05-Query-Syntax)\n[http://blog.csdn.net/bigconvience/article/details/39182161](http://blog.csdn.net/bigconvience/article/details/39182161)\n\n\n## View定位技巧\n\nCalabash定位的主要方式有三种：文字、id、index。\n\n文字是最简单的一种定位方式，但也有缺点，那就是文字的非唯一性。\n以Step:``Then /^I press \"([^\\\"]*)\"$/ do |identifier|`` 为例，当一个界面同时存在两个以上的目标文字时，按照这条命令的定义，Calabash会默认点击第一个符合条件的view。如果你想要可以选择下标的Step，就需要自定义了。\n同时，如果有些纯图标的View，文字定位就无用了。\n\nId虽然是唯一性的，但同样缺陷明显：1.有很多View没有ID,这个我们在上一节Query语句的结果中就可以看到了，这种情况不止存在于根布局，很多需要操作的View都存在这样的问题！\n2.如果id的定义并不人性化，那么同样会导致脚本的可读性下降。\n3.debug包和混淆过的release包ID往往不同，因为ID名也被混淆了，所以Debug包和relase包无法同用一套脚本。\n\nView下标是指：把当前页面的所有View当做一个数组，每一个View都有一个下标。通常这种排列都有迹可循，比如从上到下，从左到右，从深到浅。如果布局非常复杂，可以借助Query语句查询。\n\n基本原理知道了，从这几个方面找方法就很容易了。\n\n### 肉眼\n\nCalabash最大的魅力在于其自然语言一样的脚本，如果可以，我还是建议尽量使用肉眼识别文字与下标的方式进行编写Calabash脚本，点击登录按钮，在第2个输入框中输入XXX，通过这样的方式保持测试脚本的自然性。毕竟奇奇怪怪的ID和奇奇怪怪的下标，尤其混淆以后的ID，和下标上升到十几位数以后，比如下面这种尴尬：\n\n```\nWhen I press view with id \"c2\"\nThen I enter \"1\" into input field number 13\n```\nc2是什么鬼，第13个输入框？？？\n\n但毕竟人力有穷尽，很多view的定位并不是很容易。这只是建议。\n\n### Android uiautomatorviewer\n\nuiautomatorviewer工具位于Android SDK目录下,在终端中切换到Android SDK的目录下，在tools目录下可以看到uiautomatorviewer工具，运行./uiautomatorviewer就可以打开uiautomatorviewer了。\n\n连接手机，打开要查看的页面，点击uiautomatorviewer左上角第二个按钮（Device Screenshot(uiautomator dump)），将会在屏幕上出现该页面，并在右上角的窗口中显示该页面的层级结构，点击页面上的View元素，会在右下角Node Detail窗口中出现该View的基本信息，包括ID，文字等等信息。\n\n![uiautomatorviewer](Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg)\n\nuiautomatorviewer的优点在于可以在不查看代码的情况下知道View的ID。对比Query查询，其优点在于更加直观，且不需要任何编程基础。毕竟Query是以数组形式返回，如果一个页面View特别多的话，将数组中的View与页面的View做对应是很麻烦的。\n\n**需要提醒的是：这里的index和我们用Query查到的数组下标并不是一回事，所以这里的index不可用**\n\n### Query\n\nuiautomatorviewer虽然可以看到View的ID，但没有办法看到View的下标。Query的查询更加精确一点但不够直观。\n\n所以最好的办法应该是肉眼、uiautomatorviewer、Query三者结合。当然前期可能会显得比较繁琐，但熟练了之后就会很简单了。\n\n### 不定位了，找不到，直接点击屏幕吧\n\n正常来说，所有的View都是可以定位到的，只是难易程度罢了，如果你要操作的View真的特别特别难以定位，直接点击屏幕也是办法。\n\n调用下面这条预定义Step即可\n\n```\nThen /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|     \n\nuse:\nThen I click on screen 23% from the left and 34% from the top     \n```\n这里非常非常要注意的是，这条命令后面的``%``不可以省略，他是按照当前屏幕的百分比位置来点击的。\n\n但无论通过uiautomatorviewer还是Query命令，你都只能查到View的像素坐标，暂时还没有发现好的工具来查询百分比坐标。不过你可以使用像素坐标除以当前手机分辨率来计算百分比坐标。\n看到这里，你也许会想，我根本不需要手动计算，直接把计算写在脚本里不就好了嘛：\n\n```\nThen /^I click login button $/ do \n  %{\n  \tThen I click on screen 1323 from the left and 568 from the top for 1920x1080\n  }\nend\n\nThen /^I click on screen (\\d+) from the left and (\\d+) from the top for 1920x1080$/ do |x, y|\n  perform_action('click_on_screen', x/1080, y/1920)\nend\n```\n\n但我并不建议你这样去做，上面的自定义Step只适用于1920x1080的手机，在实际测试中，一定会涉及到替换不同手机跑case的，换一个手机就修改一下脚本明显不适用，尤其发展到云测阶段。这也是为什么预定义的Steps只提供了百分比坐标的点击事件。\n\n\n## 总结\n\n基本上了解上面的内容，就已经可以开始编写Calabash测试脚本进行测试了。当然Calabash还不止这些，我们将在下一章进阶中继续为你介绍Calabash使用技巧：\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n</br>\n \n------\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n《Calabash探索2-Calabash用法详解》\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Calabash探索2-Calabash用法详解","published":1,"updated":"2019-01-02T02:09:31.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsop0004yo9sl7ymwydb","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇Calabash Run起来以后，如果你立刻在自己的项目上进行尝试，我相信你一定会像我之前一样，一头雾水，那么从这篇开始，我们来对Calabash深挖。 大概从这几个方向开始：</p>\n<ul>\n<li>Feature、Scenario等关键字使用策略。</li>\n<li>Calabash预定义Steps的使用。</li>\n<li>自定义Steps。</li>\n<li>使用Ruby语法编写带逻辑判断的Steps。</li>\n<li>自定义Steps的使用策略。</li>\n<li>Ruby Query的使用。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"Feature、Scenario等关键字使用策略\"><a href=\"#Feature、Scenario等关键字使用策略\" class=\"headerlink\" title=\"Feature、Scenario等关键字使用策略\"></a>Feature、Scenario等关键字使用策略</h2><p>主要的关键字如下Feature、Scenario、Given、When、Then。前面我们也说了，其实这几个关键字实际是Cucumber体系下的，如果你想更进一步的了解，请查询<a href=\"https://github.com/cucumber/cucumber\" target=\"_blank\" rel=\"noopener\">Cucumber相关资料</a>。<br>我们重点讲Feature、Scenario两个。</p>\n<p>一个.feature文件只能含有一个Feature，以此作为一个测试用例集，一个测试用例集（Feature）可以包含多个场景（Scenario）。</p>\n<p>在不指定具体的.feature文件及其顺序的情况下，Calabash会遍历features根目录下的所有Feature按随机顺序执行。<br>每执行一个Feature都会卸载重新安装App，而执行Scenario则不会重新卸载安装App，而是重新启动。</p>\n<p>举例我有以下两个文件：</p>\n<p><em>login.feature</em> ： 测试登录和注册两个业务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Login 测试</span><br><span class=\"line\"></span><br><span class=\"line\">\tScenario: 使用无效手机号注册</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确手机号、无效验证码注册</span><br><span class=\"line\">  </span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确手机号、正确验证码注册</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t</span><br><span class=\"line\">    Scenario: 使用错误手机号登录</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    Scenario: 使用正确手机号登录</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p><em>health.feature</em> ： 测试上传健康证业务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Health 测试</span><br><span class=\"line\"></span><br><span class=\"line\">\tScenario: 登录</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用错误健康证号码上传</span><br><span class=\"line\">  </span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确健康证号码上传</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p><strong>切记：在设计时，每个Feature都应该是完全独立，他们之间不能有任何耦合（App都卸载了，你互相依赖还有啥用）</strong><br>因为每个Feature都是独立的，所以完全不必在意他们的执行顺序。</p>\n<p>使用命令 <code>calabash-android run test.apk</code> 执行时，Calabash会遍历features主目录下所有的.feature文件进行执行。<br>当你只想执行某一个或某几个Feature时，直接在该命令后加Feature文件路径即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calabash-android run test.apk ./login.feature ./health.feature</span><br></pre></td></tr></table></figure>\n<p>值的一提的是，当你指定执行哪些Feature时,Calabash会按照你指定的顺序进行执行。</p>\n<p>那么当我执行<code>calabash-android run test.apk</code> 会发生什么呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.安装App</span><br><span class=\"line\">2.执行Feature: Login 测试</span><br><span class=\"line\">3.启动App</span><br><span class=\"line\">4.执行Scenario: 使用无效手机号注册</span><br><span class=\"line\">5.关闭App,重启App</span><br><span class=\"line\">6.执行Scenario: 使用正确手机号、无效验证码注册</span><br><span class=\"line\">7.关闭App,重启App</span><br><span class=\"line\">8.执行Scenario: 使用正确手机号、正确验证码注册</span><br><span class=\"line\">9.关闭App,重启App</span><br><span class=\"line\">10.执行Scenario: 使用错误手机号登录</span><br><span class=\"line\">11.关闭App,重启App</span><br><span class=\"line\">12.执行Scenario: 使用正确手机号登录</span><br><span class=\"line\">13.卸载并重新安装App</span><br><span class=\"line\">14.执行Feature: Health 测试</span><br><span class=\"line\">15.启动App</span><br><span class=\"line\">16.执行Scenario: 登录</span><br><span class=\"line\">17.关闭App,重启App</span><br><span class=\"line\">18.执行Scenario: 使用错误健康证号码上传</span><br><span class=\"line\">19.关闭App,重启App</span><br><span class=\"line\">20.执行Scenario: 使用正确健康证号码上传</span><br><span class=\"line\">21.关闭App</span><br></pre></td></tr></table></figure>\n<p>基本上Calabash大的框框就是这样，所以我们在设计编写测试用例时，要按照这个框框来做。考虑什么情况分Feature,什么情况分Scenario，什么情况不能分，需要整体一大串的往下写。</p>\n<p>然后是Given、When、Then三个关键字，其实我并没有太搞明白他们之间的区别，似乎只是在概念上做了区分，实际的使用中并没有什么明显的区别，以我暂时的理解就是：在写法上，你用Then和用When都可以执行。只是理解上有区别。</p>\n<p>下面是Cucumber给出的定义：</p>\n<ul>\n<li>Feature（功能）— test suite （测试用例集）</li>\n<li>Scenario（情景） — test case （测试用例）</li>\n<li>Given（给定）— setup（创建测试所需环境）</li>\n<li>When（当）— test（触发被测事件）</li>\n<li>Then（则）— assert(断言，验证结果)</li>\n</ul>\n<p>虽然Then是用来验证结果的，但当When无法执行时，也会报错。我有怀疑过他们的超时时间不同，但经测试发现，他们超时时间也是一样的。这个还待深究……<br>虽然暂时认为他们在使用上是一样的，但我还是建议你在编写测试用例时，<strong>按照上面的区分进行编写，毕竟测试脚本还是需要有很强可读性的，你可以用对应关键字来区分哪些步骤是需要测试验证的重点。</strong></p>\n<h2 id=\"Calabash-预定义的Steps使用\"><a href=\"#Calabash-预定义的Steps使用\" class=\"headerlink\" title=\"Calabash 预定义的Steps使用\"></a>Calabash 预定义的Steps使用</h2><p>我只能说，Calabash最全的文档，除了安装步骤以外就是这套预定义的Steps了，虽然这个最全的指令也写的不那么友好。 <a href=\"https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md\" target=\"_blank\" rel=\"noopener\">轻戳跳转到Calabash 预定义Steps</a></p>\n<p>简单解释一下，看懂一两条基本上其他照着下面的说明看，用起来就没问题了。</p>\n<pre><code>Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|\n</code></pre><p>以这个Step为例。<br>我忍不住要吐槽了，首先要承认我正则表达式接触的很少，为了这个我还去恶补了一下，因为第一次看到上面这个我都不知道怎么用，/^是啥？要不要写上去？  那个 do 要不要加上？ 后面|text, index|看着应该是参数名，要不要也上去？ 好烦好烦~</p>\n<p>好了吐槽结束，开讲：</p>\n<p>正确的使用方法是： <code>Then I enter &quot;你好世界&quot; into input field number 1</code><br>其含义是在第一个输入框里输入 你好世界。<br>这里的1是指当前界面第一个输入框，至于为什么不像是数组一样，是从0开始的问题，我们在下一节讲<strong>自定义Steps</strong>时，会分析这条Steps的源码，到时候你就明白了。</p>\n<p>文档给出的写法实际是Step的定义写法，前面Then是关键字，我们不管它，所以 /^ $/  do |text, index| 通通都是定义语法，在使用中都是不用写上去的。这个等我们看到后面自定义Steps时就能理解了。<br>中间”([^\\”]*)”  (\\d+) 这两个就很简单了，就是两个正则表达式参数，正则所修饰的就是该参数所能接收的类型。</p>\n<h2 id=\"自定义Steps\"><a href=\"#自定义Steps\" class=\"headerlink\" title=\"自定义Steps\"></a>自定义Steps</h2><p>这一章我们暂只聊Calabash三种自定义Steps中的两种，第三种放到下一章进阶中讲。</p>\n<h3 id=\"自定义Steps-1\"><a href=\"#自定义Steps-1\" class=\"headerlink\" title=\"自定义Steps\"></a>自定义Steps</h3><p>Calabash提供的预定义Steps很明显不够用的嘛，那么就需要我们自己进行扩展。怎么扩展呢？</p>\n<p>在step_definitions文件夹下新建一个文件：first_steps.rb,然后进行修改：（这里我偷个懒，直接拿Calabash源码用来讲自定义方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>Then是前面的修饰符，这个没啥好说的<br>/^ $/ 成对出现，用来表示Steps方法名的开始和结尾<br>中间内容理解为方法名，随便写。可以在任意位置插入参数，参数用正在表达式表示<br>$/一个空格后 加关键字 do 开始定义方法体<br>如果有参数便按照|text, index| 格式添加参数，参数数目要和前面对应上，否则会报错<br>换行后就是真正的方法体，<code>enter_text()</code> 是Calabash基于Ruby编写的库方法。关于这些方法的文档我还没有找到，初期，你可以对照Calabash预定义的Steps源码找到可用的ruby库方法。<br>最后以end结尾。<br>steps定义结束。</p>\n<p>哦，还要解释一下上一节我们提到的：<strong>为什么这条指令的这里的1是指当前界面第一个输入框，而不像是数组一样，是从0开始的问题。</strong></p>\n<p>看下面的定义 <code>enter_text(&quot;android.widget.EditText index:#{index.to_i-1}&quot;, text)</code><br><strong>{index.to_i-1}</strong> 这里传参中，做了一个减1的操作，calabash在实际的处理上，还是从0开始的，但是Calabash为了最大程度保证语义的自然程度，做了这样的修改，（在自然语言中，我们从头数的话，说的都是第一个，而不是第零个）这也是我们在自定义指令时可以借鉴的一个地方。</p>\n<p>为什么说Calabash学起来很简单呢？因为他的语法简单，你完全可以照猫画虎的学。你可以在这个目录下<br><code>./Library/Ruby/Gems/2.0.0/gems/calabash-android-0.9.0/lib/calabash-android/steps</code></p>\n<p>找到Calabash预定义的Steps源码，通过对比源码来学习Steps的使用和自定义，同时寻找可用的ruby库方法。</p>\n<p>可以先看一下enter_text_steps.rb文件下的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; as &quot;([^\\&quot;]*)&quot;$/ do |text, content_description|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText &#123;contentDescription LIKE[c] &apos;#&#123;content_description&#125;&apos;&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into &quot;([^\\&quot;]*)&quot;$/ do |text, content_description|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText &#123;contentDescription LIKE[c] &apos;#&#123;content_description&#125;&apos;&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter text &quot;([^\\&quot;]*)&quot; into field with id &quot;([^\\&quot;]*)&quot;$/ do |text, id|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText id:&apos;#&#123;id&#125;&apos;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear &quot;([^\\&quot;]*)&quot;$/ do |identifier|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText marked:&apos;#&#123;identifier&#125;&apos;&#125;&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear input field number (\\d+)$/ do |index|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear input field with id &quot;([^\\&quot;]*)&quot;$/ do |id|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText id:&apos;#&#123;id&#125;&apos;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>大概就长这样，稍微有点编程基础的，照猫画虎没啥问题。</p>\n<h3 id=\"封装以定义的Steps\"><a href=\"#封装以定义的Steps\" class=\"headerlink\" title=\"封装以定义的Steps\"></a>封装以定义的Steps</h3><p>以上面我们看到的health.feature为例，我只写了两个场景，因为细分的边界case会很多，所以实际过程中我可能要写很多个场景，那么每一个场景 进入到健康证上传页面这个步骤都是一模一样的，难道我要复制粘贴这么多下么？ 不不~，一个有追求的程序猿是百分百拒绝复制粘贴的！那么我就要把进入健康证上传页面这些个步骤封装起来变成一个命令，用起来省事，修改也简单！</p>\n<p>需要说一下的是，如果你用上面自定义Steps的方法直接在方法体中写自定义Steps的话，是不可行的，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>上面的代码是无法执行的。想要封装已定义的Steps你需要这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages with (\\d+) steps$/ do |steps|</span><br><span class=\"line\">\tsteps %&#123;</span><br><span class=\"line\">    \tThen I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">        Then I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">        Then I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><code>%{}</code> 是ruby中表示多行字符串的格式，一对大括号之间的所有换行符和空格符都会原原本本的输出。</p>\n<p>如果需要再<code>%{}</code> 内部使用参数，直接写参数名是不会被识别的，需要使用<code>#{}</code>包裹。</p>\n<p>在自定义Steps时，你可能会遇到<strong>坑5：Calabash自定义的Steps,执行过程中提示未定义</strong></p>\n<h2 id=\"使用Ruby语法编写带逻辑判断的Steps\"><a href=\"#使用Ruby语法编写带逻辑判断的Steps\" class=\"headerlink\" title=\"使用Ruby语法编写带逻辑判断的Steps\"></a>使用Ruby语法编写带逻辑判断的Steps</h2><p>上面只是介绍了Steps的自定义方法，简单的对原有库方法或命令进行封装，修改方面名或参数值。扩展的能力有限，Calabash当然不会如此的初级，.rb是Ruby文件，所以这里使用的都是Ruby语法，你也当然可以通过Ruby语法为你的Steps添加各种逻辑。</p>\n<p><strong>Steps的定义不只是已有库方法和以后Steps的封装，他的内部定义同样可以非常丰富。</strong></p>\n<p>例如上一节我们封装的三行左划命令，如果我想增加一个扩展，通过传入的参数来控制左划的次数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I drag toLeft (\\d+) times$/ do |times|</span><br><span class=\"line\">\t$num = times.to_i</span><br><span class=\"line\">\twhile $num &gt; 0 do</span><br><span class=\"line\">\t\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\t\t$num = $num-1</span><br><span class=\"line\">\tend</span><br><span class=\"line\">    puts &quot;循环结束&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>即使你没有接触过Ruby，但是这个代码也应该可以大致看懂。<br><code>$num</code> 是Ruby定义变量的方法。<br><code>times.to_i</code> 是Ruby提供的类型转换函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while conditional [do]</span><br><span class=\"line\">   code</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>是Ruby的循环语法。</p>\n<p>前面一章我们还提到除了feature中编写的注释可以在执行中输出以外，你还可以使用ruby的输出语句<code>puts &quot;&quot;</code>来输出一些提示性语句。</p>\n<p>Ruby的语法真的非常简单，这里再次推荐<a href=\"http://www.runoob.com/ruby/ruby-loop.html\" target=\"_blank\" rel=\"noopener\">Ruby的学习网站</a>。</p>\n<h2 id=\"自定义Steps的使用策略\"><a href=\"#自定义Steps的使用策略\" class=\"headerlink\" title=\"自定义Steps的使用策略\"></a>自定义Steps的使用策略</h2><p>自定义Steps是Calabash测试脚本的基石，就像砖块一样，只有齐整的砖块盖起房子来才会更容易，所以为了保证后期脚本维护的方便，以及让测试脚本的编写变得越来越轻松容易，接纳更多的人员参与，应该建立一套Steps规范，并建立一个Steps文档。</p>\n<p>下面是我的建议：</p>\n<h3 id=\"与业务完全解耦的自定义Steps：\"><a href=\"#与业务完全解耦的自定义Steps：\" class=\"headerlink\" title=\"与业务完全解耦的自定义Steps：\"></a>与业务完全解耦的自定义Steps：</h3><p>该种类型应该像Calabash预定义的Steps一样，完全与业务解耦，只是不同类型的动作及检查，开放有更多的参数，有很好的灵活性，复用性很强。同时<strong>每一个新建的Steps都要加入Steps库中，一直累加，禁止或尽量避免对原有Steps进行修改。对于这样的库我们称为：Steps库</strong><br>这类型自定义Steps更多的是使用Ruby函数库定义的Step,因为使用Ruby函数库定义的Step需要设计到很多Ruby语言，增加了学习树，所以这类型Steps应该保持更高的稳定性。</p>\n<p><strong>未来的展望：</strong> 中期Calabash测试脚本的开发将分为两个梯队，一个是Steps的开发，一个是测试用例开发，测试用例开发不需要对Calabash有过深入的了解，只需要对照着Steps文档即可编写测试脚本。如果需要新的Steps,就像Steps开发提需求即可。<br>到后期Steps库逐步完善，可能很久才会有新的Steps需求，那么这个时候Calabash自动化测试脚本就真的是谁都可以编写的了，BDD将不再是乌邦托。</p>\n<p>此类型的Steps建议以 <code>*_steps.rb</code> 格式建立文件。</p>\n<h3 id=\"与业务耦合的自定义Steps\"><a href=\"#与业务耦合的自定义Steps\" class=\"headerlink\" title=\"与业务耦合的自定义Steps:\"></a>与业务耦合的自定义Steps:</h3><p>为了保证Steps复用，不写大量重复代码，一些经常被使用、稳定性较高的操作应该封装起来作为一个Steps语句进行使用。<br>例如每次重新安装App后，都需要左划三次跳过欢迎界面，那么这样的操作，我们应该封装起来作为一个Step。<br>我们将这样的Steps库称为：Enca库</p>\n<p>毕竟与业务耦合，所以变动的可能性非常大，管理难度同样会跟着上升。<br>同一个Enca Steps可能在很多个场景中使用，如果因某个场景变更，而需要修改这个Steps的话，很容易导致其他场景出错，但像Steps库一样有变更就单纯累加Steps的方式显然也不明智，会导致后期Enca库存在大量以废弃但又不敢删除的Steps。<br>所以Enca库中Steps的设计原则应该高度耦合于固定的界面，每一个Step都应对应且只对应一个页面的一个操作，即使两个页面的某个操作高度类似，也应该编写两个Steps，保证在某个页面逻辑修改时不会因为这样的耦合关系而影响其他页面。</p>\n<h3 id=\"合适的语法糖\"><a href=\"#合适的语法糖\" class=\"headerlink\" title=\"合适的语法糖\"></a>合适的语法糖</h3><p>自然语言很强的可读性副带的缺点便是记忆与编写速度的下降，过于松散的语法结构将会对脚本编写带来很大的困扰，所以你需要自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。可能说的不太明白，举个例子吧</p>\n<pre><code>#我跳过欢迎界面\nThen I skip welcome page\n#我完成登录操作\nThen I have finished the login\n</code></pre><p>上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：</p>\n<pre><code>#我跳过欢迎界面\nThen I pass &quot;welcome&quot; scenario\n#我完成登录操作\nThen I pass &quot;login&quot; scenario\n</code></pre><p>两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。</p>\n<p>如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？</p>\n<h3 id=\"严格的文档管理\"><a href=\"#严格的文档管理\" class=\"headerlink\" title=\"严格的文档管理\"></a>严格的文档管理</h3><p>无论是Stepks库还是Enca库，一定要建立完善的API文档，每一个入库的Steps一定要在文档中记录。添加新的Steps时需要现在Steps文档中查看是否已存在同样的Steps。</p>\n<h2 id=\"Ruby-Query的使用。\"><a href=\"#Ruby-Query的使用。\" class=\"headerlink\" title=\"Ruby Query的使用。\"></a>Ruby Query的使用。</h2><p>编写Calabash测试脚本，最大的难题在于定位到对应的元素。虽然预定的Steps中提供了通过文字、ID、Index的方式定位元素，但真实情况往往更加复杂。单纯通过肉眼的话，文字匹配对于图标无能为力，很多控件没有ID，也有很多控件你并不能很好的判断其类型，和其Index。</p>\n<p>元素定位很困难，但我们可以通过Ruby Query等命令帮助我们编写测试用例。</p>\n<p>首先第一步在终端中执行命令：<code>calabash-android console **.apk</code></p>\n<p>接下来会进入calabash命令行，提示符变为了 irb(main):001:0&gt;</p>\n<p>如果app未安装，先执行 <code>reinstall_apps</code><br>已安装直接执行 <code>start_test_server_in_background</code></p>\n<p>下面，先执行一个最简单的Query命令 <code>query(&quot;*&quot;)</code> 返回该页面所有view元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):021:0&gt; query(&quot;*&quot;)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [ 0] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;com.android.internal.policy.impl.PhoneWindow$DecorView&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;com.android.internal.policy.impl.PhoneWindow$DecorView&#123;ebb9e78 V.E..... R....... 0,0-1080,1920&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; nil,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 1920,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 1080,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 0,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 0,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 960</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [ 1] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.widget.LinearLayout&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.widget.LinearLayout&#123;27f6d6c3 V.E..... ........ 0,0-1080,1920&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; nil,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 1920,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 1080,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 0,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 0,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 960</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [ 2] &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    [38] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;me.ele.crowdsource.components.RedPacketView&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;me.ele.crowdsource.components.RedPacketView&#123;1df1f92a V.ED..C. ........ 880,1531-1080,1710 #7f0d02e1 app:id/red_packet_view&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;red_packet_view&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 179,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 200,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 1531,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 880,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 980,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 1620</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>返回数据是数组格式。里面的index,class，id都是编写测试用例的重要依据。</p>\n<p>查找某一类型的控件。 <code>query(&quot;android.support.v7.widget.AppCompatEditText&quot;)</code> 我们查到2个EditText。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):025:0&gt; query(&quot;android.support.v7.widget.AppCompatEditText&quot;)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [0] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&#123;1006278d VFED..CL ........ 45,0-720,153 #7f0d02cf app:id/phone_verify_sheet_phone_number&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;phone_verify_sheet_phone_number&quot;,</span><br><span class=\"line\">                      &quot;text&quot; =&gt; &quot;&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 153,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 675,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 666,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 90,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 427,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 742</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [1] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&#123;1042aa90 VFED..CL ........ 0,155-990,308 #7f0d02d2 app:id/phone_verify_sheet_verifying_code&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;phone_verify_sheet_verifying_code&quot;,</span><br><span class=\"line\">                      &quot;text&quot; =&gt; &quot;&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 153,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 990,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 821,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 45,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 897</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>假设这两个输入框都没有id，也没有文字可以匹配，你可以使用它们的下标进行定位。比如我要对下标为1的输入框进行输入，使用上面我们两次提到的Step: <code>Then I enter 输入密码 into input field number 2</code><br>下标为1的输入框在自然语言中是指第二个输入框，上面我们也分析了这条Step的源码，对传入的参数做了减1操作，所以这里传入2。</p>\n<p>当然我们同样可以执行这样的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询id等于phone_verify_sheet_verifying_code的ImageView</span><br><span class=\"line\">irb(main):018:0&gt; query(&quot;android.widget.ImageView id:&apos;img1&apos;&quot;)  </span><br><span class=\"line\"></span><br><span class=\"line\">其他一些属性均可</span><br><span class=\"line\">query(&quot;* visible:true&quot;)</span><br></pre></td></tr></table></figure>\n<p>同时你还可以指定返回的结果<code>query(&quot;*&quot;, :id)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):031:0&gt; query(&quot;*&quot;, :id)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [ 0] nil,</span><br><span class=\"line\">    [ 1] nil,</span><br><span class=\"line\">    [ 2] nil,</span><br><span class=\"line\">    [ 3] &quot;action_bar_root&quot;,</span><br><span class=\"line\">    [ 4] &quot;content&quot;,</span><br><span class=\"line\">    [ 5] nil,</span><br><span class=\"line\">    [ 6] &quot;login_login_text&quot;,</span><br><span class=\"line\">    [ 7] &quot;login_logo&quot;,</span><br><span class=\"line\">    [ 8] &quot;login_sheet&quot;,</span><br><span class=\"line\">    [ 9] nil,</span><br><span class=\"line\">    [10] &quot;phone_verify_sheet_phone_number&quot;,</span><br><span class=\"line\">    [11] &quot;phone_verify_sheet_send_code&quot;,</span><br><span class=\"line\">    [12] &quot;phone_verify_sheet_divider&quot;,</span><br><span class=\"line\">    [13] &quot;phone_verify_sheet_verifying_code&quot;,</span><br><span class=\"line\">    [14] &quot;login_login&quot;,</span><br><span class=\"line\">    [15] &quot;login_audio&quot;,</span><br><span class=\"line\">    [16] &quot;login_register&quot;,</span><br><span class=\"line\">    [17] &quot;statusBarBackground&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>上面我们简单的使用了Quewy查询，更详细的介绍可以参考下面两篇文章：</p>\n<p><a href=\"https://github.com/calabash/calabash-android/wiki/05-Query-Syntax\" target=\"_blank\" rel=\"noopener\">https://github.com/calabash/calabash-android/wiki/05-Query-Syntax</a><br><a href=\"http://blog.csdn.net/bigconvience/article/details/39182161\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/bigconvience/article/details/39182161</a></p>\n<h2 id=\"View定位技巧\"><a href=\"#View定位技巧\" class=\"headerlink\" title=\"View定位技巧\"></a>View定位技巧</h2><p>Calabash定位的主要方式有三种：文字、id、index。</p>\n<p>文字是最简单的一种定位方式，但也有缺点，那就是文字的非唯一性。<br>以Step:<code>Then /^I press &quot;([^\\&quot;]*)&quot;$/ do |identifier|</code> 为例，当一个界面同时存在两个以上的目标文字时，按照这条命令的定义，Calabash会默认点击第一个符合条件的view。如果你想要可以选择下标的Step，就需要自定义了。<br>同时，如果有些纯图标的View，文字定位就无用了。</p>\n<p>Id虽然是唯一性的，但同样缺陷明显：1.有很多View没有ID,这个我们在上一节Query语句的结果中就可以看到了，这种情况不止存在于根布局，很多需要操作的View都存在这样的问题！<br>2.如果id的定义并不人性化，那么同样会导致脚本的可读性下降。<br>3.debug包和混淆过的release包ID往往不同，因为ID名也被混淆了，所以Debug包和relase包无法同用一套脚本。</p>\n<p>View下标是指：把当前页面的所有View当做一个数组，每一个View都有一个下标。通常这种排列都有迹可循，比如从上到下，从左到右，从深到浅。如果布局非常复杂，可以借助Query语句查询。</p>\n<p>基本原理知道了，从这几个方面找方法就很容易了。</p>\n<h3 id=\"肉眼\"><a href=\"#肉眼\" class=\"headerlink\" title=\"肉眼\"></a>肉眼</h3><p>Calabash最大的魅力在于其自然语言一样的脚本，如果可以，我还是建议尽量使用肉眼识别文字与下标的方式进行编写Calabash脚本，点击登录按钮，在第2个输入框中输入XXX，通过这样的方式保持测试脚本的自然性。毕竟奇奇怪怪的ID和奇奇怪怪的下标，尤其混淆以后的ID，和下标上升到十几位数以后，比如下面这种尴尬：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When I press view with id &quot;c2&quot;</span><br><span class=\"line\">Then I enter &quot;1&quot; into input field number 13</span><br></pre></td></tr></table></figure>\n<p>c2是什么鬼，第13个输入框？？？</p>\n<p>但毕竟人力有穷尽，很多view的定位并不是很容易。这只是建议。</p>\n<h3 id=\"Android-uiautomatorviewer\"><a href=\"#Android-uiautomatorviewer\" class=\"headerlink\" title=\"Android uiautomatorviewer\"></a>Android uiautomatorviewer</h3><p>uiautomatorviewer工具位于Android SDK目录下,在终端中切换到Android SDK的目录下，在tools目录下可以看到uiautomatorviewer工具，运行./uiautomatorviewer就可以打开uiautomatorviewer了。</p>\n<p>连接手机，打开要查看的页面，点击uiautomatorviewer左上角第二个按钮（Device Screenshot(uiautomator dump)），将会在屏幕上出现该页面，并在右上角的窗口中显示该页面的层级结构，点击页面上的View元素，会在右下角Node Detail窗口中出现该View的基本信息，包括ID，文字等等信息。</p>\n<p><img src=\"/2017/03/18/Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg\" alt=\"uiautomatorviewer\"></p>\n<p>uiautomatorviewer的优点在于可以在不查看代码的情况下知道View的ID。对比Query查询，其优点在于更加直观，且不需要任何编程基础。毕竟Query是以数组形式返回，如果一个页面View特别多的话，将数组中的View与页面的View做对应是很麻烦的。</p>\n<p><strong>需要提醒的是：这里的index和我们用Query查到的数组下标并不是一回事，所以这里的index不可用</strong></p>\n<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p>uiautomatorviewer虽然可以看到View的ID，但没有办法看到View的下标。Query的查询更加精确一点但不够直观。</p>\n<p>所以最好的办法应该是肉眼、uiautomatorviewer、Query三者结合。当然前期可能会显得比较繁琐，但熟练了之后就会很简单了。</p>\n<h3 id=\"不定位了，找不到，直接点击屏幕吧\"><a href=\"#不定位了，找不到，直接点击屏幕吧\" class=\"headerlink\" title=\"不定位了，找不到，直接点击屏幕吧\"></a>不定位了，找不到，直接点击屏幕吧</h3><p>正常来说，所有的View都是可以定位到的，只是难易程度罢了，如果你要操作的View真的特别特别难以定位，直接点击屏幕也是办法。</p>\n<p>调用下面这条预定义Step即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|     </span><br><span class=\"line\"></span><br><span class=\"line\">use:</span><br><span class=\"line\">Then I click on screen 23% from the left and 34% from the top</span><br></pre></td></tr></table></figure>\n<p>这里非常非常要注意的是，这条命令后面的<code>%</code>不可以省略，他是按照当前屏幕的百分比位置来点击的。</p>\n<p>但无论通过uiautomatorviewer还是Query命令，你都只能查到View的像素坐标，暂时还没有发现好的工具来查询百分比坐标。不过你可以使用像素坐标除以当前手机分辨率来计算百分比坐标。<br>看到这里，你也许会想，我根本不需要手动计算，直接把计算写在脚本里不就好了嘛：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click login button $/ do </span><br><span class=\"line\">  %&#123;</span><br><span class=\"line\">  \tThen I click on screen 1323 from the left and 568 from the top for 1920x1080</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I click on screen (\\d+) from the left and (\\d+) from the top for 1920x1080$/ do |x, y|</span><br><span class=\"line\">  perform_action(&apos;click_on_screen&apos;, x/1080, y/1920)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>但我并不建议你这样去做，上面的自定义Step只适用于1920x1080的手机，在实际测试中，一定会涉及到替换不同手机跑case的，换一个手机就修改一下脚本明显不适用，尤其发展到云测阶段。这也是为什么预定义的Steps只提供了百分比坐标的点击事件。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>基本上了解上面的内容，就已经可以开始编写Calabash测试脚本进行测试了。当然Calabash还不止这些，我们将在下一章进阶中继续为你介绍Calabash使用技巧：</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p>《Calabash探索2-Calabash用法详解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇Calabash Run起来以后，如果你立刻在自己的项目上进行尝试，我相信你一定会像我之前一样，一头雾水，那么从这篇开始，我们来对Calabash深挖。 大概从这几个方向开始：</p>\n<ul>\n<li>Feature、Scenario等关键字使用策略。</li>\n<li>Calabash预定义Steps的使用。</li>\n<li>自定义Steps。</li>\n<li>使用Ruby语法编写带逻辑判断的Steps。</li>\n<li>自定义Steps的使用策略。</li>\n<li>Ruby Query的使用。</li>\n</ul>","more":"<h2 id=\"Feature、Scenario等关键字使用策略\"><a href=\"#Feature、Scenario等关键字使用策略\" class=\"headerlink\" title=\"Feature、Scenario等关键字使用策略\"></a>Feature、Scenario等关键字使用策略</h2><p>主要的关键字如下Feature、Scenario、Given、When、Then。前面我们也说了，其实这几个关键字实际是Cucumber体系下的，如果你想更进一步的了解，请查询<a href=\"https://github.com/cucumber/cucumber\" target=\"_blank\" rel=\"noopener\">Cucumber相关资料</a>。<br>我们重点讲Feature、Scenario两个。</p>\n<p>一个.feature文件只能含有一个Feature，以此作为一个测试用例集，一个测试用例集（Feature）可以包含多个场景（Scenario）。</p>\n<p>在不指定具体的.feature文件及其顺序的情况下，Calabash会遍历features根目录下的所有Feature按随机顺序执行。<br>每执行一个Feature都会卸载重新安装App，而执行Scenario则不会重新卸载安装App，而是重新启动。</p>\n<p>举例我有以下两个文件：</p>\n<p><em>login.feature</em> ： 测试登录和注册两个业务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Login 测试</span><br><span class=\"line\"></span><br><span class=\"line\">\tScenario: 使用无效手机号注册</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确手机号、无效验证码注册</span><br><span class=\"line\">  </span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确手机号、正确验证码注册</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t</span><br><span class=\"line\">    Scenario: 使用错误手机号登录</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    Scenario: 使用正确手机号登录</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p><em>health.feature</em> ： 测试上传健康证业务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Health 测试</span><br><span class=\"line\"></span><br><span class=\"line\">\tScenario: 登录</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用错误健康证号码上传</span><br><span class=\"line\">  </span><br><span class=\"line\">\t\tThen I...</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    </span><br><span class=\"line\">\tScenario: 使用正确健康证号码上传</span><br><span class=\"line\">   </span><br><span class=\"line\">        Then I...</span><br><span class=\"line\">        ...</span><br></pre></td></tr></table></figure>\n<p><strong>切记：在设计时，每个Feature都应该是完全独立，他们之间不能有任何耦合（App都卸载了，你互相依赖还有啥用）</strong><br>因为每个Feature都是独立的，所以完全不必在意他们的执行顺序。</p>\n<p>使用命令 <code>calabash-android run test.apk</code> 执行时，Calabash会遍历features主目录下所有的.feature文件进行执行。<br>当你只想执行某一个或某几个Feature时，直接在该命令后加Feature文件路径即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calabash-android run test.apk ./login.feature ./health.feature</span><br></pre></td></tr></table></figure>\n<p>值的一提的是，当你指定执行哪些Feature时,Calabash会按照你指定的顺序进行执行。</p>\n<p>那么当我执行<code>calabash-android run test.apk</code> 会发生什么呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.安装App</span><br><span class=\"line\">2.执行Feature: Login 测试</span><br><span class=\"line\">3.启动App</span><br><span class=\"line\">4.执行Scenario: 使用无效手机号注册</span><br><span class=\"line\">5.关闭App,重启App</span><br><span class=\"line\">6.执行Scenario: 使用正确手机号、无效验证码注册</span><br><span class=\"line\">7.关闭App,重启App</span><br><span class=\"line\">8.执行Scenario: 使用正确手机号、正确验证码注册</span><br><span class=\"line\">9.关闭App,重启App</span><br><span class=\"line\">10.执行Scenario: 使用错误手机号登录</span><br><span class=\"line\">11.关闭App,重启App</span><br><span class=\"line\">12.执行Scenario: 使用正确手机号登录</span><br><span class=\"line\">13.卸载并重新安装App</span><br><span class=\"line\">14.执行Feature: Health 测试</span><br><span class=\"line\">15.启动App</span><br><span class=\"line\">16.执行Scenario: 登录</span><br><span class=\"line\">17.关闭App,重启App</span><br><span class=\"line\">18.执行Scenario: 使用错误健康证号码上传</span><br><span class=\"line\">19.关闭App,重启App</span><br><span class=\"line\">20.执行Scenario: 使用正确健康证号码上传</span><br><span class=\"line\">21.关闭App</span><br></pre></td></tr></table></figure>\n<p>基本上Calabash大的框框就是这样，所以我们在设计编写测试用例时，要按照这个框框来做。考虑什么情况分Feature,什么情况分Scenario，什么情况不能分，需要整体一大串的往下写。</p>\n<p>然后是Given、When、Then三个关键字，其实我并没有太搞明白他们之间的区别，似乎只是在概念上做了区分，实际的使用中并没有什么明显的区别，以我暂时的理解就是：在写法上，你用Then和用When都可以执行。只是理解上有区别。</p>\n<p>下面是Cucumber给出的定义：</p>\n<ul>\n<li>Feature（功能）— test suite （测试用例集）</li>\n<li>Scenario（情景） — test case （测试用例）</li>\n<li>Given（给定）— setup（创建测试所需环境）</li>\n<li>When（当）— test（触发被测事件）</li>\n<li>Then（则）— assert(断言，验证结果)</li>\n</ul>\n<p>虽然Then是用来验证结果的，但当When无法执行时，也会报错。我有怀疑过他们的超时时间不同，但经测试发现，他们超时时间也是一样的。这个还待深究……<br>虽然暂时认为他们在使用上是一样的，但我还是建议你在编写测试用例时，<strong>按照上面的区分进行编写，毕竟测试脚本还是需要有很强可读性的，你可以用对应关键字来区分哪些步骤是需要测试验证的重点。</strong></p>\n<h2 id=\"Calabash-预定义的Steps使用\"><a href=\"#Calabash-预定义的Steps使用\" class=\"headerlink\" title=\"Calabash 预定义的Steps使用\"></a>Calabash 预定义的Steps使用</h2><p>我只能说，Calabash最全的文档，除了安装步骤以外就是这套预定义的Steps了，虽然这个最全的指令也写的不那么友好。 <a href=\"https://github.com/calabash/calabash-android/blob/master/ruby-gem/lib/calabash-android/canned_steps.md\" target=\"_blank\" rel=\"noopener\">轻戳跳转到Calabash 预定义Steps</a></p>\n<p>简单解释一下，看懂一两条基本上其他照着下面的说明看，用起来就没问题了。</p>\n<pre><code>Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|\n</code></pre><p>以这个Step为例。<br>我忍不住要吐槽了，首先要承认我正则表达式接触的很少，为了这个我还去恶补了一下，因为第一次看到上面这个我都不知道怎么用，/^是啥？要不要写上去？  那个 do 要不要加上？ 后面|text, index|看着应该是参数名，要不要也上去？ 好烦好烦~</p>\n<p>好了吐槽结束，开讲：</p>\n<p>正确的使用方法是： <code>Then I enter &quot;你好世界&quot; into input field number 1</code><br>其含义是在第一个输入框里输入 你好世界。<br>这里的1是指当前界面第一个输入框，至于为什么不像是数组一样，是从0开始的问题，我们在下一节讲<strong>自定义Steps</strong>时，会分析这条Steps的源码，到时候你就明白了。</p>\n<p>文档给出的写法实际是Step的定义写法，前面Then是关键字，我们不管它，所以 /^ $/  do |text, index| 通通都是定义语法，在使用中都是不用写上去的。这个等我们看到后面自定义Steps时就能理解了。<br>中间”([^\\”]*)”  (\\d+) 这两个就很简单了，就是两个正则表达式参数，正则所修饰的就是该参数所能接收的类型。</p>\n<h2 id=\"自定义Steps\"><a href=\"#自定义Steps\" class=\"headerlink\" title=\"自定义Steps\"></a>自定义Steps</h2><p>这一章我们暂只聊Calabash三种自定义Steps中的两种，第三种放到下一章进阶中讲。</p>\n<h3 id=\"自定义Steps-1\"><a href=\"#自定义Steps-1\" class=\"headerlink\" title=\"自定义Steps\"></a>自定义Steps</h3><p>Calabash提供的预定义Steps很明显不够用的嘛，那么就需要我们自己进行扩展。怎么扩展呢？</p>\n<p>在step_definitions文件夹下新建一个文件：first_steps.rb,然后进行修改：（这里我偷个懒，直接拿Calabash源码用来讲自定义方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>Then是前面的修饰符，这个没啥好说的<br>/^ $/ 成对出现，用来表示Steps方法名的开始和结尾<br>中间内容理解为方法名，随便写。可以在任意位置插入参数，参数用正在表达式表示<br>$/一个空格后 加关键字 do 开始定义方法体<br>如果有参数便按照|text, index| 格式添加参数，参数数目要和前面对应上，否则会报错<br>换行后就是真正的方法体，<code>enter_text()</code> 是Calabash基于Ruby编写的库方法。关于这些方法的文档我还没有找到，初期，你可以对照Calabash预定义的Steps源码找到可用的ruby库方法。<br>最后以end结尾。<br>steps定义结束。</p>\n<p>哦，还要解释一下上一节我们提到的：<strong>为什么这条指令的这里的1是指当前界面第一个输入框，而不像是数组一样，是从0开始的问题。</strong></p>\n<p>看下面的定义 <code>enter_text(&quot;android.widget.EditText index:#{index.to_i-1}&quot;, text)</code><br><strong>{index.to_i-1}</strong> 这里传参中，做了一个减1的操作，calabash在实际的处理上，还是从0开始的，但是Calabash为了最大程度保证语义的自然程度，做了这样的修改，（在自然语言中，我们从头数的话，说的都是第一个，而不是第零个）这也是我们在自定义指令时可以借鉴的一个地方。</p>\n<p>为什么说Calabash学起来很简单呢？因为他的语法简单，你完全可以照猫画虎的学。你可以在这个目录下<br><code>./Library/Ruby/Gems/2.0.0/gems/calabash-android-0.9.0/lib/calabash-android/steps</code></p>\n<p>找到Calabash预定义的Steps源码，通过对比源码来学习Steps的使用和自定义，同时寻找可用的ruby库方法。</p>\n<p>可以先看一下enter_text_steps.rb文件下的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; as &quot;([^\\&quot;]*)&quot;$/ do |text, content_description|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText &#123;contentDescription LIKE[c] &apos;#&#123;content_description&#125;&apos;&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into &quot;([^\\&quot;]*)&quot;$/ do |text, content_description|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText &#123;contentDescription LIKE[c] &apos;#&#123;content_description&#125;&apos;&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter &quot;([^\\&quot;]*)&quot; into input field number (\\d+)$/ do |text, index|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I enter text &quot;([^\\&quot;]*)&quot; into field with id &quot;([^\\&quot;]*)&quot;$/ do |text, id|</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText id:&apos;#&#123;id&#125;&apos;&quot;, text)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear &quot;([^\\&quot;]*)&quot;$/ do |identifier|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText marked:&apos;#&#123;identifier&#125;&apos;&#125;&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear input field number (\\d+)$/ do |index|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I clear input field with id &quot;([^\\&quot;]*)&quot;$/ do |id|</span><br><span class=\"line\">  clear_text_in(&quot;android.widget.EditText id:&apos;#&#123;id&#125;&apos;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>大概就长这样，稍微有点编程基础的，照猫画虎没啥问题。</p>\n<h3 id=\"封装以定义的Steps\"><a href=\"#封装以定义的Steps\" class=\"headerlink\" title=\"封装以定义的Steps\"></a>封装以定义的Steps</h3><p>以上面我们看到的health.feature为例，我只写了两个场景，因为细分的边界case会很多，所以实际过程中我可能要写很多个场景，那么每一个场景 进入到健康证上传页面这个步骤都是一模一样的，难道我要复制粘贴这么多下么？ 不不~，一个有追求的程序猿是百分百拒绝复制粘贴的！那么我就要把进入健康证上传页面这些个步骤封装起来变成一个命令，用起来省事，修改也简单！</p>\n<p>需要说一下的是，如果你用上面自定义Steps的方法直接在方法体中写自定义Steps的话，是不可行的，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>上面的代码是无法执行的。想要封装已定义的Steps你需要这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages with (\\d+) steps$/ do |steps|</span><br><span class=\"line\">\tsteps %&#123;</span><br><span class=\"line\">    \tThen I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">        Then I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">        Then I drag from 90:50 to 20:50 moving with #&#123;steps&#125; steps</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><code>%{}</code> 是ruby中表示多行字符串的格式，一对大括号之间的所有换行符和空格符都会原原本本的输出。</p>\n<p>如果需要再<code>%{}</code> 内部使用参数，直接写参数名是不会被识别的，需要使用<code>#{}</code>包裹。</p>\n<p>在自定义Steps时，你可能会遇到<strong>坑5：Calabash自定义的Steps,执行过程中提示未定义</strong></p>\n<h2 id=\"使用Ruby语法编写带逻辑判断的Steps\"><a href=\"#使用Ruby语法编写带逻辑判断的Steps\" class=\"headerlink\" title=\"使用Ruby语法编写带逻辑判断的Steps\"></a>使用Ruby语法编写带逻辑判断的Steps</h2><p>上面只是介绍了Steps的自定义方法，简单的对原有库方法或命令进行封装，修改方面名或参数值。扩展的能力有限，Calabash当然不会如此的初级，.rb是Ruby文件，所以这里使用的都是Ruby语法，你也当然可以通过Ruby语法为你的Steps添加各种逻辑。</p>\n<p><strong>Steps的定义不只是已有库方法和以后Steps的封装，他的内部定义同样可以非常丰富。</strong></p>\n<p>例如上一节我们封装的三行左划命令，如果我想增加一个扩展，通过传入的参数来控制左划的次数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I drag toLeft (\\d+) times$/ do |times|</span><br><span class=\"line\">\t$num = times.to_i</span><br><span class=\"line\">\twhile $num &gt; 0 do</span><br><span class=\"line\">\t\tperform_action(&apos;drag&apos;, 90, 20, 50, 50, 20) </span><br><span class=\"line\">\t\t$num = $num-1</span><br><span class=\"line\">\tend</span><br><span class=\"line\">    puts &quot;循环结束&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>即使你没有接触过Ruby，但是这个代码也应该可以大致看懂。<br><code>$num</code> 是Ruby定义变量的方法。<br><code>times.to_i</code> 是Ruby提供的类型转换函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while conditional [do]</span><br><span class=\"line\">   code</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>是Ruby的循环语法。</p>\n<p>前面一章我们还提到除了feature中编写的注释可以在执行中输出以外，你还可以使用ruby的输出语句<code>puts &quot;&quot;</code>来输出一些提示性语句。</p>\n<p>Ruby的语法真的非常简单，这里再次推荐<a href=\"http://www.runoob.com/ruby/ruby-loop.html\" target=\"_blank\" rel=\"noopener\">Ruby的学习网站</a>。</p>\n<h2 id=\"自定义Steps的使用策略\"><a href=\"#自定义Steps的使用策略\" class=\"headerlink\" title=\"自定义Steps的使用策略\"></a>自定义Steps的使用策略</h2><p>自定义Steps是Calabash测试脚本的基石，就像砖块一样，只有齐整的砖块盖起房子来才会更容易，所以为了保证后期脚本维护的方便，以及让测试脚本的编写变得越来越轻松容易，接纳更多的人员参与，应该建立一套Steps规范，并建立一个Steps文档。</p>\n<p>下面是我的建议：</p>\n<h3 id=\"与业务完全解耦的自定义Steps：\"><a href=\"#与业务完全解耦的自定义Steps：\" class=\"headerlink\" title=\"与业务完全解耦的自定义Steps：\"></a>与业务完全解耦的自定义Steps：</h3><p>该种类型应该像Calabash预定义的Steps一样，完全与业务解耦，只是不同类型的动作及检查，开放有更多的参数，有很好的灵活性，复用性很强。同时<strong>每一个新建的Steps都要加入Steps库中，一直累加，禁止或尽量避免对原有Steps进行修改。对于这样的库我们称为：Steps库</strong><br>这类型自定义Steps更多的是使用Ruby函数库定义的Step,因为使用Ruby函数库定义的Step需要设计到很多Ruby语言，增加了学习树，所以这类型Steps应该保持更高的稳定性。</p>\n<p><strong>未来的展望：</strong> 中期Calabash测试脚本的开发将分为两个梯队，一个是Steps的开发，一个是测试用例开发，测试用例开发不需要对Calabash有过深入的了解，只需要对照着Steps文档即可编写测试脚本。如果需要新的Steps,就像Steps开发提需求即可。<br>到后期Steps库逐步完善，可能很久才会有新的Steps需求，那么这个时候Calabash自动化测试脚本就真的是谁都可以编写的了，BDD将不再是乌邦托。</p>\n<p>此类型的Steps建议以 <code>*_steps.rb</code> 格式建立文件。</p>\n<h3 id=\"与业务耦合的自定义Steps\"><a href=\"#与业务耦合的自定义Steps\" class=\"headerlink\" title=\"与业务耦合的自定义Steps:\"></a>与业务耦合的自定义Steps:</h3><p>为了保证Steps复用，不写大量重复代码，一些经常被使用、稳定性较高的操作应该封装起来作为一个Steps语句进行使用。<br>例如每次重新安装App后，都需要左划三次跳过欢迎界面，那么这样的操作，我们应该封装起来作为一个Step。<br>我们将这样的Steps库称为：Enca库</p>\n<p>毕竟与业务耦合，所以变动的可能性非常大，管理难度同样会跟着上升。<br>同一个Enca Steps可能在很多个场景中使用，如果因某个场景变更，而需要修改这个Steps的话，很容易导致其他场景出错，但像Steps库一样有变更就单纯累加Steps的方式显然也不明智，会导致后期Enca库存在大量以废弃但又不敢删除的Steps。<br>所以Enca库中Steps的设计原则应该高度耦合于固定的界面，每一个Step都应对应且只对应一个页面的一个操作，即使两个页面的某个操作高度类似，也应该编写两个Steps，保证在某个页面逻辑修改时不会因为这样的耦合关系而影响其他页面。</p>\n<h3 id=\"合适的语法糖\"><a href=\"#合适的语法糖\" class=\"headerlink\" title=\"合适的语法糖\"></a>合适的语法糖</h3><p>自然语言很强的可读性副带的缺点便是记忆与编写速度的下降，过于松散的语法结构将会对脚本编写带来很大的困扰，所以你需要自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。可能说的不太明白，举个例子吧</p>\n<pre><code>#我跳过欢迎界面\nThen I skip welcome page\n#我完成登录操作\nThen I have finished the login\n</code></pre><p>上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：</p>\n<pre><code>#我跳过欢迎界面\nThen I pass &quot;welcome&quot; scenario\n#我完成登录操作\nThen I pass &quot;login&quot; scenario\n</code></pre><p>两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。</p>\n<p>如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？</p>\n<h3 id=\"严格的文档管理\"><a href=\"#严格的文档管理\" class=\"headerlink\" title=\"严格的文档管理\"></a>严格的文档管理</h3><p>无论是Stepks库还是Enca库，一定要建立完善的API文档，每一个入库的Steps一定要在文档中记录。添加新的Steps时需要现在Steps文档中查看是否已存在同样的Steps。</p>\n<h2 id=\"Ruby-Query的使用。\"><a href=\"#Ruby-Query的使用。\" class=\"headerlink\" title=\"Ruby Query的使用。\"></a>Ruby Query的使用。</h2><p>编写Calabash测试脚本，最大的难题在于定位到对应的元素。虽然预定的Steps中提供了通过文字、ID、Index的方式定位元素，但真实情况往往更加复杂。单纯通过肉眼的话，文字匹配对于图标无能为力，很多控件没有ID，也有很多控件你并不能很好的判断其类型，和其Index。</p>\n<p>元素定位很困难，但我们可以通过Ruby Query等命令帮助我们编写测试用例。</p>\n<p>首先第一步在终端中执行命令：<code>calabash-android console **.apk</code></p>\n<p>接下来会进入calabash命令行，提示符变为了 irb(main):001:0&gt;</p>\n<p>如果app未安装，先执行 <code>reinstall_apps</code><br>已安装直接执行 <code>start_test_server_in_background</code></p>\n<p>下面，先执行一个最简单的Query命令 <code>query(&quot;*&quot;)</code> 返回该页面所有view元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):021:0&gt; query(&quot;*&quot;)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [ 0] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;com.android.internal.policy.impl.PhoneWindow$DecorView&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;com.android.internal.policy.impl.PhoneWindow$DecorView&#123;ebb9e78 V.E..... R....... 0,0-1080,1920&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; nil,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 1920,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 1080,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 0,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 0,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 960</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [ 1] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.widget.LinearLayout&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.widget.LinearLayout&#123;27f6d6c3 V.E..... ........ 0,0-1080,1920&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; nil,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 1920,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 1080,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 0,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 0,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 960</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [ 2] &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    [38] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;me.ele.crowdsource.components.RedPacketView&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;me.ele.crowdsource.components.RedPacketView&#123;1df1f92a V.ED..C. ........ 880,1531-1080,1710 #7f0d02e1 app:id/red_packet_view&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;red_packet_view&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 179,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 200,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 1531,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 880,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 980,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 1620</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>返回数据是数组格式。里面的index,class，id都是编写测试用例的重要依据。</p>\n<p>查找某一类型的控件。 <code>query(&quot;android.support.v7.widget.AppCompatEditText&quot;)</code> 我们查到2个EditText。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):025:0&gt; query(&quot;android.support.v7.widget.AppCompatEditText&quot;)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [0] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&#123;1006278d VFED..CL ........ 45,0-720,153 #7f0d02cf app:id/phone_verify_sheet_phone_number&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;phone_verify_sheet_phone_number&quot;,</span><br><span class=\"line\">                      &quot;text&quot; =&gt; &quot;&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 153,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 675,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 666,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 90,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 427,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 742</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [1] &#123;</span><br><span class=\"line\">                     &quot;class&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&quot;,</span><br><span class=\"line\">                       &quot;tag&quot; =&gt; nil,</span><br><span class=\"line\">               &quot;description&quot; =&gt; &quot;android.support.v7.widget.AppCompatEditText&#123;1042aa90 VFED..CL ........ 0,155-990,308 #7f0d02d2 app:id/phone_verify_sheet_verifying_code&#125;&quot;,</span><br><span class=\"line\">                        &quot;id&quot; =&gt; &quot;phone_verify_sheet_verifying_code&quot;,</span><br><span class=\"line\">                      &quot;text&quot; =&gt; &quot;&quot;,</span><br><span class=\"line\">                   &quot;visible&quot; =&gt; true,</span><br><span class=\"line\">                      &quot;rect&quot; =&gt; &#123;</span><br><span class=\"line\">              &quot;height&quot; =&gt; 153,</span><br><span class=\"line\">               &quot;width&quot; =&gt; 990,</span><br><span class=\"line\">                   &quot;y&quot; =&gt; 821,</span><br><span class=\"line\">                   &quot;x&quot; =&gt; 45,</span><br><span class=\"line\">            &quot;center_x&quot; =&gt; 540,</span><br><span class=\"line\">            &quot;center_y&quot; =&gt; 897</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">                   &quot;enabled&quot; =&gt; true,</span><br><span class=\"line\">        &quot;contentDescription&quot; =&gt; nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>假设这两个输入框都没有id，也没有文字可以匹配，你可以使用它们的下标进行定位。比如我要对下标为1的输入框进行输入，使用上面我们两次提到的Step: <code>Then I enter 输入密码 into input field number 2</code><br>下标为1的输入框在自然语言中是指第二个输入框，上面我们也分析了这条Step的源码，对传入的参数做了减1操作，所以这里传入2。</p>\n<p>当然我们同样可以执行这样的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询id等于phone_verify_sheet_verifying_code的ImageView</span><br><span class=\"line\">irb(main):018:0&gt; query(&quot;android.widget.ImageView id:&apos;img1&apos;&quot;)  </span><br><span class=\"line\"></span><br><span class=\"line\">其他一些属性均可</span><br><span class=\"line\">query(&quot;* visible:true&quot;)</span><br></pre></td></tr></table></figure>\n<p>同时你还可以指定返回的结果<code>query(&quot;*&quot;, :id)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irb(main):031:0&gt; query(&quot;*&quot;, :id)</span><br><span class=\"line\">[</span><br><span class=\"line\">    [ 0] nil,</span><br><span class=\"line\">    [ 1] nil,</span><br><span class=\"line\">    [ 2] nil,</span><br><span class=\"line\">    [ 3] &quot;action_bar_root&quot;,</span><br><span class=\"line\">    [ 4] &quot;content&quot;,</span><br><span class=\"line\">    [ 5] nil,</span><br><span class=\"line\">    [ 6] &quot;login_login_text&quot;,</span><br><span class=\"line\">    [ 7] &quot;login_logo&quot;,</span><br><span class=\"line\">    [ 8] &quot;login_sheet&quot;,</span><br><span class=\"line\">    [ 9] nil,</span><br><span class=\"line\">    [10] &quot;phone_verify_sheet_phone_number&quot;,</span><br><span class=\"line\">    [11] &quot;phone_verify_sheet_send_code&quot;,</span><br><span class=\"line\">    [12] &quot;phone_verify_sheet_divider&quot;,</span><br><span class=\"line\">    [13] &quot;phone_verify_sheet_verifying_code&quot;,</span><br><span class=\"line\">    [14] &quot;login_login&quot;,</span><br><span class=\"line\">    [15] &quot;login_audio&quot;,</span><br><span class=\"line\">    [16] &quot;login_register&quot;,</span><br><span class=\"line\">    [17] &quot;statusBarBackground&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>上面我们简单的使用了Quewy查询，更详细的介绍可以参考下面两篇文章：</p>\n<p><a href=\"https://github.com/calabash/calabash-android/wiki/05-Query-Syntax\" target=\"_blank\" rel=\"noopener\">https://github.com/calabash/calabash-android/wiki/05-Query-Syntax</a><br><a href=\"http://blog.csdn.net/bigconvience/article/details/39182161\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/bigconvience/article/details/39182161</a></p>\n<h2 id=\"View定位技巧\"><a href=\"#View定位技巧\" class=\"headerlink\" title=\"View定位技巧\"></a>View定位技巧</h2><p>Calabash定位的主要方式有三种：文字、id、index。</p>\n<p>文字是最简单的一种定位方式，但也有缺点，那就是文字的非唯一性。<br>以Step:<code>Then /^I press &quot;([^\\&quot;]*)&quot;$/ do |identifier|</code> 为例，当一个界面同时存在两个以上的目标文字时，按照这条命令的定义，Calabash会默认点击第一个符合条件的view。如果你想要可以选择下标的Step，就需要自定义了。<br>同时，如果有些纯图标的View，文字定位就无用了。</p>\n<p>Id虽然是唯一性的，但同样缺陷明显：1.有很多View没有ID,这个我们在上一节Query语句的结果中就可以看到了，这种情况不止存在于根布局，很多需要操作的View都存在这样的问题！<br>2.如果id的定义并不人性化，那么同样会导致脚本的可读性下降。<br>3.debug包和混淆过的release包ID往往不同，因为ID名也被混淆了，所以Debug包和relase包无法同用一套脚本。</p>\n<p>View下标是指：把当前页面的所有View当做一个数组，每一个View都有一个下标。通常这种排列都有迹可循，比如从上到下，从左到右，从深到浅。如果布局非常复杂，可以借助Query语句查询。</p>\n<p>基本原理知道了，从这几个方面找方法就很容易了。</p>\n<h3 id=\"肉眼\"><a href=\"#肉眼\" class=\"headerlink\" title=\"肉眼\"></a>肉眼</h3><p>Calabash最大的魅力在于其自然语言一样的脚本，如果可以，我还是建议尽量使用肉眼识别文字与下标的方式进行编写Calabash脚本，点击登录按钮，在第2个输入框中输入XXX，通过这样的方式保持测试脚本的自然性。毕竟奇奇怪怪的ID和奇奇怪怪的下标，尤其混淆以后的ID，和下标上升到十几位数以后，比如下面这种尴尬：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When I press view with id &quot;c2&quot;</span><br><span class=\"line\">Then I enter &quot;1&quot; into input field number 13</span><br></pre></td></tr></table></figure>\n<p>c2是什么鬼，第13个输入框？？？</p>\n<p>但毕竟人力有穷尽，很多view的定位并不是很容易。这只是建议。</p>\n<h3 id=\"Android-uiautomatorviewer\"><a href=\"#Android-uiautomatorviewer\" class=\"headerlink\" title=\"Android uiautomatorviewer\"></a>Android uiautomatorviewer</h3><p>uiautomatorviewer工具位于Android SDK目录下,在终端中切换到Android SDK的目录下，在tools目录下可以看到uiautomatorviewer工具，运行./uiautomatorviewer就可以打开uiautomatorviewer了。</p>\n<p>连接手机，打开要查看的页面，点击uiautomatorviewer左上角第二个按钮（Device Screenshot(uiautomator dump)），将会在屏幕上出现该页面，并在右上角的窗口中显示该页面的层级结构，点击页面上的View元素，会在右下角Node Detail窗口中出现该View的基本信息，包括ID，文字等等信息。</p>\n<p><img src=\"/2017/03/18/Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg\" alt=\"uiautomatorviewer\"></p>\n<p>uiautomatorviewer的优点在于可以在不查看代码的情况下知道View的ID。对比Query查询，其优点在于更加直观，且不需要任何编程基础。毕竟Query是以数组形式返回，如果一个页面View特别多的话，将数组中的View与页面的View做对应是很麻烦的。</p>\n<p><strong>需要提醒的是：这里的index和我们用Query查到的数组下标并不是一回事，所以这里的index不可用</strong></p>\n<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p>uiautomatorviewer虽然可以看到View的ID，但没有办法看到View的下标。Query的查询更加精确一点但不够直观。</p>\n<p>所以最好的办法应该是肉眼、uiautomatorviewer、Query三者结合。当然前期可能会显得比较繁琐，但熟练了之后就会很简单了。</p>\n<h3 id=\"不定位了，找不到，直接点击屏幕吧\"><a href=\"#不定位了，找不到，直接点击屏幕吧\" class=\"headerlink\" title=\"不定位了，找不到，直接点击屏幕吧\"></a>不定位了，找不到，直接点击屏幕吧</h3><p>正常来说，所有的View都是可以定位到的，只是难易程度罢了，如果你要操作的View真的特别特别难以定位，直接点击屏幕也是办法。</p>\n<p>调用下面这条预定义Step即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|     </span><br><span class=\"line\"></span><br><span class=\"line\">use:</span><br><span class=\"line\">Then I click on screen 23% from the left and 34% from the top</span><br></pre></td></tr></table></figure>\n<p>这里非常非常要注意的是，这条命令后面的<code>%</code>不可以省略，他是按照当前屏幕的百分比位置来点击的。</p>\n<p>但无论通过uiautomatorviewer还是Query命令，你都只能查到View的像素坐标，暂时还没有发现好的工具来查询百分比坐标。不过你可以使用像素坐标除以当前手机分辨率来计算百分比坐标。<br>看到这里，你也许会想，我根本不需要手动计算，直接把计算写在脚本里不就好了嘛：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click login button $/ do </span><br><span class=\"line\">  %&#123;</span><br><span class=\"line\">  \tThen I click on screen 1323 from the left and 568 from the top for 1920x1080</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I click on screen (\\d+) from the left and (\\d+) from the top for 1920x1080$/ do |x, y|</span><br><span class=\"line\">  perform_action(&apos;click_on_screen&apos;, x/1080, y/1920)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>但我并不建议你这样去做，上面的自定义Step只适用于1920x1080的手机，在实际测试中，一定会涉及到替换不同手机跑case的，换一个手机就修改一下脚本明显不适用，尤其发展到云测阶段。这也是为什么预定义的Steps只提供了百分比坐标的点击事件。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>基本上了解上面的内容，就已经可以开始编写Calabash测试脚本进行测试了。当然Calabash还不止这些，我们将在下一章进阶中继续为你介绍Calabash使用技巧：</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p>《Calabash探索2-Calabash用法详解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>"},{"title":"Calabash探索3-Calabash进阶","date":"2017-03-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n上一篇我们讲了Calabash的基本用法，有了上一篇的经验，已经可以写基本的测试脚本了，只不过一些特殊情况会写的不那么方便，这一篇我们讲一些Calabash的进阶用法：大概是这几个方向：\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n<!-- more -->\n\n## 在自定义的Steps中使用Query语句\n\n上一篇我们简单介绍了Query的用法和通过Query来帮助我们编写测试脚本。\n但这个是建立在人工查询结果上，如果可以让脚本自己去查，是不是会更便捷？\nCalabash提供的预定义Steps中，只有极个别几种View的Steps，类似ImageView等控件暂时还没有这种待遇，按照一般情况，我们只能选择通过ID，或者人工Query查询ImageView的index。那么如果可以只通过肉眼判断当前ImageView的index就可以编写脚本是不更好呢？\n\n我们来自定义一个Step：\n\n```\nWhen /^I press imageView number (\\d+)$/ do |index|\n\t$imageView = query(\"android.support.v7.widget.AppCompatImageView\")\n\ttouch($editText[index.to_i-1])\nend\n```\n\n为了保证Steps的自然语义，这里我们也对index做了减1操作。\n你也看到了，在Steps的定义体中，是可以使用Query语句的，不过这样的写法稍显繁琐了\n\n```\nWhen /^I press imageView number (\\d+)$/ do |index|\n\ttap_when_element_exists(\"android.support.v7.widget.AppCompatImageView index:#{index.to_i-1}\")\nend\n```\n\n``tap_when_element_exists``本身也支持一定程度的查询功能。\n\n你可能会问了，既然这些库方法已经支持这样的查询了，在内部写Query语句看起来也没啥用了啊。下面我们把Calabash预定义的Steps源码拿来瞅瞅你就知道用处在哪里了：\n\n```\nThen /^I select \"([^\\\"]*)\" from \"([^\\\"]*)\"$/ do |item_identifier, spinner_identifier|\n  spinner = query(\"android.widget.Spinner marked:'#{spinner_identifier}'\")\n\n  if spinner.empty?\n    tap_when_element_exists(\"android.widget.Spinner * marked:'#{spinner_identifier}'\")\n  else\n    touch(spinner)\n  end\n\n  tap_when_element_exists(\"android.widget.PopupWindow$PopupViewContainer * marked:'#{item_identifier}'\")\nend\n```\n\n解释一下：首先查询是否有对应描述的下拉列表控件，查询的结果是一个数组，如果结果是空的，那么就调用点击事件尝试点击一下，不出意外会报错找不到这个控件。\n如果不是空的，那就点击这个查询结果的第零个元素。\n``touch``方法，如果传递的参数是一个数组，会默认点击第零个元素。\n然后点击弹出的PopupWindow中的item。\n\n\n## 自定义Steps支持环境变量扩展\n\n有几个场景。\n- 如果测试不同的系统或者不同分辨率的手机，测试用例内部可能需要细微改变，为了应对这些改变，复制多套脚本进行修改显然不是特别合适。\n- 不同账号有不同的权限和数据，同一个测试用例可能需要不同的账号来测试，为了应对不同账号复制多套脚本进行修改显示不是特别合适。\n- 初期想要让android和iOS无缝的使用一套脚本不太现实，两套脚本几乎必然，但如果遇到上面的现象，测试中需要使用一套数据进行支持（账号），这个时候两边都维护一套一模一样的数据就不太合适了。\n\n以上场景的解决实质是，**如何在不修改脚本的情况下，可以改变其中的参数？**\n其解决方案便是：引入环境变量。\n\n新建一个新的自定义Step:\n\n```\nThen /^I enter \\$([^\\$]*) into input field number (\\d+)$/ do |text_ev, index|\n  text = ENV[text_ev]\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n```\n\n有两处改变，方法名中的参数接收处：``\\$([^\\$]*)``和方法体中的参数获取：``text = ENV[text_ev]`` 这里基本照猫画虎就好了。\n\nfeature中这样调用：\n\n```\nThen I enter $env_account_1 into input field number 1\n```\n\n``$`` 后面的变量名是环境变量名。\n\n在执行``calabash-android run **.apk``前先设置环境变量\n\n```\nset env_account_1 123456\ncalabash-android run **.apk\n```\n\n这样，在脚本执行过程中，会将123456当做账号填写到输入框中。\n\n但这只是最基础的用法，当需要的环境变量非常多时，再使用这样的方式明显不太合适，这个时候可以将之放入ruby脚本中，也便于维护。\n\n新建test_data1.rb\n```\nENV[\"env_account_1\"]=\"1111111111\"\nENV[\"env_password_1\"]=\"123456\"\n```\n\n新建test_data2.rb\n```\nENV[\"env_account_1\"]=\"222222222\"\nENV[\"env_password_1\"]=\"123456\"\n```\n\n终端中执行如下命令\n\n```\nCrowdsource-android git:(feature/testing) ✗ irb\nirb(main):001:0> require './features/test_data1.rb'\n=> true\nirb(main):002:0>ENV[\"env_account_1\"]\n=> \"11111111\"\nirb(main):003:0> exec('calabash-android run debug.apk ')\nFeature: Login feature\n...\n\n#脚本执行完毕，切换另一套环境变量\nirb(main):001:0> require './features/test_data1.rb'\n=> true\nirb(main):002:0>ENV[\"env_account_2\"]\n=> \"2222222\"\nirb(main):003:0> exec('calabash-android run debug.apk ')\nFeature: Login feature\n...\n\n```\n这样就可以整套整套的替换环境变量进行测试，``ENV[\"env_account_2\"]``命令用来查看环境变量的值。\n\n\n## Hooks\n\n关于Hooks，我们在前面第二章有简单提过一下。Hooks就是在监听程序运行的某个阶段，并做一些事情。在feature/support文件夹下有三个关于Hooks的文件：\n``app_installation_hooks.rb , app_life_cycle_hooks.rb , hooks.rb``\n前两个文件分别是对app安装的Hooks,和app生命周期的Hooks。hooks.rb文件夹是空的，由我们自己来编写。\n这里暂时还没有做过什么特别的实践，我偷个懒，直接将 立成 [@richardcao](http://richardcao.me)博客中的关于这一部分的段落摘了过来，原文在这里：[http://richardcao.me/2016/10/31/客户端自动化测试小探索/](http://richardcao.me/2016/10/31/客户端自动化测试小探索/)。\n\n```\n我们看一个简单的app_life_cycle_hooks.rb理解理解：\n\nrequire 'calabash-android/management/adb'\nrequire 'calabash-android/operations'\nBefore do |scenario|\n  start_test_server_in_background\nend\nAfter do |scenario|\n  if scenario.failed?\n    screenshot_embed\n  end\n  shutdown_test_server\nend\n\n这是默认就生成好的，从字面意思上看，就是app生命周期的hook，这里可以看到，在主要用到了Before和After关键字进行操作，这个显然很容易就看懂了，于是我自己写了一个在每个step执行之后都等待2秒的hook，下面的代码写在hooks.rb中（这个文件默认生成是空的）：\n\nrequire 'calabash-android/calabash_steps'\nAfterStep do |scenario|\n\tsleep 2\nend\n\n很容易对吧？关于这部分想多了解的可以看cucumber wiki中的Hooks部分。\n\n```\n[cucumber wiki中的Hooks部分](https://github.com/cucumber/cucumber/wiki/Hooks)。\n\n\n\n## Calabash源码修改与扩展\n\n前面我们提到了两种自定义Calabash Steps的方法，分别是自定义Steps和封装已有的Steps。还有第三种更为深入的定制化方案，那就是修改Calabash源码自定义Actions，这里的Actions指的便是我们之前经常会看到的，类似这样的代码: ``perform_action('swipe', 'right')  perform_action('tap_map_marker_by_title', marker_title, 60000)``\n\n其中swipe,tap_map_marker_by_title实际是方法名，他们的核心，以Calabash-android为例，实际也是Android工程 java代码实现的。如果你有看过其他关于Calabash-android的博客，会有介绍修改其源码，创建自定义的Actions方法的实例。\n\n基本原理是：Calabash目录``/calabash-android/ruby-gem/test-server/instrumentation-backend`` 是一个Android工程，在其包``/src/sh/calaba/instrumentationbackend/actions``中实现了我们用到的ruby库方法。\n在其中创建我们自己的Action类，然后进行编译，即可创建我们自己的库方法并使用。\n\n但这样的博客都写于2016年之前，目前最新的Calabash-android项目的源码已经删除了``/calabash-android/ruby-gem/test-server``目录下的文件夹，通过翻阅Git记录得知：Calabash-android在2015.12.12日删除了本地的test_server目录，将其移动到了新的项目：[calabash-android-server](https://github.com/calabash/calabash-android-server)中。如果你将Calabash-android项目切换到2016年之前，还可以找到test_server目录，查看里面的Android工程，修改并重新编译。但我并不建议你这样去做，使用这种方式扩展意味着要放弃 Calabash一年以上的更新进度。\n\n[calabash-android-server](https://github.com/calabash/calabash-android-server)同样是开源项目，虽然暂时我还没搞明白如何在这个项目中修改源码并应用到Calabash-android中，但只是单纯研究其源码还是非常有价值的！\n\n我挑了其中最简单的一个类，我们来研究一下：\n\n../actions/gestures/ClickOnScreen.java\n\n```\npackage sh.calaba.instrumentationbackend.actions.gestures;\n\n\nimport sh.calaba.instrumentationbackend.InstrumentationBackend;\nimport sh.calaba.instrumentationbackend.Result;\nimport sh.calaba.instrumentationbackend.actions.Action;\nimport android.view.Display;\n\n\npublic class ClickOnScreen implements Action {\n\n    @Override\n    public Result execute(String... args) {\n        Display display = InstrumentationBackend.solo.getCurrentActivity().getWindowManager().getDefaultDisplay();\n        \n        float x = Float.parseFloat(args[0]);\n        float y = Float.parseFloat(args[1]);\n        \n        int width = display.getWidth();\n        int height = display.getHeight();\n        \n        InstrumentationBackend.solo.clickOnScreen((x/100)*width, (y/100)*height);\n        return Result.successResult();\n    }\n\n    @Override\n    public String key() {\n        return \"click_on_screen\";\n    }\n\n}\n\n```\n先看下Steps的定义中是怎么用这个方法的：\n```\nThen /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|\n  perform_action('click_on_screen', x, y)\nend\n```\n``public String key()`` 方法便是定义Action方法的名称。``public Result execute(String... args)``便是实现。\n\nResult返回值表示该动作是否执行成功。如果失败，会直接抛到终端中进行显示错误信息。\n这里我们重点关注这个对象：``InstrumentationBackend.solo``\n获取界面信息，以及真正实现点击操作的，都是通过solo对象来实现的。那么这个solo对象是个啥？\n\n我们摘取``InstrumentationBackend``类的一段代码：\n\n```\n...\nimport com.jayway.android.robotium.solo.SoloEnhanced;\nimport sh.calaba.instrumentationbackend.automation.CalabashAutomation;\nimport sh.calaba.instrumentationbackend.query.ui.UIObject;\n\nimport java.util.*;\n\n/*\n    Utility class based on the current test-server life cycle.\n */\npublic class InstrumentationBackend {\n    private static final String TAG = \"InstrumentationBackend\";\n\n    public static List<Intent> intents = new ArrayList<Intent>();\n    private static Map<ActivityIntentFilter, IntentHookWithCount> intentHooks =\n            new HashMap<ActivityIntentFilter, IntentHookWithCount>();\n\n    private static CalabashAutomation calabashAutomation;\n\n    /* Instrumentation does not belong to this class. Here because of old architecture */\n    public static Instrumentation instrumentation;\n\n    public static SoloEnhanced solo;\n    public static Actions actions;\n    \n...\n```\n\nsolo实际是com.jayway.android.robotium.solo.SoloEnhanced类。看到这里应该明白了，Calabash-android对UI的操作核心其实借助以Robotium来做的。\n\n*Robotium是一款国外的Android自动化测试框架，主要针对Android平台的应用进行黑盒自动化测试，它提供了模拟各种手势操作（点击、长按、滑动等）、查找和断言机制的API，能够对各种控件进行操作*\n\n**哦，还要提一点，Calabash不支持跨进程的原有就在于Robotium不支持跨进程，所以让Calabash支持跨进程的契机就在这里，修改其源码，调用uiautomator的API即可，具体可行性和方式还待探索，如果你有兴趣，不妨我们一起研究呀**\n\n## 总结\n\nOK，大概就是这样了，Calabash进阶部分会随时更新，修改Calabash-android-server源码进行扩展的方法我也会继续研究下去，成功以后会随时更新博客。\n\n\n</br>\n \n------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n《Calabash探索3-Calabash进阶》\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Calabash探索3-Calabash进阶.md","raw":"---\ntitle: Calabash探索3-Calabash进阶\ndate: 2017-3-17 16:20:58\nauthor : 暴打小女孩\n\ntags: 测试\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n上一篇我们讲了Calabash的基本用法，有了上一篇的经验，已经可以写基本的测试脚本了，只不过一些特殊情况会写的不那么方便，这一篇我们讲一些Calabash的进阶用法：大概是这几个方向：\n\n- 在自定义的Steps中使用Query语句。\n- 自定义Steps支持环境变量扩展。\n- Hooks。\n- Calabash源码修改与扩展。\n\n<!-- more -->\n\n## 在自定义的Steps中使用Query语句\n\n上一篇我们简单介绍了Query的用法和通过Query来帮助我们编写测试脚本。\n但这个是建立在人工查询结果上，如果可以让脚本自己去查，是不是会更便捷？\nCalabash提供的预定义Steps中，只有极个别几种View的Steps，类似ImageView等控件暂时还没有这种待遇，按照一般情况，我们只能选择通过ID，或者人工Query查询ImageView的index。那么如果可以只通过肉眼判断当前ImageView的index就可以编写脚本是不更好呢？\n\n我们来自定义一个Step：\n\n```\nWhen /^I press imageView number (\\d+)$/ do |index|\n\t$imageView = query(\"android.support.v7.widget.AppCompatImageView\")\n\ttouch($editText[index.to_i-1])\nend\n```\n\n为了保证Steps的自然语义，这里我们也对index做了减1操作。\n你也看到了，在Steps的定义体中，是可以使用Query语句的，不过这样的写法稍显繁琐了\n\n```\nWhen /^I press imageView number (\\d+)$/ do |index|\n\ttap_when_element_exists(\"android.support.v7.widget.AppCompatImageView index:#{index.to_i-1}\")\nend\n```\n\n``tap_when_element_exists``本身也支持一定程度的查询功能。\n\n你可能会问了，既然这些库方法已经支持这样的查询了，在内部写Query语句看起来也没啥用了啊。下面我们把Calabash预定义的Steps源码拿来瞅瞅你就知道用处在哪里了：\n\n```\nThen /^I select \"([^\\\"]*)\" from \"([^\\\"]*)\"$/ do |item_identifier, spinner_identifier|\n  spinner = query(\"android.widget.Spinner marked:'#{spinner_identifier}'\")\n\n  if spinner.empty?\n    tap_when_element_exists(\"android.widget.Spinner * marked:'#{spinner_identifier}'\")\n  else\n    touch(spinner)\n  end\n\n  tap_when_element_exists(\"android.widget.PopupWindow$PopupViewContainer * marked:'#{item_identifier}'\")\nend\n```\n\n解释一下：首先查询是否有对应描述的下拉列表控件，查询的结果是一个数组，如果结果是空的，那么就调用点击事件尝试点击一下，不出意外会报错找不到这个控件。\n如果不是空的，那就点击这个查询结果的第零个元素。\n``touch``方法，如果传递的参数是一个数组，会默认点击第零个元素。\n然后点击弹出的PopupWindow中的item。\n\n\n## 自定义Steps支持环境变量扩展\n\n有几个场景。\n- 如果测试不同的系统或者不同分辨率的手机，测试用例内部可能需要细微改变，为了应对这些改变，复制多套脚本进行修改显然不是特别合适。\n- 不同账号有不同的权限和数据，同一个测试用例可能需要不同的账号来测试，为了应对不同账号复制多套脚本进行修改显示不是特别合适。\n- 初期想要让android和iOS无缝的使用一套脚本不太现实，两套脚本几乎必然，但如果遇到上面的现象，测试中需要使用一套数据进行支持（账号），这个时候两边都维护一套一模一样的数据就不太合适了。\n\n以上场景的解决实质是，**如何在不修改脚本的情况下，可以改变其中的参数？**\n其解决方案便是：引入环境变量。\n\n新建一个新的自定义Step:\n\n```\nThen /^I enter \\$([^\\$]*) into input field number (\\d+)$/ do |text_ev, index|\n  text = ENV[text_ev]\n  enter_text(\"android.widget.EditText index:#{index.to_i-1}\", text)\nend\n```\n\n有两处改变，方法名中的参数接收处：``\\$([^\\$]*)``和方法体中的参数获取：``text = ENV[text_ev]`` 这里基本照猫画虎就好了。\n\nfeature中这样调用：\n\n```\nThen I enter $env_account_1 into input field number 1\n```\n\n``$`` 后面的变量名是环境变量名。\n\n在执行``calabash-android run **.apk``前先设置环境变量\n\n```\nset env_account_1 123456\ncalabash-android run **.apk\n```\n\n这样，在脚本执行过程中，会将123456当做账号填写到输入框中。\n\n但这只是最基础的用法，当需要的环境变量非常多时，再使用这样的方式明显不太合适，这个时候可以将之放入ruby脚本中，也便于维护。\n\n新建test_data1.rb\n```\nENV[\"env_account_1\"]=\"1111111111\"\nENV[\"env_password_1\"]=\"123456\"\n```\n\n新建test_data2.rb\n```\nENV[\"env_account_1\"]=\"222222222\"\nENV[\"env_password_1\"]=\"123456\"\n```\n\n终端中执行如下命令\n\n```\nCrowdsource-android git:(feature/testing) ✗ irb\nirb(main):001:0> require './features/test_data1.rb'\n=> true\nirb(main):002:0>ENV[\"env_account_1\"]\n=> \"11111111\"\nirb(main):003:0> exec('calabash-android run debug.apk ')\nFeature: Login feature\n...\n\n#脚本执行完毕，切换另一套环境变量\nirb(main):001:0> require './features/test_data1.rb'\n=> true\nirb(main):002:0>ENV[\"env_account_2\"]\n=> \"2222222\"\nirb(main):003:0> exec('calabash-android run debug.apk ')\nFeature: Login feature\n...\n\n```\n这样就可以整套整套的替换环境变量进行测试，``ENV[\"env_account_2\"]``命令用来查看环境变量的值。\n\n\n## Hooks\n\n关于Hooks，我们在前面第二章有简单提过一下。Hooks就是在监听程序运行的某个阶段，并做一些事情。在feature/support文件夹下有三个关于Hooks的文件：\n``app_installation_hooks.rb , app_life_cycle_hooks.rb , hooks.rb``\n前两个文件分别是对app安装的Hooks,和app生命周期的Hooks。hooks.rb文件夹是空的，由我们自己来编写。\n这里暂时还没有做过什么特别的实践，我偷个懒，直接将 立成 [@richardcao](http://richardcao.me)博客中的关于这一部分的段落摘了过来，原文在这里：[http://richardcao.me/2016/10/31/客户端自动化测试小探索/](http://richardcao.me/2016/10/31/客户端自动化测试小探索/)。\n\n```\n我们看一个简单的app_life_cycle_hooks.rb理解理解：\n\nrequire 'calabash-android/management/adb'\nrequire 'calabash-android/operations'\nBefore do |scenario|\n  start_test_server_in_background\nend\nAfter do |scenario|\n  if scenario.failed?\n    screenshot_embed\n  end\n  shutdown_test_server\nend\n\n这是默认就生成好的，从字面意思上看，就是app生命周期的hook，这里可以看到，在主要用到了Before和After关键字进行操作，这个显然很容易就看懂了，于是我自己写了一个在每个step执行之后都等待2秒的hook，下面的代码写在hooks.rb中（这个文件默认生成是空的）：\n\nrequire 'calabash-android/calabash_steps'\nAfterStep do |scenario|\n\tsleep 2\nend\n\n很容易对吧？关于这部分想多了解的可以看cucumber wiki中的Hooks部分。\n\n```\n[cucumber wiki中的Hooks部分](https://github.com/cucumber/cucumber/wiki/Hooks)。\n\n\n\n## Calabash源码修改与扩展\n\n前面我们提到了两种自定义Calabash Steps的方法，分别是自定义Steps和封装已有的Steps。还有第三种更为深入的定制化方案，那就是修改Calabash源码自定义Actions，这里的Actions指的便是我们之前经常会看到的，类似这样的代码: ``perform_action('swipe', 'right')  perform_action('tap_map_marker_by_title', marker_title, 60000)``\n\n其中swipe,tap_map_marker_by_title实际是方法名，他们的核心，以Calabash-android为例，实际也是Android工程 java代码实现的。如果你有看过其他关于Calabash-android的博客，会有介绍修改其源码，创建自定义的Actions方法的实例。\n\n基本原理是：Calabash目录``/calabash-android/ruby-gem/test-server/instrumentation-backend`` 是一个Android工程，在其包``/src/sh/calaba/instrumentationbackend/actions``中实现了我们用到的ruby库方法。\n在其中创建我们自己的Action类，然后进行编译，即可创建我们自己的库方法并使用。\n\n但这样的博客都写于2016年之前，目前最新的Calabash-android项目的源码已经删除了``/calabash-android/ruby-gem/test-server``目录下的文件夹，通过翻阅Git记录得知：Calabash-android在2015.12.12日删除了本地的test_server目录，将其移动到了新的项目：[calabash-android-server](https://github.com/calabash/calabash-android-server)中。如果你将Calabash-android项目切换到2016年之前，还可以找到test_server目录，查看里面的Android工程，修改并重新编译。但我并不建议你这样去做，使用这种方式扩展意味着要放弃 Calabash一年以上的更新进度。\n\n[calabash-android-server](https://github.com/calabash/calabash-android-server)同样是开源项目，虽然暂时我还没搞明白如何在这个项目中修改源码并应用到Calabash-android中，但只是单纯研究其源码还是非常有价值的！\n\n我挑了其中最简单的一个类，我们来研究一下：\n\n../actions/gestures/ClickOnScreen.java\n\n```\npackage sh.calaba.instrumentationbackend.actions.gestures;\n\n\nimport sh.calaba.instrumentationbackend.InstrumentationBackend;\nimport sh.calaba.instrumentationbackend.Result;\nimport sh.calaba.instrumentationbackend.actions.Action;\nimport android.view.Display;\n\n\npublic class ClickOnScreen implements Action {\n\n    @Override\n    public Result execute(String... args) {\n        Display display = InstrumentationBackend.solo.getCurrentActivity().getWindowManager().getDefaultDisplay();\n        \n        float x = Float.parseFloat(args[0]);\n        float y = Float.parseFloat(args[1]);\n        \n        int width = display.getWidth();\n        int height = display.getHeight();\n        \n        InstrumentationBackend.solo.clickOnScreen((x/100)*width, (y/100)*height);\n        return Result.successResult();\n    }\n\n    @Override\n    public String key() {\n        return \"click_on_screen\";\n    }\n\n}\n\n```\n先看下Steps的定义中是怎么用这个方法的：\n```\nThen /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|\n  perform_action('click_on_screen', x, y)\nend\n```\n``public String key()`` 方法便是定义Action方法的名称。``public Result execute(String... args)``便是实现。\n\nResult返回值表示该动作是否执行成功。如果失败，会直接抛到终端中进行显示错误信息。\n这里我们重点关注这个对象：``InstrumentationBackend.solo``\n获取界面信息，以及真正实现点击操作的，都是通过solo对象来实现的。那么这个solo对象是个啥？\n\n我们摘取``InstrumentationBackend``类的一段代码：\n\n```\n...\nimport com.jayway.android.robotium.solo.SoloEnhanced;\nimport sh.calaba.instrumentationbackend.automation.CalabashAutomation;\nimport sh.calaba.instrumentationbackend.query.ui.UIObject;\n\nimport java.util.*;\n\n/*\n    Utility class based on the current test-server life cycle.\n */\npublic class InstrumentationBackend {\n    private static final String TAG = \"InstrumentationBackend\";\n\n    public static List<Intent> intents = new ArrayList<Intent>();\n    private static Map<ActivityIntentFilter, IntentHookWithCount> intentHooks =\n            new HashMap<ActivityIntentFilter, IntentHookWithCount>();\n\n    private static CalabashAutomation calabashAutomation;\n\n    /* Instrumentation does not belong to this class. Here because of old architecture */\n    public static Instrumentation instrumentation;\n\n    public static SoloEnhanced solo;\n    public static Actions actions;\n    \n...\n```\n\nsolo实际是com.jayway.android.robotium.solo.SoloEnhanced类。看到这里应该明白了，Calabash-android对UI的操作核心其实借助以Robotium来做的。\n\n*Robotium是一款国外的Android自动化测试框架，主要针对Android平台的应用进行黑盒自动化测试，它提供了模拟各种手势操作（点击、长按、滑动等）、查找和断言机制的API，能够对各种控件进行操作*\n\n**哦，还要提一点，Calabash不支持跨进程的原有就在于Robotium不支持跨进程，所以让Calabash支持跨进程的契机就在这里，修改其源码，调用uiautomator的API即可，具体可行性和方式还待探索，如果你有兴趣，不妨我们一起研究呀**\n\n## 总结\n\nOK，大概就是这样了，Calabash进阶部分会随时更新，修改Calabash-android-server源码进行扩展的方法我也会继续研究下去，成功以后会随时更新博客。\n\n\n</br>\n \n------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n《Calabash探索3-Calabash进阶》\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Calabash探索3-Calabash进阶","published":1,"updated":"2019-01-02T02:09:31.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsos0006yo9sqfjwrsmv","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇我们讲了Calabash的基本用法，有了上一篇的经验，已经可以写基本的测试脚本了，只不过一些特殊情况会写的不那么方便，这一篇我们讲一些Calabash的进阶用法：大概是这几个方向：</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"在自定义的Steps中使用Query语句\"><a href=\"#在自定义的Steps中使用Query语句\" class=\"headerlink\" title=\"在自定义的Steps中使用Query语句\"></a>在自定义的Steps中使用Query语句</h2><p>上一篇我们简单介绍了Query的用法和通过Query来帮助我们编写测试脚本。<br>但这个是建立在人工查询结果上，如果可以让脚本自己去查，是不是会更便捷？<br>Calabash提供的预定义Steps中，只有极个别几种View的Steps，类似ImageView等控件暂时还没有这种待遇，按照一般情况，我们只能选择通过ID，或者人工Query查询ImageView的index。那么如果可以只通过肉眼判断当前ImageView的index就可以编写脚本是不更好呢？</p>\n<p>我们来自定义一个Step：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When /^I press imageView number (\\d+)$/ do |index|</span><br><span class=\"line\">\t$imageView = query(&quot;android.support.v7.widget.AppCompatImageView&quot;)</span><br><span class=\"line\">\ttouch($editText[index.to_i-1])</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>为了保证Steps的自然语义，这里我们也对index做了减1操作。<br>你也看到了，在Steps的定义体中，是可以使用Query语句的，不过这样的写法稍显繁琐了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When /^I press imageView number (\\d+)$/ do |index|</span><br><span class=\"line\">\ttap_when_element_exists(&quot;android.support.v7.widget.AppCompatImageView index:#&#123;index.to_i-1&#125;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><code>tap_when_element_exists</code>本身也支持一定程度的查询功能。</p>\n<p>你可能会问了，既然这些库方法已经支持这样的查询了，在内部写Query语句看起来也没啥用了啊。下面我们把Calabash预定义的Steps源码拿来瞅瞅你就知道用处在哪里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I select &quot;([^\\&quot;]*)&quot; from &quot;([^\\&quot;]*)&quot;$/ do |item_identifier, spinner_identifier|</span><br><span class=\"line\">  spinner = query(&quot;android.widget.Spinner marked:&apos;#&#123;spinner_identifier&#125;&apos;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">  if spinner.empty?</span><br><span class=\"line\">    tap_when_element_exists(&quot;android.widget.Spinner * marked:&apos;#&#123;spinner_identifier&#125;&apos;&quot;)</span><br><span class=\"line\">  else</span><br><span class=\"line\">    touch(spinner)</span><br><span class=\"line\">  end</span><br><span class=\"line\"></span><br><span class=\"line\">  tap_when_element_exists(&quot;android.widget.PopupWindow$PopupViewContainer * marked:&apos;#&#123;item_identifier&#125;&apos;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>解释一下：首先查询是否有对应描述的下拉列表控件，查询的结果是一个数组，如果结果是空的，那么就调用点击事件尝试点击一下，不出意外会报错找不到这个控件。<br>如果不是空的，那就点击这个查询结果的第零个元素。<br><code>touch</code>方法，如果传递的参数是一个数组，会默认点击第零个元素。<br>然后点击弹出的PopupWindow中的item。</p>\n<h2 id=\"自定义Steps支持环境变量扩展\"><a href=\"#自定义Steps支持环境变量扩展\" class=\"headerlink\" title=\"自定义Steps支持环境变量扩展\"></a>自定义Steps支持环境变量扩展</h2><p>有几个场景。</p>\n<ul>\n<li>如果测试不同的系统或者不同分辨率的手机，测试用例内部可能需要细微改变，为了应对这些改变，复制多套脚本进行修改显然不是特别合适。</li>\n<li>不同账号有不同的权限和数据，同一个测试用例可能需要不同的账号来测试，为了应对不同账号复制多套脚本进行修改显示不是特别合适。</li>\n<li>初期想要让android和iOS无缝的使用一套脚本不太现实，两套脚本几乎必然，但如果遇到上面的现象，测试中需要使用一套数据进行支持（账号），这个时候两边都维护一套一模一样的数据就不太合适了。</li>\n</ul>\n<p>以上场景的解决实质是，<strong>如何在不修改脚本的情况下，可以改变其中的参数？</strong><br>其解决方案便是：引入环境变量。</p>\n<p>新建一个新的自定义Step:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter \\$([^\\$]*) into input field number (\\d+)$/ do |text_ev, index|</span><br><span class=\"line\">  text = ENV[text_ev]</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>有两处改变，方法名中的参数接收处：<code>\\$([^\\$]*)</code>和方法体中的参数获取：<code>text = ENV[text_ev]</code> 这里基本照猫画虎就好了。</p>\n<p>feature中这样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then I enter $env_account_1 into input field number 1</span><br></pre></td></tr></table></figure>\n<p><code>$</code> 后面的变量名是环境变量名。</p>\n<p>在执行<code>calabash-android run **.apk</code>前先设置环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set env_account_1 123456</span><br><span class=\"line\">calabash-android run **.apk</span><br></pre></td></tr></table></figure>\n<p>这样，在脚本执行过程中，会将123456当做账号填写到输入框中。</p>\n<p>但这只是最基础的用法，当需要的环境变量非常多时，再使用这样的方式明显不太合适，这个时候可以将之放入ruby脚本中，也便于维护。</p>\n<p>新建test_data1.rb<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV[&quot;env_account_1&quot;]=&quot;1111111111&quot;</span><br><span class=\"line\">ENV[&quot;env_password_1&quot;]=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>\n<p>新建test_data2.rb<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV[&quot;env_account_1&quot;]=&quot;222222222&quot;</span><br><span class=\"line\">ENV[&quot;env_password_1&quot;]=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>\n<p>终端中执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Crowdsource-android git:(feature/testing) ✗ irb</span><br><span class=\"line\">irb(main):001:0&gt; require &apos;./features/test_data1.rb&apos;</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):002:0&gt;ENV[&quot;env_account_1&quot;]</span><br><span class=\"line\">=&gt; &quot;11111111&quot;</span><br><span class=\"line\">irb(main):003:0&gt; exec(&apos;calabash-android run debug.apk &apos;)</span><br><span class=\"line\">Feature: Login feature</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">#脚本执行完毕，切换另一套环境变量</span><br><span class=\"line\">irb(main):001:0&gt; require &apos;./features/test_data1.rb&apos;</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):002:0&gt;ENV[&quot;env_account_2&quot;]</span><br><span class=\"line\">=&gt; &quot;2222222&quot;</span><br><span class=\"line\">irb(main):003:0&gt; exec(&apos;calabash-android run debug.apk &apos;)</span><br><span class=\"line\">Feature: Login feature</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这样就可以整套整套的替换环境变量进行测试，<code>ENV[&quot;env_account_2&quot;]</code>命令用来查看环境变量的值。</p>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>关于Hooks，我们在前面第二章有简单提过一下。Hooks就是在监听程序运行的某个阶段，并做一些事情。在feature/support文件夹下有三个关于Hooks的文件：<br><code>app_installation_hooks.rb , app_life_cycle_hooks.rb , hooks.rb</code><br>前两个文件分别是对app安装的Hooks,和app生命周期的Hooks。hooks.rb文件夹是空的，由我们自己来编写。<br>这里暂时还没有做过什么特别的实践，我偷个懒，直接将 立成 <a href=\"http://richardcao.me\" target=\"_blank\" rel=\"noopener\">@richardcao</a>博客中的关于这一部分的段落摘了过来，原文在这里：<a href=\"http://richardcao.me/2016/10/31/客户端自动化测试小探索/\" target=\"_blank\" rel=\"noopener\">http://richardcao.me/2016/10/31/客户端自动化测试小探索/</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们看一个简单的app_life_cycle_hooks.rb理解理解：</span><br><span class=\"line\"></span><br><span class=\"line\">require &apos;calabash-android/management/adb&apos;</span><br><span class=\"line\">require &apos;calabash-android/operations&apos;</span><br><span class=\"line\">Before do |scenario|</span><br><span class=\"line\">  start_test_server_in_background</span><br><span class=\"line\">end</span><br><span class=\"line\">After do |scenario|</span><br><span class=\"line\">  if scenario.failed?</span><br><span class=\"line\">    screenshot_embed</span><br><span class=\"line\">  end</span><br><span class=\"line\">  shutdown_test_server</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">这是默认就生成好的，从字面意思上看，就是app生命周期的hook，这里可以看到，在主要用到了Before和After关键字进行操作，这个显然很容易就看懂了，于是我自己写了一个在每个step执行之后都等待2秒的hook，下面的代码写在hooks.rb中（这个文件默认生成是空的）：</span><br><span class=\"line\"></span><br><span class=\"line\">require &apos;calabash-android/calabash_steps&apos;</span><br><span class=\"line\">AfterStep do |scenario|</span><br><span class=\"line\">\tsleep 2</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">很容易对吧？关于这部分想多了解的可以看cucumber wiki中的Hooks部分。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/cucumber/cucumber/wiki/Hooks\" target=\"_blank\" rel=\"noopener\">cucumber wiki中的Hooks部分</a>。</p>\n<h2 id=\"Calabash源码修改与扩展\"><a href=\"#Calabash源码修改与扩展\" class=\"headerlink\" title=\"Calabash源码修改与扩展\"></a>Calabash源码修改与扩展</h2><p>前面我们提到了两种自定义Calabash Steps的方法，分别是自定义Steps和封装已有的Steps。还有第三种更为深入的定制化方案，那就是修改Calabash源码自定义Actions，这里的Actions指的便是我们之前经常会看到的，类似这样的代码: <code>perform_action(&#39;swipe&#39;, &#39;right&#39;)  perform_action(&#39;tap_map_marker_by_title&#39;, marker_title, 60000)</code></p>\n<p>其中swipe,tap_map_marker_by_title实际是方法名，他们的核心，以Calabash-android为例，实际也是Android工程 java代码实现的。如果你有看过其他关于Calabash-android的博客，会有介绍修改其源码，创建自定义的Actions方法的实例。</p>\n<p>基本原理是：Calabash目录<code>/calabash-android/ruby-gem/test-server/instrumentation-backend</code> 是一个Android工程，在其包<code>/src/sh/calaba/instrumentationbackend/actions</code>中实现了我们用到的ruby库方法。<br>在其中创建我们自己的Action类，然后进行编译，即可创建我们自己的库方法并使用。</p>\n<p>但这样的博客都写于2016年之前，目前最新的Calabash-android项目的源码已经删除了<code>/calabash-android/ruby-gem/test-server</code>目录下的文件夹，通过翻阅Git记录得知：Calabash-android在2015.12.12日删除了本地的test_server目录，将其移动到了新的项目：<a href=\"https://github.com/calabash/calabash-android-server\" target=\"_blank\" rel=\"noopener\">calabash-android-server</a>中。如果你将Calabash-android项目切换到2016年之前，还可以找到test_server目录，查看里面的Android工程，修改并重新编译。但我并不建议你这样去做，使用这种方式扩展意味着要放弃 Calabash一年以上的更新进度。</p>\n<p><a href=\"https://github.com/calabash/calabash-android-server\" target=\"_blank\" rel=\"noopener\">calabash-android-server</a>同样是开源项目，虽然暂时我还没搞明白如何在这个项目中修改源码并应用到Calabash-android中，但只是单纯研究其源码还是非常有价值的！</p>\n<p>我挑了其中最简单的一个类，我们来研究一下：</p>\n<p>../actions/gestures/ClickOnScreen.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package sh.calaba.instrumentationbackend.actions.gestures;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import sh.calaba.instrumentationbackend.InstrumentationBackend;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.Result;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.actions.Action;</span><br><span class=\"line\">import android.view.Display;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class ClickOnScreen implements Action &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Result execute(String... args) &#123;</span><br><span class=\"line\">        Display display = InstrumentationBackend.solo.getCurrentActivity().getWindowManager().getDefaultDisplay();</span><br><span class=\"line\">        </span><br><span class=\"line\">        float x = Float.parseFloat(args[0]);</span><br><span class=\"line\">        float y = Float.parseFloat(args[1]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        int width = display.getWidth();</span><br><span class=\"line\">        int height = display.getHeight();</span><br><span class=\"line\">        </span><br><span class=\"line\">        InstrumentationBackend.solo.clickOnScreen((x/100)*width, (y/100)*height);</span><br><span class=\"line\">        return Result.successResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String key() &#123;</span><br><span class=\"line\">        return &quot;click_on_screen&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先看下Steps的定义中是怎么用这个方法的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|</span><br><span class=\"line\">  perform_action(&apos;click_on_screen&apos;, x, y)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p><code>public String key()</code> 方法便是定义Action方法的名称。<code>public Result execute(String... args)</code>便是实现。</p>\n<p>Result返回值表示该动作是否执行成功。如果失败，会直接抛到终端中进行显示错误信息。<br>这里我们重点关注这个对象：<code>InstrumentationBackend.solo</code><br>获取界面信息，以及真正实现点击操作的，都是通过solo对象来实现的。那么这个solo对象是个啥？</p>\n<p>我们摘取<code>InstrumentationBackend</code>类的一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">import com.jayway.android.robotium.solo.SoloEnhanced;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.automation.CalabashAutomation;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.query.ui.UIObject;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">    Utility class based on the current test-server life cycle.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class InstrumentationBackend &#123;</span><br><span class=\"line\">    private static final String TAG = &quot;InstrumentationBackend&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static List&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();</span><br><span class=\"line\">    private static Map&lt;ActivityIntentFilter, IntentHookWithCount&gt; intentHooks =</span><br><span class=\"line\">            new HashMap&lt;ActivityIntentFilter, IntentHookWithCount&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static CalabashAutomation calabashAutomation;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Instrumentation does not belong to this class. Here because of old architecture */</span><br><span class=\"line\">    public static Instrumentation instrumentation;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SoloEnhanced solo;</span><br><span class=\"line\">    public static Actions actions;</span><br><span class=\"line\">    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>solo实际是com.jayway.android.robotium.solo.SoloEnhanced类。看到这里应该明白了，Calabash-android对UI的操作核心其实借助以Robotium来做的。</p>\n<p><em>Robotium是一款国外的Android自动化测试框架，主要针对Android平台的应用进行黑盒自动化测试，它提供了模拟各种手势操作（点击、长按、滑动等）、查找和断言机制的API，能够对各种控件进行操作</em></p>\n<p><strong>哦，还要提一点，Calabash不支持跨进程的原有就在于Robotium不支持跨进程，所以让Calabash支持跨进程的契机就在这里，修改其源码，调用uiautomator的API即可，具体可行性和方式还待探索，如果你有兴趣，不妨我们一起研究呀</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>OK，大概就是这样了，Calabash进阶部分会随时更新，修改Calabash-android-server源码进行扩展的方法我也会继续研究下去，成功以后会随时更新博客。</p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p>《Calabash探索3-Calabash进阶》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇我们讲了Calabash的基本用法，有了上一篇的经验，已经可以写基本的测试脚本了，只不过一些特殊情况会写的不那么方便，这一篇我们讲一些Calabash的进阶用法：大概是这几个方向：</p>\n<ul>\n<li>在自定义的Steps中使用Query语句。</li>\n<li>自定义Steps支持环境变量扩展。</li>\n<li>Hooks。</li>\n<li>Calabash源码修改与扩展。</li>\n</ul>","more":"<h2 id=\"在自定义的Steps中使用Query语句\"><a href=\"#在自定义的Steps中使用Query语句\" class=\"headerlink\" title=\"在自定义的Steps中使用Query语句\"></a>在自定义的Steps中使用Query语句</h2><p>上一篇我们简单介绍了Query的用法和通过Query来帮助我们编写测试脚本。<br>但这个是建立在人工查询结果上，如果可以让脚本自己去查，是不是会更便捷？<br>Calabash提供的预定义Steps中，只有极个别几种View的Steps，类似ImageView等控件暂时还没有这种待遇，按照一般情况，我们只能选择通过ID，或者人工Query查询ImageView的index。那么如果可以只通过肉眼判断当前ImageView的index就可以编写脚本是不更好呢？</p>\n<p>我们来自定义一个Step：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When /^I press imageView number (\\d+)$/ do |index|</span><br><span class=\"line\">\t$imageView = query(&quot;android.support.v7.widget.AppCompatImageView&quot;)</span><br><span class=\"line\">\ttouch($editText[index.to_i-1])</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>为了保证Steps的自然语义，这里我们也对index做了减1操作。<br>你也看到了，在Steps的定义体中，是可以使用Query语句的，不过这样的写法稍显繁琐了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When /^I press imageView number (\\d+)$/ do |index|</span><br><span class=\"line\">\ttap_when_element_exists(&quot;android.support.v7.widget.AppCompatImageView index:#&#123;index.to_i-1&#125;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><code>tap_when_element_exists</code>本身也支持一定程度的查询功能。</p>\n<p>你可能会问了，既然这些库方法已经支持这样的查询了，在内部写Query语句看起来也没啥用了啊。下面我们把Calabash预定义的Steps源码拿来瞅瞅你就知道用处在哪里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I select &quot;([^\\&quot;]*)&quot; from &quot;([^\\&quot;]*)&quot;$/ do |item_identifier, spinner_identifier|</span><br><span class=\"line\">  spinner = query(&quot;android.widget.Spinner marked:&apos;#&#123;spinner_identifier&#125;&apos;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">  if spinner.empty?</span><br><span class=\"line\">    tap_when_element_exists(&quot;android.widget.Spinner * marked:&apos;#&#123;spinner_identifier&#125;&apos;&quot;)</span><br><span class=\"line\">  else</span><br><span class=\"line\">    touch(spinner)</span><br><span class=\"line\">  end</span><br><span class=\"line\"></span><br><span class=\"line\">  tap_when_element_exists(&quot;android.widget.PopupWindow$PopupViewContainer * marked:&apos;#&#123;item_identifier&#125;&apos;&quot;)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>解释一下：首先查询是否有对应描述的下拉列表控件，查询的结果是一个数组，如果结果是空的，那么就调用点击事件尝试点击一下，不出意外会报错找不到这个控件。<br>如果不是空的，那就点击这个查询结果的第零个元素。<br><code>touch</code>方法，如果传递的参数是一个数组，会默认点击第零个元素。<br>然后点击弹出的PopupWindow中的item。</p>\n<h2 id=\"自定义Steps支持环境变量扩展\"><a href=\"#自定义Steps支持环境变量扩展\" class=\"headerlink\" title=\"自定义Steps支持环境变量扩展\"></a>自定义Steps支持环境变量扩展</h2><p>有几个场景。</p>\n<ul>\n<li>如果测试不同的系统或者不同分辨率的手机，测试用例内部可能需要细微改变，为了应对这些改变，复制多套脚本进行修改显然不是特别合适。</li>\n<li>不同账号有不同的权限和数据，同一个测试用例可能需要不同的账号来测试，为了应对不同账号复制多套脚本进行修改显示不是特别合适。</li>\n<li>初期想要让android和iOS无缝的使用一套脚本不太现实，两套脚本几乎必然，但如果遇到上面的现象，测试中需要使用一套数据进行支持（账号），这个时候两边都维护一套一模一样的数据就不太合适了。</li>\n</ul>\n<p>以上场景的解决实质是，<strong>如何在不修改脚本的情况下，可以改变其中的参数？</strong><br>其解决方案便是：引入环境变量。</p>\n<p>新建一个新的自定义Step:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I enter \\$([^\\$]*) into input field number (\\d+)$/ do |text_ev, index|</span><br><span class=\"line\">  text = ENV[text_ev]</span><br><span class=\"line\">  enter_text(&quot;android.widget.EditText index:#&#123;index.to_i-1&#125;&quot;, text)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>有两处改变，方法名中的参数接收处：<code>\\$([^\\$]*)</code>和方法体中的参数获取：<code>text = ENV[text_ev]</code> 这里基本照猫画虎就好了。</p>\n<p>feature中这样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then I enter $env_account_1 into input field number 1</span><br></pre></td></tr></table></figure>\n<p><code>$</code> 后面的变量名是环境变量名。</p>\n<p>在执行<code>calabash-android run **.apk</code>前先设置环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set env_account_1 123456</span><br><span class=\"line\">calabash-android run **.apk</span><br></pre></td></tr></table></figure>\n<p>这样，在脚本执行过程中，会将123456当做账号填写到输入框中。</p>\n<p>但这只是最基础的用法，当需要的环境变量非常多时，再使用这样的方式明显不太合适，这个时候可以将之放入ruby脚本中，也便于维护。</p>\n<p>新建test_data1.rb<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV[&quot;env_account_1&quot;]=&quot;1111111111&quot;</span><br><span class=\"line\">ENV[&quot;env_password_1&quot;]=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>\n<p>新建test_data2.rb<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV[&quot;env_account_1&quot;]=&quot;222222222&quot;</span><br><span class=\"line\">ENV[&quot;env_password_1&quot;]=&quot;123456&quot;</span><br></pre></td></tr></table></figure></p>\n<p>终端中执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Crowdsource-android git:(feature/testing) ✗ irb</span><br><span class=\"line\">irb(main):001:0&gt; require &apos;./features/test_data1.rb&apos;</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):002:0&gt;ENV[&quot;env_account_1&quot;]</span><br><span class=\"line\">=&gt; &quot;11111111&quot;</span><br><span class=\"line\">irb(main):003:0&gt; exec(&apos;calabash-android run debug.apk &apos;)</span><br><span class=\"line\">Feature: Login feature</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">#脚本执行完毕，切换另一套环境变量</span><br><span class=\"line\">irb(main):001:0&gt; require &apos;./features/test_data1.rb&apos;</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):002:0&gt;ENV[&quot;env_account_2&quot;]</span><br><span class=\"line\">=&gt; &quot;2222222&quot;</span><br><span class=\"line\">irb(main):003:0&gt; exec(&apos;calabash-android run debug.apk &apos;)</span><br><span class=\"line\">Feature: Login feature</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这样就可以整套整套的替换环境变量进行测试，<code>ENV[&quot;env_account_2&quot;]</code>命令用来查看环境变量的值。</p>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>关于Hooks，我们在前面第二章有简单提过一下。Hooks就是在监听程序运行的某个阶段，并做一些事情。在feature/support文件夹下有三个关于Hooks的文件：<br><code>app_installation_hooks.rb , app_life_cycle_hooks.rb , hooks.rb</code><br>前两个文件分别是对app安装的Hooks,和app生命周期的Hooks。hooks.rb文件夹是空的，由我们自己来编写。<br>这里暂时还没有做过什么特别的实践，我偷个懒，直接将 立成 <a href=\"http://richardcao.me\" target=\"_blank\" rel=\"noopener\">@richardcao</a>博客中的关于这一部分的段落摘了过来，原文在这里：<a href=\"http://richardcao.me/2016/10/31/客户端自动化测试小探索/\" target=\"_blank\" rel=\"noopener\">http://richardcao.me/2016/10/31/客户端自动化测试小探索/</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们看一个简单的app_life_cycle_hooks.rb理解理解：</span><br><span class=\"line\"></span><br><span class=\"line\">require &apos;calabash-android/management/adb&apos;</span><br><span class=\"line\">require &apos;calabash-android/operations&apos;</span><br><span class=\"line\">Before do |scenario|</span><br><span class=\"line\">  start_test_server_in_background</span><br><span class=\"line\">end</span><br><span class=\"line\">After do |scenario|</span><br><span class=\"line\">  if scenario.failed?</span><br><span class=\"line\">    screenshot_embed</span><br><span class=\"line\">  end</span><br><span class=\"line\">  shutdown_test_server</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">这是默认就生成好的，从字面意思上看，就是app生命周期的hook，这里可以看到，在主要用到了Before和After关键字进行操作，这个显然很容易就看懂了，于是我自己写了一个在每个step执行之后都等待2秒的hook，下面的代码写在hooks.rb中（这个文件默认生成是空的）：</span><br><span class=\"line\"></span><br><span class=\"line\">require &apos;calabash-android/calabash_steps&apos;</span><br><span class=\"line\">AfterStep do |scenario|</span><br><span class=\"line\">\tsleep 2</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">很容易对吧？关于这部分想多了解的可以看cucumber wiki中的Hooks部分。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/cucumber/cucumber/wiki/Hooks\" target=\"_blank\" rel=\"noopener\">cucumber wiki中的Hooks部分</a>。</p>\n<h2 id=\"Calabash源码修改与扩展\"><a href=\"#Calabash源码修改与扩展\" class=\"headerlink\" title=\"Calabash源码修改与扩展\"></a>Calabash源码修改与扩展</h2><p>前面我们提到了两种自定义Calabash Steps的方法，分别是自定义Steps和封装已有的Steps。还有第三种更为深入的定制化方案，那就是修改Calabash源码自定义Actions，这里的Actions指的便是我们之前经常会看到的，类似这样的代码: <code>perform_action(&#39;swipe&#39;, &#39;right&#39;)  perform_action(&#39;tap_map_marker_by_title&#39;, marker_title, 60000)</code></p>\n<p>其中swipe,tap_map_marker_by_title实际是方法名，他们的核心，以Calabash-android为例，实际也是Android工程 java代码实现的。如果你有看过其他关于Calabash-android的博客，会有介绍修改其源码，创建自定义的Actions方法的实例。</p>\n<p>基本原理是：Calabash目录<code>/calabash-android/ruby-gem/test-server/instrumentation-backend</code> 是一个Android工程，在其包<code>/src/sh/calaba/instrumentationbackend/actions</code>中实现了我们用到的ruby库方法。<br>在其中创建我们自己的Action类，然后进行编译，即可创建我们自己的库方法并使用。</p>\n<p>但这样的博客都写于2016年之前，目前最新的Calabash-android项目的源码已经删除了<code>/calabash-android/ruby-gem/test-server</code>目录下的文件夹，通过翻阅Git记录得知：Calabash-android在2015.12.12日删除了本地的test_server目录，将其移动到了新的项目：<a href=\"https://github.com/calabash/calabash-android-server\" target=\"_blank\" rel=\"noopener\">calabash-android-server</a>中。如果你将Calabash-android项目切换到2016年之前，还可以找到test_server目录，查看里面的Android工程，修改并重新编译。但我并不建议你这样去做，使用这种方式扩展意味着要放弃 Calabash一年以上的更新进度。</p>\n<p><a href=\"https://github.com/calabash/calabash-android-server\" target=\"_blank\" rel=\"noopener\">calabash-android-server</a>同样是开源项目，虽然暂时我还没搞明白如何在这个项目中修改源码并应用到Calabash-android中，但只是单纯研究其源码还是非常有价值的！</p>\n<p>我挑了其中最简单的一个类，我们来研究一下：</p>\n<p>../actions/gestures/ClickOnScreen.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package sh.calaba.instrumentationbackend.actions.gestures;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import sh.calaba.instrumentationbackend.InstrumentationBackend;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.Result;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.actions.Action;</span><br><span class=\"line\">import android.view.Display;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class ClickOnScreen implements Action &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Result execute(String... args) &#123;</span><br><span class=\"line\">        Display display = InstrumentationBackend.solo.getCurrentActivity().getWindowManager().getDefaultDisplay();</span><br><span class=\"line\">        </span><br><span class=\"line\">        float x = Float.parseFloat(args[0]);</span><br><span class=\"line\">        float y = Float.parseFloat(args[1]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        int width = display.getWidth();</span><br><span class=\"line\">        int height = display.getHeight();</span><br><span class=\"line\">        </span><br><span class=\"line\">        InstrumentationBackend.solo.clickOnScreen((x/100)*width, (y/100)*height);</span><br><span class=\"line\">        return Result.successResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String key() &#123;</span><br><span class=\"line\">        return &quot;click_on_screen&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先看下Steps的定义中是怎么用这个方法的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I click on screen (\\d+)% from the left and (\\d+)% from the top$/ do |x, y|</span><br><span class=\"line\">  perform_action(&apos;click_on_screen&apos;, x, y)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p><code>public String key()</code> 方法便是定义Action方法的名称。<code>public Result execute(String... args)</code>便是实现。</p>\n<p>Result返回值表示该动作是否执行成功。如果失败，会直接抛到终端中进行显示错误信息。<br>这里我们重点关注这个对象：<code>InstrumentationBackend.solo</code><br>获取界面信息，以及真正实现点击操作的，都是通过solo对象来实现的。那么这个solo对象是个啥？</p>\n<p>我们摘取<code>InstrumentationBackend</code>类的一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">import com.jayway.android.robotium.solo.SoloEnhanced;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.automation.CalabashAutomation;</span><br><span class=\"line\">import sh.calaba.instrumentationbackend.query.ui.UIObject;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">    Utility class based on the current test-server life cycle.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class InstrumentationBackend &#123;</span><br><span class=\"line\">    private static final String TAG = &quot;InstrumentationBackend&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static List&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();</span><br><span class=\"line\">    private static Map&lt;ActivityIntentFilter, IntentHookWithCount&gt; intentHooks =</span><br><span class=\"line\">            new HashMap&lt;ActivityIntentFilter, IntentHookWithCount&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static CalabashAutomation calabashAutomation;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Instrumentation does not belong to this class. Here because of old architecture */</span><br><span class=\"line\">    public static Instrumentation instrumentation;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SoloEnhanced solo;</span><br><span class=\"line\">    public static Actions actions;</span><br><span class=\"line\">    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>solo实际是com.jayway.android.robotium.solo.SoloEnhanced类。看到这里应该明白了，Calabash-android对UI的操作核心其实借助以Robotium来做的。</p>\n<p><em>Robotium是一款国外的Android自动化测试框架，主要针对Android平台的应用进行黑盒自动化测试，它提供了模拟各种手势操作（点击、长按、滑动等）、查找和断言机制的API，能够对各种控件进行操作</em></p>\n<p><strong>哦，还要提一点，Calabash不支持跨进程的原有就在于Robotium不支持跨进程，所以让Calabash支持跨进程的契机就在这里，修改其源码，调用uiautomator的API即可，具体可行性和方式还待探索，如果你有兴趣，不妨我们一起研究呀</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>OK，大概就是这样了，Calabash进阶部分会随时更新，修改Calabash-android-server源码进行扩展的方法我也会继续研究下去，成功以后会随时更新博客。</p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p>《Calabash探索3-Calabash进阶》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>"},{"title":"Calabash探索4-Calabash踩坑总结","date":"2017-03-16T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n\n## 前言\n\n为了保证前面几章阅读上的流程度，我们将Calabash从环境搭建到具体使用中所遇到的所有问题做了一个总结，这里大部分是我实际所经历的坑，同时我也会尽可能的收录一下我在学习过程中从别的博客看到的问题。\n\n\n<!-- more -->\n\n## 坑1：Calabash安装时Ruby报错\n\n```\n$ sudo gem install calabash-android\nPassword:\nBuilding natie extensions. This could take a while...\nRROR: Failed to build gem native extension.\n\n    /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb\n\tmkmf.rb can't find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/include/ruby.h\n```\n\n好像大部分人都不会遇到这个问题，虽然看着像是Ruby缺了一个头文件，但实际问题不在于Ruby。\n\n执行下面命令：\n\n\t$ xcode-select --install\n    \n安装xcode就OK了！看样子是ruby依赖了xcode？心塞~\n\n\n## 坑2：Could not find an Android SDK please make it is install\n\n```\nNo test server found for this combination of app and calabash version.Recreating test server\nERROR:Could not find an Android SDK please make it is install\n...\n\n```\n其他JDK,ANT问题同理。\n\n首先确保你确实安装了Android SDK,并且正确配置了环境变量。\n如果已经确认了什么问题都没有，还是报这个错。\n执行命令：\n\n\t$.bash_profile\n \n还是报这个错？ 哈哈哈，下面就要出绝招了：**重启大法好啊~**\n恩，重启下电脑应该就可以了\n\n\n## 坑3：App did not start 或 WARN:Did not find 'android.jar'...\n\n```\nWARN: Did not find 'android.jar' in any standard directory of '.../sdk/platforms'.Calabash will therefore take longer to load\nFeature: /**\n\tScenario: /**\n    App did not start(RuntimeError)\n    ./feature/support/app_life_cycle_hooks.rb:5:in'Before'\n    ...\n```\n\n首先确认手机或虚拟机以链接到电脑，并且调试模式什么的都开了。\n确认App配置中是否赋予了网络权限,以Android为例\n\nmanifest.xml文件：\n\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n    \n\n\n## 坑4：\\**.apk is not signed with any of the available keystores\n\n```\nNo test server found for this combination of app and calabash version.Recreating test server\n**.apk is not signed with any of the available keystores\n\n```\n\n这个其实不算是坑，Calabash测试apk需要重新对其进行签名才可，按照错误提示或官方文档就可以解决这个问题，这个教程太多啦，就不熬述了。[付官方解决方案](https://github.com/calabash/calabash-android/wiki/Running-Calabash-Android)。\n\n\n## 坑5：Calabash自定义的Steps,执行过程中提示未定义\n\n```\nYou can implement step definitions for undefined steps with these snippets:\n\nThen /^I through welcomePages $/ do\n  pending # Write code here that turns the phrase above into concrete actions\nend\n```\n\n我写的没毛病啊，怎么就一直提示未定义呢？\n如果你也遇到了这个问题，请先严格检查自己的代码有没有问题！如果检查一切都没有问题，就看看是不也犯了我这个错误！我觉得一般人都范不了我这个错误……\n\n最开始我的定义是这样写的：\n\n```\nThen /^I through welcomePages $/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n好像看着也没毛病是吧？问题在这里``Then /^I through welcomePages $/ do`` 末尾``$``符前不能有空格！！！\n\n改为下面这样就可以了！\n\n```\nThen /^I through welcomePages$/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n</br>\n\n ------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n《Calabash探索4-Calabash踩坑总结》\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Calabash探索4-Calabash踩坑总结.md","raw":"\n---\ntitle: Calabash探索4-Calabash踩坑总结\ndate: 2017-3-16 16:20:58\nauthor : 暴打小女孩\n\ntags: 测试\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n\n## 前言\n\n为了保证前面几章阅读上的流程度，我们将Calabash从环境搭建到具体使用中所遇到的所有问题做了一个总结，这里大部分是我实际所经历的坑，同时我也会尽可能的收录一下我在学习过程中从别的博客看到的问题。\n\n\n<!-- more -->\n\n## 坑1：Calabash安装时Ruby报错\n\n```\n$ sudo gem install calabash-android\nPassword:\nBuilding natie extensions. This could take a while...\nRROR: Failed to build gem native extension.\n\n    /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb\n\tmkmf.rb can't find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/include/ruby.h\n```\n\n好像大部分人都不会遇到这个问题，虽然看着像是Ruby缺了一个头文件，但实际问题不在于Ruby。\n\n执行下面命令：\n\n\t$ xcode-select --install\n    \n安装xcode就OK了！看样子是ruby依赖了xcode？心塞~\n\n\n## 坑2：Could not find an Android SDK please make it is install\n\n```\nNo test server found for this combination of app and calabash version.Recreating test server\nERROR:Could not find an Android SDK please make it is install\n...\n\n```\n其他JDK,ANT问题同理。\n\n首先确保你确实安装了Android SDK,并且正确配置了环境变量。\n如果已经确认了什么问题都没有，还是报这个错。\n执行命令：\n\n\t$.bash_profile\n \n还是报这个错？ 哈哈哈，下面就要出绝招了：**重启大法好啊~**\n恩，重启下电脑应该就可以了\n\n\n## 坑3：App did not start 或 WARN:Did not find 'android.jar'...\n\n```\nWARN: Did not find 'android.jar' in any standard directory of '.../sdk/platforms'.Calabash will therefore take longer to load\nFeature: /**\n\tScenario: /**\n    App did not start(RuntimeError)\n    ./feature/support/app_life_cycle_hooks.rb:5:in'Before'\n    ...\n```\n\n首先确认手机或虚拟机以链接到电脑，并且调试模式什么的都开了。\n确认App配置中是否赋予了网络权限,以Android为例\n\nmanifest.xml文件：\n\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n    \n\n\n## 坑4：\\**.apk is not signed with any of the available keystores\n\n```\nNo test server found for this combination of app and calabash version.Recreating test server\n**.apk is not signed with any of the available keystores\n\n```\n\n这个其实不算是坑，Calabash测试apk需要重新对其进行签名才可，按照错误提示或官方文档就可以解决这个问题，这个教程太多啦，就不熬述了。[付官方解决方案](https://github.com/calabash/calabash-android/wiki/Running-Calabash-Android)。\n\n\n## 坑5：Calabash自定义的Steps,执行过程中提示未定义\n\n```\nYou can implement step definitions for undefined steps with these snippets:\n\nThen /^I through welcomePages $/ do\n  pending # Write code here that turns the phrase above into concrete actions\nend\n```\n\n我写的没毛病啊，怎么就一直提示未定义呢？\n如果你也遇到了这个问题，请先严格检查自己的代码有没有问题！如果检查一切都没有问题，就看看是不也犯了我这个错误！我觉得一般人都范不了我这个错误……\n\n最开始我的定义是这样写的：\n\n```\nThen /^I through welcomePages $/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n好像看着也没毛病是吧？问题在这里``Then /^I through welcomePages $/ do`` 末尾``$``符前不能有空格！！！\n\n改为下面这样就可以了！\n\n```\nThen /^I through welcomePages$/ do\n\tThen I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \n    Then I drag from 90:50 to 20:50 moving with 20 steps \nend\n```\n\n</br>\n\n ------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n《Calabash探索4-Calabash踩坑总结》\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Calabash探索4-Calabash踩坑总结","published":1,"updated":"2019-01-02T02:09:31.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsou0008yo9sejkd4ae0","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了保证前面几章阅读上的流程度，我们将Calabash从环境搭建到具体使用中所遇到的所有问题做了一个总结，这里大部分是我实际所经历的坑，同时我也会尽可能的收录一下我在学习过程中从别的博客看到的问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"坑1：Calabash安装时Ruby报错\"><a href=\"#坑1：Calabash安装时Ruby报错\" class=\"headerlink\" title=\"坑1：Calabash安装时Ruby报错\"></a>坑1：Calabash安装时Ruby报错</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install calabash-android</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Building natie extensions. This could take a while...</span><br><span class=\"line\">RROR: Failed to build gem native extension.</span><br><span class=\"line\"></span><br><span class=\"line\">    /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb</span><br><span class=\"line\">\tmkmf.rb can&apos;t find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/include/ruby.h</span><br></pre></td></tr></table></figure>\n<p>好像大部分人都不会遇到这个问题，虽然看着像是Ruby缺了一个头文件，但实际问题不在于Ruby。</p>\n<p>执行下面命令：</p>\n<pre><code>$ xcode-select --install\n</code></pre><p>安装xcode就OK了！看样子是ruby依赖了xcode？心塞~</p>\n<h2 id=\"坑2：Could-not-find-an-Android-SDK-please-make-it-is-install\"><a href=\"#坑2：Could-not-find-an-Android-SDK-please-make-it-is-install\" class=\"headerlink\" title=\"坑2：Could not find an Android SDK please make it is install\"></a>坑2：Could not find an Android SDK please make it is install</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No test server found for this combination of app and calabash version.Recreating test server</span><br><span class=\"line\">ERROR:Could not find an Android SDK please make it is install</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>其他JDK,ANT问题同理。</p>\n<p>首先确保你确实安装了Android SDK,并且正确配置了环境变量。<br>如果已经确认了什么问题都没有，还是报这个错。<br>执行命令：</p>\n<pre><code>$.bash_profile\n</code></pre><p>还是报这个错？ 哈哈哈，下面就要出绝招了：<strong>重启大法好啊~</strong><br>恩，重启下电脑应该就可以了</p>\n<h2 id=\"坑3：App-did-not-start-或-WARN-Did-not-find-‘android-jar’…\"><a href=\"#坑3：App-did-not-start-或-WARN-Did-not-find-‘android-jar’…\" class=\"headerlink\" title=\"坑3：App did not start 或 WARN:Did not find ‘android.jar’…\"></a>坑3：App did not start 或 WARN:Did not find ‘android.jar’…</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARN: Did not find &apos;android.jar&apos; in any standard directory of &apos;.../sdk/platforms&apos;.Calabash will therefore take longer to load</span><br><span class=\"line\">Feature: /**</span><br><span class=\"line\">\tScenario: /**</span><br><span class=\"line\">    App did not start(RuntimeError)</span><br><span class=\"line\">    ./feature/support/app_life_cycle_hooks.rb:5:in&apos;Before&apos;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>首先确认手机或虚拟机以链接到电脑，并且调试模式什么的都开了。<br>确认App配置中是否赋予了网络权限,以Android为例</p>\n<p>manifest.xml文件：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n</code></pre><h2 id=\"坑4：-apk-is-not-signed-with-any-of-the-available-keystores\"><a href=\"#坑4：-apk-is-not-signed-with-any-of-the-available-keystores\" class=\"headerlink\" title=\"坑4：**.apk is not signed with any of the available keystores\"></a>坑4：**.apk is not signed with any of the available keystores</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No test server found for this combination of app and calabash version.Recreating test server</span><br><span class=\"line\">**.apk is not signed with any of the available keystores</span><br></pre></td></tr></table></figure>\n<p>这个其实不算是坑，Calabash测试apk需要重新对其进行签名才可，按照错误提示或官方文档就可以解决这个问题，这个教程太多啦，就不熬述了。<a href=\"https://github.com/calabash/calabash-android/wiki/Running-Calabash-Android\" target=\"_blank\" rel=\"noopener\">付官方解决方案</a>。</p>\n<h2 id=\"坑5：Calabash自定义的Steps-执行过程中提示未定义\"><a href=\"#坑5：Calabash自定义的Steps-执行过程中提示未定义\" class=\"headerlink\" title=\"坑5：Calabash自定义的Steps,执行过程中提示未定义\"></a>坑5：Calabash自定义的Steps,执行过程中提示未定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You can implement step definitions for undefined steps with these snippets:</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I through welcomePages $/ do</span><br><span class=\"line\">  pending # Write code here that turns the phrase above into concrete actions</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>我写的没毛病啊，怎么就一直提示未定义呢？<br>如果你也遇到了这个问题，请先严格检查自己的代码有没有问题！如果检查一切都没有问题，就看看是不也犯了我这个错误！我觉得一般人都范不了我这个错误……</p>\n<p>最开始我的定义是这样写的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages $/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>好像看着也没毛病是吧？问题在这里<code>Then /^I through welcomePages $/ do</code> 末尾<code>$</code>符前不能有空格！！！</p>\n<p>改为下面这样就可以了！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p>《Calabash探索4-Calabash踩坑总结》</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了保证前面几章阅读上的流程度，我们将Calabash从环境搭建到具体使用中所遇到的所有问题做了一个总结，这里大部分是我实际所经历的坑，同时我也会尽可能的收录一下我在学习过程中从别的博客看到的问题。</p>","more":"<h2 id=\"坑1：Calabash安装时Ruby报错\"><a href=\"#坑1：Calabash安装时Ruby报错\" class=\"headerlink\" title=\"坑1：Calabash安装时Ruby报错\"></a>坑1：Calabash安装时Ruby报错</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo gem install calabash-android</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Building natie extensions. This could take a while...</span><br><span class=\"line\">RROR: Failed to build gem native extension.</span><br><span class=\"line\"></span><br><span class=\"line\">    /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb</span><br><span class=\"line\">\tmkmf.rb can&apos;t find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/include/ruby.h</span><br></pre></td></tr></table></figure>\n<p>好像大部分人都不会遇到这个问题，虽然看着像是Ruby缺了一个头文件，但实际问题不在于Ruby。</p>\n<p>执行下面命令：</p>\n<pre><code>$ xcode-select --install\n</code></pre><p>安装xcode就OK了！看样子是ruby依赖了xcode？心塞~</p>\n<h2 id=\"坑2：Could-not-find-an-Android-SDK-please-make-it-is-install\"><a href=\"#坑2：Could-not-find-an-Android-SDK-please-make-it-is-install\" class=\"headerlink\" title=\"坑2：Could not find an Android SDK please make it is install\"></a>坑2：Could not find an Android SDK please make it is install</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No test server found for this combination of app and calabash version.Recreating test server</span><br><span class=\"line\">ERROR:Could not find an Android SDK please make it is install</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>其他JDK,ANT问题同理。</p>\n<p>首先确保你确实安装了Android SDK,并且正确配置了环境变量。<br>如果已经确认了什么问题都没有，还是报这个错。<br>执行命令：</p>\n<pre><code>$.bash_profile\n</code></pre><p>还是报这个错？ 哈哈哈，下面就要出绝招了：<strong>重启大法好啊~</strong><br>恩，重启下电脑应该就可以了</p>\n<h2 id=\"坑3：App-did-not-start-或-WARN-Did-not-find-‘android-jar’…\"><a href=\"#坑3：App-did-not-start-或-WARN-Did-not-find-‘android-jar’…\" class=\"headerlink\" title=\"坑3：App did not start 或 WARN:Did not find ‘android.jar’…\"></a>坑3：App did not start 或 WARN:Did not find ‘android.jar’…</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARN: Did not find &apos;android.jar&apos; in any standard directory of &apos;.../sdk/platforms&apos;.Calabash will therefore take longer to load</span><br><span class=\"line\">Feature: /**</span><br><span class=\"line\">\tScenario: /**</span><br><span class=\"line\">    App did not start(RuntimeError)</span><br><span class=\"line\">    ./feature/support/app_life_cycle_hooks.rb:5:in&apos;Before&apos;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>首先确认手机或虚拟机以链接到电脑，并且调试模式什么的都开了。<br>确认App配置中是否赋予了网络权限,以Android为例</p>\n<p>manifest.xml文件：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n</code></pre><h2 id=\"坑4：-apk-is-not-signed-with-any-of-the-available-keystores\"><a href=\"#坑4：-apk-is-not-signed-with-any-of-the-available-keystores\" class=\"headerlink\" title=\"坑4：**.apk is not signed with any of the available keystores\"></a>坑4：**.apk is not signed with any of the available keystores</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No test server found for this combination of app and calabash version.Recreating test server</span><br><span class=\"line\">**.apk is not signed with any of the available keystores</span><br></pre></td></tr></table></figure>\n<p>这个其实不算是坑，Calabash测试apk需要重新对其进行签名才可，按照错误提示或官方文档就可以解决这个问题，这个教程太多啦，就不熬述了。<a href=\"https://github.com/calabash/calabash-android/wiki/Running-Calabash-Android\" target=\"_blank\" rel=\"noopener\">付官方解决方案</a>。</p>\n<h2 id=\"坑5：Calabash自定义的Steps-执行过程中提示未定义\"><a href=\"#坑5：Calabash自定义的Steps-执行过程中提示未定义\" class=\"headerlink\" title=\"坑5：Calabash自定义的Steps,执行过程中提示未定义\"></a>坑5：Calabash自定义的Steps,执行过程中提示未定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You can implement step definitions for undefined steps with these snippets:</span><br><span class=\"line\"></span><br><span class=\"line\">Then /^I through welcomePages $/ do</span><br><span class=\"line\">  pending # Write code here that turns the phrase above into concrete actions</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>我写的没毛病啊，怎么就一直提示未定义呢？<br>如果你也遇到了这个问题，请先严格检查自己的代码有没有问题！如果检查一切都没有问题，就看看是不也犯了我这个错误！我觉得一般人都范不了我这个错误……</p>\n<p>最开始我的定义是这样写的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages $/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>好像看着也没毛病是吧？问题在这里<code>Then /^I through welcomePages $/ do</code> 末尾<code>$</code>符前不能有空格！！！</p>\n<p>改为下面这样就可以了！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I through welcomePages$/ do</span><br><span class=\"line\">\tThen I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">    Then I drag from 90:50 to 20:50 moving with 20 steps </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p>《Calabash探索4-Calabash踩坑总结》</p>"},{"title":"Java内存管理的一些小疑问","date":"2017-05-08T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n\n一直以来都在接受一个论调：在Java的内存管理中，基础类型变量保存在栈中，对象类型保存在堆中。\n这其实是一个很粗的论调，会引起很多错误的理解。\n\n这篇博客的产出，仅是因为脑子里偶然间冒出来的一个问题：java栈内存的内存回收是怎么做的？\n因为这个问题，引发了一系列的小问题：所有的基础类型变量都保存在栈中吗？栈和堆上都在运行着我们熟悉的GC吗？怎么都感觉GC算法在栈这种结构上没法跑啊……堆内存，栈内存究竟是什么样的？\n\n\n<!-- more -->\n\n这里我非常推荐你阅读一本关于java虚拟机的书：《深入理解java虚拟机》 -- 周志明\n\n\n## Java栈内存\n\n\nJava栈内存的内存回收是怎么做的？似乎因为这个问题太小白了，大部分关于JAVA GC的博客都不会特别的指明，GC是运行在JAVA内存堆上的。但也是因为这个原因，对于一些基础知识不太好的小白（比如我），看多了这种博客之后，想当然的认为了GC负责了整个java内存的管理，好像~栈内存也是由GC进行回收的……（毕竟栈的全名还叫堆栈呢）\n\n当有一天我翅膀硬了点，突然醒悟，栈这种只能在一头进出的数据结构，跑的是什么GC算法？？？如此简单的数据结构，也不需要GC了吧？\n\n终于在查阅了很多资料后，确认了一个问题：**GC运行在JAVA堆上，负责java堆内存的回收。**\n\n那么确认这个大前提下，后面接二连三的问题就都冒出来了：**栈内存是怎么进行内存回收的？所有的基础类型变量都保存在栈内存中吗？** \n\n栈嘛，仅允许在线性表的一端进行插入和删除运算，所以分配内存就在栈顶插进去一块，回收，就从栈顶取出来。\n\n这种管理结构，从方法的角度其实很容易理解，我们看下面一段伪代码：\n\n```\n\tpublic void main(){\n    \tmethod1();\n    }\n\n\tpublic void method1(){\n    \t...\n        method2();\n    }\n    \n    public void method2(){\n    \t...\n        method3();\n    }\n    \n    public void method3(){\n    \t...\n        //end\n    }\n\n```\n\n代码很简单，main方法调用了method1,method2调用了method3，method3结束了。用图的形式更直观：\n\n从main方法开始执行，各方法依次入栈，每个方法执行的同时，都会创建一个栈帧，然后进入虚拟机栈。\n![](Java内存管理的一些小疑问/method_start.png)\n\nmethod3方法执行结束后，各方法（栈帧）依次出栈：\n\n![](Java内存管理的一些小疑问/method_end.png)\n\n\n这就是java栈内存，用《深入理解java虚拟机》一段话来描述：\n\n*java虚拟机栈也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模式：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。*\n\nOK，到这里我们基本上可以解决第二个问题：**java栈内存的内存回收就是利用方法和栈的特性来做的！**\n\n那么第三个问题：**所有的基础类型变量都保存在栈中吗？**\n\n其实这个问题已经不太需要再查资料验证了，我们自己就可以分析出结果。\n栈内存主要描述的是java方法执行的内存模型，一个方法内部的局部变量生命周期跟随方法的开始和结束，管理起来非常简单，所以方法内部的局部变量保存在栈中没毛病！\n但是对象内部的基础类型成员变量呢？这个生命周期就比较复杂了，有明确的开始却没有明确的结束，放到栈中明显无法管理。所以，**只有方法内的基础类型变量才会保存在栈中！**\n\n第四个问题：**我们知道栈的回收效率和速度远大于堆，为什么这一块的管理如此简单快速呢？**\n\n继续引用《深入理解java虚拟机》一段话来描述java栈内存：\n\n*经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙，java内存区域的划分实际上远比这发杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。*\n\n*局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。\n其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。*\n\n第五个问题：**如此简单高效的栈内存，会内存溢出吗？**\n\n虽然大部分虚拟机的栈都可以动态扩展，但也并不是无限的。虽然栈溢出的情况比较小，但当有大量方法调用时非常有可能引起栈溢出，非常典型的案例就是递归调用。\n\n\n\n## 总结\n\n解决了两个常见的误解或没有关注的点：GC运行在栈还是堆还是两者都有；所有基本类型变量都保存在栈中吗？\n\njava GC仅运行在堆内存上，回收效率较低。\n栈内存仅描述了java方法的内存模型，每个方法所需的内存空间在编译器就已经确认，利用栈的特性完成内存分配和回收。\n基础类型变量仅方法内的局部变量保存在栈内存中，成员变量保存在堆中。\n\n虽然没有定量的标准，也没有办法得出优化前后的对比量。但在开发中，我们应该有意识的减少成员变量，如果数据可以在方法间传递，就没有必要利用成员变量做中间状态保存。同时业务开发避免方法的递归调用。\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java内存管理的一些小疑问.md","raw":"\n---\ntitle: Java内存管理的一些小疑问\ndate: 2017-5-8 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n\n一直以来都在接受一个论调：在Java的内存管理中，基础类型变量保存在栈中，对象类型保存在堆中。\n这其实是一个很粗的论调，会引起很多错误的理解。\n\n这篇博客的产出，仅是因为脑子里偶然间冒出来的一个问题：java栈内存的内存回收是怎么做的？\n因为这个问题，引发了一系列的小问题：所有的基础类型变量都保存在栈中吗？栈和堆上都在运行着我们熟悉的GC吗？怎么都感觉GC算法在栈这种结构上没法跑啊……堆内存，栈内存究竟是什么样的？\n\n\n<!-- more -->\n\n这里我非常推荐你阅读一本关于java虚拟机的书：《深入理解java虚拟机》 -- 周志明\n\n\n## Java栈内存\n\n\nJava栈内存的内存回收是怎么做的？似乎因为这个问题太小白了，大部分关于JAVA GC的博客都不会特别的指明，GC是运行在JAVA内存堆上的。但也是因为这个原因，对于一些基础知识不太好的小白（比如我），看多了这种博客之后，想当然的认为了GC负责了整个java内存的管理，好像~栈内存也是由GC进行回收的……（毕竟栈的全名还叫堆栈呢）\n\n当有一天我翅膀硬了点，突然醒悟，栈这种只能在一头进出的数据结构，跑的是什么GC算法？？？如此简单的数据结构，也不需要GC了吧？\n\n终于在查阅了很多资料后，确认了一个问题：**GC运行在JAVA堆上，负责java堆内存的回收。**\n\n那么确认这个大前提下，后面接二连三的问题就都冒出来了：**栈内存是怎么进行内存回收的？所有的基础类型变量都保存在栈内存中吗？** \n\n栈嘛，仅允许在线性表的一端进行插入和删除运算，所以分配内存就在栈顶插进去一块，回收，就从栈顶取出来。\n\n这种管理结构，从方法的角度其实很容易理解，我们看下面一段伪代码：\n\n```\n\tpublic void main(){\n    \tmethod1();\n    }\n\n\tpublic void method1(){\n    \t...\n        method2();\n    }\n    \n    public void method2(){\n    \t...\n        method3();\n    }\n    \n    public void method3(){\n    \t...\n        //end\n    }\n\n```\n\n代码很简单，main方法调用了method1,method2调用了method3，method3结束了。用图的形式更直观：\n\n从main方法开始执行，各方法依次入栈，每个方法执行的同时，都会创建一个栈帧，然后进入虚拟机栈。\n![](Java内存管理的一些小疑问/method_start.png)\n\nmethod3方法执行结束后，各方法（栈帧）依次出栈：\n\n![](Java内存管理的一些小疑问/method_end.png)\n\n\n这就是java栈内存，用《深入理解java虚拟机》一段话来描述：\n\n*java虚拟机栈也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模式：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。*\n\nOK，到这里我们基本上可以解决第二个问题：**java栈内存的内存回收就是利用方法和栈的特性来做的！**\n\n那么第三个问题：**所有的基础类型变量都保存在栈中吗？**\n\n其实这个问题已经不太需要再查资料验证了，我们自己就可以分析出结果。\n栈内存主要描述的是java方法执行的内存模型，一个方法内部的局部变量生命周期跟随方法的开始和结束，管理起来非常简单，所以方法内部的局部变量保存在栈中没毛病！\n但是对象内部的基础类型成员变量呢？这个生命周期就比较复杂了，有明确的开始却没有明确的结束，放到栈中明显无法管理。所以，**只有方法内的基础类型变量才会保存在栈中！**\n\n第四个问题：**我们知道栈的回收效率和速度远大于堆，为什么这一块的管理如此简单快速呢？**\n\n继续引用《深入理解java虚拟机》一段话来描述java栈内存：\n\n*经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙，java内存区域的划分实际上远比这发杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。*\n\n*局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。\n其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。*\n\n第五个问题：**如此简单高效的栈内存，会内存溢出吗？**\n\n虽然大部分虚拟机的栈都可以动态扩展，但也并不是无限的。虽然栈溢出的情况比较小，但当有大量方法调用时非常有可能引起栈溢出，非常典型的案例就是递归调用。\n\n\n\n## 总结\n\n解决了两个常见的误解或没有关注的点：GC运行在栈还是堆还是两者都有；所有基本类型变量都保存在栈中吗？\n\njava GC仅运行在堆内存上，回收效率较低。\n栈内存仅描述了java方法的内存模型，每个方法所需的内存空间在编译器就已经确认，利用栈的特性完成内存分配和回收。\n基础类型变量仅方法内的局部变量保存在栈内存中，成员变量保存在堆中。\n\n虽然没有定量的标准，也没有办法得出优化前后的对比量。但在开发中，我们应该有意识的减少成员变量，如果数据可以在方法间传递，就没有必要利用成员变量做中间状态保存。同时业务开发避免方法的递归调用。\n\n\n\n\n\n\n\n\n\n","slug":"Java内存管理的一些小疑问","published":1,"updated":"2019-01-02T02:09:31.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsov0009yo9sxtho4a6r","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一直以来都在接受一个论调：在Java的内存管理中，基础类型变量保存在栈中，对象类型保存在堆中。<br>这其实是一个很粗的论调，会引起很多错误的理解。</p>\n<p>这篇博客的产出，仅是因为脑子里偶然间冒出来的一个问题：java栈内存的内存回收是怎么做的？<br>因为这个问题，引发了一系列的小问题：所有的基础类型变量都保存在栈中吗？栈和堆上都在运行着我们熟悉的GC吗？怎么都感觉GC算法在栈这种结构上没法跑啊……堆内存，栈内存究竟是什么样的？</p>\n<a id=\"more\"></a>\n<p>这里我非常推荐你阅读一本关于java虚拟机的书：《深入理解java虚拟机》 – 周志明</p>\n<h2 id=\"Java栈内存\"><a href=\"#Java栈内存\" class=\"headerlink\" title=\"Java栈内存\"></a>Java栈内存</h2><p>Java栈内存的内存回收是怎么做的？似乎因为这个问题太小白了，大部分关于JAVA GC的博客都不会特别的指明，GC是运行在JAVA内存堆上的。但也是因为这个原因，对于一些基础知识不太好的小白（比如我），看多了这种博客之后，想当然的认为了GC负责了整个java内存的管理，好像~栈内存也是由GC进行回收的……（毕竟栈的全名还叫堆栈呢）</p>\n<p>当有一天我翅膀硬了点，突然醒悟，栈这种只能在一头进出的数据结构，跑的是什么GC算法？？？如此简单的数据结构，也不需要GC了吧？</p>\n<p>终于在查阅了很多资料后，确认了一个问题：<strong>GC运行在JAVA堆上，负责java堆内存的回收。</strong></p>\n<p>那么确认这个大前提下，后面接二连三的问题就都冒出来了：<strong>栈内存是怎么进行内存回收的？所有的基础类型变量都保存在栈内存中吗？</strong> </p>\n<p>栈嘛，仅允许在线性表的一端进行插入和删除运算，所以分配内存就在栈顶插进去一块，回收，就从栈顶取出来。</p>\n<p>这种管理结构，从方法的角度其实很容易理解，我们看下面一段伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void main()&#123;</span><br><span class=\"line\">   \tmethod1();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void method1()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       method2();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   public void method2()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       method3();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   public void method3()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       //end</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，main方法调用了method1,method2调用了method3，method3结束了。用图的形式更直观：</p>\n<p>从main方法开始执行，各方法依次入栈，每个方法执行的同时，都会创建一个栈帧，然后进入虚拟机栈。<br><img src=\"/2017/05/08/Java内存管理的一些小疑问/method_start.png\" alt=\"\"></p>\n<p>method3方法执行结束后，各方法（栈帧）依次出栈：</p>\n<p><img src=\"/2017/05/08/Java内存管理的一些小疑问/method_end.png\" alt=\"\"></p>\n<p>这就是java栈内存，用《深入理解java虚拟机》一段话来描述：</p>\n<p><em>java虚拟机栈也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模式：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</em></p>\n<p>OK，到这里我们基本上可以解决第二个问题：<strong>java栈内存的内存回收就是利用方法和栈的特性来做的！</strong></p>\n<p>那么第三个问题：<strong>所有的基础类型变量都保存在栈中吗？</strong></p>\n<p>其实这个问题已经不太需要再查资料验证了，我们自己就可以分析出结果。<br>栈内存主要描述的是java方法执行的内存模型，一个方法内部的局部变量生命周期跟随方法的开始和结束，管理起来非常简单，所以方法内部的局部变量保存在栈中没毛病！<br>但是对象内部的基础类型成员变量呢？这个生命周期就比较复杂了，有明确的开始却没有明确的结束，放到栈中明显无法管理。所以，<strong>只有方法内的基础类型变量才会保存在栈中！</strong></p>\n<p>第四个问题：<strong>我们知道栈的回收效率和速度远大于堆，为什么这一块的管理如此简单快速呢？</strong></p>\n<p>继续引用《深入理解java虚拟机》一段话来描述java栈内存：</p>\n<p><em>经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙，java内存区域的划分实际上远比这发杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</em></p>\n<p><em>局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</em></p>\n<p>第五个问题：<strong>如此简单高效的栈内存，会内存溢出吗？</strong></p>\n<p>虽然大部分虚拟机的栈都可以动态扩展，但也并不是无限的。虽然栈溢出的情况比较小，但当有大量方法调用时非常有可能引起栈溢出，非常典型的案例就是递归调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>解决了两个常见的误解或没有关注的点：GC运行在栈还是堆还是两者都有；所有基本类型变量都保存在栈中吗？</p>\n<p>java GC仅运行在堆内存上，回收效率较低。<br>栈内存仅描述了java方法的内存模型，每个方法所需的内存空间在编译器就已经确认，利用栈的特性完成内存分配和回收。<br>基础类型变量仅方法内的局部变量保存在栈内存中，成员变量保存在堆中。</p>\n<p>虽然没有定量的标准，也没有办法得出优化前后的对比量。但在开发中，我们应该有意识的减少成员变量，如果数据可以在方法间传递，就没有必要利用成员变量做中间状态保存。同时业务开发避免方法的递归调用。</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一直以来都在接受一个论调：在Java的内存管理中，基础类型变量保存在栈中，对象类型保存在堆中。<br>这其实是一个很粗的论调，会引起很多错误的理解。</p>\n<p>这篇博客的产出，仅是因为脑子里偶然间冒出来的一个问题：java栈内存的内存回收是怎么做的？<br>因为这个问题，引发了一系列的小问题：所有的基础类型变量都保存在栈中吗？栈和堆上都在运行着我们熟悉的GC吗？怎么都感觉GC算法在栈这种结构上没法跑啊……堆内存，栈内存究竟是什么样的？</p>","more":"<p>这里我非常推荐你阅读一本关于java虚拟机的书：《深入理解java虚拟机》 – 周志明</p>\n<h2 id=\"Java栈内存\"><a href=\"#Java栈内存\" class=\"headerlink\" title=\"Java栈内存\"></a>Java栈内存</h2><p>Java栈内存的内存回收是怎么做的？似乎因为这个问题太小白了，大部分关于JAVA GC的博客都不会特别的指明，GC是运行在JAVA内存堆上的。但也是因为这个原因，对于一些基础知识不太好的小白（比如我），看多了这种博客之后，想当然的认为了GC负责了整个java内存的管理，好像~栈内存也是由GC进行回收的……（毕竟栈的全名还叫堆栈呢）</p>\n<p>当有一天我翅膀硬了点，突然醒悟，栈这种只能在一头进出的数据结构，跑的是什么GC算法？？？如此简单的数据结构，也不需要GC了吧？</p>\n<p>终于在查阅了很多资料后，确认了一个问题：<strong>GC运行在JAVA堆上，负责java堆内存的回收。</strong></p>\n<p>那么确认这个大前提下，后面接二连三的问题就都冒出来了：<strong>栈内存是怎么进行内存回收的？所有的基础类型变量都保存在栈内存中吗？</strong> </p>\n<p>栈嘛，仅允许在线性表的一端进行插入和删除运算，所以分配内存就在栈顶插进去一块，回收，就从栈顶取出来。</p>\n<p>这种管理结构，从方法的角度其实很容易理解，我们看下面一段伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void main()&#123;</span><br><span class=\"line\">   \tmethod1();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void method1()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       method2();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   public void method2()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       method3();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   public void method3()&#123;</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">       //end</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，main方法调用了method1,method2调用了method3，method3结束了。用图的形式更直观：</p>\n<p>从main方法开始执行，各方法依次入栈，每个方法执行的同时，都会创建一个栈帧，然后进入虚拟机栈。<br><img src=\"/2017/05/08/Java内存管理的一些小疑问/method_start.png\" alt=\"\"></p>\n<p>method3方法执行结束后，各方法（栈帧）依次出栈：</p>\n<p><img src=\"/2017/05/08/Java内存管理的一些小疑问/method_end.png\" alt=\"\"></p>\n<p>这就是java栈内存，用《深入理解java虚拟机》一段话来描述：</p>\n<p><em>java虚拟机栈也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模式：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</em></p>\n<p>OK，到这里我们基本上可以解决第二个问题：<strong>java栈内存的内存回收就是利用方法和栈的特性来做的！</strong></p>\n<p>那么第三个问题：<strong>所有的基础类型变量都保存在栈中吗？</strong></p>\n<p>其实这个问题已经不太需要再查资料验证了，我们自己就可以分析出结果。<br>栈内存主要描述的是java方法执行的内存模型，一个方法内部的局部变量生命周期跟随方法的开始和结束，管理起来非常简单，所以方法内部的局部变量保存在栈中没毛病！<br>但是对象内部的基础类型成员变量呢？这个生命周期就比较复杂了，有明确的开始却没有明确的结束，放到栈中明显无法管理。所以，<strong>只有方法内的基础类型变量才会保存在栈中！</strong></p>\n<p>第四个问题：<strong>我们知道栈的回收效率和速度远大于堆，为什么这一块的管理如此简单快速呢？</strong></p>\n<p>继续引用《深入理解java虚拟机》一段话来描述java栈内存：</p>\n<p><em>经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙，java内存区域的划分实际上远比这发杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</em></p>\n<p><em>局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</em></p>\n<p>第五个问题：<strong>如此简单高效的栈内存，会内存溢出吗？</strong></p>\n<p>虽然大部分虚拟机的栈都可以动态扩展，但也并不是无限的。虽然栈溢出的情况比较小，但当有大量方法调用时非常有可能引起栈溢出，非常典型的案例就是递归调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>解决了两个常见的误解或没有关注的点：GC运行在栈还是堆还是两者都有；所有基本类型变量都保存在栈中吗？</p>\n<p>java GC仅运行在堆内存上，回收效率较低。<br>栈内存仅描述了java方法的内存模型，每个方法所需的内存空间在编译器就已经确认，利用栈的特性完成内存分配和回收。<br>基础类型变量仅方法内的局部变量保存在栈内存中，成员变量保存在堆中。</p>\n<p>虽然没有定量的标准，也没有办法得出优化前后的对比量。但在开发中，我们应该有意识的减少成员变量，如果数据可以在方法间传递，就没有必要利用成员变量做中间状态保存。同时业务开发避免方法的递归调用。</p>"},{"title":"Android过度绘制深度优化---View提前绘制","date":"2015-09-09T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 概述\n\n上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  **背景-background**（背景包括背景图片、颜色、形状、边框等等）。\n\n\n那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   **Android过度绘制深度优化---View提前绘制**\n\n先说原理：**不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！**\n\n<!-- more -->\n\n\n先上效果图：\n优化前   &  优化后：\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />        <img src=\"http://img.blog.csdn.net/20151103211244952\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />\n\n**Tips：**\n1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。\n2.优化后的图片，为了突出所以添加了带图案的背景图片\n\n**颜色说明：**\n优化前：\n\n- Window（无色） 绘制一次\n- 背景（蓝色） 绘制2次\n- Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次\n- 输入框本身，按钮文字 （红色） 绘制三次\n- 输入框内部文字 （深红色）  绘制四次\n\n优化后：\n\n- 背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。\n- Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。\n- 文本框上面的图片和文字（绿色）绘制三次\n\n## 要点\n\nView提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：\n\n- View的提前绘制只能应用到那些静态的View\n- View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）\n- 界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。**如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。**\n- 对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。**通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）**\n\n也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。\n\n另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：\n1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。\n2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？\n\n## 正文\n啊，好吧，废话说的有点多了，下面我们上代码。\n\nGithub链接：[https://github.com/lizhaoxuan/SoftWidgetDemo.git](https://github.com/lizhaoxuan/SoftWidgetDemo.git\n)\n\n首先看目录结构：\n\n<img src=\"http://img.blog.csdn.net/20151107151634177\" width = \"180\" height = \"230\" alt=\"图片名称\" align=center />\n\n有四个核心类：\nDrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。\nPaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状\n\nSRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局\n\n然后看布局文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    android:padding=\"10dp\">\n\t\n\t    <ImageView\n\t        android:id=\"@+id/logoView\"\n\t        android:layout_width=\"100dp\"\n\t        android:layout_height=\"100dp\"\n\t        android:layout_centerHorizontal=\"true\"\n\t        android:layout_marginTop=\"80dp\"\n\t        android:src=\"@drawable/logo\"/>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/accountLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"50dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/logoView\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_user\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/accountEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"账号\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\" />\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/passwordLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"3dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/accountLayout\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_password\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/passwordEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"密码\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\"\n\t            android:inputType=\"textPassword\"/>\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n\t        android:id=\"@+id/login_btn\"\n\t        android:layout_width=\"fill_parent\"\n\t        android:layout_height=\"50dp\"\n\t        android:layout_marginTop=\"20dp\"\n\t        android:layout_below=\"@id/passwordLayout\"\n\t        android:layout_alignLeft=\"@id/passwordLayout\"\n\t        android:layout_alignRight=\"@id/passwordLayout\"\n\t        android:layout_gravity=\"center\"\n\t        android:text=\"登录\"\n\t        android:textColor=\"@color/white\"\n\t        android:textSize=\"20sp\"\n\t        app:backgroundColor=\"#af0308\"/>\n\t\n\t\n\t    <TextView\n\t        android:id=\"@+id/forgetText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentLeft=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginLeft=\"10dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"忘记密码\"/>\n\t\n\t    <TextView\n\t        android:id=\"@+id/registerText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentRight=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"注册\"/>\n\t</RelativeLayout>\n\n这里要说一下：\n不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。\n不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。\nButton 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);\n\n通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。\n\n\n*DrawingCanvas.java:*\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Bitmap;\n\timport android.graphics.Canvas;\n\timport android.graphics.Rect;\n\timport android.graphics.RectF;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/11.\n\t * 在这上面进行提前绘制\n\t */\n\tpublic class DrawingCanvas extends Canvas {\n\t\n\t    private Bitmap output;\n\t    private Rect rect;\n\t    private RectF rectF;\n\t    private DrawingCanvas(Bitmap output_, float width_, float height_){\n\t        super(output_);\n\t        output = output_;\n\t        rect = new Rect(0,0,(int)width_,(int)height_);\n\t        rectF = new RectF(0, 0, width_, height_);\n\t    }\n\t\n\t    public static DrawingCanvas instance(float width_ , float height_){\n\t        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n\t                Bitmap.Config.ARGB_8888);\n\t        return new DrawingCanvas(bitmap,width_,height_);\n\t    }\n\t\n\t\n\t    public Bitmap getOutput(){\n\t        return output;\n\t    }\n\t    public Rect getRect(){\n\t        return rect;\n\t    }\n\t    public RectF getRectF(){\n\t        return rectF;\n\t    }\n\t}\n\n这个类继承了Canvas，并且已经传入一个Bitmap\t\t\t\n\n\t\tsuper(output_);\n所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。\n\n*PaintBox.java:*\n\n\t\n\t\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Paint;\n\t\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 用来画图的盒子，里面放着画图的方法\n\t */\n\tpublic class PaintBox {\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\t\n\t        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t        paint.setStyle(Paint.Style.FILL);\n\t        paint.setAntiAlias(true);\n\t        paint.setColor(color);\n\t        paint.setAlpha(alpha);\n\t        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t        \n\t    }\n\t\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     * @param border 带边框\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n\t        if(border){\n\t            Paint paint = new Paint();\n\t            paint.setStyle(Paint.Style.FILL);\n\t            paint.setAntiAlias(true);\n\t            paint.setColor(color);\n\t            paint.setAlpha(30);\n\t            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t            paint.setStyle(Paint.Style.STROKE);\n\t            paint.setAlpha(70);\n\t            paint.setStrokeWidth(4);\n\t            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n\t        }else{\n\t            drawRoundRect(canvas,color,alpha);\n\t        }\n\t\n\t\n\t    }\n\t\n\t    /**\n\t     * 填充颜色\n\t     * @param canvas \n\t     * @param color\n\t     */\n\t    public static void drawColor(DrawingCanvas canvas ,int color ){\n\t        Paint paint = new Paint();\n\t        paint.setAntiAlias(true);\n\t        paint.setFilterBitmap(true);\n\t        paint.setDither(true);\n\t        paint.setColor(color);\n\t        canvas.drawPaint(paint);\n\t    }\n\t\n\t\n\t    /**\n\t     * 写字在View正中间\n\t     * @param canvas  画布\n\t     * @param text   文字\n\t     * @param color  文字颜色\n\t     * @param size   文字大小\n\t     */\n\t    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n\t        //创建画笔\n\t        Paint pp = new Paint();\n\t        pp.setAntiAlias(true);\n\t        pp.setColor(color);\n\t        pp.setStrokeWidth(3);\n\t        pp.setTextSize(size);\n\t        pp.setTextAlign(Paint.Align.CENTER);\n\t        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n\t        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n\t        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n\t    }\n\t}\n\n这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。\n值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。\n\n最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.\n\n*SRoundRect_Button.java:*\n\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\t\n\timport android.content.Context;\n\timport android.content.res.Resources;\n\timport android.content.res.TypedArray;\n\timport android.graphics.Canvas;\n\timport android.util.AttributeSet;\n\timport android.widget.Button;\n\t\n\timport com.example.zhaoxuanli.softwidgetdemo.R;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n\t */\n\t\n\t//\n\t//字符编码 UTF-8  无BOM\n\tpublic class SRoundRect_Button extends Button {\n\t    private String text;\n\t    private int textColor;\n\t    private int textSize;\n\t    private int backgroundColor;\n\t    /**\n\t     * 提前绘制的画布\n\t     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n\t     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n\t     * 反编译Path源码后，这里是采用软引用的\n\t     */\n\t    private DrawingCanvas localDrawingCanvas;  \n\t\n\t    /**\n\t     * 一下是超类的三个构造方法\n\t     * @param context\n\t     */\n\t    public SRoundRect_Button(Context context) {\n\t        super(context);\n\t        init(context,null , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init(context,attrs , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n\t        super(context, attrs, defStyle);\n\t        init(context, attrs , defStyle);\n\t    }\n\t\n\t    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n\t        this.setBackgroundResource(0);  //去掉Button原来的背景\n\t        if(null == attrs)\n\t            return ;\n\t\n\t        /**\n\t         * View属性的提取\n\t         */\n\t        Resources resources = getResources();\n\t        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n\t        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n\t        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n\t        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n\t        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\t\n\t\n\t    }\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        //取得View的长宽信息，因为每一次View的载入长款\n\t        float width = this.getWidth();\n\t        float height = this.getHeight();\n\t        /**\n\t         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n\t         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n\t         */\n\t        if(localDrawingCanvas==null){\n\t            localDrawingCanvas = DrawingCanvas.instance(width,height);\n\t            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n\t            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n\t        }\n\t\n\t\n\t        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n\t    }\n\t}\n\n这就是一个提前绘制的自定义控件的实现了。\n\n## End\n\n这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？\n因为实现不了这个效果，所以只能添加了自定义属性\n\n\t<attr name=\"backgroundPic\" format=\"reference\"/>\n    <attr name=\"backgroundColor\" format=\"color\"/>\n   \n感觉很Low啊这样！！！还期待大神帮解决。\n\n设计一个可以直接使用的重绘控件库，是一个长久的目标呀~\n\n\n","source":"_posts/SoftWidget.md","raw":"\n---\ntitle: Android过度绘制深度优化---View提前绘制\ndate: 2015-9-9 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 概述\n\n上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  **背景-background**（背景包括背景图片、颜色、形状、边框等等）。\n\n\n那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   **Android过度绘制深度优化---View提前绘制**\n\n先说原理：**不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！**\n\n<!-- more -->\n\n\n先上效果图：\n优化前   &  优化后：\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />        <img src=\"http://img.blog.csdn.net/20151103211244952\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />\n\n**Tips：**\n1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。\n2.优化后的图片，为了突出所以添加了带图案的背景图片\n\n**颜色说明：**\n优化前：\n\n- Window（无色） 绘制一次\n- 背景（蓝色） 绘制2次\n- Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次\n- 输入框本身，按钮文字 （红色） 绘制三次\n- 输入框内部文字 （深红色）  绘制四次\n\n优化后：\n\n- 背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。\n- Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。\n- 文本框上面的图片和文字（绿色）绘制三次\n\n## 要点\n\nView提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：\n\n- View的提前绘制只能应用到那些静态的View\n- View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）\n- 界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。**如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。**\n- 对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。**通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）**\n\n也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。\n\n另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：\n1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。\n2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？\n\n## 正文\n啊，好吧，废话说的有点多了，下面我们上代码。\n\nGithub链接：[https://github.com/lizhaoxuan/SoftWidgetDemo.git](https://github.com/lizhaoxuan/SoftWidgetDemo.git\n)\n\n首先看目录结构：\n\n<img src=\"http://img.blog.csdn.net/20151107151634177\" width = \"180\" height = \"230\" alt=\"图片名称\" align=center />\n\n有四个核心类：\nDrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。\nPaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状\n\nSRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局\n\n然后看布局文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    android:padding=\"10dp\">\n\t\n\t    <ImageView\n\t        android:id=\"@+id/logoView\"\n\t        android:layout_width=\"100dp\"\n\t        android:layout_height=\"100dp\"\n\t        android:layout_centerHorizontal=\"true\"\n\t        android:layout_marginTop=\"80dp\"\n\t        android:src=\"@drawable/logo\"/>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/accountLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"50dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/logoView\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_user\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/accountEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"账号\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\" />\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/passwordLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"3dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/accountLayout\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_password\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/passwordEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"密码\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\"\n\t            android:inputType=\"textPassword\"/>\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n\t        android:id=\"@+id/login_btn\"\n\t        android:layout_width=\"fill_parent\"\n\t        android:layout_height=\"50dp\"\n\t        android:layout_marginTop=\"20dp\"\n\t        android:layout_below=\"@id/passwordLayout\"\n\t        android:layout_alignLeft=\"@id/passwordLayout\"\n\t        android:layout_alignRight=\"@id/passwordLayout\"\n\t        android:layout_gravity=\"center\"\n\t        android:text=\"登录\"\n\t        android:textColor=\"@color/white\"\n\t        android:textSize=\"20sp\"\n\t        app:backgroundColor=\"#af0308\"/>\n\t\n\t\n\t    <TextView\n\t        android:id=\"@+id/forgetText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentLeft=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginLeft=\"10dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"忘记密码\"/>\n\t\n\t    <TextView\n\t        android:id=\"@+id/registerText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentRight=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"注册\"/>\n\t</RelativeLayout>\n\n这里要说一下：\n不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。\n不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。\nButton 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);\n\n通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。\n\n\n*DrawingCanvas.java:*\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Bitmap;\n\timport android.graphics.Canvas;\n\timport android.graphics.Rect;\n\timport android.graphics.RectF;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/11.\n\t * 在这上面进行提前绘制\n\t */\n\tpublic class DrawingCanvas extends Canvas {\n\t\n\t    private Bitmap output;\n\t    private Rect rect;\n\t    private RectF rectF;\n\t    private DrawingCanvas(Bitmap output_, float width_, float height_){\n\t        super(output_);\n\t        output = output_;\n\t        rect = new Rect(0,0,(int)width_,(int)height_);\n\t        rectF = new RectF(0, 0, width_, height_);\n\t    }\n\t\n\t    public static DrawingCanvas instance(float width_ , float height_){\n\t        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n\t                Bitmap.Config.ARGB_8888);\n\t        return new DrawingCanvas(bitmap,width_,height_);\n\t    }\n\t\n\t\n\t    public Bitmap getOutput(){\n\t        return output;\n\t    }\n\t    public Rect getRect(){\n\t        return rect;\n\t    }\n\t    public RectF getRectF(){\n\t        return rectF;\n\t    }\n\t}\n\n这个类继承了Canvas，并且已经传入一个Bitmap\t\t\t\n\n\t\tsuper(output_);\n所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。\n\n*PaintBox.java:*\n\n\t\n\t\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Paint;\n\t\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 用来画图的盒子，里面放着画图的方法\n\t */\n\tpublic class PaintBox {\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\t\n\t        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t        paint.setStyle(Paint.Style.FILL);\n\t        paint.setAntiAlias(true);\n\t        paint.setColor(color);\n\t        paint.setAlpha(alpha);\n\t        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t        \n\t    }\n\t\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     * @param border 带边框\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n\t        if(border){\n\t            Paint paint = new Paint();\n\t            paint.setStyle(Paint.Style.FILL);\n\t            paint.setAntiAlias(true);\n\t            paint.setColor(color);\n\t            paint.setAlpha(30);\n\t            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t            paint.setStyle(Paint.Style.STROKE);\n\t            paint.setAlpha(70);\n\t            paint.setStrokeWidth(4);\n\t            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n\t        }else{\n\t            drawRoundRect(canvas,color,alpha);\n\t        }\n\t\n\t\n\t    }\n\t\n\t    /**\n\t     * 填充颜色\n\t     * @param canvas \n\t     * @param color\n\t     */\n\t    public static void drawColor(DrawingCanvas canvas ,int color ){\n\t        Paint paint = new Paint();\n\t        paint.setAntiAlias(true);\n\t        paint.setFilterBitmap(true);\n\t        paint.setDither(true);\n\t        paint.setColor(color);\n\t        canvas.drawPaint(paint);\n\t    }\n\t\n\t\n\t    /**\n\t     * 写字在View正中间\n\t     * @param canvas  画布\n\t     * @param text   文字\n\t     * @param color  文字颜色\n\t     * @param size   文字大小\n\t     */\n\t    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n\t        //创建画笔\n\t        Paint pp = new Paint();\n\t        pp.setAntiAlias(true);\n\t        pp.setColor(color);\n\t        pp.setStrokeWidth(3);\n\t        pp.setTextSize(size);\n\t        pp.setTextAlign(Paint.Align.CENTER);\n\t        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n\t        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n\t        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n\t    }\n\t}\n\n这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。\n值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。\n\n最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.\n\n*SRoundRect_Button.java:*\n\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\t\n\timport android.content.Context;\n\timport android.content.res.Resources;\n\timport android.content.res.TypedArray;\n\timport android.graphics.Canvas;\n\timport android.util.AttributeSet;\n\timport android.widget.Button;\n\t\n\timport com.example.zhaoxuanli.softwidgetdemo.R;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n\t */\n\t\n\t//\n\t//字符编码 UTF-8  无BOM\n\tpublic class SRoundRect_Button extends Button {\n\t    private String text;\n\t    private int textColor;\n\t    private int textSize;\n\t    private int backgroundColor;\n\t    /**\n\t     * 提前绘制的画布\n\t     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n\t     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n\t     * 反编译Path源码后，这里是采用软引用的\n\t     */\n\t    private DrawingCanvas localDrawingCanvas;  \n\t\n\t    /**\n\t     * 一下是超类的三个构造方法\n\t     * @param context\n\t     */\n\t    public SRoundRect_Button(Context context) {\n\t        super(context);\n\t        init(context,null , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init(context,attrs , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n\t        super(context, attrs, defStyle);\n\t        init(context, attrs , defStyle);\n\t    }\n\t\n\t    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n\t        this.setBackgroundResource(0);  //去掉Button原来的背景\n\t        if(null == attrs)\n\t            return ;\n\t\n\t        /**\n\t         * View属性的提取\n\t         */\n\t        Resources resources = getResources();\n\t        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n\t        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n\t        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n\t        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n\t        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\t\n\t\n\t    }\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        //取得View的长宽信息，因为每一次View的载入长款\n\t        float width = this.getWidth();\n\t        float height = this.getHeight();\n\t        /**\n\t         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n\t         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n\t         */\n\t        if(localDrawingCanvas==null){\n\t            localDrawingCanvas = DrawingCanvas.instance(width,height);\n\t            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n\t            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n\t        }\n\t\n\t\n\t        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n\t    }\n\t}\n\n这就是一个提前绘制的自定义控件的实现了。\n\n## End\n\n这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？\n因为实现不了这个效果，所以只能添加了自定义属性\n\n\t<attr name=\"backgroundPic\" format=\"reference\"/>\n    <attr name=\"backgroundColor\" format=\"color\"/>\n   \n感觉很Low啊这样！！！还期待大神帮解决。\n\n设计一个可以直接使用的重绘控件库，是一个长久的目标呀~\n\n\n","slug":"SoftWidget","published":1,"updated":"2019-01-02T02:09:31.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsox000cyo9s5whqmua1","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  <strong>背景-background</strong>（背景包括背景图片、颜色、形状、边框等等）。</p>\n<p>那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   <strong>Android过度绘制深度优化—View提前绘制</strong></p>\n<p>先说原理：<strong>不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！</strong></p>\n<a id=\"more\"></a>\n<p>先上效果图：<br>优化前   &amp;  优化后：<br><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\">        <img src=\"http://img.blog.csdn.net/20151103211244952\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\"></p>\n<p><strong>Tips：</strong><br>1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。<br>2.优化后的图片，为了突出所以添加了带图案的背景图片</p>\n<p><strong>颜色说明：</strong><br>优化前：</p>\n<ul>\n<li>Window（无色） 绘制一次</li>\n<li>背景（蓝色） 绘制2次</li>\n<li>Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次</li>\n<li>输入框本身，按钮文字 （红色） 绘制三次</li>\n<li>输入框内部文字 （深红色）  绘制四次</li>\n</ul>\n<p>优化后：</p>\n<ul>\n<li>背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。</li>\n<li>Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。</li>\n<li>文本框上面的图片和文字（绿色）绘制三次</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><p>View提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：</p>\n<ul>\n<li>View的提前绘制只能应用到那些静态的View</li>\n<li>View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）</li>\n<li>界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。<strong>如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。</strong></li>\n<li>对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。<strong>通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）</strong></li>\n</ul>\n<p>也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。</p>\n<p>另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：<br>1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。<br>2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>啊，好吧，废话说的有点多了，下面我们上代码。</p>\n<p>Github链接：<a href=\"https://github.com/lizhaoxuan/SoftWidgetDemo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/SoftWidgetDemo.git</a></p>\n<p>首先看目录结构：</p>\n<p><img src=\"http://img.blog.csdn.net/20151107151634177\" width=\"180\" height=\"230\" alt=\"图片名称\" align=\"center\"></p>\n<p>有四个核心类：<br>DrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。<br>PaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状</p>\n<p>SRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局</p>\n<p>然后看布局文件：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/logoView&quot;\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;100dp&quot;\n        android:layout_centerHorizontal=&quot;true&quot;\n        android:layout_marginTop=&quot;80dp&quot;\n        android:src=&quot;@drawable/logo&quot;/&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/accountLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;50dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/logoView&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_user&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/accountEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;账号&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot; /&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/passwordLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;3dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/accountLayout&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_password&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/passwordEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;密码&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot;\n            android:inputType=&quot;textPassword&quot;/&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n        android:id=&quot;@+id/login_btn&quot;\n        android:layout_width=&quot;fill_parent&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;20dp&quot;\n        android:layout_below=&quot;@id/passwordLayout&quot;\n        android:layout_alignLeft=&quot;@id/passwordLayout&quot;\n        android:layout_alignRight=&quot;@id/passwordLayout&quot;\n        android:layout_gravity=&quot;center&quot;\n        android:text=&quot;登录&quot;\n        android:textColor=&quot;@color/white&quot;\n        android:textSize=&quot;20sp&quot;\n        app:backgroundColor=&quot;#af0308&quot;/&gt;\n\n\n    &lt;TextView\n        android:id=&quot;@+id/forgetText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentLeft=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;忘记密码&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/registerText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentRight=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;注册&quot;/&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>这里要说一下：<br>不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。<br>不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。<br>Button 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);</p>\n<p>通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。</p>\n<p><em>DrawingCanvas.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\n\n/**\n * Created by zhaoxuan.li on 2015/8/11.\n * 在这上面进行提前绘制\n */\npublic class DrawingCanvas extends Canvas {\n\n    private Bitmap output;\n    private Rect rect;\n    private RectF rectF;\n    private DrawingCanvas(Bitmap output_, float width_, float height_){\n        super(output_);\n        output = output_;\n        rect = new Rect(0,0,(int)width_,(int)height_);\n        rectF = new RectF(0, 0, width_, height_);\n    }\n\n    public static DrawingCanvas instance(float width_ , float height_){\n        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n                Bitmap.Config.ARGB_8888);\n        return new DrawingCanvas(bitmap,width_,height_);\n    }\n\n\n    public Bitmap getOutput(){\n        return output;\n    }\n    public Rect getRect(){\n        return rect;\n    }\n    public RectF getRectF(){\n        return rectF;\n    }\n}\n</code></pre><p>这个类继承了Canvas，并且已经传入一个Bitmap            </p>\n<pre><code>super(output_);\n</code></pre><p>所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。</p>\n<p><em>PaintBox.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Paint;\n\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 用来画图的盒子，里面放着画图的方法\n */\npublic class PaintBox {\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\n        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        paint.setStyle(Paint.Style.FILL);\n        paint.setAntiAlias(true);\n        paint.setColor(color);\n        paint.setAlpha(alpha);\n        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n\n    }\n\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     * @param border 带边框\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n        if(border){\n            Paint paint = new Paint();\n            paint.setStyle(Paint.Style.FILL);\n            paint.setAntiAlias(true);\n            paint.setColor(color);\n            paint.setAlpha(30);\n            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n            paint.setStyle(Paint.Style.STROKE);\n            paint.setAlpha(70);\n            paint.setStrokeWidth(4);\n            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n        }else{\n            drawRoundRect(canvas,color,alpha);\n        }\n\n\n    }\n\n    /**\n     * 填充颜色\n     * @param canvas \n     * @param color\n     */\n    public static void drawColor(DrawingCanvas canvas ,int color ){\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        paint.setDither(true);\n        paint.setColor(color);\n        canvas.drawPaint(paint);\n    }\n\n\n    /**\n     * 写字在View正中间\n     * @param canvas  画布\n     * @param text   文字\n     * @param color  文字颜色\n     * @param size   文字大小\n     */\n    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n        //创建画笔\n        Paint pp = new Paint();\n        pp.setAntiAlias(true);\n        pp.setColor(color);\n        pp.setStrokeWidth(3);\n        pp.setTextSize(size);\n        pp.setTextAlign(Paint.Align.CENTER);\n        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n    }\n}\n</code></pre><p>这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。<br>值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。</p>\n<p>最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.</p>\n<p><em>SRoundRect_Button.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.util.AttributeSet;\nimport android.widget.Button;\n\nimport com.example.zhaoxuanli.softwidgetdemo.R;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n */\n\n//\n//字符编码 UTF-8  无BOM\npublic class SRoundRect_Button extends Button {\n    private String text;\n    private int textColor;\n    private int textSize;\n    private int backgroundColor;\n    /**\n     * 提前绘制的画布\n     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n     * 反编译Path源码后，这里是采用软引用的\n     */\n    private DrawingCanvas localDrawingCanvas;  \n\n    /**\n     * 一下是超类的三个构造方法\n     * @param context\n     */\n    public SRoundRect_Button(Context context) {\n        super(context);\n        init(context,null , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context,attrs , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs , defStyle);\n    }\n\n    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n        this.setBackgroundResource(0);  //去掉Button原来的背景\n        if(null == attrs)\n            return ;\n\n        /**\n         * View属性的提取\n         */\n        Resources resources = getResources();\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        //取得View的长宽信息，因为每一次View的载入长款\n        float width = this.getWidth();\n        float height = this.getHeight();\n        /**\n         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n         */\n        if(localDrawingCanvas==null){\n            localDrawingCanvas = DrawingCanvas.instance(width,height);\n            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n        }\n\n\n        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n    }\n}\n</code></pre><p>这就是一个提前绘制的自定义控件的实现了。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？<br>因为实现不了这个效果，所以只能添加了自定义属性</p>\n<pre><code>&lt;attr name=&quot;backgroundPic&quot; format=&quot;reference&quot;/&gt;\n&lt;attr name=&quot;backgroundColor&quot; format=&quot;color&quot;/&gt;\n</code></pre><p>感觉很Low啊这样！！！还期待大神帮解决。</p>\n<p>设计一个可以直接使用的重绘控件库，是一个长久的目标呀~</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  <strong>背景-background</strong>（背景包括背景图片、颜色、形状、边框等等）。</p>\n<p>那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   <strong>Android过度绘制深度优化—View提前绘制</strong></p>\n<p>先说原理：<strong>不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！</strong></p>","more":"<p>先上效果图：<br>优化前   &amp;  优化后：<br><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\">        <img src=\"http://img.blog.csdn.net/20151103211244952\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\"></p>\n<p><strong>Tips：</strong><br>1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。<br>2.优化后的图片，为了突出所以添加了带图案的背景图片</p>\n<p><strong>颜色说明：</strong><br>优化前：</p>\n<ul>\n<li>Window（无色） 绘制一次</li>\n<li>背景（蓝色） 绘制2次</li>\n<li>Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次</li>\n<li>输入框本身，按钮文字 （红色） 绘制三次</li>\n<li>输入框内部文字 （深红色）  绘制四次</li>\n</ul>\n<p>优化后：</p>\n<ul>\n<li>背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。</li>\n<li>Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。</li>\n<li>文本框上面的图片和文字（绿色）绘制三次</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><p>View提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：</p>\n<ul>\n<li>View的提前绘制只能应用到那些静态的View</li>\n<li>View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）</li>\n<li>界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。<strong>如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。</strong></li>\n<li>对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。<strong>通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）</strong></li>\n</ul>\n<p>也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。</p>\n<p>另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：<br>1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。<br>2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>啊，好吧，废话说的有点多了，下面我们上代码。</p>\n<p>Github链接：<a href=\"https://github.com/lizhaoxuan/SoftWidgetDemo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/SoftWidgetDemo.git</a></p>\n<p>首先看目录结构：</p>\n<p><img src=\"http://img.blog.csdn.net/20151107151634177\" width=\"180\" height=\"230\" alt=\"图片名称\" align=\"center\"></p>\n<p>有四个核心类：<br>DrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。<br>PaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状</p>\n<p>SRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局</p>\n<p>然后看布局文件：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/logoView&quot;\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;100dp&quot;\n        android:layout_centerHorizontal=&quot;true&quot;\n        android:layout_marginTop=&quot;80dp&quot;\n        android:src=&quot;@drawable/logo&quot;/&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/accountLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;50dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/logoView&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_user&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/accountEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;账号&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot; /&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/passwordLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;3dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/accountLayout&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_password&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/passwordEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;密码&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot;\n            android:inputType=&quot;textPassword&quot;/&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n        android:id=&quot;@+id/login_btn&quot;\n        android:layout_width=&quot;fill_parent&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;20dp&quot;\n        android:layout_below=&quot;@id/passwordLayout&quot;\n        android:layout_alignLeft=&quot;@id/passwordLayout&quot;\n        android:layout_alignRight=&quot;@id/passwordLayout&quot;\n        android:layout_gravity=&quot;center&quot;\n        android:text=&quot;登录&quot;\n        android:textColor=&quot;@color/white&quot;\n        android:textSize=&quot;20sp&quot;\n        app:backgroundColor=&quot;#af0308&quot;/&gt;\n\n\n    &lt;TextView\n        android:id=&quot;@+id/forgetText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentLeft=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;忘记密码&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/registerText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentRight=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;注册&quot;/&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>这里要说一下：<br>不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。<br>不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。<br>Button 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);</p>\n<p>通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。</p>\n<p><em>DrawingCanvas.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\n\n/**\n * Created by zhaoxuan.li on 2015/8/11.\n * 在这上面进行提前绘制\n */\npublic class DrawingCanvas extends Canvas {\n\n    private Bitmap output;\n    private Rect rect;\n    private RectF rectF;\n    private DrawingCanvas(Bitmap output_, float width_, float height_){\n        super(output_);\n        output = output_;\n        rect = new Rect(0,0,(int)width_,(int)height_);\n        rectF = new RectF(0, 0, width_, height_);\n    }\n\n    public static DrawingCanvas instance(float width_ , float height_){\n        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n                Bitmap.Config.ARGB_8888);\n        return new DrawingCanvas(bitmap,width_,height_);\n    }\n\n\n    public Bitmap getOutput(){\n        return output;\n    }\n    public Rect getRect(){\n        return rect;\n    }\n    public RectF getRectF(){\n        return rectF;\n    }\n}\n</code></pre><p>这个类继承了Canvas，并且已经传入一个Bitmap            </p>\n<pre><code>super(output_);\n</code></pre><p>所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。</p>\n<p><em>PaintBox.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Paint;\n\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 用来画图的盒子，里面放着画图的方法\n */\npublic class PaintBox {\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\n        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        paint.setStyle(Paint.Style.FILL);\n        paint.setAntiAlias(true);\n        paint.setColor(color);\n        paint.setAlpha(alpha);\n        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n\n    }\n\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     * @param border 带边框\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n        if(border){\n            Paint paint = new Paint();\n            paint.setStyle(Paint.Style.FILL);\n            paint.setAntiAlias(true);\n            paint.setColor(color);\n            paint.setAlpha(30);\n            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n            paint.setStyle(Paint.Style.STROKE);\n            paint.setAlpha(70);\n            paint.setStrokeWidth(4);\n            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n        }else{\n            drawRoundRect(canvas,color,alpha);\n        }\n\n\n    }\n\n    /**\n     * 填充颜色\n     * @param canvas \n     * @param color\n     */\n    public static void drawColor(DrawingCanvas canvas ,int color ){\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        paint.setDither(true);\n        paint.setColor(color);\n        canvas.drawPaint(paint);\n    }\n\n\n    /**\n     * 写字在View正中间\n     * @param canvas  画布\n     * @param text   文字\n     * @param color  文字颜色\n     * @param size   文字大小\n     */\n    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n        //创建画笔\n        Paint pp = new Paint();\n        pp.setAntiAlias(true);\n        pp.setColor(color);\n        pp.setStrokeWidth(3);\n        pp.setTextSize(size);\n        pp.setTextAlign(Paint.Align.CENTER);\n        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n    }\n}\n</code></pre><p>这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。<br>值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。</p>\n<p>最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.</p>\n<p><em>SRoundRect_Button.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.util.AttributeSet;\nimport android.widget.Button;\n\nimport com.example.zhaoxuanli.softwidgetdemo.R;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n */\n\n//\n//字符编码 UTF-8  无BOM\npublic class SRoundRect_Button extends Button {\n    private String text;\n    private int textColor;\n    private int textSize;\n    private int backgroundColor;\n    /**\n     * 提前绘制的画布\n     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n     * 反编译Path源码后，这里是采用软引用的\n     */\n    private DrawingCanvas localDrawingCanvas;  \n\n    /**\n     * 一下是超类的三个构造方法\n     * @param context\n     */\n    public SRoundRect_Button(Context context) {\n        super(context);\n        init(context,null , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context,attrs , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs , defStyle);\n    }\n\n    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n        this.setBackgroundResource(0);  //去掉Button原来的背景\n        if(null == attrs)\n            return ;\n\n        /**\n         * View属性的提取\n         */\n        Resources resources = getResources();\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        //取得View的长宽信息，因为每一次View的载入长款\n        float width = this.getWidth();\n        float height = this.getHeight();\n        /**\n         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n         */\n        if(localDrawingCanvas==null){\n            localDrawingCanvas = DrawingCanvas.instance(width,height);\n            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n        }\n\n\n        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n    }\n}\n</code></pre><p>这就是一个提前绘制的自定义控件的实现了。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？<br>因为实现不了这个效果，所以只能添加了自定义属性</p>\n<pre><code>&lt;attr name=&quot;backgroundPic&quot; format=&quot;reference&quot;/&gt;\n&lt;attr name=&quot;backgroundColor&quot; format=&quot;color&quot;/&gt;\n</code></pre><p>感觉很Low啊这样！！！还期待大神帮解决。</p>\n<p>设计一个可以直接使用的重绘控件库，是一个长久的目标呀~</p>"},{"title":"Android之GPU过度绘制与图形渲染优化","date":"2015-09-10T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n本文主要对过度绘制和图形渲染做一个概念性的描述。\n\n同时以案例方式列出一些简单适用的优化措施。\n\n如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：\n\n[优化Android过度绘制]()\n\n另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 [Android 性能优化典范](http://www.oschina.net/news/60157/android-performance-patterns)\n\n\n<!-- more -->\n\n## 概念\n\n\n### GPU过度绘制\n\n是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。\n\t\n**仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！**\n\n还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！\n\n\n### 图形渲染优化\t\n\n一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。\n\n\n## 关键点/字\n\n\n- 过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。\n\n- 调试GPU过渡绘制颜色区域说明    \n\n\t- 无/白色：绘制1次\n\t- 蓝色：绘制2次（理想状态）\n\t- 绿色：绘制3次\n\t- 浅红：绘制4次（要优化了）\n\t- 深红：绘制5次或5次以上。（必须要优化了）\n\n\t![](http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg)\n\n\n- 调试Hierarchy Viewer 颜色说明\t\t\t\t\t\n\t\t\t\n\t下方三个原点从左到右：测量、布局、画图时间\n\t\n\t- 红色：该View所用时间超过大部分View很多\n\t- 黄色：该View所用时间超过大部分View\n\t- 绿色：该View所用时间低于大部分View\n\t\t\n   ![调试Hierarchy Viewer颜色说明](http://img.blog.csdn.net/20151016211507297)\n\n- 引起过度绘制的两个主要因素：层级与背景图片\n\t\n\t- 层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。\n\t- 改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层\n\t- 值得注意的是，背景图片的绘制是及其耗时的\n\n- 一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。\n\n\t- 浅层布局效率高于深层布局\n\t- 布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout > RelativeLayout\n    - 基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。\n\t- 但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。\n\n## 优化措施\n\n- 在Theme中给activity增加背景。使用WindowBackground属性。\n\n\t背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。\n\n\n- 减少层级，没必要的背景图\n\n\t如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景\n\n- 避免使布局太深，而应该让布局更浅更深\n\n\t用相对布局替换线性布局\n\n- 无用的子节点、父节点删除\n\n\t没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：\n\t\n\t1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView\n\t\t\n\t2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。\n\n- 对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局\n\n- 避免出现多个使用layout-weight属性的的LinearLayout。\n\n\t首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。\n\t\n\n- 合并作为根节点的帧布局(Framelayout)  \n\t\t\n\t你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。\n\t\n\t如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。\n\t\n\t更有效的方式是使用<merge />标签替换该< Framelayout />标签 。\n\n- 使用组合控件\n\n\t首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。\n\t\n\t但它会让你的布局文件看起来非常的清晰。\n\t\n\t并且对于一些条状的控件。类似与下图这样的控件。\n\t\n\t当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。\n\t\n\t使用组合控件包装你的view，既符合封装的特性，又可以减少代码量\n\n**重要的东西放到最后说：**\n\n- **重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。**\n\n\t说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）\n\t\t\n\t那么这是你需要终极绝招：View提前绘制。\n\t\n\t不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。\n\t\n\t楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。\n\t\t\n\n\n\n\n## 案例说明 – 登录界面\n\n为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。\n\n开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。\n\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n<img src=\"http://img.blog.csdn.net/20151016211551825\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n\n惊讶吗？没关系，我们也可以做到。\n\n之后再看我们的UI层级图：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211744054)\n\n下面我们一步步分析优化。\n\n\n### 优化1\n\n**优化布局结构，解决过深的UI层级图，与无用的子节点**\n\n- \t过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差\n\n![](http://img.blog.csdn.net/20151016211802245)\n\n**优化方案1：**采用相对布局，使得布局变浅变宽。最大可以保证只有两层。\n\n\n**优化方案2：**观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。\n\n\n无用的子节点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211827892)\n\n一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。\n\n\n### 优化2\n**子view过久的测量时间。**\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211844469)\n\n查看其代码：\n\n\t<com.envision.mobile.ui.widget.EditView    \n        android:id=\"@+id/login_name\"    \n        android:layout_width=\"0dp\"    \n        android:layout_height=\"wrap_content\"   \n        android:layout_gravity=\"center_vertical\"    \n        android:layout_marginRight=\"8dip\"   \n        android:layout_weight=\"1\"    \n        android:background=\"@null\"       \n        android:hint=\"@string/hint_login_name\"    \n        android:imeOptions=\"actionNext\"    \n        android:paddingBottom=\"8dip\"   \n        android:singleLine=\"true\"   \n        android:textColor=\"@color/white\"   \n        android:textColorHint=\"@color/white_trans_88\"    \n        android:textCursorDrawable=\"@null\" />   \n\n**android:layout_weight=\"1\"  属性导致过久的测量时间。**   \n\n\n### 优化3\n\n在Theme中给activity添加背景。减少一层绘制\n\n\t\t<style name=\"AppTheme\" parent=\"AppBaseTheme\">\n\t\t    <item name=\"android:windowBackground\">\n\t\t\t@drawable/bg_homepage\n\t\t\t</item>\n\t\t</style>\n\n\n### 优化4\n\n**重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。**\n\n这里代码量较大，我们放到另一篇文章中讲： \n\nhttp://blog.csdn.net/u010255127/article/details/49702663\n\n## 最终优化效果\t\n没有红色，最高是绿色\n（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）\n\n![这里写图片描述](http://img.blog.csdn.net/20151103211244952)\n\n\n\n## 测试数据\n\n【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）\n原始状况：\n\n\tonCreate 到 onStart ： 381  370 \n\tonCreate 到 onResume ：383  373\n\tonStart 到 onResume ： 2     3\n\n\n在theme加背景\n\n\tonCreate 到 onStart ： 274  295\n\tonCreate 到 onResume ：277  298\n\tonStart 到 onResume ：  3    3\n\n\n\n仅修改布局层次(去掉两个不必要透明布局)\n\n\tonCreate 到 onStart ： 272   276\n\tonCreate 到 onResume ：274  279\n\tonStart 到 onResume ：  2     3\n\n\n\n替换自定义 提前绘制控件\n\n\tonCreate 到 onStart ：  289  299  294\n\tonCreate 到 onResume ：  292 302  296\n\tonStart 到 onResume ：   3    3    2\n\n\n## 结论\n\n我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。\n去掉不必要的布局和View，虽然效果甚微，但也减少了。\n\n最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。\n另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……\n\n\n最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。\n\n我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。\n\n","source":"_posts/android-rendering-performance-optimization.md","raw":"\n---\ntitle: Android之GPU过度绘制与图形渲染优化\ndate: 2015-9-10 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n本文主要对过度绘制和图形渲染做一个概念性的描述。\n\n同时以案例方式列出一些简单适用的优化措施。\n\n如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：\n\n[优化Android过度绘制]()\n\n另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 [Android 性能优化典范](http://www.oschina.net/news/60157/android-performance-patterns)\n\n\n<!-- more -->\n\n## 概念\n\n\n### GPU过度绘制\n\n是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。\n\t\n**仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！**\n\n还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！\n\n\n### 图形渲染优化\t\n\n一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。\n\n\n## 关键点/字\n\n\n- 过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。\n\n- 调试GPU过渡绘制颜色区域说明    \n\n\t- 无/白色：绘制1次\n\t- 蓝色：绘制2次（理想状态）\n\t- 绿色：绘制3次\n\t- 浅红：绘制4次（要优化了）\n\t- 深红：绘制5次或5次以上。（必须要优化了）\n\n\t![](http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg)\n\n\n- 调试Hierarchy Viewer 颜色说明\t\t\t\t\t\n\t\t\t\n\t下方三个原点从左到右：测量、布局、画图时间\n\t\n\t- 红色：该View所用时间超过大部分View很多\n\t- 黄色：该View所用时间超过大部分View\n\t- 绿色：该View所用时间低于大部分View\n\t\t\n   ![调试Hierarchy Viewer颜色说明](http://img.blog.csdn.net/20151016211507297)\n\n- 引起过度绘制的两个主要因素：层级与背景图片\n\t\n\t- 层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。\n\t- 改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层\n\t- 值得注意的是，背景图片的绘制是及其耗时的\n\n- 一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。\n\n\t- 浅层布局效率高于深层布局\n\t- 布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout > RelativeLayout\n    - 基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。\n\t- 但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。\n\n## 优化措施\n\n- 在Theme中给activity增加背景。使用WindowBackground属性。\n\n\t背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。\n\n\n- 减少层级，没必要的背景图\n\n\t如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景\n\n- 避免使布局太深，而应该让布局更浅更深\n\n\t用相对布局替换线性布局\n\n- 无用的子节点、父节点删除\n\n\t没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：\n\t\n\t1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView\n\t\t\n\t2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。\n\n- 对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局\n\n- 避免出现多个使用layout-weight属性的的LinearLayout。\n\n\t首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。\n\t\n\n- 合并作为根节点的帧布局(Framelayout)  \n\t\t\n\t你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。\n\t\n\t如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。\n\t\n\t更有效的方式是使用<merge />标签替换该< Framelayout />标签 。\n\n- 使用组合控件\n\n\t首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。\n\t\n\t但它会让你的布局文件看起来非常的清晰。\n\t\n\t并且对于一些条状的控件。类似与下图这样的控件。\n\t\n\t当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。\n\t\n\t使用组合控件包装你的view，既符合封装的特性，又可以减少代码量\n\n**重要的东西放到最后说：**\n\n- **重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。**\n\n\t说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）\n\t\t\n\t那么这是你需要终极绝招：View提前绘制。\n\t\n\t不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。\n\t\n\t楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。\n\t\t\n\n\n\n\n## 案例说明 – 登录界面\n\n为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。\n\n开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。\n\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n<img src=\"http://img.blog.csdn.net/20151016211551825\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n\n惊讶吗？没关系，我们也可以做到。\n\n之后再看我们的UI层级图：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211744054)\n\n下面我们一步步分析优化。\n\n\n### 优化1\n\n**优化布局结构，解决过深的UI层级图，与无用的子节点**\n\n- \t过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差\n\n![](http://img.blog.csdn.net/20151016211802245)\n\n**优化方案1：**采用相对布局，使得布局变浅变宽。最大可以保证只有两层。\n\n\n**优化方案2：**观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。\n\n\n无用的子节点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211827892)\n\n一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。\n\n\n### 优化2\n**子view过久的测量时间。**\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211844469)\n\n查看其代码：\n\n\t<com.envision.mobile.ui.widget.EditView    \n        android:id=\"@+id/login_name\"    \n        android:layout_width=\"0dp\"    \n        android:layout_height=\"wrap_content\"   \n        android:layout_gravity=\"center_vertical\"    \n        android:layout_marginRight=\"8dip\"   \n        android:layout_weight=\"1\"    \n        android:background=\"@null\"       \n        android:hint=\"@string/hint_login_name\"    \n        android:imeOptions=\"actionNext\"    \n        android:paddingBottom=\"8dip\"   \n        android:singleLine=\"true\"   \n        android:textColor=\"@color/white\"   \n        android:textColorHint=\"@color/white_trans_88\"    \n        android:textCursorDrawable=\"@null\" />   \n\n**android:layout_weight=\"1\"  属性导致过久的测量时间。**   \n\n\n### 优化3\n\n在Theme中给activity添加背景。减少一层绘制\n\n\t\t<style name=\"AppTheme\" parent=\"AppBaseTheme\">\n\t\t    <item name=\"android:windowBackground\">\n\t\t\t@drawable/bg_homepage\n\t\t\t</item>\n\t\t</style>\n\n\n### 优化4\n\n**重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。**\n\n这里代码量较大，我们放到另一篇文章中讲： \n\nhttp://blog.csdn.net/u010255127/article/details/49702663\n\n## 最终优化效果\t\n没有红色，最高是绿色\n（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）\n\n![这里写图片描述](http://img.blog.csdn.net/20151103211244952)\n\n\n\n## 测试数据\n\n【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）\n原始状况：\n\n\tonCreate 到 onStart ： 381  370 \n\tonCreate 到 onResume ：383  373\n\tonStart 到 onResume ： 2     3\n\n\n在theme加背景\n\n\tonCreate 到 onStart ： 274  295\n\tonCreate 到 onResume ：277  298\n\tonStart 到 onResume ：  3    3\n\n\n\n仅修改布局层次(去掉两个不必要透明布局)\n\n\tonCreate 到 onStart ： 272   276\n\tonCreate 到 onResume ：274  279\n\tonStart 到 onResume ：  2     3\n\n\n\n替换自定义 提前绘制控件\n\n\tonCreate 到 onStart ：  289  299  294\n\tonCreate 到 onResume ：  292 302  296\n\tonStart 到 onResume ：   3    3    2\n\n\n## 结论\n\n我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。\n去掉不必要的布局和View，虽然效果甚微，但也减少了。\n\n最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。\n另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……\n\n\n最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。\n\n我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。\n\n","slug":"android-rendering-performance-optimization","published":1,"updated":"2019-01-02T02:09:31.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsp5000eyo9sj529du5b","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要对过度绘制和图形渲染做一个概念性的描述。</p>\n<p>同时以案例方式列出一些简单适用的优化措施。</p>\n<p>如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：</p>\n<p><a href=\"\">优化Android过度绘制</a></p>\n<p>另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 <a href=\"http://www.oschina.net/news/60157/android-performance-patterns\" target=\"_blank\" rel=\"noopener\">Android 性能优化典范</a></p>\n<a id=\"more\"></a>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"GPU过度绘制\"><a href=\"#GPU过度绘制\" class=\"headerlink\" title=\"GPU过度绘制\"></a>GPU过度绘制</h3><p>是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。</p>\n<p><strong>仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！</strong></p>\n<p>还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！</p>\n<h3 id=\"图形渲染优化\"><a href=\"#图形渲染优化\" class=\"headerlink\" title=\"图形渲染优化\"></a>图形渲染优化</h3><p>一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。</p>\n<h2 id=\"关键点-字\"><a href=\"#关键点-字\" class=\"headerlink\" title=\"关键点/字\"></a>关键点/字</h2><ul>\n<li><p>过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。</p>\n</li>\n<li><p>调试GPU过渡绘制颜色区域说明    </p>\n<ul>\n<li>无/白色：绘制1次</li>\n<li>蓝色：绘制2次（理想状态）</li>\n<li>绿色：绘制3次</li>\n<li>浅红：绘制4次（要优化了）</li>\n<li><p>深红：绘制5次或5次以上。（必须要优化了）</p>\n<p><img src=\"http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>调试Hierarchy Viewer 颜色说明                    </p>\n<p>  下方三个原点从左到右：测量、布局、画图时间</p>\n<ul>\n<li>红色：该View所用时间超过大部分View很多</li>\n<li>黄色：该View所用时间超过大部分View</li>\n<li><p>绿色：该View所用时间低于大部分View</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211507297\" alt=\"调试Hierarchy Viewer颜色说明\"></p>\n</li>\n</ul>\n</li>\n<li><p>引起过度绘制的两个主要因素：层级与背景图片</p>\n<ul>\n<li>层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。</li>\n<li>改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层</li>\n<li>值得注意的是，背景图片的绘制是及其耗时的</li>\n</ul>\n</li>\n<li><p>一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。</p>\n<ul>\n<li>浅层布局效率高于深层布局</li>\n<li>布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout &gt; RelativeLayout</li>\n<li>基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。</li>\n<li>但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h2><ul>\n<li><p>在Theme中给activity增加背景。使用WindowBackground属性。</p>\n<p>  背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。</p>\n</li>\n</ul>\n<ul>\n<li><p>减少层级，没必要的背景图</p>\n<p>  如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景</p>\n</li>\n<li><p>避免使布局太深，而应该让布局更浅更深</p>\n<p>  用相对布局替换线性布局</p>\n</li>\n<li><p>无用的子节点、父节点删除</p>\n<p>  没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：</p>\n<p>  1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView</p>\n<p>  2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。</p>\n</li>\n<li><p>对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局</include></p>\n</li>\n<li><p>避免出现多个使用layout-weight属性的的LinearLayout。</p>\n<p>  首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。</p>\n</li>\n</ul>\n<ul>\n<li><p>合并作为根节点的帧布局(Framelayout)  </p>\n<p>  你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。</p>\n<p>  如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。</p>\n<p>  更有效的方式是使用<merge>标签替换该&lt; Framelayout /&gt;标签 。</merge></p>\n</li>\n<li><p>使用组合控件</p>\n<p>  首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。</p>\n<p>  但它会让你的布局文件看起来非常的清晰。</p>\n<p>  并且对于一些条状的控件。类似与下图这样的控件。</p>\n<p>  当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。</p>\n<p>  使用组合控件包装你的view，既符合封装的特性，又可以减少代码量</p>\n</li>\n</ul>\n<p><strong>重要的东西放到最后说：</strong></p>\n<ul>\n<li><p><strong>重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。</strong></p>\n<p>  说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）</p>\n<p>  那么这是你需要终极绝招：View提前绘制。</p>\n<p>  不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。</p>\n<p>  楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。</p>\n</li>\n</ul>\n<h2 id=\"案例说明-–-登录界面\"><a href=\"#案例说明-–-登录界面\" class=\"headerlink\" title=\"案例说明 – 登录界面\"></a>案例说明 – 登录界面</h2><p>为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。</p>\n<p>开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211551825\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p>惊讶吗？没关系，我们也可以做到。</p>\n<p>之后再看我们的UI层级图：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211744054\" alt=\"这里写图片描述\"></p>\n<p>下面我们一步步分析优化。</p>\n<h3 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h3><p><strong>优化布局结构，解决过深的UI层级图，与无用的子节点</strong></p>\n<ul>\n<li>过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20151016211802245\" alt=\"\"></p>\n<p><strong>优化方案1：</strong>采用相对布局，使得布局变浅变宽。最大可以保证只有两层。</p>\n<p><strong>优化方案2：</strong>观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。</p>\n<p>无用的子节点：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211827892\" alt=\"这里写图片描述\"></p>\n<p>一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。</p>\n<h3 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h3><p><strong>子view过久的测量时间。</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211844469\" alt=\"这里写图片描述\"></p>\n<p>查看其代码：</p>\n<pre><code>&lt;com.envision.mobile.ui.widget.EditView    \n    android:id=&quot;@+id/login_name&quot;    \n    android:layout_width=&quot;0dp&quot;    \n    android:layout_height=&quot;wrap_content&quot;   \n    android:layout_gravity=&quot;center_vertical&quot;    \n    android:layout_marginRight=&quot;8dip&quot;   \n    android:layout_weight=&quot;1&quot;    \n    android:background=&quot;@null&quot;       \n    android:hint=&quot;@string/hint_login_name&quot;    \n    android:imeOptions=&quot;actionNext&quot;    \n    android:paddingBottom=&quot;8dip&quot;   \n    android:singleLine=&quot;true&quot;   \n    android:textColor=&quot;@color/white&quot;   \n    android:textColorHint=&quot;@color/white_trans_88&quot;    \n    android:textCursorDrawable=&quot;@null&quot; /&gt;   \n</code></pre><p><strong>android:layout_weight=”1”  属性导致过久的测量时间。</strong>   </p>\n<h3 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h3><p>在Theme中给activity添加背景。减少一层绘制</p>\n<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;\n    @drawable/bg_homepage\n    &lt;/item&gt;\n&lt;/style&gt;\n</code></pre><h3 id=\"优化4\"><a href=\"#优化4\" class=\"headerlink\" title=\"优化4\"></a>优化4</h3><p><strong>重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。</strong></p>\n<p>这里代码量较大，我们放到另一篇文章中讲： </p>\n<p><a href=\"http://blog.csdn.net/u010255127/article/details/49702663\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u010255127/article/details/49702663</a></p>\n<h2 id=\"最终优化效果\"><a href=\"#最终优化效果\" class=\"headerlink\" title=\"最终优化效果\"></a>最终优化效果</h2><p>没有红色，最高是绿色<br>（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211244952\" alt=\"这里写图片描述\"></p>\n<h2 id=\"测试数据\"><a href=\"#测试数据\" class=\"headerlink\" title=\"测试数据\"></a>测试数据</h2><p>【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）<br>原始状况：</p>\n<pre><code>onCreate 到 onStart ： 381  370 \nonCreate 到 onResume ：383  373\nonStart 到 onResume ： 2     3\n</code></pre><p>在theme加背景</p>\n<pre><code>onCreate 到 onStart ： 274  295\nonCreate 到 onResume ：277  298\nonStart 到 onResume ：  3    3\n</code></pre><p>仅修改布局层次(去掉两个不必要透明布局)</p>\n<pre><code>onCreate 到 onStart ： 272   276\nonCreate 到 onResume ：274  279\nonStart 到 onResume ：  2     3\n</code></pre><p>替换自定义 提前绘制控件</p>\n<pre><code>onCreate 到 onStart ：  289  299  294\nonCreate 到 onResume ：  292 302  296\nonStart 到 onResume ：   3    3    2\n</code></pre><h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。<br>去掉不必要的布局和View，虽然效果甚微，但也减少了。</p>\n<p>最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。<br>另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……</p>\n<p>最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。</p>\n<p>我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要对过度绘制和图形渲染做一个概念性的描述。</p>\n<p>同时以案例方式列出一些简单适用的优化措施。</p>\n<p>如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：</p>\n<p><a href=\"\">优化Android过度绘制</a></p>\n<p>另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 <a href=\"http://www.oschina.net/news/60157/android-performance-patterns\" target=\"_blank\" rel=\"noopener\">Android 性能优化典范</a></p>","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"GPU过度绘制\"><a href=\"#GPU过度绘制\" class=\"headerlink\" title=\"GPU过度绘制\"></a>GPU过度绘制</h3><p>是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。</p>\n<p><strong>仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！</strong></p>\n<p>还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！</p>\n<h3 id=\"图形渲染优化\"><a href=\"#图形渲染优化\" class=\"headerlink\" title=\"图形渲染优化\"></a>图形渲染优化</h3><p>一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。</p>\n<h2 id=\"关键点-字\"><a href=\"#关键点-字\" class=\"headerlink\" title=\"关键点/字\"></a>关键点/字</h2><ul>\n<li><p>过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。</p>\n</li>\n<li><p>调试GPU过渡绘制颜色区域说明    </p>\n<ul>\n<li>无/白色：绘制1次</li>\n<li>蓝色：绘制2次（理想状态）</li>\n<li>绿色：绘制3次</li>\n<li>浅红：绘制4次（要优化了）</li>\n<li><p>深红：绘制5次或5次以上。（必须要优化了）</p>\n<p><img src=\"http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>调试Hierarchy Viewer 颜色说明                    </p>\n<p>  下方三个原点从左到右：测量、布局、画图时间</p>\n<ul>\n<li>红色：该View所用时间超过大部分View很多</li>\n<li>黄色：该View所用时间超过大部分View</li>\n<li><p>绿色：该View所用时间低于大部分View</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211507297\" alt=\"调试Hierarchy Viewer颜色说明\"></p>\n</li>\n</ul>\n</li>\n<li><p>引起过度绘制的两个主要因素：层级与背景图片</p>\n<ul>\n<li>层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。</li>\n<li>改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层</li>\n<li>值得注意的是，背景图片的绘制是及其耗时的</li>\n</ul>\n</li>\n<li><p>一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。</p>\n<ul>\n<li>浅层布局效率高于深层布局</li>\n<li>布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout &gt; RelativeLayout</li>\n<li>基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。</li>\n<li>但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h2><ul>\n<li><p>在Theme中给activity增加背景。使用WindowBackground属性。</p>\n<p>  背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。</p>\n</li>\n</ul>\n<ul>\n<li><p>减少层级，没必要的背景图</p>\n<p>  如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景</p>\n</li>\n<li><p>避免使布局太深，而应该让布局更浅更深</p>\n<p>  用相对布局替换线性布局</p>\n</li>\n<li><p>无用的子节点、父节点删除</p>\n<p>  没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：</p>\n<p>  1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView</p>\n<p>  2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。</p>\n</li>\n<li><p>对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局</include></p>\n</li>\n<li><p>避免出现多个使用layout-weight属性的的LinearLayout。</p>\n<p>  首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。</p>\n</li>\n</ul>\n<ul>\n<li><p>合并作为根节点的帧布局(Framelayout)  </p>\n<p>  你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。</p>\n<p>  如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。</p>\n<p>  更有效的方式是使用<merge>标签替换该&lt; Framelayout /&gt;标签 。</merge></p>\n</li>\n<li><p>使用组合控件</p>\n<p>  首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。</p>\n<p>  但它会让你的布局文件看起来非常的清晰。</p>\n<p>  并且对于一些条状的控件。类似与下图这样的控件。</p>\n<p>  当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。</p>\n<p>  使用组合控件包装你的view，既符合封装的特性，又可以减少代码量</p>\n</li>\n</ul>\n<p><strong>重要的东西放到最后说：</strong></p>\n<ul>\n<li><p><strong>重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。</strong></p>\n<p>  说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）</p>\n<p>  那么这是你需要终极绝招：View提前绘制。</p>\n<p>  不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。</p>\n<p>  楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。</p>\n</li>\n</ul>\n<h2 id=\"案例说明-–-登录界面\"><a href=\"#案例说明-–-登录界面\" class=\"headerlink\" title=\"案例说明 – 登录界面\"></a>案例说明 – 登录界面</h2><p>为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。</p>\n<p>开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211551825\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p>惊讶吗？没关系，我们也可以做到。</p>\n<p>之后再看我们的UI层级图：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211744054\" alt=\"这里写图片描述\"></p>\n<p>下面我们一步步分析优化。</p>\n<h3 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h3><p><strong>优化布局结构，解决过深的UI层级图，与无用的子节点</strong></p>\n<ul>\n<li>过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20151016211802245\" alt=\"\"></p>\n<p><strong>优化方案1：</strong>采用相对布局，使得布局变浅变宽。最大可以保证只有两层。</p>\n<p><strong>优化方案2：</strong>观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。</p>\n<p>无用的子节点：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211827892\" alt=\"这里写图片描述\"></p>\n<p>一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。</p>\n<h3 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h3><p><strong>子view过久的测量时间。</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211844469\" alt=\"这里写图片描述\"></p>\n<p>查看其代码：</p>\n<pre><code>&lt;com.envision.mobile.ui.widget.EditView    \n    android:id=&quot;@+id/login_name&quot;    \n    android:layout_width=&quot;0dp&quot;    \n    android:layout_height=&quot;wrap_content&quot;   \n    android:layout_gravity=&quot;center_vertical&quot;    \n    android:layout_marginRight=&quot;8dip&quot;   \n    android:layout_weight=&quot;1&quot;    \n    android:background=&quot;@null&quot;       \n    android:hint=&quot;@string/hint_login_name&quot;    \n    android:imeOptions=&quot;actionNext&quot;    \n    android:paddingBottom=&quot;8dip&quot;   \n    android:singleLine=&quot;true&quot;   \n    android:textColor=&quot;@color/white&quot;   \n    android:textColorHint=&quot;@color/white_trans_88&quot;    \n    android:textCursorDrawable=&quot;@null&quot; /&gt;   \n</code></pre><p><strong>android:layout_weight=”1”  属性导致过久的测量时间。</strong>   </p>\n<h3 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h3><p>在Theme中给activity添加背景。减少一层绘制</p>\n<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;\n    @drawable/bg_homepage\n    &lt;/item&gt;\n&lt;/style&gt;\n</code></pre><h3 id=\"优化4\"><a href=\"#优化4\" class=\"headerlink\" title=\"优化4\"></a>优化4</h3><p><strong>重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。</strong></p>\n<p>这里代码量较大，我们放到另一篇文章中讲： </p>\n<p><a href=\"http://blog.csdn.net/u010255127/article/details/49702663\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u010255127/article/details/49702663</a></p>\n<h2 id=\"最终优化效果\"><a href=\"#最终优化效果\" class=\"headerlink\" title=\"最终优化效果\"></a>最终优化效果</h2><p>没有红色，最高是绿色<br>（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211244952\" alt=\"这里写图片描述\"></p>\n<h2 id=\"测试数据\"><a href=\"#测试数据\" class=\"headerlink\" title=\"测试数据\"></a>测试数据</h2><p>【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）<br>原始状况：</p>\n<pre><code>onCreate 到 onStart ： 381  370 \nonCreate 到 onResume ：383  373\nonStart 到 onResume ： 2     3\n</code></pre><p>在theme加背景</p>\n<pre><code>onCreate 到 onStart ： 274  295\nonCreate 到 onResume ：277  298\nonStart 到 onResume ：  3    3\n</code></pre><p>仅修改布局层次(去掉两个不必要透明布局)</p>\n<pre><code>onCreate 到 onStart ： 272   276\nonCreate 到 onResume ：274  279\nonStart 到 onResume ：  2     3\n</code></pre><p>替换自定义 提前绘制控件</p>\n<pre><code>onCreate 到 onStart ：  289  299  294\nonCreate 到 onResume ：  292 302  296\nonStart 到 onResume ：   3    3    2\n</code></pre><h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。<br>去掉不必要的布局和View，虽然效果甚微，但也减少了。</p>\n<p>最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。<br>另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……</p>\n<p>最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。</p>\n<p>我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。</p>"},{"title":"Android编译时注解框架4-爬坑","date":"2016-07-17T07:30:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。\n\n这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）\n\n随时踩坑，随时更新~\n\n<!-- more -->\n\n\n### 坑1：无法引入javax包下的类库\n\n编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。\n\n![](http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg)\n\n\n#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。\n\n----------------\n\n### 坑2：Build通过，编译失败\n\n报错信息： **finished with non-zero exit value 2**\n\n\tError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\t> com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2\n\n\n![](http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg)\n\n\t\n这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。\n\n开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑3：只能成功运行一次，修改代码后再运行就报错\n\n报错内容同 **坑2** 相同。\n\napp Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n\n错误提示：\n\n\t错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑5：成功运行，没有任何报错，但也没有任何预期结果。\n\n这是比较容易忽视的两个问题。\n\n#####Check 1:检查是否添加了配置文件：*javax.annotation.processing.Processor*\n\n（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）\n\n#####Check 2:检查是否重写了*getSupportedAnnotationTypes*方法：*javax.annotation.processing.Processor*\n\n重写该方法告诉*Processor*它需要处理哪些注解。\n\t\n----------------\n\t\n### 坑6：替换APT jar包后，apt代码并没有被执行。\n\n#####解决： 尝试 clean项目 ，并重新编译。\n\t\n----------------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n《Android编译时注解框架-爬坑》\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\t\n\t\n\t\n\t\n\t","source":"_posts/apt-Climbed-out-of-the-pit.md","raw":"---\ntitle: Android编译时注解框架4-爬坑\ndate: 2016-07-17 15:30:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。\n\n这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）\n\n随时踩坑，随时更新~\n\n<!-- more -->\n\n\n### 坑1：无法引入javax包下的类库\n\n编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。\n\n![](http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg)\n\n\n#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。\n\n----------------\n\n### 坑2：Build通过，编译失败\n\n报错信息： **finished with non-zero exit value 2**\n\n\tError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\t> com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2\n\n\n![](http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg)\n\n\t\n这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。\n\n开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑3：只能成功运行一次，修改代码后再运行就报错\n\n报错内容同 **坑2** 相同。\n\napp Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n\n错误提示：\n\n\t错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑5：成功运行，没有任何报错，但也没有任何预期结果。\n\n这是比较容易忽视的两个问题。\n\n#####Check 1:检查是否添加了配置文件：*javax.annotation.processing.Processor*\n\n（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）\n\n#####Check 2:检查是否重写了*getSupportedAnnotationTypes*方法：*javax.annotation.processing.Processor*\n\n重写该方法告诉*Processor*它需要处理哪些注解。\n\t\n----------------\n\t\n### 坑6：替换APT jar包后，apt代码并没有被执行。\n\n#####解决： 尝试 clean项目 ，并重新编译。\n\t\n----------------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n《Android编译时注解框架-爬坑》\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\t\n\t\n\t\n\t\n\t","slug":"apt-Climbed-out-of-the-pit","published":1,"updated":"2019-01-02T02:09:31.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspc000hyo9syt87p5gh","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。</p>\n<p>这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）</p>\n<p>随时踩坑，随时更新~</p>\n<a id=\"more\"></a>\n<h3 id=\"坑1：无法引入javax包下的类库\"><a href=\"#坑1：无法引入javax包下的类库\" class=\"headerlink\" title=\"坑1：无法引入javax包下的类库\"></a>坑1：无法引入javax包下的类库</h3><p>编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。</p>\n<p><img src=\"http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg\" alt=\"\"></p>\n<p>#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。</p>\n<hr>\n<h3 id=\"坑2：Build通过，编译失败\"><a href=\"#坑2：Build通过，编译失败\" class=\"headerlink\" title=\"坑2：Build通过，编译失败\"></a>坑2：Build通过，编译失败</h3><p>报错信息： <strong>finished with non-zero exit value 2</strong></p>\n<pre><code>Error:Execution failed for task &apos;:app:transformClassesWithDexForDebug&apos;.\n&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java&apos;&apos; finished with non-zero exit value 2\n</code></pre><p><img src=\"http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg\" alt=\"\"></p>\n<p>这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。</p>\n<p>开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑3：只能成功运行一次，修改代码后再运行就报错\"><a href=\"#坑3：只能成功运行一次，修改代码后再运行就报错\" class=\"headerlink\" title=\"坑3：只能成功运行一次，修改代码后再运行就报错\"></a>坑3：只能成功运行一次，修改代码后再运行就报错</h3><p>报错内容同 <strong>坑2</strong> 相同。</p>\n<p>app Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\"><a href=\"#坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\" class=\"headerlink\" title=\"坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\"></a>坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误</h3><p>错误提示：</p>\n<pre><code>错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n</code></pre><p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"><a href=\"#坑5：成功运行，没有任何报错，但也没有任何预期结果。\" class=\"headerlink\" title=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"></a>坑5：成功运行，没有任何报错，但也没有任何预期结果。</h3><p>这是比较容易忽视的两个问题。</p>\n<p>#####Check 1:检查是否添加了配置文件：<em>javax.annotation.processing.Processor</em></p>\n<p>（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）</p>\n<p>#####Check 2:检查是否重写了<em>getSupportedAnnotationTypes</em>方法：<em>javax.annotation.processing.Processor</em></p>\n<p>重写该方法告诉<em>Processor</em>它需要处理哪些注解。</p>\n<hr>\n<h3 id=\"坑6：替换APT-jar包后，apt代码并没有被执行。\"><a href=\"#坑6：替换APT-jar包后，apt代码并没有被执行。\" class=\"headerlink\" title=\"坑6：替换APT jar包后，apt代码并没有被执行。\"></a>坑6：替换APT jar包后，apt代码并没有被执行。</h3><p>#####解决： 尝试 clean项目 ，并重新编译。</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p>《Android编译时注解框架-爬坑》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。</p>\n<p>这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）</p>\n<p>随时踩坑，随时更新~</p>","more":"<h3 id=\"坑1：无法引入javax包下的类库\"><a href=\"#坑1：无法引入javax包下的类库\" class=\"headerlink\" title=\"坑1：无法引入javax包下的类库\"></a>坑1：无法引入javax包下的类库</h3><p>编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。</p>\n<p><img src=\"http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg\" alt=\"\"></p>\n<p>#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。</p>\n<hr>\n<h3 id=\"坑2：Build通过，编译失败\"><a href=\"#坑2：Build通过，编译失败\" class=\"headerlink\" title=\"坑2：Build通过，编译失败\"></a>坑2：Build通过，编译失败</h3><p>报错信息： <strong>finished with non-zero exit value 2</strong></p>\n<pre><code>Error:Execution failed for task &apos;:app:transformClassesWithDexForDebug&apos;.\n&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java&apos;&apos; finished with non-zero exit value 2\n</code></pre><p><img src=\"http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg\" alt=\"\"></p>\n<p>这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。</p>\n<p>开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑3：只能成功运行一次，修改代码后再运行就报错\"><a href=\"#坑3：只能成功运行一次，修改代码后再运行就报错\" class=\"headerlink\" title=\"坑3：只能成功运行一次，修改代码后再运行就报错\"></a>坑3：只能成功运行一次，修改代码后再运行就报错</h3><p>报错内容同 <strong>坑2</strong> 相同。</p>\n<p>app Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\"><a href=\"#坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\" class=\"headerlink\" title=\"坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\"></a>坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误</h3><p>错误提示：</p>\n<pre><code>错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n</code></pre><p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"><a href=\"#坑5：成功运行，没有任何报错，但也没有任何预期结果。\" class=\"headerlink\" title=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"></a>坑5：成功运行，没有任何报错，但也没有任何预期结果。</h3><p>这是比较容易忽视的两个问题。</p>\n<p>#####Check 1:检查是否添加了配置文件：<em>javax.annotation.processing.Processor</em></p>\n<p>（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）</p>\n<p>#####Check 2:检查是否重写了<em>getSupportedAnnotationTypes</em>方法：<em>javax.annotation.processing.Processor</em></p>\n<p>重写该方法告诉<em>Processor</em>它需要处理哪些注解。</p>\n<hr>\n<h3 id=\"坑6：替换APT-jar包后，apt代码并没有被执行。\"><a href=\"#坑6：替换APT-jar包后，apt代码并没有被执行。\" class=\"headerlink\" title=\"坑6：替换APT jar包后，apt代码并没有被执行。\"></a>坑6：替换APT jar包后，apt代码并没有被执行。</h3><p>#####解决： 尝试 clean项目 ，并重新编译。</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p>《Android编译时注解框架-爬坑》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android GC机制实践调研","date":"2016-02-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~\n\n网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：\n\n- System.gc(),真的是随叫随到？\n- 软引用弱引用的错误使用\n- 你觉得内存释放了，它就真的释放了么?\n\n\n幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。\n\n<!-- more -->\n\n***测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。***\n\n### 概要\n\n本次测试从以下几个方面对Android GC 进行调研\n\n- 主动调用System.gc()，不同状态的GC时机\n- 空白Activity所占内存大小及GC时机\n- 大内存量的Activity的GC时机\n- 奔溃临界值下，对象置NULL，是否还会引起内存溢出\n- 内存抖动\n- 软引用、弱引用的使用\n\n**本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛**\n\n\n### 主动调用GC下的GC时机\n\n<img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width = \"250\" height = \"150\" alt=\"红米-初始内存值\" align=center />\n\n（红米初始内存值）\n\n\n#### 测试1：创建临时变量，通过主动调用System.gc()观察\n\n<img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width = \"250\" height = \"200\" alt=\"创建临时变量\" align=center />\n\n可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，**内存增加量是远大于图片大小的**。\n\n\t\t//并没有进行显示，仅是创建一个图片\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n2分钟后内存一直维持在这个水平，**临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方**\n\n<img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width = \"250\" height = \"200\" alt=\"主动调用GC\" align=center />\n\n**之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。**\n\n\n#### 测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\n\n<img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width = \"250\" height = \"200\" alt=\"创建类成员变量\" align=center />\n\n\n        this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        \n        //置NULL\n        this.bitmap = null;\n        \n        //GC\n        System.gc();\n        \n\n\n<img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width = \"250\" height = \"200\" alt=\"置NULL后销毁\" align=center />\n\n\n**GC依然没有被触发**\n\n**发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了**\n\n#### 测试3：不停的初始化类成员变量\n\n也就是说不停的调用下面代码\n\n\tthis.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n\n\n\n<img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width = \"500\" height = \"200\" alt=\"多次初始化类成员\" align=center />\n\n\n可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。\n\n**内存占用只有达到一定限度时，GC才会开始执行。**\n\n期间也创建过临时变量，GC也多次调用后全无反应。\n\n\n### 空Activity占用的内存大小及销毁时间\n\n\n<img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width = \"150\" height = \"150\" alt=\"初始\" align=center />\n\n初始值\n\n<img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width = \"150\" height = \"150\" alt=\"初次打开\" align=center />\n\n初次打开\n\n<img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n<img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n\n初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）\n\n**一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右**\n\n迷之增长……\n\n\n### 非空Activity的销毁\n\n\n通过下面代码增加Activity内存占用量\n\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n            this.bitmapList.add(bmp);\n        }\n        \n <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \n 之后执行\n \n \t\tSystem.gc();\n        finish();\n        \n  无任何反应。\n  \n  **无论Activity是否占用大量内存，其销毁的时间都是迟钝的。**\n  \n  \n  \n### 濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\n\n经测算，当前测试机在190MB+时，将会内存溢出崩溃。\n\n\n <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\n\n对象置NULL\n\n\tthis.bitmapList = null;\n\n\n再次增加并显示\n\n\tthis.img.setImageResource(R.drawable.big_254);\n\n\n<img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n欣喜的事情发生了，**“类成员置NULL，对防止内存溢出崩溃是有必要的”**\n\n\n\n### 循环内创建（big or small）对象是否会引起内存抖动\n\n\n<img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n        }\n\n创建“小（1MB左右）”对象 \n\n<img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        }\n\n循环内创建“大（10MB左右）”对象会引起严重的内存抖动\n\n\n**无论对象大小，都应避免在循环内创建对象**\n\n\n### 软引用弱引用的错误使用\n\n这个错误似乎很少会有人犯，但感觉还是列出来比较好\n\n\n\t//错误使用\n\tprivate SoftReference<List<Bitmap>> softReference = new SoftReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    private WeakReference<List<Bitmap>> weakReference = new WeakReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    \n    \n    //正确使用\n    private List<SoftReference<Bitmap>> listRefrence = new ArrayList<>();\n\n\n用上述错误使用方式代码的两种情况\n\n\tList<Bitmap> list = softReference.get();\n        if (list == null) {\n            list = new ArrayList<>();\n            softReference = new SoftReference<>(list);\n        }\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list.add(bmp);\n        }\n\n\tList<Bitmap> list = null;\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list = weakReference.get();\n            if (list == null) {\n                list = new ArrayList<>();\n                weakReference = new WeakReference<>(list);\n            }\n            list.add(bmp);\n        }\n        \n      \n\n<img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \t\n内存会一直暴涨到奔溃。软引用弱引用并不会被收回\n\n\t//正确使用\n\tResources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            right.add(new SoftReference<>(bmp));\n        }\n\n\n<img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。**\n\n<img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~**\n\n\n### 结论\n\n\n- 不同系统不同型号的手机的GC机制是不同的\n\t- System.gc()调用结果不同（立即GC或无反应）\n\t- 废弃内存回收频率不同\n\t- 大规模GC临界值不同\n- 对于加载图片来说，内存增加量是远大于图片大小的。\n- 临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。\n- System.gc()并不是立刻执行GC的。\n- 每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的\n- 有时，内存占用只有达到一定限度时，GC才会开始被触发。\n- 一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右\n- 无论Activity是否占用大量内存，其销毁的时间都是迟钝的。\n- 类成员置NULL，对防止内存溢出崩溃是有必要的\n- 无论对象大小，都应避免在循环内创建对象\n- 注意软引用与弱引用的正确使用\n\n\n**最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。**\n\n[Demo代码https://github.com/lizhaoxuan/Android-GC-Research](https://github.com/lizhaoxuan/Android-GC-Research)\n\n\n\n\n\n\t\n","source":"_posts/androidgcdiaoyan.md","raw":"---\ntitle: Android GC机制实践调研\ndate: 2016-02-17 16:20:58\nauthor : 暴打小女孩\n\ntags: GC\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~\n\n网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：\n\n- System.gc(),真的是随叫随到？\n- 软引用弱引用的错误使用\n- 你觉得内存释放了，它就真的释放了么?\n\n\n幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。\n\n<!-- more -->\n\n***测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。***\n\n### 概要\n\n本次测试从以下几个方面对Android GC 进行调研\n\n- 主动调用System.gc()，不同状态的GC时机\n- 空白Activity所占内存大小及GC时机\n- 大内存量的Activity的GC时机\n- 奔溃临界值下，对象置NULL，是否还会引起内存溢出\n- 内存抖动\n- 软引用、弱引用的使用\n\n**本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛**\n\n\n### 主动调用GC下的GC时机\n\n<img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width = \"250\" height = \"150\" alt=\"红米-初始内存值\" align=center />\n\n（红米初始内存值）\n\n\n#### 测试1：创建临时变量，通过主动调用System.gc()观察\n\n<img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width = \"250\" height = \"200\" alt=\"创建临时变量\" align=center />\n\n可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，**内存增加量是远大于图片大小的**。\n\n\t\t//并没有进行显示，仅是创建一个图片\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n2分钟后内存一直维持在这个水平，**临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方**\n\n<img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width = \"250\" height = \"200\" alt=\"主动调用GC\" align=center />\n\n**之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。**\n\n\n#### 测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\n\n<img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width = \"250\" height = \"200\" alt=\"创建类成员变量\" align=center />\n\n\n        this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        \n        //置NULL\n        this.bitmap = null;\n        \n        //GC\n        System.gc();\n        \n\n\n<img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width = \"250\" height = \"200\" alt=\"置NULL后销毁\" align=center />\n\n\n**GC依然没有被触发**\n\n**发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了**\n\n#### 测试3：不停的初始化类成员变量\n\n也就是说不停的调用下面代码\n\n\tthis.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n\n\n\n<img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width = \"500\" height = \"200\" alt=\"多次初始化类成员\" align=center />\n\n\n可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。\n\n**内存占用只有达到一定限度时，GC才会开始执行。**\n\n期间也创建过临时变量，GC也多次调用后全无反应。\n\n\n### 空Activity占用的内存大小及销毁时间\n\n\n<img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width = \"150\" height = \"150\" alt=\"初始\" align=center />\n\n初始值\n\n<img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width = \"150\" height = \"150\" alt=\"初次打开\" align=center />\n\n初次打开\n\n<img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n<img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n\n初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）\n\n**一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右**\n\n迷之增长……\n\n\n### 非空Activity的销毁\n\n\n通过下面代码增加Activity内存占用量\n\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n            this.bitmapList.add(bmp);\n        }\n        \n <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \n 之后执行\n \n \t\tSystem.gc();\n        finish();\n        \n  无任何反应。\n  \n  **无论Activity是否占用大量内存，其销毁的时间都是迟钝的。**\n  \n  \n  \n### 濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\n\n经测算，当前测试机在190MB+时，将会内存溢出崩溃。\n\n\n <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\n\n对象置NULL\n\n\tthis.bitmapList = null;\n\n\n再次增加并显示\n\n\tthis.img.setImageResource(R.drawable.big_254);\n\n\n<img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n欣喜的事情发生了，**“类成员置NULL，对防止内存溢出崩溃是有必要的”**\n\n\n\n### 循环内创建（big or small）对象是否会引起内存抖动\n\n\n<img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n        }\n\n创建“小（1MB左右）”对象 \n\n<img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        }\n\n循环内创建“大（10MB左右）”对象会引起严重的内存抖动\n\n\n**无论对象大小，都应避免在循环内创建对象**\n\n\n### 软引用弱引用的错误使用\n\n这个错误似乎很少会有人犯，但感觉还是列出来比较好\n\n\n\t//错误使用\n\tprivate SoftReference<List<Bitmap>> softReference = new SoftReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    private WeakReference<List<Bitmap>> weakReference = new WeakReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    \n    \n    //正确使用\n    private List<SoftReference<Bitmap>> listRefrence = new ArrayList<>();\n\n\n用上述错误使用方式代码的两种情况\n\n\tList<Bitmap> list = softReference.get();\n        if (list == null) {\n            list = new ArrayList<>();\n            softReference = new SoftReference<>(list);\n        }\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list.add(bmp);\n        }\n\n\tList<Bitmap> list = null;\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list = weakReference.get();\n            if (list == null) {\n                list = new ArrayList<>();\n                weakReference = new WeakReference<>(list);\n            }\n            list.add(bmp);\n        }\n        \n      \n\n<img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \t\n内存会一直暴涨到奔溃。软引用弱引用并不会被收回\n\n\t//正确使用\n\tResources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            right.add(new SoftReference<>(bmp));\n        }\n\n\n<img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。**\n\n<img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~**\n\n\n### 结论\n\n\n- 不同系统不同型号的手机的GC机制是不同的\n\t- System.gc()调用结果不同（立即GC或无反应）\n\t- 废弃内存回收频率不同\n\t- 大规模GC临界值不同\n- 对于加载图片来说，内存增加量是远大于图片大小的。\n- 临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。\n- System.gc()并不是立刻执行GC的。\n- 每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的\n- 有时，内存占用只有达到一定限度时，GC才会开始被触发。\n- 一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右\n- 无论Activity是否占用大量内存，其销毁的时间都是迟钝的。\n- 类成员置NULL，对防止内存溢出崩溃是有必要的\n- 无论对象大小，都应避免在循环内创建对象\n- 注意软引用与弱引用的正确使用\n\n\n**最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。**\n\n[Demo代码https://github.com/lizhaoxuan/Android-GC-Research](https://github.com/lizhaoxuan/Android-GC-Research)\n\n\n\n\n\n\t\n","slug":"androidgcdiaoyan","published":1,"updated":"2019-01-02T02:09:31.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspe000jyo9srp0gtg1n","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p>众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~</p>\n<p>网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：</p>\n<ul>\n<li>System.gc(),真的是随叫随到？</li>\n<li>软引用弱引用的错误使用</li>\n<li>你觉得内存释放了，它就真的释放了么?</li>\n</ul>\n<p>幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。</p>\n<a id=\"more\"></a>\n<p><strong><em>测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。</em></strong></p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>本次测试从以下几个方面对Android GC 进行调研</p>\n<ul>\n<li>主动调用System.gc()，不同状态的GC时机</li>\n<li>空白Activity所占内存大小及GC时机</li>\n<li>大内存量的Activity的GC时机</li>\n<li>奔溃临界值下，对象置NULL，是否还会引起内存溢出</li>\n<li>内存抖动</li>\n<li>软引用、弱引用的使用</li>\n</ul>\n<p><strong>本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛</strong></p>\n<h3 id=\"主动调用GC下的GC时机\"><a href=\"#主动调用GC下的GC时机\" class=\"headerlink\" title=\"主动调用GC下的GC时机\"></a>主动调用GC下的GC时机</h3><p><img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width=\"250\" height=\"150\" alt=\"红米-初始内存值\" align=\"center\"></p>\n<p>（红米初始内存值）</p>\n<h4 id=\"测试1：创建临时变量，通过主动调用System-gc-观察\"><a href=\"#测试1：创建临时变量，通过主动调用System-gc-观察\" class=\"headerlink\" title=\"测试1：创建临时变量，通过主动调用System.gc()观察\"></a>测试1：创建临时变量，通过主动调用System.gc()观察</h4><p><img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width=\"250\" height=\"200\" alt=\"创建临时变量\" align=\"center\"></p>\n<p>可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，<strong>内存增加量是远大于图片大小的</strong>。</p>\n<pre><code>//并没有进行显示，仅是创建一个图片\nBitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p>2分钟后内存一直维持在这个水平，<strong>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方</strong></p>\n<p><img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width=\"250\" height=\"200\" alt=\"主动调用GC\" align=\"center\"></p>\n<p><strong>之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。</strong></p>\n<h4 id=\"测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\"><a href=\"#测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\" class=\"headerlink\" title=\"测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\"></a>测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察</h4><p><img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width=\"250\" height=\"200\" alt=\"创建类成员变量\" align=\"center\"></p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n//置NULL\nthis.bitmap = null;\n\n//GC\nSystem.gc();\n</code></pre><p><img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width=\"250\" height=\"200\" alt=\"置NULL后销毁\" align=\"center\"></p>\n<p><strong>GC依然没有被触发</strong></p>\n<p><strong>发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了</strong></p>\n<h4 id=\"测试3：不停的初始化类成员变量\"><a href=\"#测试3：不停的初始化类成员变量\" class=\"headerlink\" title=\"测试3：不停的初始化类成员变量\"></a>测试3：不停的初始化类成员变量</h4><p>也就是说不停的调用下面代码</p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width=\"500\" height=\"200\" alt=\"多次初始化类成员\" align=\"center\"></p>\n<p>可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。</p>\n<p><strong>内存占用只有达到一定限度时，GC才会开始执行。</strong></p>\n<p>期间也创建过临时变量，GC也多次调用后全无反应。</p>\n<h3 id=\"空Activity占用的内存大小及销毁时间\"><a href=\"#空Activity占用的内存大小及销毁时间\" class=\"headerlink\" title=\"空Activity占用的内存大小及销毁时间\"></a>空Activity占用的内存大小及销毁时间</h3><p><img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width=\"150\" height=\"150\" alt=\"初始\" align=\"center\"></p>\n<p>初始值</p>\n<p><img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width=\"150\" height=\"150\" alt=\"初次打开\" align=\"center\"></p>\n<p>初次打开</p>\n<p><img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p><img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p>初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）</p>\n<p><strong>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</strong></p>\n<p>迷之增长……</p>\n<h3 id=\"非空Activity的销毁\"><a href=\"#非空Activity的销毁\" class=\"headerlink\" title=\"非空Activity的销毁\"></a>非空Activity的销毁</h3><p>通过下面代码增加Activity内存占用量</p>\n<pre><code>Resources res = getResources();\nfor (int i = 0; i &lt; 10; i++) {\n    Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n    this.bitmapList.add(bmp);\n}\n</code></pre><p> <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p> 之后执行</p>\n<pre><code> System.gc();\nfinish();\n</code></pre><p>  无任何反应。</p>\n<p>  <strong>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</strong></p>\n<h3 id=\"濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\"><a href=\"#濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\" class=\"headerlink\" title=\"濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\"></a>濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出</h3><p>经测算，当前测试机在190MB+时，将会内存溢出崩溃。</p>\n<p> <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>对象置NULL</p>\n<pre><code>this.bitmapList = null;\n</code></pre><p>再次增加并显示</p>\n<pre><code>this.img.setImageResource(R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>欣喜的事情发生了，<strong>“类成员置NULL，对防止内存溢出崩溃是有必要的”</strong></p>\n<h3 id=\"循环内创建（big-or-small）对象是否会引起内存抖动\"><a href=\"#循环内创建（big-or-small）对象是否会引起内存抖动\" class=\"headerlink\" title=\"循环内创建（big or small）对象是否会引起内存抖动\"></a>循环内创建（big or small）对象是否会引起内存抖动</h3><p><img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n    }\n</code></pre><p>创建“小（1MB左右）”对象 </p>\n<p><img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n    }\n</code></pre><p>循环内创建“大（10MB左右）”对象会引起严重的内存抖动</p>\n<p><strong>无论对象大小，都应避免在循环内创建对象</strong></p>\n<h3 id=\"软引用弱引用的错误使用\"><a href=\"#软引用弱引用的错误使用\" class=\"headerlink\" title=\"软引用弱引用的错误使用\"></a>软引用弱引用的错误使用</h3><p>这个错误似乎很少会有人犯，但感觉还是列出来比较好</p>\n<pre><code>//错误使用\nprivate SoftReference&lt;List&lt;Bitmap&gt;&gt; softReference = new SoftReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\nprivate WeakReference&lt;List&lt;Bitmap&gt;&gt; weakReference = new WeakReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\n\n\n//正确使用\nprivate List&lt;SoftReference&lt;Bitmap&gt;&gt; listRefrence = new ArrayList&lt;&gt;();\n</code></pre><p>用上述错误使用方式代码的两种情况</p>\n<pre><code>List&lt;Bitmap&gt; list = softReference.get();\n    if (list == null) {\n        list = new ArrayList&lt;&gt;();\n        softReference = new SoftReference&lt;&gt;(list);\n    }\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list.add(bmp);\n    }\n\nList&lt;Bitmap&gt; list = null;\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list = weakReference.get();\n        if (list == null) {\n            list = new ArrayList&lt;&gt;();\n            weakReference = new WeakReference&lt;&gt;(list);\n        }\n        list.add(bmp);\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>内存会一直暴涨到奔溃。软引用弱引用并不会被收回</p>\n<pre><code>//正确使用\nResources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        right.add(new SoftReference&lt;&gt;(bmp));\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。</strong></p>\n<p><img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>不同系统不同型号的手机的GC机制是不同的<ul>\n<li>System.gc()调用结果不同（立即GC或无反应）</li>\n<li>废弃内存回收频率不同</li>\n<li>大规模GC临界值不同</li>\n</ul>\n</li>\n<li>对于加载图片来说，内存增加量是远大于图片大小的。</li>\n<li>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。</li>\n<li>System.gc()并不是立刻执行GC的。</li>\n<li>每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的</li>\n<li>有时，内存占用只有达到一定限度时，GC才会开始被触发。</li>\n<li>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</li>\n<li>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</li>\n<li>类成员置NULL，对防止内存溢出崩溃是有必要的</li>\n<li>无论对象大小，都应避免在循环内创建对象</li>\n<li>注意软引用与弱引用的正确使用</li>\n</ul>\n<p><strong>最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-GC-Research\" target=\"_blank\" rel=\"noopener\">Demo代码https://github.com/lizhaoxuan/Android-GC-Research</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p>众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~</p>\n<p>网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：</p>\n<ul>\n<li>System.gc(),真的是随叫随到？</li>\n<li>软引用弱引用的错误使用</li>\n<li>你觉得内存释放了，它就真的释放了么?</li>\n</ul>\n<p>幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。</p>","more":"<p><strong><em>测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。</em></strong></p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>本次测试从以下几个方面对Android GC 进行调研</p>\n<ul>\n<li>主动调用System.gc()，不同状态的GC时机</li>\n<li>空白Activity所占内存大小及GC时机</li>\n<li>大内存量的Activity的GC时机</li>\n<li>奔溃临界值下，对象置NULL，是否还会引起内存溢出</li>\n<li>内存抖动</li>\n<li>软引用、弱引用的使用</li>\n</ul>\n<p><strong>本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛</strong></p>\n<h3 id=\"主动调用GC下的GC时机\"><a href=\"#主动调用GC下的GC时机\" class=\"headerlink\" title=\"主动调用GC下的GC时机\"></a>主动调用GC下的GC时机</h3><p><img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width=\"250\" height=\"150\" alt=\"红米-初始内存值\" align=\"center\"></p>\n<p>（红米初始内存值）</p>\n<h4 id=\"测试1：创建临时变量，通过主动调用System-gc-观察\"><a href=\"#测试1：创建临时变量，通过主动调用System-gc-观察\" class=\"headerlink\" title=\"测试1：创建临时变量，通过主动调用System.gc()观察\"></a>测试1：创建临时变量，通过主动调用System.gc()观察</h4><p><img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width=\"250\" height=\"200\" alt=\"创建临时变量\" align=\"center\"></p>\n<p>可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，<strong>内存增加量是远大于图片大小的</strong>。</p>\n<pre><code>//并没有进行显示，仅是创建一个图片\nBitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p>2分钟后内存一直维持在这个水平，<strong>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方</strong></p>\n<p><img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width=\"250\" height=\"200\" alt=\"主动调用GC\" align=\"center\"></p>\n<p><strong>之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。</strong></p>\n<h4 id=\"测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\"><a href=\"#测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\" class=\"headerlink\" title=\"测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\"></a>测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察</h4><p><img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width=\"250\" height=\"200\" alt=\"创建类成员变量\" align=\"center\"></p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n//置NULL\nthis.bitmap = null;\n\n//GC\nSystem.gc();\n</code></pre><p><img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width=\"250\" height=\"200\" alt=\"置NULL后销毁\" align=\"center\"></p>\n<p><strong>GC依然没有被触发</strong></p>\n<p><strong>发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了</strong></p>\n<h4 id=\"测试3：不停的初始化类成员变量\"><a href=\"#测试3：不停的初始化类成员变量\" class=\"headerlink\" title=\"测试3：不停的初始化类成员变量\"></a>测试3：不停的初始化类成员变量</h4><p>也就是说不停的调用下面代码</p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width=\"500\" height=\"200\" alt=\"多次初始化类成员\" align=\"center\"></p>\n<p>可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。</p>\n<p><strong>内存占用只有达到一定限度时，GC才会开始执行。</strong></p>\n<p>期间也创建过临时变量，GC也多次调用后全无反应。</p>\n<h3 id=\"空Activity占用的内存大小及销毁时间\"><a href=\"#空Activity占用的内存大小及销毁时间\" class=\"headerlink\" title=\"空Activity占用的内存大小及销毁时间\"></a>空Activity占用的内存大小及销毁时间</h3><p><img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width=\"150\" height=\"150\" alt=\"初始\" align=\"center\"></p>\n<p>初始值</p>\n<p><img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width=\"150\" height=\"150\" alt=\"初次打开\" align=\"center\"></p>\n<p>初次打开</p>\n<p><img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p><img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p>初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）</p>\n<p><strong>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</strong></p>\n<p>迷之增长……</p>\n<h3 id=\"非空Activity的销毁\"><a href=\"#非空Activity的销毁\" class=\"headerlink\" title=\"非空Activity的销毁\"></a>非空Activity的销毁</h3><p>通过下面代码增加Activity内存占用量</p>\n<pre><code>Resources res = getResources();\nfor (int i = 0; i &lt; 10; i++) {\n    Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n    this.bitmapList.add(bmp);\n}\n</code></pre><p> <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p> 之后执行</p>\n<pre><code> System.gc();\nfinish();\n</code></pre><p>  无任何反应。</p>\n<p>  <strong>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</strong></p>\n<h3 id=\"濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\"><a href=\"#濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\" class=\"headerlink\" title=\"濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\"></a>濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出</h3><p>经测算，当前测试机在190MB+时，将会内存溢出崩溃。</p>\n<p> <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>对象置NULL</p>\n<pre><code>this.bitmapList = null;\n</code></pre><p>再次增加并显示</p>\n<pre><code>this.img.setImageResource(R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>欣喜的事情发生了，<strong>“类成员置NULL，对防止内存溢出崩溃是有必要的”</strong></p>\n<h3 id=\"循环内创建（big-or-small）对象是否会引起内存抖动\"><a href=\"#循环内创建（big-or-small）对象是否会引起内存抖动\" class=\"headerlink\" title=\"循环内创建（big or small）对象是否会引起内存抖动\"></a>循环内创建（big or small）对象是否会引起内存抖动</h3><p><img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n    }\n</code></pre><p>创建“小（1MB左右）”对象 </p>\n<p><img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n    }\n</code></pre><p>循环内创建“大（10MB左右）”对象会引起严重的内存抖动</p>\n<p><strong>无论对象大小，都应避免在循环内创建对象</strong></p>\n<h3 id=\"软引用弱引用的错误使用\"><a href=\"#软引用弱引用的错误使用\" class=\"headerlink\" title=\"软引用弱引用的错误使用\"></a>软引用弱引用的错误使用</h3><p>这个错误似乎很少会有人犯，但感觉还是列出来比较好</p>\n<pre><code>//错误使用\nprivate SoftReference&lt;List&lt;Bitmap&gt;&gt; softReference = new SoftReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\nprivate WeakReference&lt;List&lt;Bitmap&gt;&gt; weakReference = new WeakReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\n\n\n//正确使用\nprivate List&lt;SoftReference&lt;Bitmap&gt;&gt; listRefrence = new ArrayList&lt;&gt;();\n</code></pre><p>用上述错误使用方式代码的两种情况</p>\n<pre><code>List&lt;Bitmap&gt; list = softReference.get();\n    if (list == null) {\n        list = new ArrayList&lt;&gt;();\n        softReference = new SoftReference&lt;&gt;(list);\n    }\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list.add(bmp);\n    }\n\nList&lt;Bitmap&gt; list = null;\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list = weakReference.get();\n        if (list == null) {\n            list = new ArrayList&lt;&gt;();\n            weakReference = new WeakReference&lt;&gt;(list);\n        }\n        list.add(bmp);\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>内存会一直暴涨到奔溃。软引用弱引用并不会被收回</p>\n<pre><code>//正确使用\nResources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        right.add(new SoftReference&lt;&gt;(bmp));\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。</strong></p>\n<p><img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>不同系统不同型号的手机的GC机制是不同的<ul>\n<li>System.gc()调用结果不同（立即GC或无反应）</li>\n<li>废弃内存回收频率不同</li>\n<li>大规模GC临界值不同</li>\n</ul>\n</li>\n<li>对于加载图片来说，内存增加量是远大于图片大小的。</li>\n<li>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。</li>\n<li>System.gc()并不是立刻执行GC的。</li>\n<li>每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的</li>\n<li>有时，内存占用只有达到一定限度时，GC才会开始被触发。</li>\n<li>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</li>\n<li>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</li>\n<li>类成员置NULL，对防止内存溢出崩溃是有必要的</li>\n<li>无论对象大小，都应避免在循环内创建对象</li>\n<li>注意软引用与弱引用的正确使用</li>\n</ul>\n<p><strong>最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-GC-Research\" target=\"_blank\" rel=\"noopener\">Demo代码https://github.com/lizhaoxuan/Android-GC-Research</a></p>"},{"title":"Android编译时注解框架系列2-Run Demo","date":"2016-07-17T07:50:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。\n\n正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。\n\n<!-- more -->\n\n以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。\n\n所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！\n\n**在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。**\n\n\n### Running\n\n#### 项目搭建\n\n首先创建一个Android项目\n\n![](http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg)\n\n\n然后给我们的项目增加一个module,一定要记得是Java Library.\n\n因为APT需要用到jdk下的 【 *javax.~ *】包下的类，这在AndroidSdk中是没有的。\n\n\n![](http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg)\n\n\n![](http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg)\n\n\n#### 自定义注解\n\n新建一个类，GetMsg。就是我们自定义的注解。\n\n![](http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg)\n\n这是一个编译时注解，用*@Retention(RetentionPolicy.CLASS)*修饰。\n\n这个注解只能修饰方法。用*@Target(ElementType.METHOD)*修饰。\n\n且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 \n\n\n#### 创建Processor\n\nProcessor是用来处理Annotation的类。继承自AbstractProcessor。\n\n![](http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg)\n\n复写AbstractProcessor两个最重要的方法。\n\n*process*方法是用来处理注解的，我们一会写。\n\n*getSupportedAnnotationTypes*用来表示该Processor处理哪些注解。这里我们只有一个*GetMsg*注解需要处理。\n\n\n#### 重写process方法\n\n我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n            //获取该注解所在类的包名\n            String packageName = packageElement.getQualifiedName().toString();\n            TypeElement classElement = (TypeElement) element;\n            //获取该注解所在类的类名\n            String className = classElement.getSimpleName().toString();\n            //获取该注解所在类的全类名\n            String fullClassName = classElement.getQualifiedName().toString();\n            VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n            //获取方法名\n            String methodName = variableElement.getSimpleName().toString();\n            //获取该注解的值\n            int id = classElement.getAnnotation(GetMsg.class).id();\n            String name = classElement.getAnnotation(GetMsg.class).name();\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : packageName = \" + packageName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + className);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : fullClassName = \" + fullClassName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : methodName = \" + methodName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : id = \" + id + \"  name = \" + name);\n        }\n        return true;\n    }\n\n\n\n简单介绍一下代码：\n\n1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~\n\n2.这里还要解释一下`Messager messager = processingEnv.getMessager();` 这行代码里的`processingEnv`对象是哪来的。`processingEnv`是`CakeProcess`的父类`AbstractProcessor`的protected字段，其初始化是在父类中实现的，我们子类可以直接使用，比如这里就是通过`processingEnv`来获取`Messager`实例用来打Log。\n\n3.用for循环遍历所有的 GetMsg注解，然后进行处理。\n\n4.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。\n\n5.return true;表示该Process已经处理了，其他的Process不需要再处理了。\n\n#### 配置\n\n一定不能忘记的文件配置。\n\n在main文件夹下创建一个resources.META-INF.services文件夹，创建文件\n\njavax.annotation.processing.Processor\n\n![](http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg)\n\n文件内容是Process类的包名+类名\n\n![](http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg)\n\n忘记这个配置文件的后果就是，注解无法生效。\n\n#### 编译jar\n\n这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）\n\n而如何单独编译这个java Module呢？\n\n在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。\n\n![](http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg)\n\n\n代码没有问题编译通过的话，会有BUILD SUCCESS提示\n\n![](http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg)\n\n生成的jar包在 apt 下的build目录下的libs下\n\n![](http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg)\n\n将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.\n\n![](http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg)\n\n![](http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg)\n\n在APP项目中使用该注解GetMsg。运行。\n\n![](http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg)\n\n\n**当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法**\n\n\n#### 运行结果\n\n![](http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg)\n\n\n### 总结\n\n\n这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。\n\n整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》\n\n这个Demo的代码我放到了GitHub:\n\n[https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao](https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao)\n\n</br>\n \n------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n《Android编译时注解框架-Run Demo》\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n","source":"_posts/apt-run_demo.md","raw":"---\ntitle: Android编译时注解框架系列2-Run Demo\ndate: 2016-07-17 15:50:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。\n\n正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。\n\n<!-- more -->\n\n以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。\n\n所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！\n\n**在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。**\n\n\n### Running\n\n#### 项目搭建\n\n首先创建一个Android项目\n\n![](http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg)\n\n\n然后给我们的项目增加一个module,一定要记得是Java Library.\n\n因为APT需要用到jdk下的 【 *javax.~ *】包下的类，这在AndroidSdk中是没有的。\n\n\n![](http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg)\n\n\n![](http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg)\n\n\n#### 自定义注解\n\n新建一个类，GetMsg。就是我们自定义的注解。\n\n![](http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg)\n\n这是一个编译时注解，用*@Retention(RetentionPolicy.CLASS)*修饰。\n\n这个注解只能修饰方法。用*@Target(ElementType.METHOD)*修饰。\n\n且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 \n\n\n#### 创建Processor\n\nProcessor是用来处理Annotation的类。继承自AbstractProcessor。\n\n![](http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg)\n\n复写AbstractProcessor两个最重要的方法。\n\n*process*方法是用来处理注解的，我们一会写。\n\n*getSupportedAnnotationTypes*用来表示该Processor处理哪些注解。这里我们只有一个*GetMsg*注解需要处理。\n\n\n#### 重写process方法\n\n我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n            //获取该注解所在类的包名\n            String packageName = packageElement.getQualifiedName().toString();\n            TypeElement classElement = (TypeElement) element;\n            //获取该注解所在类的类名\n            String className = classElement.getSimpleName().toString();\n            //获取该注解所在类的全类名\n            String fullClassName = classElement.getQualifiedName().toString();\n            VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n            //获取方法名\n            String methodName = variableElement.getSimpleName().toString();\n            //获取该注解的值\n            int id = classElement.getAnnotation(GetMsg.class).id();\n            String name = classElement.getAnnotation(GetMsg.class).name();\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : packageName = \" + packageName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + className);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : fullClassName = \" + fullClassName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : methodName = \" + methodName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : id = \" + id + \"  name = \" + name);\n        }\n        return true;\n    }\n\n\n\n简单介绍一下代码：\n\n1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~\n\n2.这里还要解释一下`Messager messager = processingEnv.getMessager();` 这行代码里的`processingEnv`对象是哪来的。`processingEnv`是`CakeProcess`的父类`AbstractProcessor`的protected字段，其初始化是在父类中实现的，我们子类可以直接使用，比如这里就是通过`processingEnv`来获取`Messager`实例用来打Log。\n\n3.用for循环遍历所有的 GetMsg注解，然后进行处理。\n\n4.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。\n\n5.return true;表示该Process已经处理了，其他的Process不需要再处理了。\n\n#### 配置\n\n一定不能忘记的文件配置。\n\n在main文件夹下创建一个resources.META-INF.services文件夹，创建文件\n\njavax.annotation.processing.Processor\n\n![](http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg)\n\n文件内容是Process类的包名+类名\n\n![](http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg)\n\n忘记这个配置文件的后果就是，注解无法生效。\n\n#### 编译jar\n\n这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）\n\n而如何单独编译这个java Module呢？\n\n在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。\n\n![](http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg)\n\n\n代码没有问题编译通过的话，会有BUILD SUCCESS提示\n\n![](http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg)\n\n生成的jar包在 apt 下的build目录下的libs下\n\n![](http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg)\n\n将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.\n\n![](http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg)\n\n![](http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg)\n\n在APP项目中使用该注解GetMsg。运行。\n\n![](http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg)\n\n\n**当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法**\n\n\n#### 运行结果\n\n![](http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg)\n\n\n### 总结\n\n\n这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。\n\n整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》\n\n这个Demo的代码我放到了GitHub:\n\n[https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao](https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao)\n\n</br>\n \n------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n《Android编译时注解框架-Run Demo》\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n","slug":"apt-run_demo","published":1,"updated":"2019-01-02T02:09:31.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspg000myo9s5uuy41m4","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。</p>\n<p>正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。</p>\n<a id=\"more\"></a>\n<p>以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。</p>\n<p>所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！</p>\n<p><strong>在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。</strong></p>\n<h3 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>首先创建一个Android项目</p>\n<p><img src=\"http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg\" alt=\"\"></p>\n<p>然后给我们的项目增加一个module,一定要记得是Java Library.</p>\n<p>因为APT需要用到jdk下的 【 <em>javax.~ </em>】包下的类，这在AndroidSdk中是没有的。</p>\n<p><img src=\"http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg\" alt=\"\"></p>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>新建一个类，GetMsg。就是我们自定义的注解。</p>\n<p><img src=\"http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg\" alt=\"\"></p>\n<p>这是一个编译时注解，用<em>@Retention(RetentionPolicy.CLASS)</em>修饰。</p>\n<p>这个注解只能修饰方法。用<em>@Target(ElementType.METHOD)</em>修饰。</p>\n<p>且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 </p>\n<h4 id=\"创建Processor\"><a href=\"#创建Processor\" class=\"headerlink\" title=\"创建Processor\"></a>创建Processor</h4><p>Processor是用来处理Annotation的类。继承自AbstractProcessor。</p>\n<p><img src=\"http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg\" alt=\"\"></p>\n<p>复写AbstractProcessor两个最重要的方法。</p>\n<p><em>process</em>方法是用来处理注解的，我们一会写。</p>\n<p><em>getSupportedAnnotationTypes</em>用来表示该Processor处理哪些注解。这里我们只有一个<em>GetMsg</em>注解需要处理。</p>\n<h4 id=\"重写process方法\"><a href=\"#重写process方法\" class=\"headerlink\" title=\"重写process方法\"></a>重写process方法</h4><p>我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n        //获取该注解所在类的包名\n        String packageName = packageElement.getQualifiedName().toString();\n        TypeElement classElement = (TypeElement) element;\n        //获取该注解所在类的类名\n        String className = classElement.getSimpleName().toString();\n        //获取该注解所在类的全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n        //获取方法名\n        String methodName = variableElement.getSimpleName().toString();\n        //获取该注解的值\n        int id = classElement.getAnnotation(GetMsg.class).id();\n        String name = classElement.getAnnotation(GetMsg.class).name();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : packageName = &quot; + packageName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + className);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : fullClassName = &quot; + fullClassName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : methodName = &quot; + methodName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : id = &quot; + id + &quot;  name = &quot; + name);\n    }\n    return true;\n}\n</code></pre><p>简单介绍一下代码：</p>\n<p>1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~</p>\n<p>2.这里还要解释一下<code>Messager messager = processingEnv.getMessager();</code> 这行代码里的<code>processingEnv</code>对象是哪来的。<code>processingEnv</code>是<code>CakeProcess</code>的父类<code>AbstractProcessor</code>的protected字段，其初始化是在父类中实现的，我们子类可以直接使用，比如这里就是通过<code>processingEnv</code>来获取<code>Messager</code>实例用来打Log。</p>\n<p>3.用for循环遍历所有的 GetMsg注解，然后进行处理。</p>\n<p>4.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。</p>\n<p>5.return true;表示该Process已经处理了，其他的Process不需要再处理了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>一定不能忘记的文件配置。</p>\n<p>在main文件夹下创建一个resources.META-INF.services文件夹，创建文件</p>\n<p>javax.annotation.processing.Processor</p>\n<p><img src=\"http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg\" alt=\"\"></p>\n<p>文件内容是Process类的包名+类名</p>\n<p><img src=\"http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg\" alt=\"\"></p>\n<p>忘记这个配置文件的后果就是，注解无法生效。</p>\n<h4 id=\"编译jar\"><a href=\"#编译jar\" class=\"headerlink\" title=\"编译jar\"></a>编译jar</h4><p>这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）</p>\n<p>而如何单独编译这个java Module呢？</p>\n<p>在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。</p>\n<p><img src=\"http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg\" alt=\"\"></p>\n<p>代码没有问题编译通过的话，会有BUILD SUCCESS提示</p>\n<p><img src=\"http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg\" alt=\"\"></p>\n<p>生成的jar包在 apt 下的build目录下的libs下</p>\n<p><img src=\"http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg\" alt=\"\"></p>\n<p>将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.</p>\n<p><img src=\"http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg\" alt=\"\"></p>\n<p>在APP项目中使用该注解GetMsg。运行。</p>\n<p><img src=\"http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg\" alt=\"\"></p>\n<p><strong>当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法</strong></p>\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。</p>\n<p>整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》</p>\n<p>这个Demo的代码我放到了GitHub:</p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao</a></p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p>《Android编译时注解框架-Run Demo》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。</p>\n<p>正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。</p>","more":"<p>以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。</p>\n<p>所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！</p>\n<p><strong>在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。</strong></p>\n<h3 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>首先创建一个Android项目</p>\n<p><img src=\"http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg\" alt=\"\"></p>\n<p>然后给我们的项目增加一个module,一定要记得是Java Library.</p>\n<p>因为APT需要用到jdk下的 【 <em>javax.~ </em>】包下的类，这在AndroidSdk中是没有的。</p>\n<p><img src=\"http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg\" alt=\"\"></p>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>新建一个类，GetMsg。就是我们自定义的注解。</p>\n<p><img src=\"http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg\" alt=\"\"></p>\n<p>这是一个编译时注解，用<em>@Retention(RetentionPolicy.CLASS)</em>修饰。</p>\n<p>这个注解只能修饰方法。用<em>@Target(ElementType.METHOD)</em>修饰。</p>\n<p>且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 </p>\n<h4 id=\"创建Processor\"><a href=\"#创建Processor\" class=\"headerlink\" title=\"创建Processor\"></a>创建Processor</h4><p>Processor是用来处理Annotation的类。继承自AbstractProcessor。</p>\n<p><img src=\"http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg\" alt=\"\"></p>\n<p>复写AbstractProcessor两个最重要的方法。</p>\n<p><em>process</em>方法是用来处理注解的，我们一会写。</p>\n<p><em>getSupportedAnnotationTypes</em>用来表示该Processor处理哪些注解。这里我们只有一个<em>GetMsg</em>注解需要处理。</p>\n<h4 id=\"重写process方法\"><a href=\"#重写process方法\" class=\"headerlink\" title=\"重写process方法\"></a>重写process方法</h4><p>我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n        //获取该注解所在类的包名\n        String packageName = packageElement.getQualifiedName().toString();\n        TypeElement classElement = (TypeElement) element;\n        //获取该注解所在类的类名\n        String className = classElement.getSimpleName().toString();\n        //获取该注解所在类的全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n        //获取方法名\n        String methodName = variableElement.getSimpleName().toString();\n        //获取该注解的值\n        int id = classElement.getAnnotation(GetMsg.class).id();\n        String name = classElement.getAnnotation(GetMsg.class).name();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : packageName = &quot; + packageName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + className);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : fullClassName = &quot; + fullClassName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : methodName = &quot; + methodName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : id = &quot; + id + &quot;  name = &quot; + name);\n    }\n    return true;\n}\n</code></pre><p>简单介绍一下代码：</p>\n<p>1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~</p>\n<p>2.这里还要解释一下<code>Messager messager = processingEnv.getMessager();</code> 这行代码里的<code>processingEnv</code>对象是哪来的。<code>processingEnv</code>是<code>CakeProcess</code>的父类<code>AbstractProcessor</code>的protected字段，其初始化是在父类中实现的，我们子类可以直接使用，比如这里就是通过<code>processingEnv</code>来获取<code>Messager</code>实例用来打Log。</p>\n<p>3.用for循环遍历所有的 GetMsg注解，然后进行处理。</p>\n<p>4.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。</p>\n<p>5.return true;表示该Process已经处理了，其他的Process不需要再处理了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>一定不能忘记的文件配置。</p>\n<p>在main文件夹下创建一个resources.META-INF.services文件夹，创建文件</p>\n<p>javax.annotation.processing.Processor</p>\n<p><img src=\"http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg\" alt=\"\"></p>\n<p>文件内容是Process类的包名+类名</p>\n<p><img src=\"http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg\" alt=\"\"></p>\n<p>忘记这个配置文件的后果就是，注解无法生效。</p>\n<h4 id=\"编译jar\"><a href=\"#编译jar\" class=\"headerlink\" title=\"编译jar\"></a>编译jar</h4><p>这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）</p>\n<p>而如何单独编译这个java Module呢？</p>\n<p>在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。</p>\n<p><img src=\"http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg\" alt=\"\"></p>\n<p>代码没有问题编译通过的话，会有BUILD SUCCESS提示</p>\n<p><img src=\"http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg\" alt=\"\"></p>\n<p>生成的jar包在 apt 下的build目录下的libs下</p>\n<p><img src=\"http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg\" alt=\"\"></p>\n<p>将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.</p>\n<p><img src=\"http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg\" alt=\"\"></p>\n<p>在APP项目中使用该注解GetMsg。运行。</p>\n<p><img src=\"http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg\" alt=\"\"></p>\n<p><strong>当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法</strong></p>\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。</p>\n<p>整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》</p>\n<p>这个Demo的代码我放到了GitHub:</p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao</a></p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p>《Android编译时注解框架-Run Demo》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架5-语法讲解","date":"2016-07-17T07:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……\n\n这里对猜对的结果进行一个总结，让后来者可以更快的上手。\n\n<!-- more -->\n\n第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。\n\n\n\n### 自定义注解相关\n\n定义注解格式：   public @interface 注解名 {定义体}\n\nAnnotation里面的参数该设定: \n\n第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　\n\n第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1,name = \"asd\")\n\tclass Test{\n\t}\n\t\n如果只有一个参数，建议设置为value\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Println {\n\t    int value();\n\t}\n\t\n\t//使用\n\t@Println(1)\n\tclass Test{\n\t}\n\t\n参数为value时，可以直接写入参数,使用时不在需要key=value写法。\n但当有多个参数时，不可以再使用value。\n\n\t\n#### @Retention\n\n这个在第一章有讲。申明该注解属于什么类型注解\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）\n\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t运行时注解，一般在运行时通过反射去识别的注解。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t编译时注解，在编译时处理。\n\t\n#### @Target(ElementType.TYPE)\n\n表示该注解用来修饰哪些元素。并可以修饰多个\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\n\tpublic @interface GetMsg {\n\t    int id();\n\t    String name() default \"default\";\n\t}\n\n例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。\n\n\t@GetMsg(1)\n    public void printError(){\n        //TODO ~\n    }\n    \n    @GetMsg(1)  //编译器会报错\n    class Test{\n     \t//TODO ~\n    }\n    \n- @Target(ElementType.TYPE)\n\n\t接口、类、枚举、注解\n\t\n- @Target(ElementType.FIELD) \n\n\t字段、枚举的常量\n\t\n- @Target(ElementType.METHOD) \n\n\t方法\n\t\n- @Target(ElementType.PARAMETER)\n\t\n\t方法参数 \n\t\n- @Target(ElementType.CONSTRUCTOR) \n\n\t构造函数 \n\n- @Target(ElementType.LOCAL_VARIABLE)\n\n\t局部变量 \n\n- @Target(ElementType.ANNOTATION_TYPE)\n\n\t注解 \n\t\n- @Target(ElementType.package) \n\n\t包 \n\t\n\t\n#### @Inherited\n\n该注解的字面意识是继承，但你要知道**注解是不可以继承的**。\n\n@Inherited是在继承结构中使用的注解。\n\n如果你的注解是这样定义的：\n\n\t@Inherited\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Test {\n\t\t//...\n\t}\n\n当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。\n\n*这里感谢 豪哥 @刘志豪 的排疑解惑~*\n\n#### 注解的默认值\n\n注解可以设置默认值，有默认值的参数可以不写。\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1) //name有默认值可以不写\n\tclass Test{\n\t}\n\n\n#### “注解的继承”（依赖倒置？）\n\n这里讲的继承并不是通过@Inherited修饰的注解。\n\n这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。\n\n先看代码。\n\n\t@Target(METHOD)\n\t@Retention(CLASS)\n\t@ListenerClass(\n\t    targetType = \"android.view.View\",\n    \tsetter = \"setOnClickListener\",\n    \ttype = \"butterknife.internal.DebouncingOnClickListener\",\n    \tmethod = @ListenerMethod(\n        \tname = \"doClick\",\n        \tparameters = \"android.view.View\"\n    \t)\n\t)\n\tpublic @interface OnClick {\n  \t\t/** View IDs to which the method will be bound. */\n  \t\tint[] value() default { View.NO_ID };\n\t}\n\t\n\n这是ButterKnife的OnClick 注解。特殊的地方在于**@OnClick修饰了注解@ListenerClass**，并且设置了一些只属于@OnClick的属性。\n\n那这样的作用是什么呢？\n\n凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。\n\n这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。\n\n\n### 处理器类Processor编写\n\n自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。\n\nAbstractProcessor有两个重要的方法需要重写。\n\n![](http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg)\n\n\n#### 重写getSupportedAnnotationTypes方法：\n\n通过重写该方法，告知Processor哪些注解需要处理。\n\n返回一个Set集合，集合内容为自定义注解的包名+类名。\n\n建议项目中这样编写：\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        //需要全类名\n        types.add(GetMsg.class.getCanonicalName()); \n        types.add(Println.class.getCanonicalName());\n        return types;\n    }\n    \n另外如果注解数量很少的话，可以通过另一种方式实现：\n\n\t//在只有一到两个注解需要处理时，可以这样编写：\n\t@SupportedAnnotationTypes(\"com.example.annotation.SetContentView\")\n\t@SupportedSourceVersion(SourceVersion.RELEASE_7)\n\tpublic class ContentViewProcessor extends AbstractProcessor {\n\t\n\t}\n\t\n#### 重写process方法：\n\n所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        \n        \n        return false;\n    }\n\n先简单解释下这个方法的参数和返回值。\n\n**参数** *Set<? extends TypeElement> annotations* ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）\n**参数** *RoundEnvironment roundEnv* ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。\n\n例：\t\t\n\n\tfor (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n\t\t//所有被使用的@GetMsg\n\t}\n\n**返回值** 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理\n\n### 输出Log\n\n虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。\n\n**Processor日志输出的位置在编译器下方的Messages窗口中。**\n\nProcessor支持最基础的System.out方法。\n\n同样Processor也有自己的Log输出工具: Messager。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n    \t\n    \t//取得Messager对象\n        Messager messager = processingEnv.getMessager();\n        \n        //输出日志\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + element.getSimpleName().toString());\n        }\n\n同Log类似，Messager也有日志级别的选择。\n\n- Diagnostic.Kind.ERROR \n- Diagnostic.Kind.WARNING \n- Diagnostic.Kind.MANDATORY_WARNING \n- Diagnostic.Kind.NOTE \n- Diagnostic.Kind.OTHER \n\n他们的输出样式如图：\n\n\n\n\n![](http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg)\n\n![](http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg)\n\n**注意：当没有属于该Process处理的注解被使用时，process不会执行。**\n\n**注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。**\n\n这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？\n\n### 用生成的代码来生成代码\n\nAPT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？\n\n同样可以被扫描到，并且用于代码生成。其过程如下：\n\nAPT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。\n\n同样你肯定也会发现一个问题，这不很容易会变成死循环吗？\n\n**没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！**\n\n\n### Element\n\nElement也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。\n\nElement的官方注释：\n\nRepresents a program element such as a package, class, or method.\nEach element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).\n\n表示一个程序元素，比如包、类或者方法。\n\n例如：取得所有修饰了@OnceClick的元素。\n\t\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\t//OnceClick.class是@Target(METHOD)\n\t\t//则该element是可以强转为表示方法的ExecutableElement\n\t\tExecutableElement method = （ExecutableElement）element;\n\t\t//如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n\t\t//但有例外情况，我们稍后列举\n\t\tTypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n\t}\n\nElement的子类有：\n\n- ExecutableElement\n\t\n\t表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\t\n\t对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)\n\n- PackageElement;\n\n\t表示一个包程序元素。提供对有关包极其成员的信息访问。\n\t\n\t对应@Target(ElementType.PACKAGE)\n\n- TypeElement;\n\n\t表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。\n\t\n\t对应@Target(ElementType.TYPE)\n\t\n\t**注意：枚举类型是一种类，而注解类型是一种接口。**\n\n- TypeParameterElement;\n\n\t表示一般类、接口、方法或构造方法元素的类型参数。\n\t\n\t对应@Target(ElementType.PARAMETER)\n\n- VariableElement;\n\n\t表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。\n\t\n\t对应@Target(ElementType.LOCAL_VARIABLE)\n\t\n例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：\n\nElement 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\tExecutableElement method = (ExecutableElement)element;\n\t}\n\n\n接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。\n\n### 修饰方法的注解和ExecutableElement\n\n当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。\n\n如何获取：\n\n\t//OnceClick.class 以 @Target(ElementType.METHOD)修饰\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n\t\t//对于Element直接强转\n        ExecutableElement executableElement = (ExecutableElement) element;\n        \n        //非对应的Element，通过getEnclosingElement转换获取\n        TypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n                    \n        //当(ExecutableElement) element成立时，使用(PackageElement) element\n        //            .getEnclosingElement();将报错。\n        //需要使用elementUtils来获取\n        Elements elementUtils = processingEnv.getElementUtils();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\t\t\n\t\t//全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //方法名\n        String methodName = executableElement.getSimpleName().toString();\n\n\t\t//取得方法参数列表\n\t\tList<? extends VariableElement> methodParameters = executableElement.getParameters();\n\t\t//参数类型列表\n\t\tList<String> types = new ArrayList<>();\n        for (VariableElement variableElement : methodParameters) {\n            TypeMirror methodParameterType = variableElement.asType();\n            if (methodParameterType instanceof TypeVariable) {\n                TypeVariable typeVariable = (TypeVariable) methodParameterType;\n                methodParameterType = typeVariable.getUpperBound();\n                \n            }\n            //参数名\n            String parameterName = variableElement.getSimpleName().toString();\n            //参数类型\n            String parameteKind = methodParameterType.toString();\n            types.add(methodParameterType.toString());\n        }\n\t}\n\n\n### 修饰属性、类成员的注解和VariableElement\n\n\n当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名\n\n如何获取：\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n\t\t//ElementType.FIELD注解可以直接强转VariableElement\n\t\tVariableElement variableElement = (VariableElement) element;\n\t\t\n        TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //类成员名\n        String variableName = variableElement.getSimpleName().toString();\n        \n        //类成员类型\n        TypeMirror typeMirror = variableElement.asType();\n        String type = typeMirror.toString();\n        \n\t}\n\t\n\t\n### 修饰类的注解和TypeElement\n\n\n当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。\n\n如何获取：\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n\t\t//ElementType.TYPE注解可以直接强转TypeElement\n        TypeElement classElement = (TypeElement) element;\n        \n        PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n                    \n        //全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n \t\t//父类名\n \t\tString superClassName = classElement.getSuperclass().toString();\n        \n\t}\n\t\n\t\n<br/>\n\n-------------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n《Android编译时注解框架-语法讲解》\n\n\n\t\n","source":"_posts/apt-Grammar-explanation.md","raw":"---\ntitle: Android编译时注解框架5-语法讲解\ndate: 2016-07-17 15:20:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……\n\n这里对猜对的结果进行一个总结，让后来者可以更快的上手。\n\n<!-- more -->\n\n第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。\n\n\n\n### 自定义注解相关\n\n定义注解格式：   public @interface 注解名 {定义体}\n\nAnnotation里面的参数该设定: \n\n第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　\n\n第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1,name = \"asd\")\n\tclass Test{\n\t}\n\t\n如果只有一个参数，建议设置为value\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Println {\n\t    int value();\n\t}\n\t\n\t//使用\n\t@Println(1)\n\tclass Test{\n\t}\n\t\n参数为value时，可以直接写入参数,使用时不在需要key=value写法。\n但当有多个参数时，不可以再使用value。\n\n\t\n#### @Retention\n\n这个在第一章有讲。申明该注解属于什么类型注解\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）\n\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t运行时注解，一般在运行时通过反射去识别的注解。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t编译时注解，在编译时处理。\n\t\n#### @Target(ElementType.TYPE)\n\n表示该注解用来修饰哪些元素。并可以修饰多个\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\n\tpublic @interface GetMsg {\n\t    int id();\n\t    String name() default \"default\";\n\t}\n\n例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。\n\n\t@GetMsg(1)\n    public void printError(){\n        //TODO ~\n    }\n    \n    @GetMsg(1)  //编译器会报错\n    class Test{\n     \t//TODO ~\n    }\n    \n- @Target(ElementType.TYPE)\n\n\t接口、类、枚举、注解\n\t\n- @Target(ElementType.FIELD) \n\n\t字段、枚举的常量\n\t\n- @Target(ElementType.METHOD) \n\n\t方法\n\t\n- @Target(ElementType.PARAMETER)\n\t\n\t方法参数 \n\t\n- @Target(ElementType.CONSTRUCTOR) \n\n\t构造函数 \n\n- @Target(ElementType.LOCAL_VARIABLE)\n\n\t局部变量 \n\n- @Target(ElementType.ANNOTATION_TYPE)\n\n\t注解 \n\t\n- @Target(ElementType.package) \n\n\t包 \n\t\n\t\n#### @Inherited\n\n该注解的字面意识是继承，但你要知道**注解是不可以继承的**。\n\n@Inherited是在继承结构中使用的注解。\n\n如果你的注解是这样定义的：\n\n\t@Inherited\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Test {\n\t\t//...\n\t}\n\n当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。\n\n*这里感谢 豪哥 @刘志豪 的排疑解惑~*\n\n#### 注解的默认值\n\n注解可以设置默认值，有默认值的参数可以不写。\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1) //name有默认值可以不写\n\tclass Test{\n\t}\n\n\n#### “注解的继承”（依赖倒置？）\n\n这里讲的继承并不是通过@Inherited修饰的注解。\n\n这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。\n\n先看代码。\n\n\t@Target(METHOD)\n\t@Retention(CLASS)\n\t@ListenerClass(\n\t    targetType = \"android.view.View\",\n    \tsetter = \"setOnClickListener\",\n    \ttype = \"butterknife.internal.DebouncingOnClickListener\",\n    \tmethod = @ListenerMethod(\n        \tname = \"doClick\",\n        \tparameters = \"android.view.View\"\n    \t)\n\t)\n\tpublic @interface OnClick {\n  \t\t/** View IDs to which the method will be bound. */\n  \t\tint[] value() default { View.NO_ID };\n\t}\n\t\n\n这是ButterKnife的OnClick 注解。特殊的地方在于**@OnClick修饰了注解@ListenerClass**，并且设置了一些只属于@OnClick的属性。\n\n那这样的作用是什么呢？\n\n凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。\n\n这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。\n\n\n### 处理器类Processor编写\n\n自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。\n\nAbstractProcessor有两个重要的方法需要重写。\n\n![](http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg)\n\n\n#### 重写getSupportedAnnotationTypes方法：\n\n通过重写该方法，告知Processor哪些注解需要处理。\n\n返回一个Set集合，集合内容为自定义注解的包名+类名。\n\n建议项目中这样编写：\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        //需要全类名\n        types.add(GetMsg.class.getCanonicalName()); \n        types.add(Println.class.getCanonicalName());\n        return types;\n    }\n    \n另外如果注解数量很少的话，可以通过另一种方式实现：\n\n\t//在只有一到两个注解需要处理时，可以这样编写：\n\t@SupportedAnnotationTypes(\"com.example.annotation.SetContentView\")\n\t@SupportedSourceVersion(SourceVersion.RELEASE_7)\n\tpublic class ContentViewProcessor extends AbstractProcessor {\n\t\n\t}\n\t\n#### 重写process方法：\n\n所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        \n        \n        return false;\n    }\n\n先简单解释下这个方法的参数和返回值。\n\n**参数** *Set<? extends TypeElement> annotations* ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）\n**参数** *RoundEnvironment roundEnv* ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。\n\n例：\t\t\n\n\tfor (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n\t\t//所有被使用的@GetMsg\n\t}\n\n**返回值** 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理\n\n### 输出Log\n\n虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。\n\n**Processor日志输出的位置在编译器下方的Messages窗口中。**\n\nProcessor支持最基础的System.out方法。\n\n同样Processor也有自己的Log输出工具: Messager。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n    \t\n    \t//取得Messager对象\n        Messager messager = processingEnv.getMessager();\n        \n        //输出日志\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + element.getSimpleName().toString());\n        }\n\n同Log类似，Messager也有日志级别的选择。\n\n- Diagnostic.Kind.ERROR \n- Diagnostic.Kind.WARNING \n- Diagnostic.Kind.MANDATORY_WARNING \n- Diagnostic.Kind.NOTE \n- Diagnostic.Kind.OTHER \n\n他们的输出样式如图：\n\n\n\n\n![](http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg)\n\n![](http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg)\n\n**注意：当没有属于该Process处理的注解被使用时，process不会执行。**\n\n**注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。**\n\n这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？\n\n### 用生成的代码来生成代码\n\nAPT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？\n\n同样可以被扫描到，并且用于代码生成。其过程如下：\n\nAPT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。\n\n同样你肯定也会发现一个问题，这不很容易会变成死循环吗？\n\n**没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！**\n\n\n### Element\n\nElement也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。\n\nElement的官方注释：\n\nRepresents a program element such as a package, class, or method.\nEach element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).\n\n表示一个程序元素，比如包、类或者方法。\n\n例如：取得所有修饰了@OnceClick的元素。\n\t\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\t//OnceClick.class是@Target(METHOD)\n\t\t//则该element是可以强转为表示方法的ExecutableElement\n\t\tExecutableElement method = （ExecutableElement）element;\n\t\t//如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n\t\t//但有例外情况，我们稍后列举\n\t\tTypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n\t}\n\nElement的子类有：\n\n- ExecutableElement\n\t\n\t表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\t\n\t对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)\n\n- PackageElement;\n\n\t表示一个包程序元素。提供对有关包极其成员的信息访问。\n\t\n\t对应@Target(ElementType.PACKAGE)\n\n- TypeElement;\n\n\t表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。\n\t\n\t对应@Target(ElementType.TYPE)\n\t\n\t**注意：枚举类型是一种类，而注解类型是一种接口。**\n\n- TypeParameterElement;\n\n\t表示一般类、接口、方法或构造方法元素的类型参数。\n\t\n\t对应@Target(ElementType.PARAMETER)\n\n- VariableElement;\n\n\t表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。\n\t\n\t对应@Target(ElementType.LOCAL_VARIABLE)\n\t\n例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：\n\nElement 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\tExecutableElement method = (ExecutableElement)element;\n\t}\n\n\n接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。\n\n### 修饰方法的注解和ExecutableElement\n\n当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。\n\n如何获取：\n\n\t//OnceClick.class 以 @Target(ElementType.METHOD)修饰\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n\t\t//对于Element直接强转\n        ExecutableElement executableElement = (ExecutableElement) element;\n        \n        //非对应的Element，通过getEnclosingElement转换获取\n        TypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n                    \n        //当(ExecutableElement) element成立时，使用(PackageElement) element\n        //            .getEnclosingElement();将报错。\n        //需要使用elementUtils来获取\n        Elements elementUtils = processingEnv.getElementUtils();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\t\t\n\t\t//全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //方法名\n        String methodName = executableElement.getSimpleName().toString();\n\n\t\t//取得方法参数列表\n\t\tList<? extends VariableElement> methodParameters = executableElement.getParameters();\n\t\t//参数类型列表\n\t\tList<String> types = new ArrayList<>();\n        for (VariableElement variableElement : methodParameters) {\n            TypeMirror methodParameterType = variableElement.asType();\n            if (methodParameterType instanceof TypeVariable) {\n                TypeVariable typeVariable = (TypeVariable) methodParameterType;\n                methodParameterType = typeVariable.getUpperBound();\n                \n            }\n            //参数名\n            String parameterName = variableElement.getSimpleName().toString();\n            //参数类型\n            String parameteKind = methodParameterType.toString();\n            types.add(methodParameterType.toString());\n        }\n\t}\n\n\n### 修饰属性、类成员的注解和VariableElement\n\n\n当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名\n\n如何获取：\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n\t\t//ElementType.FIELD注解可以直接强转VariableElement\n\t\tVariableElement variableElement = (VariableElement) element;\n\t\t\n        TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //类成员名\n        String variableName = variableElement.getSimpleName().toString();\n        \n        //类成员类型\n        TypeMirror typeMirror = variableElement.asType();\n        String type = typeMirror.toString();\n        \n\t}\n\t\n\t\n### 修饰类的注解和TypeElement\n\n\n当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。\n\n如何获取：\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n\t\t//ElementType.TYPE注解可以直接强转TypeElement\n        TypeElement classElement = (TypeElement) element;\n        \n        PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n                    \n        //全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n \t\t//父类名\n \t\tString superClassName = classElement.getSuperclass().toString();\n        \n\t}\n\t\n\t\n<br/>\n\n-------------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n《Android编译时注解框架-语法讲解》\n\n\n\t\n","slug":"apt-Grammar-explanation","published":1,"updated":"2019-01-02T02:09:31.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbsph000oyo9syb5zmjkp","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……</p>\n<p>这里对猜对的结果进行一个总结，让后来者可以更快的上手。</p>\n<a id=\"more\"></a>\n<p>第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。</p>\n<h3 id=\"自定义注解相关\"><a href=\"#自定义注解相关\" class=\"headerlink\" title=\"自定义注解相关\"></a>自定义注解相关</h3><p>定义注解格式：   public @interface 注解名 {定义体}</p>\n<p>Annotation里面的参数该设定: </p>\n<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　</p>\n<p>第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1,name = &quot;asd&quot;)\nclass Test{\n}\n</code></pre><p>如果只有一个参数，建议设置为value</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Println {\n    int value();\n}\n\n//使用\n@Println(1)\nclass Test{\n}\n</code></pre><p>参数为value时，可以直接写入参数,使用时不在需要key=value写法。<br>但当有多个参数时，不可以再使用value。</p>\n<h4 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h4><p>这个在第一章有讲。申明该注解属于什么类型注解</p>\n<ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  运行时注解，一般在运行时通过反射去识别的注解。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  编译时注解，在编译时处理。</p>\n</li>\n</ul>\n<h4 id=\"Target-ElementType-TYPE\"><a href=\"#Target-ElementType-TYPE\" class=\"headerlink\" title=\"@Target(ElementType.TYPE)\"></a>@Target(ElementType.TYPE)</h4><p>表示该注解用来修饰哪些元素。并可以修饰多个</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\npublic @interface GetMsg {\n    int id();\n    String name() default &quot;default&quot;;\n}\n</code></pre><p>例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。</p>\n<pre><code>@GetMsg(1)\npublic void printError(){\n    //TODO ~\n}\n\n@GetMsg(1)  //编译器会报错\nclass Test{\n     //TODO ~\n}\n</code></pre><ul>\n<li><p>@Target(ElementType.TYPE)</p>\n<p>  接口、类、枚举、注解</p>\n</li>\n<li><p>@Target(ElementType.FIELD) </p>\n<p>  字段、枚举的常量</p>\n</li>\n<li><p>@Target(ElementType.METHOD) </p>\n<p>  方法</p>\n</li>\n<li><p>@Target(ElementType.PARAMETER)</p>\n<p>  方法参数 </p>\n</li>\n<li><p>@Target(ElementType.CONSTRUCTOR) </p>\n<p>  构造函数 </p>\n</li>\n<li><p>@Target(ElementType.LOCAL_VARIABLE)</p>\n<p>  局部变量 </p>\n</li>\n<li><p>@Target(ElementType.ANNOTATION_TYPE)</p>\n<p>  注解 </p>\n</li>\n<li><p>@Target(ElementType.package) </p>\n<p>  包 </p>\n</li>\n</ul>\n<h4 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h4><p>该注解的字面意识是继承，但你要知道<strong>注解是不可以继承的</strong>。</p>\n<p>@Inherited是在继承结构中使用的注解。</p>\n<p>如果你的注解是这样定义的：</p>\n<pre><code>@Inherited\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Test {\n    //...\n}\n</code></pre><p>当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。</p>\n<p><em>这里感谢 豪哥 @刘志豪 的排疑解惑~</em></p>\n<h4 id=\"注解的默认值\"><a href=\"#注解的默认值\" class=\"headerlink\" title=\"注解的默认值\"></a>注解的默认值</h4><p>注解可以设置默认值，有默认值的参数可以不写。</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1) //name有默认值可以不写\nclass Test{\n}\n</code></pre><h4 id=\"“注解的继承”（依赖倒置？）\"><a href=\"#“注解的继承”（依赖倒置？）\" class=\"headerlink\" title=\"“注解的继承”（依赖倒置？）\"></a>“注解的继承”（依赖倒置？）</h4><p>这里讲的继承并不是通过@Inherited修饰的注解。</p>\n<p>这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。</p>\n<p>先看代码。</p>\n<pre><code>@Target(METHOD)\n@Retention(CLASS)\n@ListenerClass(\n    targetType = &quot;android.view.View&quot;,\n    setter = &quot;setOnClickListener&quot;,\n    type = &quot;butterknife.internal.DebouncingOnClickListener&quot;,\n    method = @ListenerMethod(\n        name = &quot;doClick&quot;,\n        parameters = &quot;android.view.View&quot;\n    )\n)\npublic @interface OnClick {\n      /** View IDs to which the method will be bound. */\n      int[] value() default { View.NO_ID };\n}\n</code></pre><p>这是ButterKnife的OnClick 注解。特殊的地方在于<strong>@OnClick修饰了注解@ListenerClass</strong>，并且设置了一些只属于@OnClick的属性。</p>\n<p>那这样的作用是什么呢？</p>\n<p>凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。</p>\n<p>这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。</p>\n<h3 id=\"处理器类Processor编写\"><a href=\"#处理器类Processor编写\" class=\"headerlink\" title=\"处理器类Processor编写\"></a>处理器类Processor编写</h3><p>自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。</p>\n<p>AbstractProcessor有两个重要的方法需要重写。</p>\n<p><img src=\"http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg\" alt=\"\"></p>\n<h4 id=\"重写getSupportedAnnotationTypes方法：\"><a href=\"#重写getSupportedAnnotationTypes方法：\" class=\"headerlink\" title=\"重写getSupportedAnnotationTypes方法：\"></a>重写getSupportedAnnotationTypes方法：</h4><p>通过重写该方法，告知Processor哪些注解需要处理。</p>\n<p>返回一个Set集合，集合内容为自定义注解的包名+类名。</p>\n<p>建议项目中这样编写：</p>\n<pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    //需要全类名\n    types.add(GetMsg.class.getCanonicalName()); \n    types.add(Println.class.getCanonicalName());\n    return types;\n}\n</code></pre><p>另外如果注解数量很少的话，可以通过另一种方式实现：</p>\n<pre><code>//在只有一到两个注解需要处理时，可以这样编写：\n@SupportedAnnotationTypes(&quot;com.example.annotation.SetContentView&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class ContentViewProcessor extends AbstractProcessor {\n\n}\n</code></pre><h4 id=\"重写process方法：\"><a href=\"#重写process方法：\" class=\"headerlink\" title=\"重写process方法：\"></a>重写process方法：</h4><p>所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n\n\n    return false;\n}\n</code></pre><p>先简单解释下这个方法的参数和返回值。</p>\n<p><strong>参数</strong> <em>Set&lt;? extends TypeElement&gt; annotations</em> ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）<br><strong>参数</strong> <em>RoundEnvironment roundEnv</em> ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。</p>\n<p>例：        </p>\n<pre><code>for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n    //所有被使用的@GetMsg\n}\n</code></pre><p><strong>返回值</strong> 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理</p>\n<h3 id=\"输出Log\"><a href=\"#输出Log\" class=\"headerlink\" title=\"输出Log\"></a>输出Log</h3><p>虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。</p>\n<p><strong>Processor日志输出的位置在编译器下方的Messages窗口中。</strong></p>\n<p>Processor支持最基础的System.out方法。</p>\n<p>同样Processor也有自己的Log输出工具: Messager。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n\n    //取得Messager对象\n    Messager messager = processingEnv.getMessager();\n\n    //输出日志\n    messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + element.getSimpleName().toString());\n    }\n</code></pre><p>同Log类似，Messager也有日志级别的选择。</p>\n<ul>\n<li>Diagnostic.Kind.ERROR </li>\n<li>Diagnostic.Kind.WARNING </li>\n<li>Diagnostic.Kind.MANDATORY_WARNING </li>\n<li>Diagnostic.Kind.NOTE </li>\n<li>Diagnostic.Kind.OTHER </li>\n</ul>\n<p>他们的输出样式如图：</p>\n<p><img src=\"http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg\" alt=\"\"></p>\n<p><strong>注意：当没有属于该Process处理的注解被使用时，process不会执行。</strong></p>\n<p><strong>注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。</strong></p>\n<p>这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？</p>\n<h3 id=\"用生成的代码来生成代码\"><a href=\"#用生成的代码来生成代码\" class=\"headerlink\" title=\"用生成的代码来生成代码\"></a>用生成的代码来生成代码</h3><p>APT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？</p>\n<p>同样可以被扫描到，并且用于代码生成。其过程如下：</p>\n<p>APT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。</p>\n<p>同样你肯定也会发现一个问题，这不很容易会变成死循环吗？</p>\n<p><strong>没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！</strong></p>\n<h3 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h3><p>Element也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。</p>\n<p>Element的官方注释：</p>\n<p>Represents a program element such as a package, class, or method.<br>Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).</p>\n<p>表示一个程序元素，比如包、类或者方法。</p>\n<p>例如：取得所有修饰了@OnceClick的元素。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    //OnceClick.class是@Target(METHOD)\n    //则该element是可以强转为表示方法的ExecutableElement\n    ExecutableElement method = （ExecutableElement）element;\n    //如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n    //但有例外情况，我们稍后列举\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n}\n</code></pre><p>Element的子类有：</p>\n<ul>\n<li><p>ExecutableElement</p>\n<p>  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</p>\n<p>  对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)</p>\n</li>\n<li><p>PackageElement;</p>\n<p>  表示一个包程序元素。提供对有关包极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.PACKAGE)</p>\n</li>\n<li><p>TypeElement;</p>\n<p>  表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.TYPE)</p>\n<p>  <strong>注意：枚举类型是一种类，而注解类型是一种接口。</strong></p>\n</li>\n<li><p>TypeParameterElement;</p>\n<p>  表示一般类、接口、方法或构造方法元素的类型参数。</p>\n<p>  对应@Target(ElementType.PARAMETER)</p>\n</li>\n<li><p>VariableElement;</p>\n<p>  表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。</p>\n<p>  对应@Target(ElementType.LOCAL_VARIABLE)</p>\n</li>\n</ul>\n<p>例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：</p>\n<p>Element 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    ExecutableElement method = (ExecutableElement)element;\n}\n</code></pre><p>接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。</p>\n<h3 id=\"修饰方法的注解和ExecutableElement\"><a href=\"#修饰方法的注解和ExecutableElement\" class=\"headerlink\" title=\"修饰方法的注解和ExecutableElement\"></a>修饰方法的注解和ExecutableElement</h3><p>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。</p>\n<p>如何获取：</p>\n<pre><code>//OnceClick.class 以 @Target(ElementType.METHOD)修饰\nfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n    //对于Element直接强转\n    ExecutableElement executableElement = (ExecutableElement) element;\n\n    //非对应的Element，通过getEnclosingElement转换获取\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n\n    //当(ExecutableElement) element成立时，使用(PackageElement) element\n    //            .getEnclosingElement();将报错。\n    //需要使用elementUtils来获取\n    Elements elementUtils = processingEnv.getElementUtils();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //方法名\n    String methodName = executableElement.getSimpleName().toString();\n\n    //取得方法参数列表\n    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();\n    //参数类型列表\n    List&lt;String&gt; types = new ArrayList&lt;&gt;();\n    for (VariableElement variableElement : methodParameters) {\n        TypeMirror methodParameterType = variableElement.asType();\n        if (methodParameterType instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) methodParameterType;\n            methodParameterType = typeVariable.getUpperBound();\n\n        }\n        //参数名\n        String parameterName = variableElement.getSimpleName().toString();\n        //参数类型\n        String parameteKind = methodParameterType.toString();\n        types.add(methodParameterType.toString());\n    }\n}\n</code></pre><h3 id=\"修饰属性、类成员的注解和VariableElement\"><a href=\"#修饰属性、类成员的注解和VariableElement\" class=\"headerlink\" title=\"修饰属性、类成员的注解和VariableElement\"></a>修饰属性、类成员的注解和VariableElement</h3><p>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n    //ElementType.FIELD注解可以直接强转VariableElement\n    VariableElement variableElement = (VariableElement) element;\n\n    TypeElement classElement = (TypeElement) element\n            .getEnclosingElement();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //类成员名\n    String variableName = variableElement.getSimpleName().toString();\n\n    //类成员类型\n    TypeMirror typeMirror = variableElement.asType();\n    String type = typeMirror.toString();\n\n}\n</code></pre><h3 id=\"修饰类的注解和TypeElement\"><a href=\"#修饰类的注解和TypeElement\" class=\"headerlink\" title=\"修饰类的注解和TypeElement\"></a>修饰类的注解和TypeElement</h3><p>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n    //ElementType.TYPE注解可以直接强转TypeElement\n    TypeElement classElement = (TypeElement) element;\n\n    PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n     //父类名\n     String superClassName = classElement.getSuperclass().toString();\n\n}\n</code></pre><p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p>《Android编译时注解框架-语法讲解》</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……</p>\n<p>这里对猜对的结果进行一个总结，让后来者可以更快的上手。</p>","more":"<p>第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。</p>\n<h3 id=\"自定义注解相关\"><a href=\"#自定义注解相关\" class=\"headerlink\" title=\"自定义注解相关\"></a>自定义注解相关</h3><p>定义注解格式：   public @interface 注解名 {定义体}</p>\n<p>Annotation里面的参数该设定: </p>\n<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　</p>\n<p>第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1,name = &quot;asd&quot;)\nclass Test{\n}\n</code></pre><p>如果只有一个参数，建议设置为value</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Println {\n    int value();\n}\n\n//使用\n@Println(1)\nclass Test{\n}\n</code></pre><p>参数为value时，可以直接写入参数,使用时不在需要key=value写法。<br>但当有多个参数时，不可以再使用value。</p>\n<h4 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h4><p>这个在第一章有讲。申明该注解属于什么类型注解</p>\n<ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  运行时注解，一般在运行时通过反射去识别的注解。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  编译时注解，在编译时处理。</p>\n</li>\n</ul>\n<h4 id=\"Target-ElementType-TYPE\"><a href=\"#Target-ElementType-TYPE\" class=\"headerlink\" title=\"@Target(ElementType.TYPE)\"></a>@Target(ElementType.TYPE)</h4><p>表示该注解用来修饰哪些元素。并可以修饰多个</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\npublic @interface GetMsg {\n    int id();\n    String name() default &quot;default&quot;;\n}\n</code></pre><p>例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。</p>\n<pre><code>@GetMsg(1)\npublic void printError(){\n    //TODO ~\n}\n\n@GetMsg(1)  //编译器会报错\nclass Test{\n     //TODO ~\n}\n</code></pre><ul>\n<li><p>@Target(ElementType.TYPE)</p>\n<p>  接口、类、枚举、注解</p>\n</li>\n<li><p>@Target(ElementType.FIELD) </p>\n<p>  字段、枚举的常量</p>\n</li>\n<li><p>@Target(ElementType.METHOD) </p>\n<p>  方法</p>\n</li>\n<li><p>@Target(ElementType.PARAMETER)</p>\n<p>  方法参数 </p>\n</li>\n<li><p>@Target(ElementType.CONSTRUCTOR) </p>\n<p>  构造函数 </p>\n</li>\n<li><p>@Target(ElementType.LOCAL_VARIABLE)</p>\n<p>  局部变量 </p>\n</li>\n<li><p>@Target(ElementType.ANNOTATION_TYPE)</p>\n<p>  注解 </p>\n</li>\n<li><p>@Target(ElementType.package) </p>\n<p>  包 </p>\n</li>\n</ul>\n<h4 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h4><p>该注解的字面意识是继承，但你要知道<strong>注解是不可以继承的</strong>。</p>\n<p>@Inherited是在继承结构中使用的注解。</p>\n<p>如果你的注解是这样定义的：</p>\n<pre><code>@Inherited\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Test {\n    //...\n}\n</code></pre><p>当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。</p>\n<p><em>这里感谢 豪哥 @刘志豪 的排疑解惑~</em></p>\n<h4 id=\"注解的默认值\"><a href=\"#注解的默认值\" class=\"headerlink\" title=\"注解的默认值\"></a>注解的默认值</h4><p>注解可以设置默认值，有默认值的参数可以不写。</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1) //name有默认值可以不写\nclass Test{\n}\n</code></pre><h4 id=\"“注解的继承”（依赖倒置？）\"><a href=\"#“注解的继承”（依赖倒置？）\" class=\"headerlink\" title=\"“注解的继承”（依赖倒置？）\"></a>“注解的继承”（依赖倒置？）</h4><p>这里讲的继承并不是通过@Inherited修饰的注解。</p>\n<p>这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。</p>\n<p>先看代码。</p>\n<pre><code>@Target(METHOD)\n@Retention(CLASS)\n@ListenerClass(\n    targetType = &quot;android.view.View&quot;,\n    setter = &quot;setOnClickListener&quot;,\n    type = &quot;butterknife.internal.DebouncingOnClickListener&quot;,\n    method = @ListenerMethod(\n        name = &quot;doClick&quot;,\n        parameters = &quot;android.view.View&quot;\n    )\n)\npublic @interface OnClick {\n      /** View IDs to which the method will be bound. */\n      int[] value() default { View.NO_ID };\n}\n</code></pre><p>这是ButterKnife的OnClick 注解。特殊的地方在于<strong>@OnClick修饰了注解@ListenerClass</strong>，并且设置了一些只属于@OnClick的属性。</p>\n<p>那这样的作用是什么呢？</p>\n<p>凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。</p>\n<p>这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。</p>\n<h3 id=\"处理器类Processor编写\"><a href=\"#处理器类Processor编写\" class=\"headerlink\" title=\"处理器类Processor编写\"></a>处理器类Processor编写</h3><p>自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。</p>\n<p>AbstractProcessor有两个重要的方法需要重写。</p>\n<p><img src=\"http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg\" alt=\"\"></p>\n<h4 id=\"重写getSupportedAnnotationTypes方法：\"><a href=\"#重写getSupportedAnnotationTypes方法：\" class=\"headerlink\" title=\"重写getSupportedAnnotationTypes方法：\"></a>重写getSupportedAnnotationTypes方法：</h4><p>通过重写该方法，告知Processor哪些注解需要处理。</p>\n<p>返回一个Set集合，集合内容为自定义注解的包名+类名。</p>\n<p>建议项目中这样编写：</p>\n<pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    //需要全类名\n    types.add(GetMsg.class.getCanonicalName()); \n    types.add(Println.class.getCanonicalName());\n    return types;\n}\n</code></pre><p>另外如果注解数量很少的话，可以通过另一种方式实现：</p>\n<pre><code>//在只有一到两个注解需要处理时，可以这样编写：\n@SupportedAnnotationTypes(&quot;com.example.annotation.SetContentView&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class ContentViewProcessor extends AbstractProcessor {\n\n}\n</code></pre><h4 id=\"重写process方法：\"><a href=\"#重写process方法：\" class=\"headerlink\" title=\"重写process方法：\"></a>重写process方法：</h4><p>所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n\n\n    return false;\n}\n</code></pre><p>先简单解释下这个方法的参数和返回值。</p>\n<p><strong>参数</strong> <em>Set&lt;? extends TypeElement&gt; annotations</em> ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）<br><strong>参数</strong> <em>RoundEnvironment roundEnv</em> ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。</p>\n<p>例：        </p>\n<pre><code>for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n    //所有被使用的@GetMsg\n}\n</code></pre><p><strong>返回值</strong> 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理</p>\n<h3 id=\"输出Log\"><a href=\"#输出Log\" class=\"headerlink\" title=\"输出Log\"></a>输出Log</h3><p>虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。</p>\n<p><strong>Processor日志输出的位置在编译器下方的Messages窗口中。</strong></p>\n<p>Processor支持最基础的System.out方法。</p>\n<p>同样Processor也有自己的Log输出工具: Messager。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n\n    //取得Messager对象\n    Messager messager = processingEnv.getMessager();\n\n    //输出日志\n    messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + element.getSimpleName().toString());\n    }\n</code></pre><p>同Log类似，Messager也有日志级别的选择。</p>\n<ul>\n<li>Diagnostic.Kind.ERROR </li>\n<li>Diagnostic.Kind.WARNING </li>\n<li>Diagnostic.Kind.MANDATORY_WARNING </li>\n<li>Diagnostic.Kind.NOTE </li>\n<li>Diagnostic.Kind.OTHER </li>\n</ul>\n<p>他们的输出样式如图：</p>\n<p><img src=\"http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg\" alt=\"\"></p>\n<p><strong>注意：当没有属于该Process处理的注解被使用时，process不会执行。</strong></p>\n<p><strong>注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。</strong></p>\n<p>这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？</p>\n<h3 id=\"用生成的代码来生成代码\"><a href=\"#用生成的代码来生成代码\" class=\"headerlink\" title=\"用生成的代码来生成代码\"></a>用生成的代码来生成代码</h3><p>APT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？</p>\n<p>同样可以被扫描到，并且用于代码生成。其过程如下：</p>\n<p>APT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。</p>\n<p>同样你肯定也会发现一个问题，这不很容易会变成死循环吗？</p>\n<p><strong>没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！</strong></p>\n<h3 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h3><p>Element也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。</p>\n<p>Element的官方注释：</p>\n<p>Represents a program element such as a package, class, or method.<br>Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).</p>\n<p>表示一个程序元素，比如包、类或者方法。</p>\n<p>例如：取得所有修饰了@OnceClick的元素。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    //OnceClick.class是@Target(METHOD)\n    //则该element是可以强转为表示方法的ExecutableElement\n    ExecutableElement method = （ExecutableElement）element;\n    //如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n    //但有例外情况，我们稍后列举\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n}\n</code></pre><p>Element的子类有：</p>\n<ul>\n<li><p>ExecutableElement</p>\n<p>  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</p>\n<p>  对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)</p>\n</li>\n<li><p>PackageElement;</p>\n<p>  表示一个包程序元素。提供对有关包极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.PACKAGE)</p>\n</li>\n<li><p>TypeElement;</p>\n<p>  表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.TYPE)</p>\n<p>  <strong>注意：枚举类型是一种类，而注解类型是一种接口。</strong></p>\n</li>\n<li><p>TypeParameterElement;</p>\n<p>  表示一般类、接口、方法或构造方法元素的类型参数。</p>\n<p>  对应@Target(ElementType.PARAMETER)</p>\n</li>\n<li><p>VariableElement;</p>\n<p>  表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。</p>\n<p>  对应@Target(ElementType.LOCAL_VARIABLE)</p>\n</li>\n</ul>\n<p>例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：</p>\n<p>Element 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    ExecutableElement method = (ExecutableElement)element;\n}\n</code></pre><p>接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。</p>\n<h3 id=\"修饰方法的注解和ExecutableElement\"><a href=\"#修饰方法的注解和ExecutableElement\" class=\"headerlink\" title=\"修饰方法的注解和ExecutableElement\"></a>修饰方法的注解和ExecutableElement</h3><p>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。</p>\n<p>如何获取：</p>\n<pre><code>//OnceClick.class 以 @Target(ElementType.METHOD)修饰\nfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n    //对于Element直接强转\n    ExecutableElement executableElement = (ExecutableElement) element;\n\n    //非对应的Element，通过getEnclosingElement转换获取\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n\n    //当(ExecutableElement) element成立时，使用(PackageElement) element\n    //            .getEnclosingElement();将报错。\n    //需要使用elementUtils来获取\n    Elements elementUtils = processingEnv.getElementUtils();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //方法名\n    String methodName = executableElement.getSimpleName().toString();\n\n    //取得方法参数列表\n    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();\n    //参数类型列表\n    List&lt;String&gt; types = new ArrayList&lt;&gt;();\n    for (VariableElement variableElement : methodParameters) {\n        TypeMirror methodParameterType = variableElement.asType();\n        if (methodParameterType instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) methodParameterType;\n            methodParameterType = typeVariable.getUpperBound();\n\n        }\n        //参数名\n        String parameterName = variableElement.getSimpleName().toString();\n        //参数类型\n        String parameteKind = methodParameterType.toString();\n        types.add(methodParameterType.toString());\n    }\n}\n</code></pre><h3 id=\"修饰属性、类成员的注解和VariableElement\"><a href=\"#修饰属性、类成员的注解和VariableElement\" class=\"headerlink\" title=\"修饰属性、类成员的注解和VariableElement\"></a>修饰属性、类成员的注解和VariableElement</h3><p>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n    //ElementType.FIELD注解可以直接强转VariableElement\n    VariableElement variableElement = (VariableElement) element;\n\n    TypeElement classElement = (TypeElement) element\n            .getEnclosingElement();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //类成员名\n    String variableName = variableElement.getSimpleName().toString();\n\n    //类成员类型\n    TypeMirror typeMirror = variableElement.asType();\n    String type = typeMirror.toString();\n\n}\n</code></pre><h3 id=\"修饰类的注解和TypeElement\"><a href=\"#修饰类的注解和TypeElement\" class=\"headerlink\" title=\"修饰类的注解和TypeElement\"></a>修饰类的注解和TypeElement</h3><p>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n    //ElementType.TYPE注解可以直接强转TypeElement\n    TypeElement classElement = (TypeElement) element;\n\n    PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n     //父类名\n     String superClassName = classElement.getSuperclass().toString();\n\n}\n</code></pre><p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p>《Android编译时注解框架-语法讲解》</p>"},{"title":"Android编译时注解框架3-Run Project:OnceClick","date":"2016-07-17T07:40:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。\n\n本章将以生成代码为重点进行一个案例讲解。\n\n\n<!-- more -->\n\n\n### 框架名称：OnceClick\n\n**框架功能：**功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。\n\n**框架背景：**从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。\n\n**使用及项目引用地址：**[https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)\n\nOK，这是一个功能非常简单的小型类库。下面我们来实现它。\n\n\n### 项目搭建\n\n具体的项目搭建细节前一章已经有了介绍，这里不再讲述。\n\n**需要说明的是：**我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。\n\n项目目录结构如图：\n\nModule职责：\n\napp：Demo\n\napt：java Library.负责代码生成。编译成apt-jar包供外部使用\n\nonceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包\n\n![](http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg)\n\n\n\n### OnceClick使用\n\n\tpublic class MainActivity extends AppCompatActivity {\n\n    \tprivate TextView text;\n    \tprivate int num;\n\n    \t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n    \t    super.onCreate(savedInstanceState);\n    \t    setContentView(R.layout.activity_main);\n        \t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n    \t    OnceInit.once(this,2000);\n    \t    text = (TextView)findViewById(R.id.textView);\n    \t}\n\n    \t@OnceClick(R.id.btn)\n    \tpublic void once(){\n    \t    text.setText(\"click\"+num++);\n    \t    Log.d(\"tag\",\"once\");\n    \t}\n\n    \t@OnceClick(R.id.btn2)\n    \tpublic void onceMe(View v){\n    \t    ((Button)v).setText(\"click\"+num++);\n     \t   Log.d(\"tag\",\"onceMe\");\n    \t}\n\t}\n\t\n在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。\n\t\n![](http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg)\n\n\n### 生成后代码\n\n\t// Generated code from OnceClick. Do not modify!\n\tpackage com.lizhaoxuan.onceclickdemo;\n\n\timport android.view.View;\n\n\timport com.lizhaoxuan.onceclick.Finder;\n\timport com.lizhaoxuan.onceclick.AbstractInjector;\n\n\tpublic class MainActivity$$PROXY<T extends MainActivity> implements AbstractInjector<T> {\n\t\t//间隔多久可以执行一次点击事件\n    \tpublic long intervalTime;\n\n    \t@Override\n    \tpublic void setIntervalTime(long time) {\n    \t    intervalTime = time;\n    \t}\n\t\t\n    \t@Override\n    \tpublic void inject(final Finder finder, final T target, Object source) {\n        \tView view;\n        \tview = finder.findViewById(source, 2131492945);\n        \tif (view != null) {\n            \tview.setOnClickListener(new View.OnClickListener() {\n                \tlong time = 0L;\n                \t@Override\n                \tpublic void onClick(View v) {\n                    \tlong temp = System.currentTimeMillis();\n                    \tif (temp - time >= intervalTime) {\n                        \ttime = temp;\n                        \ttarget.once();\n                    \t}\n                \t}\n            \t});\n        \t}\n\t        view = finder.findViewById(source, 2131492946);\n\t        if (view != null) {\n\t            view.setOnClickListener(new View.OnClickListener() {\n\t                long time = 0L;\n\t                @Override\n\t                public void onClick(View v) {\n\t                    long temp = System.currentTimeMillis();\n\t                    if (temp - time >= intervalTime) {\n\t                        time = temp;\n\t                        target.onceMe(v);\n\t\t                    }\n\t                }\n            \t});\n        \t}\n    \t}\n\t}\n\n这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。\n\n================\n\n### OnceClick Module\n\n#### OnceInit.once\n\n看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下*OnceInit.java*一目了然，我在注释中做讲解:\n\n\tpublic class OnceInit {\n    \tprivate static final Map<Class<?>, AbstractInjector<Object>> INJECTORS = new LinkedHashMap<Class<?>, AbstractInjector<Object>>();\n\n    \tprivate static final long INTERVAL_TIME = 2000;\n\n    \tpublic static void once(Activity activity, long intervalTime) {\n    \t\t//生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n    \t    AbstractInjector<Object> injector = findInjector(activity);\n    \t    //执行生成代码中的inject方法\n    \t    //Finder是枚举，这里用Activity类型\n    \t    injector.inject(Finder.ACTIVITY, activity, activity);\n    \t    //设置间隔时间\n    \t    injector.setIntervalTime(intervalTime);\n    \t}\n\t\t\n\t\t//其他几个重载方法\n    \tpublic static void once(View view, long intervalTime) {\n    \t    AbstractInjector<Object> injector = findInjector(view);\n    \t    //Finder是枚举，这里用VIEW类型\n        \tinjector.inject(Finder.VIEW, view, view);\n        \tinjector.setIntervalTime(intervalTime);\n    \t}\n    \tpublic static void once(Activity activity) {\n        \tonce(activity, INTERVAL_TIME);\n    \t}\n    \tpublic static void once(View view) {\n        \tonce(view, INTERVAL_TIME);\n    \t}\n\t\t\n\t\t//查找生成的代码\n    \tprivate static AbstractInjector<Object> findInjector(Object activity) {\n        \tClass<?> clazz = activity.getClass();\n        \t//使用Map缓存一下，避免重复查找\n        \tAbstractInjector<Object> injector = INJECTORS.get(clazz);\n        \tif (injector == null) {\n            \ttry {\n            \t\t//生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                \tClass injectorClazz = Class.forName(clazz.getName() + \"$$\"\n                        + ProxyInfo.PROXY);\n                \tinjector = (AbstractInjector<Object>) injectorClazz\n                        .newInstance();\n                \tINJECTORS.put(clazz, injector);\n            \t} catch (Exception e) {\n                \te.printStackTrace();\n            \t}\n        \t}\n        \treturn injector;\n    \t}\n\t}\n\n\n\n#### AbstractInjector\n代理类接口，所有生成代码类都要实现这个接口。\n\ninject方法用于实现代理代码。\n\nsetIntervalTime设置点击事件执行间隔时间。\n\n\tpublic interface AbstractInjector<T> {\n\n    \tvoid inject(Finder finder, T target, Object source);\n\t\n    \tvoid setIntervalTime(long time);\n\t}\n\n\n#### Finder\n\nFinder的作用是根据不同的类型，去实现不同的findViewById方法。\n\n\tpublic enum Finder {\n    \tVIEW {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((View) source).findViewById(id);\n        \t}\n    \t},\n    \tACTIVITY {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((Activity) source).findViewById(id);\n        \t}\n    \t};\n    \tpublic abstract View findViewById(Object source, int id);\n\t}\n\n================\n\n### APT MODULE\n\n#### 自定义注解\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.METHOD)\n\tpublic @interface OnceClick {\n\n    \tint value();\n\t}\n\nOnceClick只有一个默认参数，用来设置View的Id。\n\n\n#### 配置文件\n\n编写文件javax.annotation.processing.Processor。\n\n\tcom.example.OnceClickProcessor\n\t\n![](http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg)\n\n\n#### Process类-getSupportedAnnotationTypes\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        types.add(OnceClick.class.getCanonicalName());\n        return types;\n    }\n    \n\n#### Process类-process方法\n\n重点来啦。这里需要讲一个概念。\n\n当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。\n\n所以，一个代理类可能有多个需要处理的View。\n\n先看process代码：\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //获取proxyMap\n        Map<String, ProxyInfo> proxyMap = getProxyMap(roundEnv);\n        //遍历proxyMap，并生成代码\n        for (String key : proxyMap.keySet()) {\n            ProxyInfo proxyInfo = proxyMap.get(key);\n            writeCode(proxyInfo);\n        }\n        return true;\n    }\n\n**ProxyInfo对象**：存放生成代理类的必要信息，并生成代码。\n\n**getProxyMap方法**：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。\n\n**writeCode方法**：真正生成代码的方法。\n\n\n总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。\n\n#### ProxyInfo代理类\n\n其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<OnceMethod> methods保存。**然后根据这些信息生成类。**\n\n\n\tpublic class ProxyInfo {\n\t    private String packageName;\n\t    private String targetClassName;\n\t    private String proxyClassName;\n\t    private TypeElement typeElement;\n\n\t    private List<OnceMethod> methods;\n\n\t    public static final String PROXY = \"PROXY\";\n\n\t    ProxyInfo(String packageName, String className) {\n\t        this.packageName = packageName;\n\t        this.targetClassName = className;\n\t        this.proxyClassName = className + \"$$\" + PROXY;\n\t    }\n\n\t    String getProxyClassFullName() {\n\t        return packageName + \".\" + proxyClassName;\n\t    }\n\n\t    String generateJavaCode() throws OnceClickException {\n\n\t        StringBuilder builder = new StringBuilder();\n\t        builder.append(\"// Generated code from OnceClick. Do not modify!\\n\");\n\t        builder.append(\"package \").append(packageName).append(\";\\n\\n\");\n\n\t        builder.append(\"import android.view.View;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.Finder;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.AbstractInjector;\\n\");\n\t        builder.append('\\n');\n\n\t        builder.append(\"public class \").append(proxyClassName);\n\t        builder.append(\"<T extends \").append(getTargetClassName()).append(\">\");\n\t        builder.append(\" implements AbstractInjector<T>\");\n\t        builder.append(\" {\\n\");\n\n\t        generateInjectMethod(builder);\n\t        builder.append('\\n');\n\n\t        builder.append(\"}\\n\");\n\t        return builder.toString();\n\n\t    }\n\n\t    private String getTargetClassName() {\n\t        return targetClassName.replace(\"$\", \".\");\n\t    }\n\n\t    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n\t        builder.append(\"public long intervalTime; \\n\");\n\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void setIntervalTime(long time) {\\n\")\n\t                .append(\"intervalTime = time;\\n     } \\n\");\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void inject(final Finder finder, final T target, Object source) {\\n\");\n\t        builder.append(\"View view;\");\n\n\t        for (OnceMethod method : getMethods()) {\n\t            builder.append(\"    view = \")\n\t                    .append(\"finder.findViewById(source, \")\n\t                    .append(method.getId())\n\t                    .append(\");\\n\");\n\t            builder.append(\"if(view != null){\")\n\t                    .append(\"view.setOnClickListener(new View.OnClickListener() {\\n\")\n\t                    .append(\"long time = 0L;\");\n\t            builder.append(\"@Override\\n\")\n\t                    .append(\"public void onClick(View v) {\");\n\t            builder.append(\"long temp = System.currentTimeMillis();\\n\")\n\t                    .append(\"if (temp - time >= intervalTime) {\\n\" +\n\t                            \t\"time = temp;\\n\");\n            \tif (method.getMethodParametersSize() == 1) {\n                \tif (method.getMethodParameters().get(0).equals(\"android.view.View\")) {\n                    \tbuilder.append(\"target.\").append(method.getMethodName()).append(\"(v);\");\n                \t} else {\n                    \tthrow new OnceClickException(\"Parameters must be android.view.View\");\n                \t}\n            \t} else if (method.getMethodParametersSize() == 0) {\n                builder.append(\"target.\").append(method.getMethodName()).append(\"();\");\n            \t} else {\n                \tthrow new OnceClickException(\"Does not support more than one parameter\");\n            \t}\n            \tbuilder.append(\"\\n}\")\n            \t        .append(\"    }\\n\")\n            \t        .append(\"        });\\n}\");\n        \t}\n\n        \tbuilder.append(\"  }\\n\");\n    \t}\n\n    \tTypeElement getTypeElement() {\n    \t    return typeElement;\n    \t}\n\n    \tvoid setTypeElement(TypeElement typeElement) {\n    \t    this.typeElement = typeElement;\n    \t}\n\n    \tList<OnceMethod> getMethods() {\n    \t    return methods == null ? new ArrayList<OnceMethod>() : methods;\n    \t}\n\n    \tvoid addMethod(OnceMethod onceMethod) {\n        \tif (methods == null) {\n            \tmethods = new ArrayList<>();\n        \t}\n        \tmethods.add(onceMethod);\n    \t}\n\t}\n\n\n#### OnceMethod类\n\n需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:\n\n\tpublic class OnceMethod {\n    \n        private int id;\n        private String methodName;\n        private List<String> methodParameters;\n    \n        OnceMethod(int id, String methodName, List<String> methodParameters) {\n            this.id = id;\n            this.methodName = methodName;\n            this.methodParameters = methodParameters;\n        }\n    \n        int getMethodParametersSize() {\n            return methodParameters == null ? 0 : methodParameters.size();\n        }\n    \n        int getId() {\n            return id;\n        }\n    \n        String getMethodName() {\n            return methodName;\n        }\n    \n        List<String> getMethodParameters() {\n            return methodParameters;\n        }\n    \n    }\n\n#### getProxyMap方法\n\ngetProxyMap其实也很简单的。通过注释就可以理解。\n\n比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。\n\n\tprivate Map<String, ProxyInfo> getProxyMap( RoundEnvironment roundEnv){\n        Map<String, ProxyInfo> proxyMap = new HashMap<>();\n        //遍历项目中所有的@OnceClick注解\n        for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\t\t\t\n        \t//获取基本的类名、包名\n            TypeElement classElement = (TypeElement) element;\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n\n            String fullClassName = classElement.getQualifiedName().toString();\n            String className = classElement.getSimpleName().toString();\n            String packageName = packageElement.getQualifiedName().toString();\n            //获取注解参数\n            int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n            ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n            //如果以创建该代理类，就只add viewId\n            if (proxyInfo != null) {\n                proxyInfo.addLayoutId(viewId);\n            } else {\n                proxyInfo = new ProxyInfo(packageName, className);\n                proxyInfo.setTypeElement(classElement);\n                proxyInfo.addLayoutId(viewId);\n                proxyMap.put(fullClassName, proxyInfo);\n            }\n        }\n        return proxyMap;\n    }\n\n#### writeCode方法\n\nwriteCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。\n\n需要注意的是 *writer.write(proxyInfo.generateJavaCode());*。需要生成的代码以字符串形式传给writer。\n\n\tprivate void writeCode(ProxyInfo proxyInfo){\n        try {\n            JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                    proxyInfo.getProxyClassFullName(),\n                    proxyInfo.getTypeElement());\n            Writer writer = jfo.openWriter();\n            writer.write(proxyInfo.generateJavaCode());\n            writer.flush();\n            writer.close();\n        } catch (IOException e) {\n            error(proxyInfo.getTypeElement(),\n                    \"Unable to write injector for type %s: %s\",\n                    proxyInfo.getTypeElement(), e.getMessage());\n        }\n    }\n    \n    //两个日志输出方法。\n    private void print(String message){\n        messager.printMessage(Diagnostic.Kind.NOTE, message);\n    }\n\n    private void error(Element element, String message, Object... args) {\n        if (args.length > 0) {\n            message = String.format(message, args);\n        }\n        messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n    }\n\n\n\n### 结论\n\n这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？\n\n\t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n\tOnceInit.once(this,2000);\n\t\n技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。\n\n每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：\n\n\t@OnceClick(R.id.btn)\n如果有两个属性，就必须要带名字了 \n\n\t@OnceClick(id = R.id.btn)\n\n最后在把源码地址再放一下 [https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)。看着Demo学习会更快！\n\n</br>\n\n--------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n《Android编译时注解框架-Run Project：OnceClick》\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n","source":"_posts/apt-run_project.md","raw":"\n---\ntitle: Android编译时注解框架3-Run Project:OnceClick\ndate: 2016-07-17 15:40:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。\n\n本章将以生成代码为重点进行一个案例讲解。\n\n\n<!-- more -->\n\n\n### 框架名称：OnceClick\n\n**框架功能：**功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。\n\n**框架背景：**从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。\n\n**使用及项目引用地址：**[https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)\n\nOK，这是一个功能非常简单的小型类库。下面我们来实现它。\n\n\n### 项目搭建\n\n具体的项目搭建细节前一章已经有了介绍，这里不再讲述。\n\n**需要说明的是：**我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。\n\n项目目录结构如图：\n\nModule职责：\n\napp：Demo\n\napt：java Library.负责代码生成。编译成apt-jar包供外部使用\n\nonceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包\n\n![](http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg)\n\n\n\n### OnceClick使用\n\n\tpublic class MainActivity extends AppCompatActivity {\n\n    \tprivate TextView text;\n    \tprivate int num;\n\n    \t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n    \t    super.onCreate(savedInstanceState);\n    \t    setContentView(R.layout.activity_main);\n        \t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n    \t    OnceInit.once(this,2000);\n    \t    text = (TextView)findViewById(R.id.textView);\n    \t}\n\n    \t@OnceClick(R.id.btn)\n    \tpublic void once(){\n    \t    text.setText(\"click\"+num++);\n    \t    Log.d(\"tag\",\"once\");\n    \t}\n\n    \t@OnceClick(R.id.btn2)\n    \tpublic void onceMe(View v){\n    \t    ((Button)v).setText(\"click\"+num++);\n     \t   Log.d(\"tag\",\"onceMe\");\n    \t}\n\t}\n\t\n在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。\n\t\n![](http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg)\n\n\n### 生成后代码\n\n\t// Generated code from OnceClick. Do not modify!\n\tpackage com.lizhaoxuan.onceclickdemo;\n\n\timport android.view.View;\n\n\timport com.lizhaoxuan.onceclick.Finder;\n\timport com.lizhaoxuan.onceclick.AbstractInjector;\n\n\tpublic class MainActivity$$PROXY<T extends MainActivity> implements AbstractInjector<T> {\n\t\t//间隔多久可以执行一次点击事件\n    \tpublic long intervalTime;\n\n    \t@Override\n    \tpublic void setIntervalTime(long time) {\n    \t    intervalTime = time;\n    \t}\n\t\t\n    \t@Override\n    \tpublic void inject(final Finder finder, final T target, Object source) {\n        \tView view;\n        \tview = finder.findViewById(source, 2131492945);\n        \tif (view != null) {\n            \tview.setOnClickListener(new View.OnClickListener() {\n                \tlong time = 0L;\n                \t@Override\n                \tpublic void onClick(View v) {\n                    \tlong temp = System.currentTimeMillis();\n                    \tif (temp - time >= intervalTime) {\n                        \ttime = temp;\n                        \ttarget.once();\n                    \t}\n                \t}\n            \t});\n        \t}\n\t        view = finder.findViewById(source, 2131492946);\n\t        if (view != null) {\n\t            view.setOnClickListener(new View.OnClickListener() {\n\t                long time = 0L;\n\t                @Override\n\t                public void onClick(View v) {\n\t                    long temp = System.currentTimeMillis();\n\t                    if (temp - time >= intervalTime) {\n\t                        time = temp;\n\t                        target.onceMe(v);\n\t\t                    }\n\t                }\n            \t});\n        \t}\n    \t}\n\t}\n\n这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。\n\n================\n\n### OnceClick Module\n\n#### OnceInit.once\n\n看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下*OnceInit.java*一目了然，我在注释中做讲解:\n\n\tpublic class OnceInit {\n    \tprivate static final Map<Class<?>, AbstractInjector<Object>> INJECTORS = new LinkedHashMap<Class<?>, AbstractInjector<Object>>();\n\n    \tprivate static final long INTERVAL_TIME = 2000;\n\n    \tpublic static void once(Activity activity, long intervalTime) {\n    \t\t//生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n    \t    AbstractInjector<Object> injector = findInjector(activity);\n    \t    //执行生成代码中的inject方法\n    \t    //Finder是枚举，这里用Activity类型\n    \t    injector.inject(Finder.ACTIVITY, activity, activity);\n    \t    //设置间隔时间\n    \t    injector.setIntervalTime(intervalTime);\n    \t}\n\t\t\n\t\t//其他几个重载方法\n    \tpublic static void once(View view, long intervalTime) {\n    \t    AbstractInjector<Object> injector = findInjector(view);\n    \t    //Finder是枚举，这里用VIEW类型\n        \tinjector.inject(Finder.VIEW, view, view);\n        \tinjector.setIntervalTime(intervalTime);\n    \t}\n    \tpublic static void once(Activity activity) {\n        \tonce(activity, INTERVAL_TIME);\n    \t}\n    \tpublic static void once(View view) {\n        \tonce(view, INTERVAL_TIME);\n    \t}\n\t\t\n\t\t//查找生成的代码\n    \tprivate static AbstractInjector<Object> findInjector(Object activity) {\n        \tClass<?> clazz = activity.getClass();\n        \t//使用Map缓存一下，避免重复查找\n        \tAbstractInjector<Object> injector = INJECTORS.get(clazz);\n        \tif (injector == null) {\n            \ttry {\n            \t\t//生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                \tClass injectorClazz = Class.forName(clazz.getName() + \"$$\"\n                        + ProxyInfo.PROXY);\n                \tinjector = (AbstractInjector<Object>) injectorClazz\n                        .newInstance();\n                \tINJECTORS.put(clazz, injector);\n            \t} catch (Exception e) {\n                \te.printStackTrace();\n            \t}\n        \t}\n        \treturn injector;\n    \t}\n\t}\n\n\n\n#### AbstractInjector\n代理类接口，所有生成代码类都要实现这个接口。\n\ninject方法用于实现代理代码。\n\nsetIntervalTime设置点击事件执行间隔时间。\n\n\tpublic interface AbstractInjector<T> {\n\n    \tvoid inject(Finder finder, T target, Object source);\n\t\n    \tvoid setIntervalTime(long time);\n\t}\n\n\n#### Finder\n\nFinder的作用是根据不同的类型，去实现不同的findViewById方法。\n\n\tpublic enum Finder {\n    \tVIEW {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((View) source).findViewById(id);\n        \t}\n    \t},\n    \tACTIVITY {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((Activity) source).findViewById(id);\n        \t}\n    \t};\n    \tpublic abstract View findViewById(Object source, int id);\n\t}\n\n================\n\n### APT MODULE\n\n#### 自定义注解\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.METHOD)\n\tpublic @interface OnceClick {\n\n    \tint value();\n\t}\n\nOnceClick只有一个默认参数，用来设置View的Id。\n\n\n#### 配置文件\n\n编写文件javax.annotation.processing.Processor。\n\n\tcom.example.OnceClickProcessor\n\t\n![](http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg)\n\n\n#### Process类-getSupportedAnnotationTypes\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        types.add(OnceClick.class.getCanonicalName());\n        return types;\n    }\n    \n\n#### Process类-process方法\n\n重点来啦。这里需要讲一个概念。\n\n当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。\n\n所以，一个代理类可能有多个需要处理的View。\n\n先看process代码：\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //获取proxyMap\n        Map<String, ProxyInfo> proxyMap = getProxyMap(roundEnv);\n        //遍历proxyMap，并生成代码\n        for (String key : proxyMap.keySet()) {\n            ProxyInfo proxyInfo = proxyMap.get(key);\n            writeCode(proxyInfo);\n        }\n        return true;\n    }\n\n**ProxyInfo对象**：存放生成代理类的必要信息，并生成代码。\n\n**getProxyMap方法**：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。\n\n**writeCode方法**：真正生成代码的方法。\n\n\n总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。\n\n#### ProxyInfo代理类\n\n其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<OnceMethod> methods保存。**然后根据这些信息生成类。**\n\n\n\tpublic class ProxyInfo {\n\t    private String packageName;\n\t    private String targetClassName;\n\t    private String proxyClassName;\n\t    private TypeElement typeElement;\n\n\t    private List<OnceMethod> methods;\n\n\t    public static final String PROXY = \"PROXY\";\n\n\t    ProxyInfo(String packageName, String className) {\n\t        this.packageName = packageName;\n\t        this.targetClassName = className;\n\t        this.proxyClassName = className + \"$$\" + PROXY;\n\t    }\n\n\t    String getProxyClassFullName() {\n\t        return packageName + \".\" + proxyClassName;\n\t    }\n\n\t    String generateJavaCode() throws OnceClickException {\n\n\t        StringBuilder builder = new StringBuilder();\n\t        builder.append(\"// Generated code from OnceClick. Do not modify!\\n\");\n\t        builder.append(\"package \").append(packageName).append(\";\\n\\n\");\n\n\t        builder.append(\"import android.view.View;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.Finder;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.AbstractInjector;\\n\");\n\t        builder.append('\\n');\n\n\t        builder.append(\"public class \").append(proxyClassName);\n\t        builder.append(\"<T extends \").append(getTargetClassName()).append(\">\");\n\t        builder.append(\" implements AbstractInjector<T>\");\n\t        builder.append(\" {\\n\");\n\n\t        generateInjectMethod(builder);\n\t        builder.append('\\n');\n\n\t        builder.append(\"}\\n\");\n\t        return builder.toString();\n\n\t    }\n\n\t    private String getTargetClassName() {\n\t        return targetClassName.replace(\"$\", \".\");\n\t    }\n\n\t    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n\t        builder.append(\"public long intervalTime; \\n\");\n\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void setIntervalTime(long time) {\\n\")\n\t                .append(\"intervalTime = time;\\n     } \\n\");\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void inject(final Finder finder, final T target, Object source) {\\n\");\n\t        builder.append(\"View view;\");\n\n\t        for (OnceMethod method : getMethods()) {\n\t            builder.append(\"    view = \")\n\t                    .append(\"finder.findViewById(source, \")\n\t                    .append(method.getId())\n\t                    .append(\");\\n\");\n\t            builder.append(\"if(view != null){\")\n\t                    .append(\"view.setOnClickListener(new View.OnClickListener() {\\n\")\n\t                    .append(\"long time = 0L;\");\n\t            builder.append(\"@Override\\n\")\n\t                    .append(\"public void onClick(View v) {\");\n\t            builder.append(\"long temp = System.currentTimeMillis();\\n\")\n\t                    .append(\"if (temp - time >= intervalTime) {\\n\" +\n\t                            \t\"time = temp;\\n\");\n            \tif (method.getMethodParametersSize() == 1) {\n                \tif (method.getMethodParameters().get(0).equals(\"android.view.View\")) {\n                    \tbuilder.append(\"target.\").append(method.getMethodName()).append(\"(v);\");\n                \t} else {\n                    \tthrow new OnceClickException(\"Parameters must be android.view.View\");\n                \t}\n            \t} else if (method.getMethodParametersSize() == 0) {\n                builder.append(\"target.\").append(method.getMethodName()).append(\"();\");\n            \t} else {\n                \tthrow new OnceClickException(\"Does not support more than one parameter\");\n            \t}\n            \tbuilder.append(\"\\n}\")\n            \t        .append(\"    }\\n\")\n            \t        .append(\"        });\\n}\");\n        \t}\n\n        \tbuilder.append(\"  }\\n\");\n    \t}\n\n    \tTypeElement getTypeElement() {\n    \t    return typeElement;\n    \t}\n\n    \tvoid setTypeElement(TypeElement typeElement) {\n    \t    this.typeElement = typeElement;\n    \t}\n\n    \tList<OnceMethod> getMethods() {\n    \t    return methods == null ? new ArrayList<OnceMethod>() : methods;\n    \t}\n\n    \tvoid addMethod(OnceMethod onceMethod) {\n        \tif (methods == null) {\n            \tmethods = new ArrayList<>();\n        \t}\n        \tmethods.add(onceMethod);\n    \t}\n\t}\n\n\n#### OnceMethod类\n\n需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:\n\n\tpublic class OnceMethod {\n    \n        private int id;\n        private String methodName;\n        private List<String> methodParameters;\n    \n        OnceMethod(int id, String methodName, List<String> methodParameters) {\n            this.id = id;\n            this.methodName = methodName;\n            this.methodParameters = methodParameters;\n        }\n    \n        int getMethodParametersSize() {\n            return methodParameters == null ? 0 : methodParameters.size();\n        }\n    \n        int getId() {\n            return id;\n        }\n    \n        String getMethodName() {\n            return methodName;\n        }\n    \n        List<String> getMethodParameters() {\n            return methodParameters;\n        }\n    \n    }\n\n#### getProxyMap方法\n\ngetProxyMap其实也很简单的。通过注释就可以理解。\n\n比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。\n\n\tprivate Map<String, ProxyInfo> getProxyMap( RoundEnvironment roundEnv){\n        Map<String, ProxyInfo> proxyMap = new HashMap<>();\n        //遍历项目中所有的@OnceClick注解\n        for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\t\t\t\n        \t//获取基本的类名、包名\n            TypeElement classElement = (TypeElement) element;\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n\n            String fullClassName = classElement.getQualifiedName().toString();\n            String className = classElement.getSimpleName().toString();\n            String packageName = packageElement.getQualifiedName().toString();\n            //获取注解参数\n            int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n            ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n            //如果以创建该代理类，就只add viewId\n            if (proxyInfo != null) {\n                proxyInfo.addLayoutId(viewId);\n            } else {\n                proxyInfo = new ProxyInfo(packageName, className);\n                proxyInfo.setTypeElement(classElement);\n                proxyInfo.addLayoutId(viewId);\n                proxyMap.put(fullClassName, proxyInfo);\n            }\n        }\n        return proxyMap;\n    }\n\n#### writeCode方法\n\nwriteCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。\n\n需要注意的是 *writer.write(proxyInfo.generateJavaCode());*。需要生成的代码以字符串形式传给writer。\n\n\tprivate void writeCode(ProxyInfo proxyInfo){\n        try {\n            JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                    proxyInfo.getProxyClassFullName(),\n                    proxyInfo.getTypeElement());\n            Writer writer = jfo.openWriter();\n            writer.write(proxyInfo.generateJavaCode());\n            writer.flush();\n            writer.close();\n        } catch (IOException e) {\n            error(proxyInfo.getTypeElement(),\n                    \"Unable to write injector for type %s: %s\",\n                    proxyInfo.getTypeElement(), e.getMessage());\n        }\n    }\n    \n    //两个日志输出方法。\n    private void print(String message){\n        messager.printMessage(Diagnostic.Kind.NOTE, message);\n    }\n\n    private void error(Element element, String message, Object... args) {\n        if (args.length > 0) {\n            message = String.format(message, args);\n        }\n        messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n    }\n\n\n\n### 结论\n\n这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？\n\n\t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n\tOnceInit.once(this,2000);\n\t\n技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。\n\n每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：\n\n\t@OnceClick(R.id.btn)\n如果有两个属性，就必须要带名字了 \n\n\t@OnceClick(id = R.id.btn)\n\n最后在把源码地址再放一下 [https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)。看着Demo学习会更快！\n\n</br>\n\n--------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n《Android编译时注解框架-Run Project：OnceClick》\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n","slug":"apt-run_project","published":1,"updated":"2019-01-02T02:09:31.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspj000qyo9sbhqx1me5","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。</p>\n<p>本章将以生成代码为重点进行一个案例讲解。</p>\n<a id=\"more\"></a>\n<h3 id=\"框架名称：OnceClick\"><a href=\"#框架名称：OnceClick\" class=\"headerlink\" title=\"框架名称：OnceClick\"></a>框架名称：OnceClick</h3><p><strong>框架功能：</strong>功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。</p>\n<p><strong>框架背景：</strong>从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。</p>\n<p><strong>使用及项目引用地址：</strong><a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/OnceClick</a></p>\n<p>OK，这是一个功能非常简单的小型类库。下面我们来实现它。</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><p>具体的项目搭建细节前一章已经有了介绍，这里不再讲述。</p>\n<p><strong>需要说明的是：</strong>我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。</p>\n<p>项目目录结构如图：</p>\n<p>Module职责：</p>\n<p>app：Demo</p>\n<p>apt：java Library.负责代码生成。编译成apt-jar包供外部使用</p>\n<p>onceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包</p>\n<p><img src=\"http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg\" alt=\"\"></p>\n<h3 id=\"OnceClick使用\"><a href=\"#OnceClick使用\" class=\"headerlink\" title=\"OnceClick使用\"></a>OnceClick使用</h3><pre><code>public class MainActivity extends AppCompatActivity {\n\n    private TextView text;\n    private int num;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        //类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n        OnceInit.once(this,2000);\n        text = (TextView)findViewById(R.id.textView);\n    }\n\n    @OnceClick(R.id.btn)\n    public void once(){\n        text.setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;once&quot;);\n    }\n\n    @OnceClick(R.id.btn2)\n    public void onceMe(View v){\n        ((Button)v).setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;onceMe&quot;);\n    }\n}\n</code></pre><p>在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。</p>\n<p><img src=\"http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg\" alt=\"\"></p>\n<h3 id=\"生成后代码\"><a href=\"#生成后代码\" class=\"headerlink\" title=\"生成后代码\"></a>生成后代码</h3><pre><code>// Generated code from OnceClick. Do not modify!\npackage com.lizhaoxuan.onceclickdemo;\n\nimport android.view.View;\n\nimport com.lizhaoxuan.onceclick.Finder;\nimport com.lizhaoxuan.onceclick.AbstractInjector;\n\npublic class MainActivity$$PROXY&lt;T extends MainActivity&gt; implements AbstractInjector&lt;T&gt; {\n    //间隔多久可以执行一次点击事件\n    public long intervalTime;\n\n    @Override\n    public void setIntervalTime(long time) {\n        intervalTime = time;\n    }\n\n    @Override\n    public void inject(final Finder finder, final T target, Object source) {\n        View view;\n        view = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n        view = finder.findViewById(source, 2131492946);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.onceMe(v);\n                        }\n                }\n            });\n        }\n    }\n}\n</code></pre><p>这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。</p>\n<p>================</p>\n<h3 id=\"OnceClick-Module\"><a href=\"#OnceClick-Module\" class=\"headerlink\" title=\"OnceClick Module\"></a>OnceClick Module</h3><h4 id=\"OnceInit-once\"><a href=\"#OnceInit-once\" class=\"headerlink\" title=\"OnceInit.once\"></a>OnceInit.once</h4><p>看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下<em>OnceInit.java</em>一目了然，我在注释中做讲解:</p>\n<pre><code>public class OnceInit {\n    private static final Map&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt; INJECTORS = new LinkedHashMap&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt;();\n\n    private static final long INTERVAL_TIME = 2000;\n\n    public static void once(Activity activity, long intervalTime) {\n        //生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n        AbstractInjector&lt;Object&gt; injector = findInjector(activity);\n        //执行生成代码中的inject方法\n        //Finder是枚举，这里用Activity类型\n        injector.inject(Finder.ACTIVITY, activity, activity);\n        //设置间隔时间\n        injector.setIntervalTime(intervalTime);\n    }\n\n    //其他几个重载方法\n    public static void once(View view, long intervalTime) {\n        AbstractInjector&lt;Object&gt; injector = findInjector(view);\n        //Finder是枚举，这里用VIEW类型\n        injector.inject(Finder.VIEW, view, view);\n        injector.setIntervalTime(intervalTime);\n    }\n    public static void once(Activity activity) {\n        once(activity, INTERVAL_TIME);\n    }\n    public static void once(View view) {\n        once(view, INTERVAL_TIME);\n    }\n\n    //查找生成的代码\n    private static AbstractInjector&lt;Object&gt; findInjector(Object activity) {\n        Class&lt;?&gt; clazz = activity.getClass();\n        //使用Map缓存一下，避免重复查找\n        AbstractInjector&lt;Object&gt; injector = INJECTORS.get(clazz);\n        if (injector == null) {\n            try {\n                //生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                Class injectorClazz = Class.forName(clazz.getName() + &quot;$$&quot;\n                    + ProxyInfo.PROXY);\n                injector = (AbstractInjector&lt;Object&gt;) injectorClazz\n                    .newInstance();\n                INJECTORS.put(clazz, injector);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return injector;\n    }\n}\n</code></pre><h4 id=\"AbstractInjector\"><a href=\"#AbstractInjector\" class=\"headerlink\" title=\"AbstractInjector\"></a>AbstractInjector</h4><p>代理类接口，所有生成代码类都要实现这个接口。</p>\n<p>inject方法用于实现代理代码。</p>\n<p>setIntervalTime设置点击事件执行间隔时间。</p>\n<pre><code>public interface AbstractInjector&lt;T&gt; {\n\n    void inject(Finder finder, T target, Object source);\n\n    void setIntervalTime(long time);\n}\n</code></pre><h4 id=\"Finder\"><a href=\"#Finder\" class=\"headerlink\" title=\"Finder\"></a>Finder</h4><p>Finder的作用是根据不同的类型，去实现不同的findViewById方法。</p>\n<pre><code>public enum Finder {\n    VIEW {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((View) source).findViewById(id);\n        }\n    },\n    ACTIVITY {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((Activity) source).findViewById(id);\n        }\n    };\n    public abstract View findViewById(Object source, int id);\n}\n</code></pre><p>================</p>\n<h3 id=\"APT-MODULE\"><a href=\"#APT-MODULE\" class=\"headerlink\" title=\"APT MODULE\"></a>APT MODULE</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\npublic @interface OnceClick {\n\n    int value();\n}\n</code></pre><p>OnceClick只有一个默认参数，用来设置View的Id。</p>\n<h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>编写文件javax.annotation.processing.Processor。</p>\n<pre><code>com.example.OnceClickProcessor\n</code></pre><p><img src=\"http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg\" alt=\"\"></p>\n<h4 id=\"Process类-getSupportedAnnotationTypes\"><a href=\"#Process类-getSupportedAnnotationTypes\" class=\"headerlink\" title=\"Process类-getSupportedAnnotationTypes\"></a>Process类-getSupportedAnnotationTypes</h4><pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    types.add(OnceClick.class.getCanonicalName());\n    return types;\n}\n</code></pre><h4 id=\"Process类-process方法\"><a href=\"#Process类-process方法\" class=\"headerlink\" title=\"Process类-process方法\"></a>Process类-process方法</h4><p>重点来啦。这里需要讲一个概念。</p>\n<p>当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。</p>\n<p>所以，一个代理类可能有多个需要处理的View。</p>\n<p>先看process代码：</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    //获取proxyMap\n    Map&lt;String, ProxyInfo&gt; proxyMap = getProxyMap(roundEnv);\n    //遍历proxyMap，并生成代码\n    for (String key : proxyMap.keySet()) {\n        ProxyInfo proxyInfo = proxyMap.get(key);\n        writeCode(proxyInfo);\n    }\n    return true;\n}\n</code></pre><p><strong>ProxyInfo对象</strong>：存放生成代理类的必要信息，并生成代码。</p>\n<p><strong>getProxyMap方法</strong>：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。</p>\n<p><strong>writeCode方法</strong>：真正生成代码的方法。</p>\n<p>总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。</p>\n<h4 id=\"ProxyInfo代理类\"><a href=\"#ProxyInfo代理类\" class=\"headerlink\" title=\"ProxyInfo代理类\"></a>ProxyInfo代理类</h4><p>其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<oncemethod> methods保存。<strong>然后根据这些信息生成类。</strong></oncemethod></p>\n<pre><code>public class ProxyInfo {\n    private String packageName;\n    private String targetClassName;\n    private String proxyClassName;\n    private TypeElement typeElement;\n\n    private List&lt;OnceMethod&gt; methods;\n\n    public static final String PROXY = &quot;PROXY&quot;;\n\n    ProxyInfo(String packageName, String className) {\n        this.packageName = packageName;\n        this.targetClassName = className;\n        this.proxyClassName = className + &quot;$$&quot; + PROXY;\n    }\n\n    String getProxyClassFullName() {\n        return packageName + &quot;.&quot; + proxyClassName;\n    }\n\n    String generateJavaCode() throws OnceClickException {\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(&quot;// Generated code from OnceClick. Do not modify!\\n&quot;);\n        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\\n\\n&quot;);\n\n        builder.append(&quot;import android.view.View;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.Finder;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.AbstractInjector;\\n&quot;);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;public class &quot;).append(proxyClassName);\n        builder.append(&quot;&lt;T extends &quot;).append(getTargetClassName()).append(&quot;&gt;&quot;);\n        builder.append(&quot; implements AbstractInjector&lt;T&gt;&quot;);\n        builder.append(&quot; {\\n&quot;);\n\n        generateInjectMethod(builder);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;}\\n&quot;);\n        return builder.toString();\n\n    }\n\n    private String getTargetClassName() {\n        return targetClassName.replace(&quot;$&quot;, &quot;.&quot;);\n    }\n\n    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n        builder.append(&quot;public long intervalTime; \\n&quot;);\n\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void setIntervalTime(long time) {\\n&quot;)\n                .append(&quot;intervalTime = time;\\n     } \\n&quot;);\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void inject(final Finder finder, final T target, Object source) {\\n&quot;);\n        builder.append(&quot;View view;&quot;);\n\n        for (OnceMethod method : getMethods()) {\n            builder.append(&quot;    view = &quot;)\n                    .append(&quot;finder.findViewById(source, &quot;)\n                    .append(method.getId())\n                    .append(&quot;);\\n&quot;);\n            builder.append(&quot;if(view != null){&quot;)\n                    .append(&quot;view.setOnClickListener(new View.OnClickListener() {\\n&quot;)\n                    .append(&quot;long time = 0L;&quot;);\n            builder.append(&quot;@Override\\n&quot;)\n                    .append(&quot;public void onClick(View v) {&quot;);\n            builder.append(&quot;long temp = System.currentTimeMillis();\\n&quot;)\n                    .append(&quot;if (temp - time &gt;= intervalTime) {\\n&quot; +\n                                &quot;time = temp;\\n&quot;);\n            if (method.getMethodParametersSize() == 1) {\n                if (method.getMethodParameters().get(0).equals(&quot;android.view.View&quot;)) {\n                    builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;(v);&quot;);\n                } else {\n                    throw new OnceClickException(&quot;Parameters must be android.view.View&quot;);\n                }\n            } else if (method.getMethodParametersSize() == 0) {\n            builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;();&quot;);\n            } else {\n                throw new OnceClickException(&quot;Does not support more than one parameter&quot;);\n            }\n            builder.append(&quot;\\n}&quot;)\n                    .append(&quot;    }\\n&quot;)\n                    .append(&quot;        });\\n}&quot;);\n        }\n\n        builder.append(&quot;  }\\n&quot;);\n    }\n\n    TypeElement getTypeElement() {\n        return typeElement;\n    }\n\n    void setTypeElement(TypeElement typeElement) {\n        this.typeElement = typeElement;\n    }\n\n    List&lt;OnceMethod&gt; getMethods() {\n        return methods == null ? new ArrayList&lt;OnceMethod&gt;() : methods;\n    }\n\n    void addMethod(OnceMethod onceMethod) {\n        if (methods == null) {\n            methods = new ArrayList&lt;&gt;();\n        }\n        methods.add(onceMethod);\n    }\n}\n</code></pre><h4 id=\"OnceMethod类\"><a href=\"#OnceMethod类\" class=\"headerlink\" title=\"OnceMethod类\"></a>OnceMethod类</h4><p>需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:</p>\n<pre><code>public class OnceMethod {\n\n    private int id;\n    private String methodName;\n    private List&lt;String&gt; methodParameters;\n\n    OnceMethod(int id, String methodName, List&lt;String&gt; methodParameters) {\n        this.id = id;\n        this.methodName = methodName;\n        this.methodParameters = methodParameters;\n    }\n\n    int getMethodParametersSize() {\n        return methodParameters == null ? 0 : methodParameters.size();\n    }\n\n    int getId() {\n        return id;\n    }\n\n    String getMethodName() {\n        return methodName;\n    }\n\n    List&lt;String&gt; getMethodParameters() {\n        return methodParameters;\n    }\n\n}\n</code></pre><h4 id=\"getProxyMap方法\"><a href=\"#getProxyMap方法\" class=\"headerlink\" title=\"getProxyMap方法\"></a>getProxyMap方法</h4><p>getProxyMap其实也很简单的。通过注释就可以理解。</p>\n<p>比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。</p>\n<pre><code>private Map&lt;String, ProxyInfo&gt; getProxyMap( RoundEnvironment roundEnv){\n    Map&lt;String, ProxyInfo&gt; proxyMap = new HashMap&lt;&gt;();\n    //遍历项目中所有的@OnceClick注解\n    for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {            \n        //获取基本的类名、包名\n        TypeElement classElement = (TypeElement) element;\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n        String fullClassName = classElement.getQualifiedName().toString();\n        String className = classElement.getSimpleName().toString();\n        String packageName = packageElement.getQualifiedName().toString();\n        //获取注解参数\n        int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n        ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n        //如果以创建该代理类，就只add viewId\n        if (proxyInfo != null) {\n            proxyInfo.addLayoutId(viewId);\n        } else {\n            proxyInfo = new ProxyInfo(packageName, className);\n            proxyInfo.setTypeElement(classElement);\n            proxyInfo.addLayoutId(viewId);\n            proxyMap.put(fullClassName, proxyInfo);\n        }\n    }\n    return proxyMap;\n}\n</code></pre><h4 id=\"writeCode方法\"><a href=\"#writeCode方法\" class=\"headerlink\" title=\"writeCode方法\"></a>writeCode方法</h4><p>writeCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。</p>\n<p>需要注意的是 <em>writer.write(proxyInfo.generateJavaCode());</em>。需要生成的代码以字符串形式传给writer。</p>\n<pre><code>private void writeCode(ProxyInfo proxyInfo){\n    try {\n        JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                proxyInfo.getProxyClassFullName(),\n                proxyInfo.getTypeElement());\n        Writer writer = jfo.openWriter();\n        writer.write(proxyInfo.generateJavaCode());\n        writer.flush();\n        writer.close();\n    } catch (IOException e) {\n        error(proxyInfo.getTypeElement(),\n                &quot;Unable to write injector for type %s: %s&quot;,\n                proxyInfo.getTypeElement(), e.getMessage());\n    }\n}\n\n//两个日志输出方法。\nprivate void print(String message){\n    messager.printMessage(Diagnostic.Kind.NOTE, message);\n}\n\nprivate void error(Element element, String message, Object... args) {\n    if (args.length &gt; 0) {\n        message = String.format(message, args);\n    }\n    messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n}\n</code></pre><h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？</p>\n<pre><code>//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\nOnceInit.once(this,2000);\n</code></pre><p>技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。</p>\n<p>每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：</p>\n<pre><code>@OnceClick(R.id.btn)\n</code></pre><p>如果有两个属性，就必须要带名字了 </p>\n<pre><code>@OnceClick(id = R.id.btn)\n</code></pre><p>最后在把源码地址再放一下 <a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/OnceClick</a>。看着Demo学习会更快！</p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p>《Android编译时注解框架-Run Project：OnceClick》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。</p>\n<p>本章将以生成代码为重点进行一个案例讲解。</p>","more":"<h3 id=\"框架名称：OnceClick\"><a href=\"#框架名称：OnceClick\" class=\"headerlink\" title=\"框架名称：OnceClick\"></a>框架名称：OnceClick</h3><p><strong>框架功能：</strong>功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。</p>\n<p><strong>框架背景：</strong>从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。</p>\n<p><strong>使用及项目引用地址：</strong><a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/OnceClick</a></p>\n<p>OK，这是一个功能非常简单的小型类库。下面我们来实现它。</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><p>具体的项目搭建细节前一章已经有了介绍，这里不再讲述。</p>\n<p><strong>需要说明的是：</strong>我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。</p>\n<p>项目目录结构如图：</p>\n<p>Module职责：</p>\n<p>app：Demo</p>\n<p>apt：java Library.负责代码生成。编译成apt-jar包供外部使用</p>\n<p>onceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包</p>\n<p><img src=\"http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg\" alt=\"\"></p>\n<h3 id=\"OnceClick使用\"><a href=\"#OnceClick使用\" class=\"headerlink\" title=\"OnceClick使用\"></a>OnceClick使用</h3><pre><code>public class MainActivity extends AppCompatActivity {\n\n    private TextView text;\n    private int num;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        //类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n        OnceInit.once(this,2000);\n        text = (TextView)findViewById(R.id.textView);\n    }\n\n    @OnceClick(R.id.btn)\n    public void once(){\n        text.setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;once&quot;);\n    }\n\n    @OnceClick(R.id.btn2)\n    public void onceMe(View v){\n        ((Button)v).setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;onceMe&quot;);\n    }\n}\n</code></pre><p>在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。</p>\n<p><img src=\"http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg\" alt=\"\"></p>\n<h3 id=\"生成后代码\"><a href=\"#生成后代码\" class=\"headerlink\" title=\"生成后代码\"></a>生成后代码</h3><pre><code>// Generated code from OnceClick. Do not modify!\npackage com.lizhaoxuan.onceclickdemo;\n\nimport android.view.View;\n\nimport com.lizhaoxuan.onceclick.Finder;\nimport com.lizhaoxuan.onceclick.AbstractInjector;\n\npublic class MainActivity$$PROXY&lt;T extends MainActivity&gt; implements AbstractInjector&lt;T&gt; {\n    //间隔多久可以执行一次点击事件\n    public long intervalTime;\n\n    @Override\n    public void setIntervalTime(long time) {\n        intervalTime = time;\n    }\n\n    @Override\n    public void inject(final Finder finder, final T target, Object source) {\n        View view;\n        view = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n        view = finder.findViewById(source, 2131492946);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.onceMe(v);\n                        }\n                }\n            });\n        }\n    }\n}\n</code></pre><p>这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。</p>\n<p>================</p>\n<h3 id=\"OnceClick-Module\"><a href=\"#OnceClick-Module\" class=\"headerlink\" title=\"OnceClick Module\"></a>OnceClick Module</h3><h4 id=\"OnceInit-once\"><a href=\"#OnceInit-once\" class=\"headerlink\" title=\"OnceInit.once\"></a>OnceInit.once</h4><p>看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下<em>OnceInit.java</em>一目了然，我在注释中做讲解:</p>\n<pre><code>public class OnceInit {\n    private static final Map&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt; INJECTORS = new LinkedHashMap&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt;();\n\n    private static final long INTERVAL_TIME = 2000;\n\n    public static void once(Activity activity, long intervalTime) {\n        //生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n        AbstractInjector&lt;Object&gt; injector = findInjector(activity);\n        //执行生成代码中的inject方法\n        //Finder是枚举，这里用Activity类型\n        injector.inject(Finder.ACTIVITY, activity, activity);\n        //设置间隔时间\n        injector.setIntervalTime(intervalTime);\n    }\n\n    //其他几个重载方法\n    public static void once(View view, long intervalTime) {\n        AbstractInjector&lt;Object&gt; injector = findInjector(view);\n        //Finder是枚举，这里用VIEW类型\n        injector.inject(Finder.VIEW, view, view);\n        injector.setIntervalTime(intervalTime);\n    }\n    public static void once(Activity activity) {\n        once(activity, INTERVAL_TIME);\n    }\n    public static void once(View view) {\n        once(view, INTERVAL_TIME);\n    }\n\n    //查找生成的代码\n    private static AbstractInjector&lt;Object&gt; findInjector(Object activity) {\n        Class&lt;?&gt; clazz = activity.getClass();\n        //使用Map缓存一下，避免重复查找\n        AbstractInjector&lt;Object&gt; injector = INJECTORS.get(clazz);\n        if (injector == null) {\n            try {\n                //生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                Class injectorClazz = Class.forName(clazz.getName() + &quot;$$&quot;\n                    + ProxyInfo.PROXY);\n                injector = (AbstractInjector&lt;Object&gt;) injectorClazz\n                    .newInstance();\n                INJECTORS.put(clazz, injector);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return injector;\n    }\n}\n</code></pre><h4 id=\"AbstractInjector\"><a href=\"#AbstractInjector\" class=\"headerlink\" title=\"AbstractInjector\"></a>AbstractInjector</h4><p>代理类接口，所有生成代码类都要实现这个接口。</p>\n<p>inject方法用于实现代理代码。</p>\n<p>setIntervalTime设置点击事件执行间隔时间。</p>\n<pre><code>public interface AbstractInjector&lt;T&gt; {\n\n    void inject(Finder finder, T target, Object source);\n\n    void setIntervalTime(long time);\n}\n</code></pre><h4 id=\"Finder\"><a href=\"#Finder\" class=\"headerlink\" title=\"Finder\"></a>Finder</h4><p>Finder的作用是根据不同的类型，去实现不同的findViewById方法。</p>\n<pre><code>public enum Finder {\n    VIEW {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((View) source).findViewById(id);\n        }\n    },\n    ACTIVITY {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((Activity) source).findViewById(id);\n        }\n    };\n    public abstract View findViewById(Object source, int id);\n}\n</code></pre><p>================</p>\n<h3 id=\"APT-MODULE\"><a href=\"#APT-MODULE\" class=\"headerlink\" title=\"APT MODULE\"></a>APT MODULE</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\npublic @interface OnceClick {\n\n    int value();\n}\n</code></pre><p>OnceClick只有一个默认参数，用来设置View的Id。</p>\n<h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>编写文件javax.annotation.processing.Processor。</p>\n<pre><code>com.example.OnceClickProcessor\n</code></pre><p><img src=\"http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg\" alt=\"\"></p>\n<h4 id=\"Process类-getSupportedAnnotationTypes\"><a href=\"#Process类-getSupportedAnnotationTypes\" class=\"headerlink\" title=\"Process类-getSupportedAnnotationTypes\"></a>Process类-getSupportedAnnotationTypes</h4><pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    types.add(OnceClick.class.getCanonicalName());\n    return types;\n}\n</code></pre><h4 id=\"Process类-process方法\"><a href=\"#Process类-process方法\" class=\"headerlink\" title=\"Process类-process方法\"></a>Process类-process方法</h4><p>重点来啦。这里需要讲一个概念。</p>\n<p>当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。</p>\n<p>所以，一个代理类可能有多个需要处理的View。</p>\n<p>先看process代码：</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    //获取proxyMap\n    Map&lt;String, ProxyInfo&gt; proxyMap = getProxyMap(roundEnv);\n    //遍历proxyMap，并生成代码\n    for (String key : proxyMap.keySet()) {\n        ProxyInfo proxyInfo = proxyMap.get(key);\n        writeCode(proxyInfo);\n    }\n    return true;\n}\n</code></pre><p><strong>ProxyInfo对象</strong>：存放生成代理类的必要信息，并生成代码。</p>\n<p><strong>getProxyMap方法</strong>：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。</p>\n<p><strong>writeCode方法</strong>：真正生成代码的方法。</p>\n<p>总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。</p>\n<h4 id=\"ProxyInfo代理类\"><a href=\"#ProxyInfo代理类\" class=\"headerlink\" title=\"ProxyInfo代理类\"></a>ProxyInfo代理类</h4><p>其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<oncemethod> methods保存。<strong>然后根据这些信息生成类。</strong></oncemethod></p>\n<pre><code>public class ProxyInfo {\n    private String packageName;\n    private String targetClassName;\n    private String proxyClassName;\n    private TypeElement typeElement;\n\n    private List&lt;OnceMethod&gt; methods;\n\n    public static final String PROXY = &quot;PROXY&quot;;\n\n    ProxyInfo(String packageName, String className) {\n        this.packageName = packageName;\n        this.targetClassName = className;\n        this.proxyClassName = className + &quot;$$&quot; + PROXY;\n    }\n\n    String getProxyClassFullName() {\n        return packageName + &quot;.&quot; + proxyClassName;\n    }\n\n    String generateJavaCode() throws OnceClickException {\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(&quot;// Generated code from OnceClick. Do not modify!\\n&quot;);\n        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\\n\\n&quot;);\n\n        builder.append(&quot;import android.view.View;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.Finder;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.AbstractInjector;\\n&quot;);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;public class &quot;).append(proxyClassName);\n        builder.append(&quot;&lt;T extends &quot;).append(getTargetClassName()).append(&quot;&gt;&quot;);\n        builder.append(&quot; implements AbstractInjector&lt;T&gt;&quot;);\n        builder.append(&quot; {\\n&quot;);\n\n        generateInjectMethod(builder);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;}\\n&quot;);\n        return builder.toString();\n\n    }\n\n    private String getTargetClassName() {\n        return targetClassName.replace(&quot;$&quot;, &quot;.&quot;);\n    }\n\n    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n        builder.append(&quot;public long intervalTime; \\n&quot;);\n\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void setIntervalTime(long time) {\\n&quot;)\n                .append(&quot;intervalTime = time;\\n     } \\n&quot;);\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void inject(final Finder finder, final T target, Object source) {\\n&quot;);\n        builder.append(&quot;View view;&quot;);\n\n        for (OnceMethod method : getMethods()) {\n            builder.append(&quot;    view = &quot;)\n                    .append(&quot;finder.findViewById(source, &quot;)\n                    .append(method.getId())\n                    .append(&quot;);\\n&quot;);\n            builder.append(&quot;if(view != null){&quot;)\n                    .append(&quot;view.setOnClickListener(new View.OnClickListener() {\\n&quot;)\n                    .append(&quot;long time = 0L;&quot;);\n            builder.append(&quot;@Override\\n&quot;)\n                    .append(&quot;public void onClick(View v) {&quot;);\n            builder.append(&quot;long temp = System.currentTimeMillis();\\n&quot;)\n                    .append(&quot;if (temp - time &gt;= intervalTime) {\\n&quot; +\n                                &quot;time = temp;\\n&quot;);\n            if (method.getMethodParametersSize() == 1) {\n                if (method.getMethodParameters().get(0).equals(&quot;android.view.View&quot;)) {\n                    builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;(v);&quot;);\n                } else {\n                    throw new OnceClickException(&quot;Parameters must be android.view.View&quot;);\n                }\n            } else if (method.getMethodParametersSize() == 0) {\n            builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;();&quot;);\n            } else {\n                throw new OnceClickException(&quot;Does not support more than one parameter&quot;);\n            }\n            builder.append(&quot;\\n}&quot;)\n                    .append(&quot;    }\\n&quot;)\n                    .append(&quot;        });\\n}&quot;);\n        }\n\n        builder.append(&quot;  }\\n&quot;);\n    }\n\n    TypeElement getTypeElement() {\n        return typeElement;\n    }\n\n    void setTypeElement(TypeElement typeElement) {\n        this.typeElement = typeElement;\n    }\n\n    List&lt;OnceMethod&gt; getMethods() {\n        return methods == null ? new ArrayList&lt;OnceMethod&gt;() : methods;\n    }\n\n    void addMethod(OnceMethod onceMethod) {\n        if (methods == null) {\n            methods = new ArrayList&lt;&gt;();\n        }\n        methods.add(onceMethod);\n    }\n}\n</code></pre><h4 id=\"OnceMethod类\"><a href=\"#OnceMethod类\" class=\"headerlink\" title=\"OnceMethod类\"></a>OnceMethod类</h4><p>需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:</p>\n<pre><code>public class OnceMethod {\n\n    private int id;\n    private String methodName;\n    private List&lt;String&gt; methodParameters;\n\n    OnceMethod(int id, String methodName, List&lt;String&gt; methodParameters) {\n        this.id = id;\n        this.methodName = methodName;\n        this.methodParameters = methodParameters;\n    }\n\n    int getMethodParametersSize() {\n        return methodParameters == null ? 0 : methodParameters.size();\n    }\n\n    int getId() {\n        return id;\n    }\n\n    String getMethodName() {\n        return methodName;\n    }\n\n    List&lt;String&gt; getMethodParameters() {\n        return methodParameters;\n    }\n\n}\n</code></pre><h4 id=\"getProxyMap方法\"><a href=\"#getProxyMap方法\" class=\"headerlink\" title=\"getProxyMap方法\"></a>getProxyMap方法</h4><p>getProxyMap其实也很简单的。通过注释就可以理解。</p>\n<p>比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。</p>\n<pre><code>private Map&lt;String, ProxyInfo&gt; getProxyMap( RoundEnvironment roundEnv){\n    Map&lt;String, ProxyInfo&gt; proxyMap = new HashMap&lt;&gt;();\n    //遍历项目中所有的@OnceClick注解\n    for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {            \n        //获取基本的类名、包名\n        TypeElement classElement = (TypeElement) element;\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n        String fullClassName = classElement.getQualifiedName().toString();\n        String className = classElement.getSimpleName().toString();\n        String packageName = packageElement.getQualifiedName().toString();\n        //获取注解参数\n        int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n        ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n        //如果以创建该代理类，就只add viewId\n        if (proxyInfo != null) {\n            proxyInfo.addLayoutId(viewId);\n        } else {\n            proxyInfo = new ProxyInfo(packageName, className);\n            proxyInfo.setTypeElement(classElement);\n            proxyInfo.addLayoutId(viewId);\n            proxyMap.put(fullClassName, proxyInfo);\n        }\n    }\n    return proxyMap;\n}\n</code></pre><h4 id=\"writeCode方法\"><a href=\"#writeCode方法\" class=\"headerlink\" title=\"writeCode方法\"></a>writeCode方法</h4><p>writeCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。</p>\n<p>需要注意的是 <em>writer.write(proxyInfo.generateJavaCode());</em>。需要生成的代码以字符串形式传给writer。</p>\n<pre><code>private void writeCode(ProxyInfo proxyInfo){\n    try {\n        JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                proxyInfo.getProxyClassFullName(),\n                proxyInfo.getTypeElement());\n        Writer writer = jfo.openWriter();\n        writer.write(proxyInfo.generateJavaCode());\n        writer.flush();\n        writer.close();\n    } catch (IOException e) {\n        error(proxyInfo.getTypeElement(),\n                &quot;Unable to write injector for type %s: %s&quot;,\n                proxyInfo.getTypeElement(), e.getMessage());\n    }\n}\n\n//两个日志输出方法。\nprivate void print(String message){\n    messager.printMessage(Diagnostic.Kind.NOTE, message);\n}\n\nprivate void error(Element element, String message, Object... args) {\n    if (args.length &gt; 0) {\n        message = String.format(message, args);\n    }\n    messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n}\n</code></pre><h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？</p>\n<pre><code>//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\nOnceInit.once(this,2000);\n</code></pre><p>技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。</p>\n<p>每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：</p>\n<pre><code>@OnceClick(R.id.btn)\n</code></pre><p>如果有两个属性，就必须要带名字了 </p>\n<pre><code>@OnceClick(id = R.id.btn)\n</code></pre><p>最后在把源码地址再放一下 <a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/OnceClick</a>。看着Demo学习会更快！</p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p>《Android编译时注解框架-Run Project：OnceClick》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架系列1-什么是编译时注解","date":"2016-07-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n**Android编译时注解框架从入门到项目实践**。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。\n\n提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。\n\n但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题...\n\n\n\n<!-- more -->\n\n\n今天我们要讲的是，不会对性能有任何影响的黑科技：**编译时注解**。也有人叫它**代码生成**，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool\n\n得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。\n\n本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。\n\n- 什么是注解\n\n- 运行时注解的简单使用\n\n- 编译时注解框架ButterKnife源码初探\n\n\n\n### 什么是注解\n\n注解你一定不会陌生，这就是我们最常见的注解：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg)\n\n\n首先注解分为三类：\n\n- 标准 Annotation\n\n\t包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，\n\t不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。\n\n- 元 Annotation\n\n\t@Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。\n\t\n- 自定义 Annotation\n\t\n\t根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。\n\t\n\n同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：\n\n这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释\n\n\t/**\n     * Annotation is only available in the source code.\n     */\n    SOURCE,\n    /**\n     * Annotation is available in the source code and in the class file, but not\n     * at runtime. This is the default policy.\n     */\n    CLASS,\n    /**\n     * Annotation is available in the source code, the class file and is\n     * available at runtime.\n     */\n    RUNTIME\n\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t该注解仅用于源码阶段，就是我们编写的java文件。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。\n\t\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t该注解用于源码、类文件和运行时阶段。\n\t\n\t\n可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。\n\nRetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。\n修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。\n\n那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？\n\n没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。\n\nRetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。\n\n**请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环**\n\n\n\n### 运行时注解的简单使用\n\n\n运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。\n\n下面展示一个Demo。其功能是通过注解实现布局文件的设置。\n\n之前我们是这样设置布局文件的：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_home);\n    }\n    \n如果使用注解，我们就可以这样设置布局了\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\t\n我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。\n\n那么这样的注解是怎么实现的呢？很简单，往下看。\n\n#### 创建一个注解\n\t\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE})\n\tpublic @interface ContentView {\n    \tint value();\n\t}\n\n\n**第一行:@Retention(RetentionPolicy.RUNTIME)**\n\n@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。\n\n**第二行：@Target({ElementType.TYPE})**\n\n@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。\n\n**第三行：public @interface ContentView**\n\n这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）\n\n\t/** Class, interface (including annotation type), or enum declaration */\n\tTYPE,\n\n**第四行：int value();**\n\n返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的\n\n\t@ContentView(R.layout.activity_home)\n\t\nR.layout.activity_home实质是一个int型id，如果这样用就会报错：\n\n\t@ContentView(“string”)\n\t\n\n**关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中**\n\n\n#### 注解解析\n\n注解申明好了，但具体是怎么识别这个注解并使用的呢？\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\n注解的解析就在BaseActivity中。我们看一下BaseActivity代码\n\n\tpublic class BaseActivity extends AppCompatActivity {\n\t\n\t\t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //注解解析\n\t\tfor (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n            ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n            if (annotation != null) {\n                try {\n                    this.setContentView(annotation.value());\n                } catch (RuntimeException e) {\n                    e.printStackTrace();\n                }\n                return;\n            }\n        }\n\t}\n\n\n\t\n第一步：遍历所有的子类\n\n第二步：找到修饰了注解ContentView的类\n\n第三步：获取ContentView的属性值。\n\n第四步：为Activity设置布局。\n\n#### 总结\n\n相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。\n\n你可能会觉得*setContentView(R.layout.activity_home)*和*@ContentView(R.layout.activity_home)*没什么区别，用了注解反而还增加了性能问题。\n\n但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。\n\n因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。\n\n\n\n\n\n\n### 编译时注解框架ButterKnife源码初探\n\nButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg)\n\n你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。\n\n秘密在这里，编译工程后，打开你的项目app目录下的build目录：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg)\n\n你可以看到一些带有*$$ViewBinder*后缀的类文件。这个就是ButterKnife生成的代码我们打开它：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg)\n\n\n\n\n上面有一条注释：\n// Generated code from Butter Knife. Do not modify!\n\n1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：\n\n\tpackage com.zhaoxuan.wehome.view.activity;\n\t\n同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：\n\n\t\t//accountEdit是ForgetActivity当中定义的控件\n\t    target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n所以你也应该知道了为什么当使用private时会报错了吧？\n\n2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。\n\n\t@Override\n    public void bind(final Finder finder, final T target, Object source) {\n        //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n        View view;\n        \n        //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n        view = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n        \n        //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n        target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n        \n        view = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n        target.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n        \n        //给view设置一个点击事件\n        view.setOnClickListener(\n                new butterknife.internal.DebouncingOnClickListener() {\n                    @Override\n                    public void doClick(android.view.View p0) {\n                    \n                    \t//forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                       target.forgetOnClick();\n                       \n                    }\n                });\n    }\n\nOK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：\n\n1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。\n\n2.Finder到底是个什么东西？凭什么它可以找到view。\n\n不着急不着急，慢慢看。\n#### 注解: @Bind的定义\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg)\n\n我们可以解读的信息如下：\n\n1. Bind是编译时注解\n\n2. 只能修饰属性\n\n3. 属性值是一个int型的数组。\n\n\n创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。\n\n#### Finder类\n\n通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg)\n\n根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。\n\n另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： *finder.findRequiredView* 和 *finder.castView*\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg)\n\n\nfindRequiredView 方法调用了 findOptionalView 方法\n\nfindOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）\n\nfindView取得view后，又交给了castView做一些容错处理。\n\ncastView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。\n\n\n\n#### ButterKnife.bind(this)方法\n\n*ButterKnife.bind(this)*这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~\n\nbind有几个重载方法，但最终调的都是下面这个方法。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg)\n\n参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。\n\n首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：*ForgetActivity$$ViewBinder*。\n\n然后调用ForgetActivity$$ViewBinder的bind方法。\n\n然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。\n\n\n#### ButterKnifeProcessor\n\n你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg)\n\nAbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg)\n\n重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。\n\n第一个最明显的就是Bind注解啦。\n\n而所有的注解处理，都是在process中执行的：\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg)\n\n通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。\n\nJavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。\n\n这里我们只关注最重要的一句话\n\n\twriter.write(bindingClass.brewJava());\n\t\nForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。\n\n\n#### bindingClass.brewJava方法\n\n哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……\n\n我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……\n\n既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。\n\n由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg)\n\n\n### 总结\n\n当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。\n\n但这不正是学习的魅力么？\n\n好了，总结一下。\n\n1. 编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。\n\n2. 代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。\n\n3. APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~\n\n4. ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：**写一个框架最难的不是技术实现，而是稳定！**\n\n5. ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。\n\nAPT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。\n\n后续篇章我将会陆续推出几款以Cake命名的APT框架。\n\n\n\n<br/>\n\n《Android编译时注解框架-什么是编译时注解》\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n\n\n\n","source":"_posts/apt-wathapt.md","raw":"---\ntitle: Android编译时注解框架系列1-什么是编译时注解\ndate: 2016-07-17 16:20:58\nauthor : 暴打小女孩\n\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n**Android编译时注解框架从入门到项目实践**。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。\n\n提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。\n\n但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题...\n\n\n\n<!-- more -->\n\n\n今天我们要讲的是，不会对性能有任何影响的黑科技：**编译时注解**。也有人叫它**代码生成**，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool\n\n得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。\n\n本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。\n\n- 什么是注解\n\n- 运行时注解的简单使用\n\n- 编译时注解框架ButterKnife源码初探\n\n\n\n### 什么是注解\n\n注解你一定不会陌生，这就是我们最常见的注解：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg)\n\n\n首先注解分为三类：\n\n- 标准 Annotation\n\n\t包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，\n\t不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。\n\n- 元 Annotation\n\n\t@Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。\n\t\n- 自定义 Annotation\n\t\n\t根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。\n\t\n\n同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：\n\n这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释\n\n\t/**\n     * Annotation is only available in the source code.\n     */\n    SOURCE,\n    /**\n     * Annotation is available in the source code and in the class file, but not\n     * at runtime. This is the default policy.\n     */\n    CLASS,\n    /**\n     * Annotation is available in the source code, the class file and is\n     * available at runtime.\n     */\n    RUNTIME\n\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t该注解仅用于源码阶段，就是我们编写的java文件。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。\n\t\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t该注解用于源码、类文件和运行时阶段。\n\t\n\t\n可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。\n\nRetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。\n修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。\n\n那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？\n\n没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。\n\nRetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。\n\n**请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环**\n\n\n\n### 运行时注解的简单使用\n\n\n运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。\n\n下面展示一个Demo。其功能是通过注解实现布局文件的设置。\n\n之前我们是这样设置布局文件的：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_home);\n    }\n    \n如果使用注解，我们就可以这样设置布局了\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\t\n我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。\n\n那么这样的注解是怎么实现的呢？很简单，往下看。\n\n#### 创建一个注解\n\t\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE})\n\tpublic @interface ContentView {\n    \tint value();\n\t}\n\n\n**第一行:@Retention(RetentionPolicy.RUNTIME)**\n\n@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。\n\n**第二行：@Target({ElementType.TYPE})**\n\n@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。\n\n**第三行：public @interface ContentView**\n\n这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）\n\n\t/** Class, interface (including annotation type), or enum declaration */\n\tTYPE,\n\n**第四行：int value();**\n\n返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的\n\n\t@ContentView(R.layout.activity_home)\n\t\nR.layout.activity_home实质是一个int型id，如果这样用就会报错：\n\n\t@ContentView(“string”)\n\t\n\n**关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中**\n\n\n#### 注解解析\n\n注解申明好了，但具体是怎么识别这个注解并使用的呢？\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\n注解的解析就在BaseActivity中。我们看一下BaseActivity代码\n\n\tpublic class BaseActivity extends AppCompatActivity {\n\t\n\t\t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //注解解析\n\t\tfor (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n            ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n            if (annotation != null) {\n                try {\n                    this.setContentView(annotation.value());\n                } catch (RuntimeException e) {\n                    e.printStackTrace();\n                }\n                return;\n            }\n        }\n\t}\n\n\n\t\n第一步：遍历所有的子类\n\n第二步：找到修饰了注解ContentView的类\n\n第三步：获取ContentView的属性值。\n\n第四步：为Activity设置布局。\n\n#### 总结\n\n相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。\n\n你可能会觉得*setContentView(R.layout.activity_home)*和*@ContentView(R.layout.activity_home)*没什么区别，用了注解反而还增加了性能问题。\n\n但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。\n\n因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。\n\n\n\n\n\n\n### 编译时注解框架ButterKnife源码初探\n\nButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg)\n\n你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。\n\n秘密在这里，编译工程后，打开你的项目app目录下的build目录：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg)\n\n你可以看到一些带有*$$ViewBinder*后缀的类文件。这个就是ButterKnife生成的代码我们打开它：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg)\n\n\n\n\n上面有一条注释：\n// Generated code from Butter Knife. Do not modify!\n\n1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：\n\n\tpackage com.zhaoxuan.wehome.view.activity;\n\t\n同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：\n\n\t\t//accountEdit是ForgetActivity当中定义的控件\n\t    target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n所以你也应该知道了为什么当使用private时会报错了吧？\n\n2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。\n\n\t@Override\n    public void bind(final Finder finder, final T target, Object source) {\n        //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n        View view;\n        \n        //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n        view = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n        \n        //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n        target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n        \n        view = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n        target.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n        \n        //给view设置一个点击事件\n        view.setOnClickListener(\n                new butterknife.internal.DebouncingOnClickListener() {\n                    @Override\n                    public void doClick(android.view.View p0) {\n                    \n                    \t//forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                       target.forgetOnClick();\n                       \n                    }\n                });\n    }\n\nOK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：\n\n1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。\n\n2.Finder到底是个什么东西？凭什么它可以找到view。\n\n不着急不着急，慢慢看。\n#### 注解: @Bind的定义\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg)\n\n我们可以解读的信息如下：\n\n1. Bind是编译时注解\n\n2. 只能修饰属性\n\n3. 属性值是一个int型的数组。\n\n\n创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。\n\n#### Finder类\n\n通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg)\n\n根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。\n\n另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： *finder.findRequiredView* 和 *finder.castView*\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg)\n\n\nfindRequiredView 方法调用了 findOptionalView 方法\n\nfindOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）\n\nfindView取得view后，又交给了castView做一些容错处理。\n\ncastView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。\n\n\n\n#### ButterKnife.bind(this)方法\n\n*ButterKnife.bind(this)*这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~\n\nbind有几个重载方法，但最终调的都是下面这个方法。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg)\n\n参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。\n\n首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：*ForgetActivity$$ViewBinder*。\n\n然后调用ForgetActivity$$ViewBinder的bind方法。\n\n然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。\n\n\n#### ButterKnifeProcessor\n\n你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg)\n\nAbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg)\n\n重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。\n\n第一个最明显的就是Bind注解啦。\n\n而所有的注解处理，都是在process中执行的：\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg)\n\n通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。\n\nJavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。\n\n这里我们只关注最重要的一句话\n\n\twriter.write(bindingClass.brewJava());\n\t\nForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。\n\n\n#### bindingClass.brewJava方法\n\n哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……\n\n我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……\n\n既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。\n\n由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg)\n\n\n### 总结\n\n当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。\n\n但这不正是学习的魅力么？\n\n好了，总结一下。\n\n1. 编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。\n\n2. 代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。\n\n3. APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~\n\n4. ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：**写一个框架最难的不是技术实现，而是稳定！**\n\n5. ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。\n\nAPT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。\n\n后续篇章我将会陆续推出几款以Cake命名的APT框架。\n\n\n\n<br/>\n\n《Android编译时注解框架-什么是编译时注解》\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n\n\n\n","slug":"apt-wathapt","published":1,"updated":"2019-01-02T02:09:31.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspk000syo9sbg0icqs3","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><strong>Android编译时注解框架从入门到项目实践</strong>。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。</p>\n<p>提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。</p>\n<p>但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题…</p>\n<a id=\"more\"></a>\n<p>今天我们要讲的是，不会对性能有任何影响的黑科技：<strong>编译时注解</strong>。也有人叫它<strong>代码生成</strong>，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool</p>\n<p>得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。</p>\n<p>本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。</p>\n<ul>\n<li><p>什么是注解</p>\n</li>\n<li><p>运行时注解的简单使用</p>\n</li>\n<li><p>编译时注解框架ButterKnife源码初探</p>\n</li>\n</ul>\n<h3 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h3><p>注解你一定不会陌生，这就是我们最常见的注解：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg\" alt=\"\"></p>\n<p>首先注解分为三类：</p>\n<ul>\n<li><p>标准 Annotation</p>\n<p>  包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，<br>  不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。</p>\n</li>\n<li><p>元 Annotation</p>\n<p>  @Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。</p>\n</li>\n<li><p>自定义 Annotation</p>\n<p>  根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。</p>\n</li>\n</ul>\n<p>同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：</p>\n<p>这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释</p>\n<pre><code>/**\n * Annotation is only available in the source code.\n */\nSOURCE,\n/**\n * Annotation is available in the source code and in the class file, but not\n * at runtime. This is the default policy.\n */\nCLASS,\n/**\n * Annotation is available in the source code, the class file and is\n * available at runtime.\n */\nRUNTIME\n</code></pre><ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  该注解仅用于源码阶段，就是我们编写的java文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  该注解用于源码、类文件和运行时阶段。</p>\n</li>\n</ul>\n<p>可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。</p>\n<p>RetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。<br>修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。</p>\n<p>那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？</p>\n<p>没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。</p>\n<p>RetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。</p>\n<p><strong>请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环</strong></p>\n<h3 id=\"运行时注解的简单使用\"><a href=\"#运行时注解的简单使用\" class=\"headerlink\" title=\"运行时注解的简单使用\"></a>运行时注解的简单使用</h3><p>运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。</p>\n<p>下面展示一个Demo。其功能是通过注解实现布局文件的设置。</p>\n<p>之前我们是这样设置布局文件的：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_home);\n}\n</code></pre><p>如果使用注解，我们就可以这样设置布局了</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。</p>\n<p>那么这样的注解是怎么实现的呢？很简单，往下看。</p>\n<h4 id=\"创建一个注解\"><a href=\"#创建一个注解\" class=\"headerlink\" title=\"创建一个注解\"></a>创建一个注解</h4><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface ContentView {\n    int value();\n}\n</code></pre><p><strong>第一行:@Retention(RetentionPolicy.RUNTIME)</strong></p>\n<p>@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。</p>\n<p><strong>第二行：@Target({ElementType.TYPE})</strong></p>\n<p>@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。</p>\n<p><strong>第三行：public @interface ContentView</strong></p>\n<p>这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）</p>\n<pre><code>/** Class, interface (including annotation type), or enum declaration */\nTYPE,\n</code></pre><p><strong>第四行：int value();</strong></p>\n<p>返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的</p>\n<pre><code>@ContentView(R.layout.activity_home)\n</code></pre><p>R.layout.activity_home实质是一个int型id，如果这样用就会报错：</p>\n<pre><code>@ContentView(“string”)\n</code></pre><p><strong>关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中</strong></p>\n<h4 id=\"注解解析\"><a href=\"#注解解析\" class=\"headerlink\" title=\"注解解析\"></a>注解解析</h4><p>注解申明好了，但具体是怎么识别这个注解并使用的呢？</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>注解的解析就在BaseActivity中。我们看一下BaseActivity代码</p>\n<pre><code>public class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //注解解析\n    for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n        ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n        if (annotation != null) {\n            try {\n                this.setContentView(annotation.value());\n            } catch (RuntimeException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n    }\n}\n</code></pre><p>第一步：遍历所有的子类</p>\n<p>第二步：找到修饰了注解ContentView的类</p>\n<p>第三步：获取ContentView的属性值。</p>\n<p>第四步：为Activity设置布局。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。</p>\n<p>你可能会觉得<em>setContentView(R.layout.activity_home)</em>和<em>@ContentView(R.layout.activity_home)</em>没什么区别，用了注解反而还增加了性能问题。</p>\n<p>但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。</p>\n<p>因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。</p>\n<h3 id=\"编译时注解框架ButterKnife源码初探\"><a href=\"#编译时注解框架ButterKnife源码初探\" class=\"headerlink\" title=\"编译时注解框架ButterKnife源码初探\"></a>编译时注解框架ButterKnife源码初探</h3><p>ButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg\" alt=\"\"></p>\n<p>你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。</p>\n<p>秘密在这里，编译工程后，打开你的项目app目录下的build目录：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg\" alt=\"\"></p>\n<p>你可以看到一些带有<em>$$ViewBinder</em>后缀的类文件。这个就是ButterKnife生成的代码我们打开它：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg\" alt=\"\"></p>\n<p>上面有一条注释：<br>// Generated code from Butter Knife. Do not modify!</p>\n<p>1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：</p>\n<pre><code>package com.zhaoxuan.wehome.view.activity;\n</code></pre><p>同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：</p>\n<pre><code>//accountEdit是ForgetActivity当中定义的控件\ntarget.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n</code></pre><p>所以你也应该知道了为什么当使用private时会报错了吧？</p>\n<p>2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。</p>\n<pre><code>@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n}\n</code></pre><p>OK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：</p>\n<p>1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。</p>\n<p>2.Finder到底是个什么东西？凭什么它可以找到view。</p>\n<p>不着急不着急，慢慢看。</p>\n<h4 id=\"注解-Bind的定义\"><a href=\"#注解-Bind的定义\" class=\"headerlink\" title=\"注解: @Bind的定义\"></a>注解: @Bind的定义</h4><p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg\" alt=\"\"></p>\n<p>我们可以解读的信息如下：</p>\n<ol>\n<li><p>Bind是编译时注解</p>\n</li>\n<li><p>只能修饰属性</p>\n</li>\n<li><p>属性值是一个int型的数组。</p>\n</li>\n</ol>\n<p>创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。</p>\n<h4 id=\"Finder类\"><a href=\"#Finder类\" class=\"headerlink\" title=\"Finder类\"></a>Finder类</h4><p>通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg\" alt=\"\"></p>\n<p>根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。</p>\n<p>另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： <em>finder.findRequiredView</em> 和 <em>finder.castView</em></p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg\" alt=\"\"></p>\n<p>findRequiredView 方法调用了 findOptionalView 方法</p>\n<p>findOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）</p>\n<p>findView取得view后，又交给了castView做一些容错处理。</p>\n<p>castView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。</p>\n<h4 id=\"ButterKnife-bind-this-方法\"><a href=\"#ButterKnife-bind-this-方法\" class=\"headerlink\" title=\"ButterKnife.bind(this)方法\"></a>ButterKnife.bind(this)方法</h4><p><em>ButterKnife.bind(this)</em>这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~</p>\n<p>bind有几个重载方法，但最终调的都是下面这个方法。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg\" alt=\"\"></p>\n<p>参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。</p>\n<p>首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：<em>ForgetActivity$$ViewBinder</em>。</p>\n<p>然后调用ForgetActivity$$ViewBinder的bind方法。</p>\n<p>然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。</p>\n<h4 id=\"ButterKnifeProcessor\"><a href=\"#ButterKnifeProcessor\" class=\"headerlink\" title=\"ButterKnifeProcessor\"></a>ButterKnifeProcessor</h4><p>你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg\" alt=\"\"></p>\n<p>AbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg\" alt=\"\"></p>\n<p>重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。</p>\n<p>第一个最明显的就是Bind注解啦。</p>\n<p>而所有的注解处理，都是在process中执行的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg\" alt=\"\"></p>\n<p>通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。</p>\n<p>JavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。</p>\n<p>这里我们只关注最重要的一句话</p>\n<pre><code>writer.write(bindingClass.brewJava());\n</code></pre><p>ForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。</p>\n<h4 id=\"bindingClass-brewJava方法\"><a href=\"#bindingClass-brewJava方法\" class=\"headerlink\" title=\"bindingClass.brewJava方法\"></a>bindingClass.brewJava方法</h4><p>哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……</p>\n<p>我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……</p>\n<p>既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。</p>\n<p>由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg\" alt=\"\"></p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。</p>\n<p>但这不正是学习的魅力么？</p>\n<p>好了，总结一下。</p>\n<ol>\n<li><p>编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。</p>\n</li>\n<li><p>代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。</p>\n</li>\n<li><p>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~</p>\n</li>\n<li><p>ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：<strong>写一个框架最难的不是技术实现，而是稳定！</strong></p>\n</li>\n<li><p>ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。</p>\n</li>\n</ol>\n<p>APT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。</p>\n<p>后续篇章我将会陆续推出几款以Cake命名的APT框架。</p>\n<p><br></p>\n<p>《Android编译时注解框架-什么是编译时注解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><strong>Android编译时注解框架从入门到项目实践</strong>。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。</p>\n<p>提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。</p>\n<p>但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题…</p>","more":"<p>今天我们要讲的是，不会对性能有任何影响的黑科技：<strong>编译时注解</strong>。也有人叫它<strong>代码生成</strong>，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool</p>\n<p>得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。</p>\n<p>本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。</p>\n<ul>\n<li><p>什么是注解</p>\n</li>\n<li><p>运行时注解的简单使用</p>\n</li>\n<li><p>编译时注解框架ButterKnife源码初探</p>\n</li>\n</ul>\n<h3 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h3><p>注解你一定不会陌生，这就是我们最常见的注解：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg\" alt=\"\"></p>\n<p>首先注解分为三类：</p>\n<ul>\n<li><p>标准 Annotation</p>\n<p>  包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，<br>  不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。</p>\n</li>\n<li><p>元 Annotation</p>\n<p>  @Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。</p>\n</li>\n<li><p>自定义 Annotation</p>\n<p>  根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。</p>\n</li>\n</ul>\n<p>同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：</p>\n<p>这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释</p>\n<pre><code>/**\n * Annotation is only available in the source code.\n */\nSOURCE,\n/**\n * Annotation is available in the source code and in the class file, but not\n * at runtime. This is the default policy.\n */\nCLASS,\n/**\n * Annotation is available in the source code, the class file and is\n * available at runtime.\n */\nRUNTIME\n</code></pre><ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  该注解仅用于源码阶段，就是我们编写的java文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  该注解用于源码、类文件和运行时阶段。</p>\n</li>\n</ul>\n<p>可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。</p>\n<p>RetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。<br>修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。</p>\n<p>那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？</p>\n<p>没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。</p>\n<p>RetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。</p>\n<p><strong>请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环</strong></p>\n<h3 id=\"运行时注解的简单使用\"><a href=\"#运行时注解的简单使用\" class=\"headerlink\" title=\"运行时注解的简单使用\"></a>运行时注解的简单使用</h3><p>运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。</p>\n<p>下面展示一个Demo。其功能是通过注解实现布局文件的设置。</p>\n<p>之前我们是这样设置布局文件的：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_home);\n}\n</code></pre><p>如果使用注解，我们就可以这样设置布局了</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。</p>\n<p>那么这样的注解是怎么实现的呢？很简单，往下看。</p>\n<h4 id=\"创建一个注解\"><a href=\"#创建一个注解\" class=\"headerlink\" title=\"创建一个注解\"></a>创建一个注解</h4><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface ContentView {\n    int value();\n}\n</code></pre><p><strong>第一行:@Retention(RetentionPolicy.RUNTIME)</strong></p>\n<p>@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。</p>\n<p><strong>第二行：@Target({ElementType.TYPE})</strong></p>\n<p>@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。</p>\n<p><strong>第三行：public @interface ContentView</strong></p>\n<p>这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）</p>\n<pre><code>/** Class, interface (including annotation type), or enum declaration */\nTYPE,\n</code></pre><p><strong>第四行：int value();</strong></p>\n<p>返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的</p>\n<pre><code>@ContentView(R.layout.activity_home)\n</code></pre><p>R.layout.activity_home实质是一个int型id，如果这样用就会报错：</p>\n<pre><code>@ContentView(“string”)\n</code></pre><p><strong>关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中</strong></p>\n<h4 id=\"注解解析\"><a href=\"#注解解析\" class=\"headerlink\" title=\"注解解析\"></a>注解解析</h4><p>注解申明好了，但具体是怎么识别这个注解并使用的呢？</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>注解的解析就在BaseActivity中。我们看一下BaseActivity代码</p>\n<pre><code>public class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //注解解析\n    for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n        ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n        if (annotation != null) {\n            try {\n                this.setContentView(annotation.value());\n            } catch (RuntimeException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n    }\n}\n</code></pre><p>第一步：遍历所有的子类</p>\n<p>第二步：找到修饰了注解ContentView的类</p>\n<p>第三步：获取ContentView的属性值。</p>\n<p>第四步：为Activity设置布局。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。</p>\n<p>你可能会觉得<em>setContentView(R.layout.activity_home)</em>和<em>@ContentView(R.layout.activity_home)</em>没什么区别，用了注解反而还增加了性能问题。</p>\n<p>但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。</p>\n<p>因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。</p>\n<h3 id=\"编译时注解框架ButterKnife源码初探\"><a href=\"#编译时注解框架ButterKnife源码初探\" class=\"headerlink\" title=\"编译时注解框架ButterKnife源码初探\"></a>编译时注解框架ButterKnife源码初探</h3><p>ButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg\" alt=\"\"></p>\n<p>你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。</p>\n<p>秘密在这里，编译工程后，打开你的项目app目录下的build目录：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg\" alt=\"\"></p>\n<p>你可以看到一些带有<em>$$ViewBinder</em>后缀的类文件。这个就是ButterKnife生成的代码我们打开它：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg\" alt=\"\"></p>\n<p>上面有一条注释：<br>// Generated code from Butter Knife. Do not modify!</p>\n<p>1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：</p>\n<pre><code>package com.zhaoxuan.wehome.view.activity;\n</code></pre><p>同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：</p>\n<pre><code>//accountEdit是ForgetActivity当中定义的控件\ntarget.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n</code></pre><p>所以你也应该知道了为什么当使用private时会报错了吧？</p>\n<p>2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。</p>\n<pre><code>@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n}\n</code></pre><p>OK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：</p>\n<p>1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。</p>\n<p>2.Finder到底是个什么东西？凭什么它可以找到view。</p>\n<p>不着急不着急，慢慢看。</p>\n<h4 id=\"注解-Bind的定义\"><a href=\"#注解-Bind的定义\" class=\"headerlink\" title=\"注解: @Bind的定义\"></a>注解: @Bind的定义</h4><p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg\" alt=\"\"></p>\n<p>我们可以解读的信息如下：</p>\n<ol>\n<li><p>Bind是编译时注解</p>\n</li>\n<li><p>只能修饰属性</p>\n</li>\n<li><p>属性值是一个int型的数组。</p>\n</li>\n</ol>\n<p>创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。</p>\n<h4 id=\"Finder类\"><a href=\"#Finder类\" class=\"headerlink\" title=\"Finder类\"></a>Finder类</h4><p>通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg\" alt=\"\"></p>\n<p>根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。</p>\n<p>另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： <em>finder.findRequiredView</em> 和 <em>finder.castView</em></p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg\" alt=\"\"></p>\n<p>findRequiredView 方法调用了 findOptionalView 方法</p>\n<p>findOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）</p>\n<p>findView取得view后，又交给了castView做一些容错处理。</p>\n<p>castView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。</p>\n<h4 id=\"ButterKnife-bind-this-方法\"><a href=\"#ButterKnife-bind-this-方法\" class=\"headerlink\" title=\"ButterKnife.bind(this)方法\"></a>ButterKnife.bind(this)方法</h4><p><em>ButterKnife.bind(this)</em>这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~</p>\n<p>bind有几个重载方法，但最终调的都是下面这个方法。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg\" alt=\"\"></p>\n<p>参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。</p>\n<p>首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：<em>ForgetActivity$$ViewBinder</em>。</p>\n<p>然后调用ForgetActivity$$ViewBinder的bind方法。</p>\n<p>然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。</p>\n<h4 id=\"ButterKnifeProcessor\"><a href=\"#ButterKnifeProcessor\" class=\"headerlink\" title=\"ButterKnifeProcessor\"></a>ButterKnifeProcessor</h4><p>你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg\" alt=\"\"></p>\n<p>AbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg\" alt=\"\"></p>\n<p>重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。</p>\n<p>第一个最明显的就是Bind注解啦。</p>\n<p>而所有的注解处理，都是在process中执行的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg\" alt=\"\"></p>\n<p>通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。</p>\n<p>JavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。</p>\n<p>这里我们只关注最重要的一句话</p>\n<pre><code>writer.write(bindingClass.brewJava());\n</code></pre><p>ForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。</p>\n<h4 id=\"bindingClass-brewJava方法\"><a href=\"#bindingClass-brewJava方法\" class=\"headerlink\" title=\"bindingClass.brewJava方法\"></a>bindingClass.brewJava方法</h4><p>哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……</p>\n<p>我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……</p>\n<p>既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。</p>\n<p>由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg\" alt=\"\"></p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。</p>\n<p>但这不正是学习的魅力么？</p>\n<p>好了，总结一下。</p>\n<ol>\n<li><p>编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。</p>\n</li>\n<li><p>代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。</p>\n</li>\n<li><p>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~</p>\n</li>\n<li><p>ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：<strong>写一个框架最难的不是技术实现，而是稳定！</strong></p>\n</li>\n<li><p>ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。</p>\n</li>\n</ol>\n<p>APT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。</p>\n<p>后续篇章我将会陆续推出几款以Cake命名的APT框架。</p>\n<p><br></p>\n<p>《Android编译时注解框架-什么是编译时注解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架6-APT的优缺点与应用","date":"2016-08-26T07:30:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？\n\n但就像我前面提到过的，**APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！** \n\nAPT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~\n\n（**本系列所讲APT均泛指编译时注解+代码生成**，虽然运行时注解也属APT）\n\n<!-- more -->\n\n### APT优点\n\n- 对代码进行标记，在编译时收集信息，并做处理。\n\n- 生成一套独立代码，辅助代码运行\n\n- 生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便\n\n- 更为可靠的自动代码生成\n\n- 自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率\n\n\n### APT缺点\n\n- APT往往容易被误解可以实现代码插入，然而事实是并不可以\n\n- APT可以自动生成代码，但在运行时却需要主动调用\n\n- 与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板\n\n\n### APT容易被你忽视的点\n\n一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。\n\n产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。\n\n事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。\n\n说白了，编译时注解你也完全可以当反射来理解。\n\nAPT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~**一定要放大你的脑洞！！！**\n\n### 应用场景-信息收集与统计\n\n\n注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~\n\n#### 编译时代码检查或统计\n\n统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~\n\n\t//示例代码  类统计\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                \"Annotation class size = \" + size);\n    }\n\n代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？\n\n这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~\n\n（此处有点瞎扯淡了，一般代码检查都不会这么干）\n\n\t\n#### 运行时数据收集与统计\n\n通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。\n\n手写代码容易出错，交给APT来实现便可以将错误率降到最低。\n\n另外还有一个灵感来源于一个你不陌生的类：BuildConfig.\n\n在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。\n\n同理，APT也可以实现这样的功能。\n\n\n### 应用场景-事件代理\n\n此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。\n\n\t//示例代码\n\t@Override\n\tpublic void bind(final Finder finder, final T target, Object source) {\n    \t//定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    \tView view;\n\n    \t//暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    \tview = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n\n    \t//target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    \ttarget.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n    \tview = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n    \ttarget.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n\n    \t//给view设置一个点击事件\n    \tview.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n\t}\n\t\n\n#### ButterKnife扩展\n\nButterKnife绑定View的同时，我们也可以附加一些操作。\n\n一个典型案例就是 前面博客提到的OnceClick\n\n在给View设置监听事件时，添加一些自定操作。\n\n\tview = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time >= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n\n\n#### 其他属性（跨域）初始化\\赋值\n\nButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。\n\n举一个列子：\n\nIntent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。\n\nActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。\n\n### 应用场景-代理执行 or \"代码插入\"\n\n虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。\n\n####代理执行\n\n用注解修饰一系列方法，由APT来代理执行。\n\n此部分参考[CakeRun](https://github.com/lizhaoxuan/CakeRun)\n\n\tpublic class CrashApplication extends Application {\n\t\n\t\t@Override\n    \tpublic void onCreate() {\n        \tsuper.onCreate();\n        \t//初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        \t//某种程度实现了代码插入\n        \tCakeRun.getInstance().applicationInit();\n    \t}\n\t\n\t\t@AppInit(tag = 1, canSkip = true)\n    \tprotected void init1() {\n        \tLog.d(\"TAG\", \"init1()  将引起crash。非关键路径可以跳过\");\n        \tString s = null;\n        \tLog.d(\"TAG\", s);\n    \t}\n\n    \t@AsyncInit(tag = 2, packageName = {\"com.lizhaoxuan.cakerundemo.Lib1\", \"other packageName\"})\n    \tprotected void init2() {\n        \tLog.d(\"TAG\", \"AsyncInit2() 引起Crash ,关键路径不可跳过\");\n        \tLib1.AsyncInit();\n    \t}\n\n    \t@AppInit(tag = 3)\n    \tprotected void init3() {\n        \tLog.d(\"TAG\", \"init3() 未引起crash\");\n    \t}\n\n    \t@AppInit(tag = 4)\n    \tprotected void init4() {\n        \tLog.d(\"TAG\", \"init4() 未引起crash\");\n    \t}\n\t}\n\t\nAPT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。\n\n#### 代码插入AOP\n\n使用APT实现AOP\n\n因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick\n\t \n\t@CrashClick(id = R.id.btn, target = HomeActivity)\n\tpublic void startActivity() {\n  \t\t...\n        this.startActivity(intent);\n    }\n    \n但对于普通方法，可能就需要这样调用\n\n    protected void onCreate(Bundle savedInstanceState) {\n    \n    \t//...\n    \t\n    \t//原本是这样调用方法的\n        startHomeActivity();\n\n        //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n        //就需要这样调用\n        AptClient.doMethod(this,\"startHomeActivity\");\n\n    }\n\n    @DemoTest(method = \"startHomeActivity\")\n    protected void startHomeActivity() {\n\n    }\n\n\nAPT生成代码样式：\n\n\tpublic void doMethod(Object target){\n\t\tint temp;\n\t\tif(//一些逻辑条件){\n\t\t\t//执行前做一些操作，比如记录\n\t\t\ttemp = 2; \n\t\t\t//执行真正的方法\n\t\t\ttarget.startHomeActivity();\n\t\t}else{\n\t\t\t//这个方法有些问题不能执行\n\t\t}\n\t}\n\n\n### 应用场景-反射优化\n\n编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。\n\n#### EventBus优化\n\nEventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。\n\nAPT优化:\n\n- 使用编译时注解标记Event接收方法。\n\n- 通过APT+代码生成，生成对应代理类，并提取所有Event接收方法\n\n- 每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。\n\n\n### 应用场景-让代码返璞归真\n\n实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。\n\n运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。\n\n以ORM数据库框架为例。\n\n细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。\n\nOrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。\n\n而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！\n\n但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。\n\n**那么通过APT，则是一个很好的技术方案：CakeDao**\n\n[https://github.com/lizhaoxuan/CakeDao](https://github.com/lizhaoxuan/CakeDao)\n\n与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\t\n\n\n\n\n\n\n\n\n","source":"_posts/apt_usage_scenario.md","raw":"---\ntitle: Android编译时注解框架6-APT的优缺点与应用\ndate: 2016-08-26 15:30:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？\n\n但就像我前面提到过的，**APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！** \n\nAPT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~\n\n（**本系列所讲APT均泛指编译时注解+代码生成**，虽然运行时注解也属APT）\n\n<!-- more -->\n\n### APT优点\n\n- 对代码进行标记，在编译时收集信息，并做处理。\n\n- 生成一套独立代码，辅助代码运行\n\n- 生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便\n\n- 更为可靠的自动代码生成\n\n- 自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率\n\n\n### APT缺点\n\n- APT往往容易被误解可以实现代码插入，然而事实是并不可以\n\n- APT可以自动生成代码，但在运行时却需要主动调用\n\n- 与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板\n\n\n### APT容易被你忽视的点\n\n一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。\n\n产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。\n\n事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。\n\n说白了，编译时注解你也完全可以当反射来理解。\n\nAPT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~**一定要放大你的脑洞！！！**\n\n### 应用场景-信息收集与统计\n\n\n注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~\n\n#### 编译时代码检查或统计\n\n统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~\n\n\t//示例代码  类统计\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                \"Annotation class size = \" + size);\n    }\n\n代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？\n\n这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~\n\n（此处有点瞎扯淡了，一般代码检查都不会这么干）\n\n\t\n#### 运行时数据收集与统计\n\n通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。\n\n手写代码容易出错，交给APT来实现便可以将错误率降到最低。\n\n另外还有一个灵感来源于一个你不陌生的类：BuildConfig.\n\n在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。\n\n同理，APT也可以实现这样的功能。\n\n\n### 应用场景-事件代理\n\n此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。\n\n\t//示例代码\n\t@Override\n\tpublic void bind(final Finder finder, final T target, Object source) {\n    \t//定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    \tView view;\n\n    \t//暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    \tview = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n\n    \t//target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    \ttarget.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n    \tview = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n    \ttarget.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n\n    \t//给view设置一个点击事件\n    \tview.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n\t}\n\t\n\n#### ButterKnife扩展\n\nButterKnife绑定View的同时，我们也可以附加一些操作。\n\n一个典型案例就是 前面博客提到的OnceClick\n\n在给View设置监听事件时，添加一些自定操作。\n\n\tview = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time >= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n\n\n#### 其他属性（跨域）初始化\\赋值\n\nButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。\n\n举一个列子：\n\nIntent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。\n\nActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。\n\n### 应用场景-代理执行 or \"代码插入\"\n\n虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。\n\n####代理执行\n\n用注解修饰一系列方法，由APT来代理执行。\n\n此部分参考[CakeRun](https://github.com/lizhaoxuan/CakeRun)\n\n\tpublic class CrashApplication extends Application {\n\t\n\t\t@Override\n    \tpublic void onCreate() {\n        \tsuper.onCreate();\n        \t//初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        \t//某种程度实现了代码插入\n        \tCakeRun.getInstance().applicationInit();\n    \t}\n\t\n\t\t@AppInit(tag = 1, canSkip = true)\n    \tprotected void init1() {\n        \tLog.d(\"TAG\", \"init1()  将引起crash。非关键路径可以跳过\");\n        \tString s = null;\n        \tLog.d(\"TAG\", s);\n    \t}\n\n    \t@AsyncInit(tag = 2, packageName = {\"com.lizhaoxuan.cakerundemo.Lib1\", \"other packageName\"})\n    \tprotected void init2() {\n        \tLog.d(\"TAG\", \"AsyncInit2() 引起Crash ,关键路径不可跳过\");\n        \tLib1.AsyncInit();\n    \t}\n\n    \t@AppInit(tag = 3)\n    \tprotected void init3() {\n        \tLog.d(\"TAG\", \"init3() 未引起crash\");\n    \t}\n\n    \t@AppInit(tag = 4)\n    \tprotected void init4() {\n        \tLog.d(\"TAG\", \"init4() 未引起crash\");\n    \t}\n\t}\n\t\nAPT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。\n\n#### 代码插入AOP\n\n使用APT实现AOP\n\n因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick\n\t \n\t@CrashClick(id = R.id.btn, target = HomeActivity)\n\tpublic void startActivity() {\n  \t\t...\n        this.startActivity(intent);\n    }\n    \n但对于普通方法，可能就需要这样调用\n\n    protected void onCreate(Bundle savedInstanceState) {\n    \n    \t//...\n    \t\n    \t//原本是这样调用方法的\n        startHomeActivity();\n\n        //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n        //就需要这样调用\n        AptClient.doMethod(this,\"startHomeActivity\");\n\n    }\n\n    @DemoTest(method = \"startHomeActivity\")\n    protected void startHomeActivity() {\n\n    }\n\n\nAPT生成代码样式：\n\n\tpublic void doMethod(Object target){\n\t\tint temp;\n\t\tif(//一些逻辑条件){\n\t\t\t//执行前做一些操作，比如记录\n\t\t\ttemp = 2; \n\t\t\t//执行真正的方法\n\t\t\ttarget.startHomeActivity();\n\t\t}else{\n\t\t\t//这个方法有些问题不能执行\n\t\t}\n\t}\n\n\n### 应用场景-反射优化\n\n编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。\n\n#### EventBus优化\n\nEventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。\n\nAPT优化:\n\n- 使用编译时注解标记Event接收方法。\n\n- 通过APT+代码生成，生成对应代理类，并提取所有Event接收方法\n\n- 每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。\n\n\n### 应用场景-让代码返璞归真\n\n实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。\n\n运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。\n\n以ORM数据库框架为例。\n\n细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。\n\nOrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。\n\n而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！\n\n但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。\n\n**那么通过APT，则是一个很好的技术方案：CakeDao**\n\n[https://github.com/lizhaoxuan/CakeDao](https://github.com/lizhaoxuan/CakeDao)\n\n与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\t\n\n\n\n\n\n\n\n\n","slug":"apt_usage_scenario","published":1,"updated":"2019-01-02T02:09:31.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspm000uyo9s27p1ngki","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？</p>\n<p>但就像我前面提到过的，<strong>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！</strong> </p>\n<p>APT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~</p>\n<p>（<strong>本系列所讲APT均泛指编译时注解+代码生成</strong>，虽然运行时注解也属APT）</p>\n<a id=\"more\"></a>\n<h3 id=\"APT优点\"><a href=\"#APT优点\" class=\"headerlink\" title=\"APT优点\"></a>APT优点</h3><ul>\n<li><p>对代码进行标记，在编译时收集信息，并做处理。</p>\n</li>\n<li><p>生成一套独立代码，辅助代码运行</p>\n</li>\n<li><p>生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便</p>\n</li>\n<li><p>更为可靠的自动代码生成</p>\n</li>\n<li><p>自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率</p>\n</li>\n</ul>\n<h3 id=\"APT缺点\"><a href=\"#APT缺点\" class=\"headerlink\" title=\"APT缺点\"></a>APT缺点</h3><ul>\n<li><p>APT往往容易被误解可以实现代码插入，然而事实是并不可以</p>\n</li>\n<li><p>APT可以自动生成代码，但在运行时却需要主动调用</p>\n</li>\n<li><p>与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板</p>\n</li>\n</ul>\n<h3 id=\"APT容易被你忽视的点\"><a href=\"#APT容易被你忽视的点\" class=\"headerlink\" title=\"APT容易被你忽视的点\"></a>APT容易被你忽视的点</h3><p>一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。</p>\n<p>产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。</p>\n<p>事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。</p>\n<p>说白了，编译时注解你也完全可以当反射来理解。</p>\n<p>APT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~<strong>一定要放大你的脑洞！！！</strong></p>\n<h3 id=\"应用场景-信息收集与统计\"><a href=\"#应用场景-信息收集与统计\" class=\"headerlink\" title=\"应用场景-信息收集与统计\"></a>应用场景-信息收集与统计</h3><p>注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~</p>\n<h4 id=\"编译时代码检查或统计\"><a href=\"#编译时代码检查或统计\" class=\"headerlink\" title=\"编译时代码检查或统计\"></a>编译时代码检查或统计</h4><p>统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~</p>\n<pre><code>//示例代码  类统计\n@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n    messager.printMessage(Diagnostic.Kind.NOTE,\n            &quot;Annotation class size = &quot; + size);\n}\n</code></pre><p>代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？</p>\n<p>这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~</p>\n<p>（此处有点瞎扯淡了，一般代码检查都不会这么干）</p>\n<h4 id=\"运行时数据收集与统计\"><a href=\"#运行时数据收集与统计\" class=\"headerlink\" title=\"运行时数据收集与统计\"></a>运行时数据收集与统计</h4><p>通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。</p>\n<p>手写代码容易出错，交给APT来实现便可以将错误率降到最低。</p>\n<p>另外还有一个灵感来源于一个你不陌生的类：BuildConfig.</p>\n<p>在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。</p>\n<p>同理，APT也可以实现这样的功能。</p>\n<h3 id=\"应用场景-事件代理\"><a href=\"#应用场景-事件代理\" class=\"headerlink\" title=\"应用场景-事件代理\"></a>应用场景-事件代理</h3><p>此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。</p>\n<pre><code>//示例代码\n@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n        new butterknife.internal.DebouncingOnClickListener() {\n            @Override\n            public void doClick(android.view.View p0) {\n\n                //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n               target.forgetOnClick();\n\n            }\n        });\n}\n</code></pre><h4 id=\"ButterKnife扩展\"><a href=\"#ButterKnife扩展\" class=\"headerlink\" title=\"ButterKnife扩展\"></a>ButterKnife扩展</h4><p>ButterKnife绑定View的同时，我们也可以附加一些操作。</p>\n<p>一个典型案例就是 前面博客提到的OnceClick</p>\n<p>在给View设置监听事件时，添加一些自定操作。</p>\n<pre><code>view = finder.findViewById(source, 2131492945);\n    if (view != null) {\n        view.setOnClickListener(new View.OnClickListener() {\n            long time = 0L;\n            @Override\n            public void onClick(View v) {\n                long temp = System.currentTimeMillis();\n                if (temp - time &gt;= intervalTime) {\n                    time = temp;\n                    target.once();\n                }\n            }\n        });\n    }\n</code></pre><h4 id=\"其他属性（跨域）初始化-赋值\"><a href=\"#其他属性（跨域）初始化-赋值\" class=\"headerlink\" title=\"其他属性（跨域）初始化\\赋值\"></a>其他属性（跨域）初始化\\赋值</h4><p>ButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。</p>\n<p>举一个列子：</p>\n<p>Intent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。</p>\n<p>ActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。</p>\n<h3 id=\"应用场景-代理执行-or-“代码插入”\"><a href=\"#应用场景-代理执行-or-“代码插入”\" class=\"headerlink\" title=\"应用场景-代理执行 or “代码插入”\"></a>应用场景-代理执行 or “代码插入”</h3><p>虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。</p>\n<p>####代理执行</p>\n<p>用注解修饰一系列方法，由APT来代理执行。</p>\n<p>此部分参考<a href=\"https://github.com/lizhaoxuan/CakeRun\" target=\"_blank\" rel=\"noopener\">CakeRun</a></p>\n<pre><code>public class CrashApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        //某种程度实现了代码插入\n        CakeRun.getInstance().applicationInit();\n    }\n\n    @AppInit(tag = 1, canSkip = true)\n    protected void init1() {\n        Log.d(&quot;TAG&quot;, &quot;init1()  将引起crash。非关键路径可以跳过&quot;);\n        String s = null;\n        Log.d(&quot;TAG&quot;, s);\n    }\n\n    @AsyncInit(tag = 2, packageName = {&quot;com.lizhaoxuan.cakerundemo.Lib1&quot;, &quot;other packageName&quot;})\n    protected void init2() {\n        Log.d(&quot;TAG&quot;, &quot;AsyncInit2() 引起Crash ,关键路径不可跳过&quot;);\n        Lib1.AsyncInit();\n    }\n\n    @AppInit(tag = 3)\n    protected void init3() {\n        Log.d(&quot;TAG&quot;, &quot;init3() 未引起crash&quot;);\n    }\n\n    @AppInit(tag = 4)\n    protected void init4() {\n        Log.d(&quot;TAG&quot;, &quot;init4() 未引起crash&quot;);\n    }\n}\n</code></pre><p>APT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。</p>\n<h4 id=\"代码插入AOP\"><a href=\"#代码插入AOP\" class=\"headerlink\" title=\"代码插入AOP\"></a>代码插入AOP</h4><p>使用APT实现AOP</p>\n<p>因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick</p>\n<pre><code>@CrashClick(id = R.id.btn, target = HomeActivity)\npublic void startActivity() {\n      ...\n    this.startActivity(intent);\n}\n</code></pre><p>但对于普通方法，可能就需要这样调用</p>\n<pre><code>protected void onCreate(Bundle savedInstanceState) {\n\n    //...\n\n    //原本是这样调用方法的\n    startHomeActivity();\n\n    //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n    //就需要这样调用\n    AptClient.doMethod(this,&quot;startHomeActivity&quot;);\n\n}\n\n@DemoTest(method = &quot;startHomeActivity&quot;)\nprotected void startHomeActivity() {\n\n}\n</code></pre><p>APT生成代码样式：</p>\n<pre><code>public void doMethod(Object target){\n    int temp;\n    if(//一些逻辑条件){\n        //执行前做一些操作，比如记录\n        temp = 2; \n        //执行真正的方法\n        target.startHomeActivity();\n    }else{\n        //这个方法有些问题不能执行\n    }\n}\n</code></pre><h3 id=\"应用场景-反射优化\"><a href=\"#应用场景-反射优化\" class=\"headerlink\" title=\"应用场景-反射优化\"></a>应用场景-反射优化</h3><p>编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。</p>\n<h4 id=\"EventBus优化\"><a href=\"#EventBus优化\" class=\"headerlink\" title=\"EventBus优化\"></a>EventBus优化</h4><p>EventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。</p>\n<p>APT优化:</p>\n<ul>\n<li><p>使用编译时注解标记Event接收方法。</p>\n</li>\n<li><p>通过APT+代码生成，生成对应代理类，并提取所有Event接收方法</p>\n</li>\n<li><p>每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。</p>\n</li>\n</ul>\n<h3 id=\"应用场景-让代码返璞归真\"><a href=\"#应用场景-让代码返璞归真\" class=\"headerlink\" title=\"应用场景-让代码返璞归真\"></a>应用场景-让代码返璞归真</h3><p>实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。</p>\n<p>运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。</p>\n<p>以ORM数据库框架为例。</p>\n<p>细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。</p>\n<p>OrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。</p>\n<p>而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！</p>\n<p>但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。</p>\n<p><strong>那么通过APT，则是一个很好的技术方案：CakeDao</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/CakeDao\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/CakeDao</a></p>\n<p>与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？</p>\n<p>但就像我前面提到过的，<strong>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！</strong> </p>\n<p>APT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~</p>\n<p>（<strong>本系列所讲APT均泛指编译时注解+代码生成</strong>，虽然运行时注解也属APT）</p>","more":"<h3 id=\"APT优点\"><a href=\"#APT优点\" class=\"headerlink\" title=\"APT优点\"></a>APT优点</h3><ul>\n<li><p>对代码进行标记，在编译时收集信息，并做处理。</p>\n</li>\n<li><p>生成一套独立代码，辅助代码运行</p>\n</li>\n<li><p>生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便</p>\n</li>\n<li><p>更为可靠的自动代码生成</p>\n</li>\n<li><p>自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率</p>\n</li>\n</ul>\n<h3 id=\"APT缺点\"><a href=\"#APT缺点\" class=\"headerlink\" title=\"APT缺点\"></a>APT缺点</h3><ul>\n<li><p>APT往往容易被误解可以实现代码插入，然而事实是并不可以</p>\n</li>\n<li><p>APT可以自动生成代码，但在运行时却需要主动调用</p>\n</li>\n<li><p>与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板</p>\n</li>\n</ul>\n<h3 id=\"APT容易被你忽视的点\"><a href=\"#APT容易被你忽视的点\" class=\"headerlink\" title=\"APT容易被你忽视的点\"></a>APT容易被你忽视的点</h3><p>一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。</p>\n<p>产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。</p>\n<p>事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。</p>\n<p>说白了，编译时注解你也完全可以当反射来理解。</p>\n<p>APT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~<strong>一定要放大你的脑洞！！！</strong></p>\n<h3 id=\"应用场景-信息收集与统计\"><a href=\"#应用场景-信息收集与统计\" class=\"headerlink\" title=\"应用场景-信息收集与统计\"></a>应用场景-信息收集与统计</h3><p>注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~</p>\n<h4 id=\"编译时代码检查或统计\"><a href=\"#编译时代码检查或统计\" class=\"headerlink\" title=\"编译时代码检查或统计\"></a>编译时代码检查或统计</h4><p>统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~</p>\n<pre><code>//示例代码  类统计\n@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n    messager.printMessage(Diagnostic.Kind.NOTE,\n            &quot;Annotation class size = &quot; + size);\n}\n</code></pre><p>代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？</p>\n<p>这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~</p>\n<p>（此处有点瞎扯淡了，一般代码检查都不会这么干）</p>\n<h4 id=\"运行时数据收集与统计\"><a href=\"#运行时数据收集与统计\" class=\"headerlink\" title=\"运行时数据收集与统计\"></a>运行时数据收集与统计</h4><p>通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。</p>\n<p>手写代码容易出错，交给APT来实现便可以将错误率降到最低。</p>\n<p>另外还有一个灵感来源于一个你不陌生的类：BuildConfig.</p>\n<p>在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。</p>\n<p>同理，APT也可以实现这样的功能。</p>\n<h3 id=\"应用场景-事件代理\"><a href=\"#应用场景-事件代理\" class=\"headerlink\" title=\"应用场景-事件代理\"></a>应用场景-事件代理</h3><p>此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。</p>\n<pre><code>//示例代码\n@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n        new butterknife.internal.DebouncingOnClickListener() {\n            @Override\n            public void doClick(android.view.View p0) {\n\n                //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n               target.forgetOnClick();\n\n            }\n        });\n}\n</code></pre><h4 id=\"ButterKnife扩展\"><a href=\"#ButterKnife扩展\" class=\"headerlink\" title=\"ButterKnife扩展\"></a>ButterKnife扩展</h4><p>ButterKnife绑定View的同时，我们也可以附加一些操作。</p>\n<p>一个典型案例就是 前面博客提到的OnceClick</p>\n<p>在给View设置监听事件时，添加一些自定操作。</p>\n<pre><code>view = finder.findViewById(source, 2131492945);\n    if (view != null) {\n        view.setOnClickListener(new View.OnClickListener() {\n            long time = 0L;\n            @Override\n            public void onClick(View v) {\n                long temp = System.currentTimeMillis();\n                if (temp - time &gt;= intervalTime) {\n                    time = temp;\n                    target.once();\n                }\n            }\n        });\n    }\n</code></pre><h4 id=\"其他属性（跨域）初始化-赋值\"><a href=\"#其他属性（跨域）初始化-赋值\" class=\"headerlink\" title=\"其他属性（跨域）初始化\\赋值\"></a>其他属性（跨域）初始化\\赋值</h4><p>ButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。</p>\n<p>举一个列子：</p>\n<p>Intent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。</p>\n<p>ActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。</p>\n<h3 id=\"应用场景-代理执行-or-“代码插入”\"><a href=\"#应用场景-代理执行-or-“代码插入”\" class=\"headerlink\" title=\"应用场景-代理执行 or “代码插入”\"></a>应用场景-代理执行 or “代码插入”</h3><p>虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。</p>\n<p>####代理执行</p>\n<p>用注解修饰一系列方法，由APT来代理执行。</p>\n<p>此部分参考<a href=\"https://github.com/lizhaoxuan/CakeRun\" target=\"_blank\" rel=\"noopener\">CakeRun</a></p>\n<pre><code>public class CrashApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        //某种程度实现了代码插入\n        CakeRun.getInstance().applicationInit();\n    }\n\n    @AppInit(tag = 1, canSkip = true)\n    protected void init1() {\n        Log.d(&quot;TAG&quot;, &quot;init1()  将引起crash。非关键路径可以跳过&quot;);\n        String s = null;\n        Log.d(&quot;TAG&quot;, s);\n    }\n\n    @AsyncInit(tag = 2, packageName = {&quot;com.lizhaoxuan.cakerundemo.Lib1&quot;, &quot;other packageName&quot;})\n    protected void init2() {\n        Log.d(&quot;TAG&quot;, &quot;AsyncInit2() 引起Crash ,关键路径不可跳过&quot;);\n        Lib1.AsyncInit();\n    }\n\n    @AppInit(tag = 3)\n    protected void init3() {\n        Log.d(&quot;TAG&quot;, &quot;init3() 未引起crash&quot;);\n    }\n\n    @AppInit(tag = 4)\n    protected void init4() {\n        Log.d(&quot;TAG&quot;, &quot;init4() 未引起crash&quot;);\n    }\n}\n</code></pre><p>APT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。</p>\n<h4 id=\"代码插入AOP\"><a href=\"#代码插入AOP\" class=\"headerlink\" title=\"代码插入AOP\"></a>代码插入AOP</h4><p>使用APT实现AOP</p>\n<p>因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick</p>\n<pre><code>@CrashClick(id = R.id.btn, target = HomeActivity)\npublic void startActivity() {\n      ...\n    this.startActivity(intent);\n}\n</code></pre><p>但对于普通方法，可能就需要这样调用</p>\n<pre><code>protected void onCreate(Bundle savedInstanceState) {\n\n    //...\n\n    //原本是这样调用方法的\n    startHomeActivity();\n\n    //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n    //就需要这样调用\n    AptClient.doMethod(this,&quot;startHomeActivity&quot;);\n\n}\n\n@DemoTest(method = &quot;startHomeActivity&quot;)\nprotected void startHomeActivity() {\n\n}\n</code></pre><p>APT生成代码样式：</p>\n<pre><code>public void doMethod(Object target){\n    int temp;\n    if(//一些逻辑条件){\n        //执行前做一些操作，比如记录\n        temp = 2; \n        //执行真正的方法\n        target.startHomeActivity();\n    }else{\n        //这个方法有些问题不能执行\n    }\n}\n</code></pre><h3 id=\"应用场景-反射优化\"><a href=\"#应用场景-反射优化\" class=\"headerlink\" title=\"应用场景-反射优化\"></a>应用场景-反射优化</h3><p>编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。</p>\n<h4 id=\"EventBus优化\"><a href=\"#EventBus优化\" class=\"headerlink\" title=\"EventBus优化\"></a>EventBus优化</h4><p>EventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。</p>\n<p>APT优化:</p>\n<ul>\n<li><p>使用编译时注解标记Event接收方法。</p>\n</li>\n<li><p>通过APT+代码生成，生成对应代理类，并提取所有Event接收方法</p>\n</li>\n<li><p>每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。</p>\n</li>\n</ul>\n<h3 id=\"应用场景-让代码返璞归真\"><a href=\"#应用场景-让代码返璞归真\" class=\"headerlink\" title=\"应用场景-让代码返璞归真\"></a>应用场景-让代码返璞归真</h3><p>实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。</p>\n<p>运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。</p>\n<p>以ORM数据库框架为例。</p>\n<p>细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。</p>\n<p>OrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。</p>\n<p>而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！</p>\n<p>但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。</p>\n<p><strong>那么通过APT，则是一个很好的技术方案：CakeDao</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/CakeDao\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/CakeDao</a></p>\n<p>与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。</p>"},{"title":"小微团队怎么玩转App自动化测试","date":"2017-03-21T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n\n## 前言\n\n这篇博客，我会站在小微团队的角度，介绍一下我对App自动化测试的一些看法。在帮助你降低对App自动化测试的期望的同时说服你开始实践App自动化测试。\n\n<!-- more -->\n\nApp自动化测试一直是小微团队很少会去涉足的领域，在互联网快速迭代这个大场景下，随着业务发展，回归压力逐渐增大。相信每次因为回归覆盖不足而导致线上事故，懊恼郁闷到要砸桌子的绝对不止我一个。\n\n一般情况小微团队的测试包括回归测试都是人工进行的，一些偏离主流程却又比较关键的业务往往是人工回归测试容易遗漏的。人力有穷尽，这个时候自动化测试这个念头就从你的脑袋里冒出来了，然后就是去研究嘛。但可能最终也就止步于研究了。不谈自动化框架的搭建，种种细分的边界case,一个必然很繁琐的东西想一想就更繁琐了。如果你是App开发，本来业务开发上的人手就不是很充足，再去开发自动化脚本，有心无力！如果你是测试，每个迭代的业务需求测试就填满了你的排期，更何况承担的可不只是App测试任务。作为小微团队，自动化我们也想，但我们没有资源……\n\n\n首先我们要明白App自动化测试并没有你预想中的那么强大，但如果你像我一样面临着回归测试痛点，它绝对可以满足你的需求。没有那么强大，所以也没有你预想中的那么复杂，同时它的参与者也绝不只应限制在Tester或Developer上，所以在资源上你可以有更灵活的调配。当然，自动化测试是一个长期的过程，它的未来，也绝不仅是回归……\n\n最后我会为你安利一款偏冷的自动化测试工具：Calabash。并奉上Calabash入门教程博客和一点我的使用心得。介绍Calabash，是因为Calabash的特性在我个人看来更为适合资源紧缺的小微团队。\n\n## 大话App自动化测试\n\n仅代表个人观点，见识还浅，欢迎多多打脸。\n\n### 现状\n\n先说点大家都知道的。以Android为例，从2010年开始，Android开发环境以及其迅猛的态势发展到今天，几近趋于成熟，开发者的目光早已不在局限于这单一的开发平台，开始寻求Android，iOS在开发上的统一：ReactNactive,WEEX,H5……\n\n开发环境已经成熟，但移动客户端的测试环境却有些滞后。这中间的几座大山是很多团队正在面对且驻足的：\n\n1.App测试不像服务端测试通常只需对数据本身进行验证即可，App涉及到界面展示及交互，自动化识别难度大。\n2.互联网企业一直都在追寻快速迭代，且App直接对接用户，App的界面与逻辑变更更是家常便饭，编写自动化测试脚本的稳定性很差，可能设计对界面的一次改动，之前与这个页面挂钩的所有脚本就都废掉了。\n3.Android iOS 双平台,web页面。多平台的情况下想要依靠一套代码进行自动化测试几乎是不可能的。再考虑需要经常变更，你懂得。\n4.比起人工来说，自动化测试可能需要为种种边界case编写很多的脚本。同比人工测试，可能需要的只是事先设计几个场景，其他的异常边界case通过测试中人为观察就好了。自动化测试成本倍增！\n\n所以往往一个完善的移动自动化测试环境需要一个庞大的测试团队支撑，但一个庞大的测试团队只有大公司才能负担的起。移动的自动化测试，一直都在被中小型的创业公司所忽略。小型公司开发自测了事，中型公司依靠测试人员人工操作进行验证。\n\n自动化测试真的对于小微团队紧闭大门吗？\n\n### Just do it\n\n上面说的这些现状只能说是难题，也许现在讨论解决这些问题还早了些。我觉得你有些东西还没确定清楚，要不然先跟着我的思路走一走？等下面一些事情都想明白了，也许这些问题能避也就避过了，需要硬上的，也有足够心理准备了。\n\n#### 1.设定阶段计划试错\n其实让小微团队面对自动化测试左右徘徊最大的一个问题就是：投入产出比！\n很难去预估实行自动化测试后，在页面频繁变更与脚本的开发和维护之间，测试或开发人员会不会陷入泥潭。\n\n但纸上谈兵永远也不会有结果，其他大公司的借鉴意义也不是很强，因为这涉及到团队、资源分配、业务变更频度、测试工具、脚本开发的解耦程度等等。不过自动化测试是一个必然的趋势，所以行动是最首要的！\n\n你的团队目前到底适不适合，只有试了才知道。不妨先设定几个阶段，然后用第一阶段试错：\n\n**阶段1**：抽出一个人一个迭代的资源完成主流程业务的自动化测试case，试运行两到三个迭代，并在这期间增加主流程异常case。利用这三个迭代来评估后续发展可行性！\n**阶段2-（阶段1成功度过）**：如果你认为阶段1的状态还不错，那么在维护阶段1成果的基础上从剩余业务场景中按照业务关键程度、变更频率来选取一个新的业务，以一个人一个迭代一个业务的节奏编写自动化测试case！\n**阶段2-（阶段1过度失败）**：当然，经过三个迭代的评估，随着异常case增多，同步维护难度越来越大，你可能认为实行自动化测试的成本过大，但也不要轻易放弃这三个迭代的成果。请先利用编程思维检查所有的测试脚本，是否有抽取相似代码，封装特定View操作，抽离与业务无关指令的可能。同时考虑利用全组资源就此维护这套主流程自动化case。直到将来资源充足或找到更好的替代方案后进行阶段3或重新阶段1。\n**阶段3**：大概在5~8个迭代后，你成功撑过了阶段2，说明你的自动化测试环境已经步入正轨，那么这个时候可以按照团队资源情况适当加快自动化case覆盖率！\n\n利用一人一个迭代的资源进行试错，相信是你可以接受的一个损失。当然，先不要急着做，你也许只是决定了要进行自动化测试，但还是要定一些详细的计划和一些思想、实际行动上的准备！\n\n\n#### 2.确定明确且简单的目标\n\n有了大的计划，还要明确具体的需求，可选的需求大概有这么些：\n\n**1.黑盒测试还是白盒测试**\n虽然是UI自动化测试，但也可以分为黑盒或白盒，这个取决你想要的测试精密度，也就是在这个时候，可以初步确定要使用什么自动化测试工具。比如通常我们为了可以双平台会选择Appium这种可以跨平台的测试工具，但假如你有很高的测试要求，以Android为例，建议你使用Android官方推荐的测试框架：Espresso，直接在Android工程项目中写Test。\n这样说出来好像谁都明白，但如果你不能在前期就明确你的需求，可能会在后期带来很大的困扰！选择Appium，因为是黑盒，遇到某些特殊的场景或需求，导致个别case无法测试。或者选择了Espresso，但后来发现其实并没有那么精密的测试需求，导致后期无法跨平台或者认为Espresso编写成本过高，还很难移交给测试团队。\n\n**2.前端UI还是整体业务**\n举个例子，抢单并且进行配送这个场景。发现一个订单并点击抢单，然后进行取餐，最后完成配送这一套只能用肉眼观察到的UI层操作，我们暂定为这是前端UI逻辑。但在这一系列操作背后订单状态流转引起其他数据变动，比如：钱包数据变更，活动奖励数据变更，欺诈单判定等等这个范围，就属于整体业务范畴了。\n而我们需要现在确定的，就是你想要达到的测试期望是UI测试，还是整体业务测试。这直接决定了你测试脚本的复杂度。而我的建议是仅测UI逻辑，也是我想让你降低期望一个点。\n\n先确定一个明确且简单的目标，然后一头扎进去。如果想的多了，困难也就多了，最后可能也就只是想想了，这就是下面紧接着要说的点：**降低期望**！\n\n#### 3.降低期望\n在人工（对着手机点点点）测试的环境下，我们通常都是通过操作App进行各种case验证，只要操作app验证通过了那基本可以确定前后端没什么问题了。但这个前提是人工验证是人脑加肉眼，它会有更准确的主观判断。\n涉及到前后端交互会增加极大的复杂性，你的测试case不会无限多无限精细，但作为人脑你可以在有限的case执行中发现更多不符合常理的bug：文字不合理的折行，不准确的数值显示，按钮颜色不对，Toast展示数量有误等等等。自动化测试会死板的跟着你写的脚本走，你能保证你的case覆盖到了所有了吗？\n\n这也是谈到自动化测试，好多人都会抛出的一个疑问，那么多异常case怎么写啊，想想都累，考虑一下投入产出比要不还是人工测试吧。\n\n首先要明确的一点，前后端自动化测试一定要分开，一套解决不了问题，这样在前端测试中可以忽略很多的case。\n另外自动化测试是一个与项目成长一样的长期过程，自动化完全代替人工依然还需要走一段时间，你不要想着一步到位。\n依然还是会有很多的case要写对吧？资源不够我们可以先跑通主流程再说，跑通主流程也就意味着脚本依赖（环境搭建，view定位）已经较为成熟了，其他异常case脚本对着主流程脚本修改即可，这个我们慢慢来嘛，而且这个时候你就可以放开给别的开发或测试让他们照猫画虎了。这也就是我们上面说的**阶段1**。\n\n如果这些问题不能想通，你会发现在App自动化测试条件有限的情况下，并不能实现你想要的结果，从而迫于压力而放弃了。**说服自己降低期望**！\n\n- 降低期望，先以回归为目标\n- 降低期望，前后端自动化测试都要有，一套解决不了问题\n- 降低期望，客户端自动化测试限制依然很多，人工测试验证不能全部丢下\n- 降低期望，一口吃不成个胖子，自动化测试也是需要慢慢迭代完善的，先跑通再关心验证异常case。快速迭代，逐步完善\n\n#### 4.术业有专攻\n\n也许你的团队里是开发或者测试中的某一方无法承受压力，从而开始探索App自动化测试。\n开发去做自动化测试的优点在于因为有更丰富的开发经验，测试环境的搭建更为熟练，且因为是自己写的代码，会更了解风险点在哪里，能写出有针对性的case。测试去做自动化测试的优点在于发现更多的边界场景，写出更全面的测试case。\n\n在自动化测试上，开发和测试各具不同的优势，但同时这也是对方的劣势。\n\n测试case一定要越全面越好，而且自动化测试本身就是一个工程项目，在写脚本时，如果更多的考虑一些编程思想，合理的耦合和解耦，将会让之后的脚本编写更便捷。\n所以，非常不建议自动化测试完全单独交给测试人员或开发人员来负责，最好是一种紧密合作的关系。**同时也是应对资源不足的一个解决之道**。虽是测试，但有开发的加入，会让测试工程朝着更优的方向发展。\n\n#### 5.一个巴掌拍不响\n\n首先再次明确我的一个观点：在没有足够的资源的情况下，移动客户端自动化测试，主要针对的应该是回归测试。\n\n自动化测试相比起人工测试，是非常死板的，那么就需要非常“死板”的数据支持.如果是App开发（就像我）去做自动化测试这件事，难道所有数据我都要mock一遍吗？虽说前后端自动化应该分开，前面也说了应该只关心前端逻辑。但一定还是要在真实的服务环境（测试环境，非生产环境）进行测试。\nmock数据过于死板，很多case可能就无法验证了，比如注册场景，要验证注册过的账号无法再注册时的异常提示，mock数据显然较难兼顾正常注册和异常注册两种。而且在真实环境中测试，万一测出来一个后端bug不挺好么。\n而且，手机淘宝这样完全2C的应用直接在生产环境测试好像没什么太大问题，但像蜂鸟配送这样半2C的应用来说就比较尴尬，直接去抢线上单明显不可能，那么在测试环境这个订单谁来发怎么发呢？\n\n所以这个时候你就不能自己单干了，去找测试同学，看能不能搞一个配合自动化测试的测试环境，拿抢单来说，我希望这个环境上永远有好多单让我抢。我就是抢单的app，没单我还玩什么。\n\n如果测试同学搞不定，那么就去拉后端的同学啦，我相信为了项目越来越好，他们是不会拒绝你的。\n\n自动化测试，不仅是自动化测试工具就够了，同样还需要测试环境的支持。\n\n\n### 小结\n\n其实说了这么多，就是想要你降低期望，并付诸行动。\nApp的自动化识别和多平台自然会有大批的自动化工具帮你实现，而学会降低期望的同时也会降低脚本开发和维护的难度。\n\n难道你还在纠结细分case太多的问题？先放一放又如何？反正你都裸奔这么久了，穿裤子不也要先穿个裤衩才行么，裤子慢慢来！\n或者你依然徘徊在投入产出比的问题上？买衣服不也要先试穿才知道码号的吗？\n\nOK，下面我们聊聊这个裤衩，和怎么穿这个裤衩！\n\n## 测试工具\n\n做好了思想工作，具体实现还是需要选择一个具体的测试工具，工具没有好坏，只有适不适合。\nCalabash是我个人建议小微团队使用的测试工具，因为其兼具门槛低、跨平台、脚本维护容易的特性，而这正是小微团队最急需的。\n且其BDD（行为驱动开发）的思想虽然有点乌托邦，但从远瞻的角度来看，实现测试脚本先于程序开发编写的这种先进项目管理可能性也大于其他工具，让测试不仅仅是测试！\n\n下面我会对Calabash的特性做一个简单介绍，详述其优缺点，你可以根据自身团队经验进行选择是否使用，如果喜欢，文末会附上Calabash由浅入深的入门教程，加之更详细的特性介绍和我自己的使用建议。\n\n### Calabash\n谈Calabash前，先要交代清楚Calabash是啥。\n\nCalabash的核心是Cucumber，Cucumber是一个能够用自然语言编写实例的协作工具，其核心思想是行为驱动开发（BDD），回归测试是其自然而然的副带结果。你可以简单的理解为Calabash-android 或 Calabash-iOS是在Cucumber上进行了一次扩展，从而可以对Android或iOS进行自动化测试。\n\n在解释一下BDD，我从网络摘了一段介绍：*你可以在Cucumber中编写用户场景，让它表现出业务规则而不仅仅是UI功能。这样你就能够让业务分析师加入这个过程，在编码工作开始前编写场景。程序员们就能够按照这个清晰的规范进行编码工作了。这种方式就是行为驱动开发（BDD）。*\n\nOK，关于BDD我们就此打住，毕竟还是很未来的事情，下面我们聊点实在的。\n\nCalabash与appium，Espresso类似，都是通过脚本去操作界面，作出点击、滑动等操作，同时可以对界面的上UI组件进行一定识别。run起来就是那么回事，模拟控制手机。主要是脚本的编写上不同，我们来看一下Calabash的脚本，**相信我，爱上它，就从看到它脚本开始**：\n\n\n```\nFeature: Login feature\n\n  Scenario: 登录测试用例\n\n  \tWhen I press view with id \"account_edit\"\n  \tThen I enter \"15104053650流量\" into input field number 1\n\n  \tThen I press \"发送验证码\"\n  \tThen I wait for 5 seconds\n\n  \tWhen I press view with id \"verifying_code_edit\"\n  \tThen I enter \"306423\" into input field number 2\n\n  \tThen I wait for 5 seconds\n\n  \tThen I press view with id \"login_login\"\n\n```\n\n\n我觉得我不需要再解释这脚本的含义了，这就是大白话！！\n**Calabash最大的魅力在于，将难以理解的编程语言转换为谁都可以看得懂得自然语言。从而降低学习门槛和维护难度。**\n**特点1：极高的可读性**，可读性越高的测试脚本，意义越大。当测试脚本的编写先于或与开发同步时，测试脚本也可以成为开发过程中的设计文档及参考手册。\n\n在可读性非常高的基础上，其编写难度也变得非常的低。**特点2：语法简单易懂，谁都能写**。\n\n同时可喜的是，这个代码同时支持Android 和iOS，web也有一定的支持！RN就更不用说了，跑起来的RN就是原生代码！WEEX还要再考察考察~在合理的解耦与耦合的情况下，Android 和iOS只需提供一套各自的View定位封装即可共用一套场景case脚本。**特点3：支持多种平台，代码复用性强**。\n\n\n一段使用自然语言编写的脚本，其底层当然要费一番功夫。上面我们看到一段测试用例是使用Calabash预定义的Steps写的一段测试用例。\n\n而这些大白话一样的Steps的实质是这样的：\n\n```\nThen /^I press \"([^\\\"]*)\"$/ do |identifier|  # ---方法名\n  tap_when_element_exists(\"* marked:'#{identifier}'\")  # ---方法体\nend\n```\n\n很傻瓜的解释一下：你可以很简单的认为上面这一段是一个函数、一个方法。\n第一行就是一个自然语言夹杂着正则符号的方法名，方法名随便起。第二行是用Ruby实现的方法体。\n不要被这段代码吓到，在大部分时候，你都不需要接触到这些大白话的具体实现（Ruby语言），而是直接用大白话写小作文就好了。\n预定义的Steps肯定不能满足我们的需求，所以Calabash灵活的支持**不同程度自定义steps**，样子大概就像上面那样，你可以简单理解为Calabash支持不同程度的，代码到自然语言的转换。最大程度的满足业务需求。\n正是这种灵活的转换方式，让我们有了更多的想象：\n\n**特点4：Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的脚本开发人员** \n再简单解释一下：先让一部分(实际情况可能是一个)人学起来，写出一个个大白话似的Steps。再接纳另一部分人进来，比如其他的开发或测试人员，甚至是产品经理！直接用这些大白话写测试case，熟悉了之后有想法的话再去学自定义Steps。甚至产品都不需要学自定义Steps,给开发提需求好了，当你有一个非常丰富的Steps库的时候，你所烦的无穷无尽的边界case，不过就是全民小作文~\n\n**特点5：自定义语法糖**\nSteps的方法名定义完全自由，在带来可读性提高的同时也降低了Steps的记忆和脚本编写速度。但这其实完全依赖于你定义的规范，你完全可以自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。\n\n还有哦，如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？\n\n**特点6：维护简单，我不知道小作文维护起来有什么难的~**\n\n**特点7：case也有设计感，不在那么枯燥**\n在加一个最起码我觉得很兴奋的特点，考虑复用的话，自定义的Steps就要考虑与业务的解耦问题了，有的要解耦有的却要耦合一点。而且如果为了最小程度修改代码从而保证Android iOS在代码上通用，Android和iOS的开发上就会有更多的交流，测试脚本的编写也会有更通用的设计。这里面就有设计的快感了。\n\n**特点8：除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook**\n\n**特点9：丰富的元素定位辅助方法。**\nApp自动化测试一个普遍的痛点就是元素定位，Calabash有非常多的元素定位辅助方法，且都较为简单且无脑。 \n\n最后我们在看一个从网上摘下来的一段Calabash脚本：\n\n```\nFeature： 登陆\n\n　　Scenario： 输入正确的用户名密码能够正常登陆\n\n　　When 打开登陆页面\n　　And    输入用户名XXX输入密码XXX\n　　And   点击登陆\n　　Then  验证登陆成功\n\n```\n\n完全纯中文的脚本编写有木有？是不看起来屌屌的~恩，虽然博主自身并不建议这样纯中文的step定义，我们就看看，你只要知道Calabash很强大就行了。\n\n\n最后我们总结一下Calabash的大方向的优点：\n\n- 极高的可读性\n- 语法简单易懂，学习门槛低\n- 一种语言支持多种平台，代码复用性强\n- Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的开发\n- 自定义语法糖\n- 小作文维护简单\n- case也有设计感\n- 除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook\n- 非常多的元素定位辅助方法\n- 对代码无侵入性，纯黑盒测试。\n- 用Calabash搭一个自有的云测平台可行性很高\n\n这只是大方向的几个优点，文末会奉上Calabash的入门文章，更详细的介绍Calabash的各种特性，利用这些特性，你会发现Calabash有太多的想象。\n\n### Calabash缺点\n\n说了那么多优点，缺点当然也是有的啦~我们吐槽一下\n#### 资料、Demo稀少\n\nCalabash大概有五年以上的历史，最早的first commit是2012年2月份，对于一个技术工具来说，这已经可以算是很老了，但Calabash依然是一个小众产品，然后导致的问题是资料非常非常少……官方Github只给了很简单很基础的API，还基本没有Demo,(官方Demo就几行代码~) \n\n资料少也意味着后面有很多坑需要自己往过趟，不过有了文末的入门教程，快速上手应该是没问题啦~\n\n我大胆的怀疑了一下Calabash小众的原因，可能大厂还是更钟爱appium这种主流测试框架，毕竟语法复杂也意味着功能强大，而小厂呢，相比起维护一套自动化测试框架，不如就手点点人工测试好了，所以Calabash这样的，就处于一个很尴尬的位置了（这篇文章不就是让你破解这种尴尬的嘛！）\n\n#### 不支持跨进程\n\nCalabash底层是Robotium，Robotium不支持跨进程操作，所以Calabash也不支持。当你跳出当前测试App时，calabash便无法响应并做任何操作了。\n在个别需要跨进程调用业务较多的App中，这个点是很痛的，甚至基本上就可以放弃Calabash了。\n\n以蜂鸟众包为例，需要跨进程的业务有分享和拍照（拍照调用了系统相机），分享对于蜂鸟众包来说是一个很边界的业务，暂不讨论，但拍照影响到了主流程。\n不过如果修改拍照为自定义相机，而是不调用系统相机的话，将不会存在这个问题，并且可以解决不同手机系统相机样式不同，脚本需要进行兼容的困扰。所以即使是为了测试而对业务代码做了这种程度的改动，也是值得的！\n\n另外通过最近研究发现，**Calabash支持跨进程似乎也是有希望的！**Espresso实现跨进程操作的方式是调用了uiautomator的API。而Calabash作为开源项目，想要修改其源码也是完全OK的。 以Android为例，其内部核心是通过java调用Robotium API实现的，所以我们只要修改其源码调用uiautomator的API即可实现跨进程。恩……实现思想是这样的，只是不知道官方为什么没有这样去做，具体情况还待研究……（2015年底之前Calabash相关的博客中可以很容易的找到修改其源码进行功能扩展的博客，但Calabash在2015年年底将Calabash的源码抽离到了另一个项目中，所以这些博客中提到方案便无法使用了，后续的具体实现方式还待研究，详情会在文末的教程中提到）\n\n#### 不够严谨的自然语言\n\n可能大部分人会对Calabash这样的自然语言抱有怀疑，认为Calabash这样Cucumber风格的语言（就是上面的我们看到的测试脚本）不够严谨。无法向代码那样简练且规范严格，在某种程度也降低了编写速度，且非常不够严谨易错度高！\n\n首先要澄清一点的是，Java、Python等隶属编程语言，而Cucumber风格的脚本更倾向于是一种描述性语言。他们是两种不同的领域。\n\n所以不能站在编程语言的角度去要求Cucumber风格的脚本的严谨程度，而“严谨”也不过是作为编程人员的一种惯性思维。\n\n而从记忆与编写速度考虑，还记得我们上面曾说到的语法糖吗？不恰当的定义Steps确实会导致这样的问题。举个例子吧\n\n\t#我跳过欢迎界面\n\tThen I skip welcome page\n    #我完成登录操作\n\tThen I have finished the login\n\n上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：\n\n\n\t#我跳过欢迎界面\n\tThen I pass \"welcome\" scenario\n    #我完成登录操作\n\tThen I pass \"login\" scenario\n\n两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。\n\n当然，确实是因为Calabash过于宽松的语法，导致这个致命的缺点需要通过严格的管理进行约束，稍有不慎会埋有祸根。所以这确实是Calabash的缺点之一。\n\n## End\n\n最后，虽然我个人建议使用Calabash，但对于小微团队，**合适的才是最好的！** 资源紧张情况下想要实行自动化测试，我的建议是在提高人效的基础上调动更多的人力来分摊压力。那么这对低学习门槛和低推广成本的要求就会很高，所以学习门槛和推广成本应该是你选择自动化工具最需要考察的点。\n\n正是因为Calabash的特性非常契合这两点，我才会极力推荐，同时如果你想在未来的某一天尝试一下BDD这种思想，或者想让产品经理参与到这个环节做一些尝试，同样是非常建议使用Calabash的。当然如果你有较为宽松的资源、或者追求更加工程化的自动化测试，还可以选择Appium这样主流的测试工具。还是那句话：**合适的才是最好的！**\n\n最后，奉上Calabash的入门博客：\n\n------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n","source":"_posts/小微团队怎么玩转App自动化测试.md","raw":"\n---\ntitle: 小微团队怎么玩转App自动化测试\ndate: 2017-3-21 16:20:58\nauthor : 暴打小女孩\n\ntags: 测试\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n\n## 前言\n\n这篇博客，我会站在小微团队的角度，介绍一下我对App自动化测试的一些看法。在帮助你降低对App自动化测试的期望的同时说服你开始实践App自动化测试。\n\n<!-- more -->\n\nApp自动化测试一直是小微团队很少会去涉足的领域，在互联网快速迭代这个大场景下，随着业务发展，回归压力逐渐增大。相信每次因为回归覆盖不足而导致线上事故，懊恼郁闷到要砸桌子的绝对不止我一个。\n\n一般情况小微团队的测试包括回归测试都是人工进行的，一些偏离主流程却又比较关键的业务往往是人工回归测试容易遗漏的。人力有穷尽，这个时候自动化测试这个念头就从你的脑袋里冒出来了，然后就是去研究嘛。但可能最终也就止步于研究了。不谈自动化框架的搭建，种种细分的边界case,一个必然很繁琐的东西想一想就更繁琐了。如果你是App开发，本来业务开发上的人手就不是很充足，再去开发自动化脚本，有心无力！如果你是测试，每个迭代的业务需求测试就填满了你的排期，更何况承担的可不只是App测试任务。作为小微团队，自动化我们也想，但我们没有资源……\n\n\n首先我们要明白App自动化测试并没有你预想中的那么强大，但如果你像我一样面临着回归测试痛点，它绝对可以满足你的需求。没有那么强大，所以也没有你预想中的那么复杂，同时它的参与者也绝不只应限制在Tester或Developer上，所以在资源上你可以有更灵活的调配。当然，自动化测试是一个长期的过程，它的未来，也绝不仅是回归……\n\n最后我会为你安利一款偏冷的自动化测试工具：Calabash。并奉上Calabash入门教程博客和一点我的使用心得。介绍Calabash，是因为Calabash的特性在我个人看来更为适合资源紧缺的小微团队。\n\n## 大话App自动化测试\n\n仅代表个人观点，见识还浅，欢迎多多打脸。\n\n### 现状\n\n先说点大家都知道的。以Android为例，从2010年开始，Android开发环境以及其迅猛的态势发展到今天，几近趋于成熟，开发者的目光早已不在局限于这单一的开发平台，开始寻求Android，iOS在开发上的统一：ReactNactive,WEEX,H5……\n\n开发环境已经成熟，但移动客户端的测试环境却有些滞后。这中间的几座大山是很多团队正在面对且驻足的：\n\n1.App测试不像服务端测试通常只需对数据本身进行验证即可，App涉及到界面展示及交互，自动化识别难度大。\n2.互联网企业一直都在追寻快速迭代，且App直接对接用户，App的界面与逻辑变更更是家常便饭，编写自动化测试脚本的稳定性很差，可能设计对界面的一次改动，之前与这个页面挂钩的所有脚本就都废掉了。\n3.Android iOS 双平台,web页面。多平台的情况下想要依靠一套代码进行自动化测试几乎是不可能的。再考虑需要经常变更，你懂得。\n4.比起人工来说，自动化测试可能需要为种种边界case编写很多的脚本。同比人工测试，可能需要的只是事先设计几个场景，其他的异常边界case通过测试中人为观察就好了。自动化测试成本倍增！\n\n所以往往一个完善的移动自动化测试环境需要一个庞大的测试团队支撑，但一个庞大的测试团队只有大公司才能负担的起。移动的自动化测试，一直都在被中小型的创业公司所忽略。小型公司开发自测了事，中型公司依靠测试人员人工操作进行验证。\n\n自动化测试真的对于小微团队紧闭大门吗？\n\n### Just do it\n\n上面说的这些现状只能说是难题，也许现在讨论解决这些问题还早了些。我觉得你有些东西还没确定清楚，要不然先跟着我的思路走一走？等下面一些事情都想明白了，也许这些问题能避也就避过了，需要硬上的，也有足够心理准备了。\n\n#### 1.设定阶段计划试错\n其实让小微团队面对自动化测试左右徘徊最大的一个问题就是：投入产出比！\n很难去预估实行自动化测试后，在页面频繁变更与脚本的开发和维护之间，测试或开发人员会不会陷入泥潭。\n\n但纸上谈兵永远也不会有结果，其他大公司的借鉴意义也不是很强，因为这涉及到团队、资源分配、业务变更频度、测试工具、脚本开发的解耦程度等等。不过自动化测试是一个必然的趋势，所以行动是最首要的！\n\n你的团队目前到底适不适合，只有试了才知道。不妨先设定几个阶段，然后用第一阶段试错：\n\n**阶段1**：抽出一个人一个迭代的资源完成主流程业务的自动化测试case，试运行两到三个迭代，并在这期间增加主流程异常case。利用这三个迭代来评估后续发展可行性！\n**阶段2-（阶段1成功度过）**：如果你认为阶段1的状态还不错，那么在维护阶段1成果的基础上从剩余业务场景中按照业务关键程度、变更频率来选取一个新的业务，以一个人一个迭代一个业务的节奏编写自动化测试case！\n**阶段2-（阶段1过度失败）**：当然，经过三个迭代的评估，随着异常case增多，同步维护难度越来越大，你可能认为实行自动化测试的成本过大，但也不要轻易放弃这三个迭代的成果。请先利用编程思维检查所有的测试脚本，是否有抽取相似代码，封装特定View操作，抽离与业务无关指令的可能。同时考虑利用全组资源就此维护这套主流程自动化case。直到将来资源充足或找到更好的替代方案后进行阶段3或重新阶段1。\n**阶段3**：大概在5~8个迭代后，你成功撑过了阶段2，说明你的自动化测试环境已经步入正轨，那么这个时候可以按照团队资源情况适当加快自动化case覆盖率！\n\n利用一人一个迭代的资源进行试错，相信是你可以接受的一个损失。当然，先不要急着做，你也许只是决定了要进行自动化测试，但还是要定一些详细的计划和一些思想、实际行动上的准备！\n\n\n#### 2.确定明确且简单的目标\n\n有了大的计划，还要明确具体的需求，可选的需求大概有这么些：\n\n**1.黑盒测试还是白盒测试**\n虽然是UI自动化测试，但也可以分为黑盒或白盒，这个取决你想要的测试精密度，也就是在这个时候，可以初步确定要使用什么自动化测试工具。比如通常我们为了可以双平台会选择Appium这种可以跨平台的测试工具，但假如你有很高的测试要求，以Android为例，建议你使用Android官方推荐的测试框架：Espresso，直接在Android工程项目中写Test。\n这样说出来好像谁都明白，但如果你不能在前期就明确你的需求，可能会在后期带来很大的困扰！选择Appium，因为是黑盒，遇到某些特殊的场景或需求，导致个别case无法测试。或者选择了Espresso，但后来发现其实并没有那么精密的测试需求，导致后期无法跨平台或者认为Espresso编写成本过高，还很难移交给测试团队。\n\n**2.前端UI还是整体业务**\n举个例子，抢单并且进行配送这个场景。发现一个订单并点击抢单，然后进行取餐，最后完成配送这一套只能用肉眼观察到的UI层操作，我们暂定为这是前端UI逻辑。但在这一系列操作背后订单状态流转引起其他数据变动，比如：钱包数据变更，活动奖励数据变更，欺诈单判定等等这个范围，就属于整体业务范畴了。\n而我们需要现在确定的，就是你想要达到的测试期望是UI测试，还是整体业务测试。这直接决定了你测试脚本的复杂度。而我的建议是仅测UI逻辑，也是我想让你降低期望一个点。\n\n先确定一个明确且简单的目标，然后一头扎进去。如果想的多了，困难也就多了，最后可能也就只是想想了，这就是下面紧接着要说的点：**降低期望**！\n\n#### 3.降低期望\n在人工（对着手机点点点）测试的环境下，我们通常都是通过操作App进行各种case验证，只要操作app验证通过了那基本可以确定前后端没什么问题了。但这个前提是人工验证是人脑加肉眼，它会有更准确的主观判断。\n涉及到前后端交互会增加极大的复杂性，你的测试case不会无限多无限精细，但作为人脑你可以在有限的case执行中发现更多不符合常理的bug：文字不合理的折行，不准确的数值显示，按钮颜色不对，Toast展示数量有误等等等。自动化测试会死板的跟着你写的脚本走，你能保证你的case覆盖到了所有了吗？\n\n这也是谈到自动化测试，好多人都会抛出的一个疑问，那么多异常case怎么写啊，想想都累，考虑一下投入产出比要不还是人工测试吧。\n\n首先要明确的一点，前后端自动化测试一定要分开，一套解决不了问题，这样在前端测试中可以忽略很多的case。\n另外自动化测试是一个与项目成长一样的长期过程，自动化完全代替人工依然还需要走一段时间，你不要想着一步到位。\n依然还是会有很多的case要写对吧？资源不够我们可以先跑通主流程再说，跑通主流程也就意味着脚本依赖（环境搭建，view定位）已经较为成熟了，其他异常case脚本对着主流程脚本修改即可，这个我们慢慢来嘛，而且这个时候你就可以放开给别的开发或测试让他们照猫画虎了。这也就是我们上面说的**阶段1**。\n\n如果这些问题不能想通，你会发现在App自动化测试条件有限的情况下，并不能实现你想要的结果，从而迫于压力而放弃了。**说服自己降低期望**！\n\n- 降低期望，先以回归为目标\n- 降低期望，前后端自动化测试都要有，一套解决不了问题\n- 降低期望，客户端自动化测试限制依然很多，人工测试验证不能全部丢下\n- 降低期望，一口吃不成个胖子，自动化测试也是需要慢慢迭代完善的，先跑通再关心验证异常case。快速迭代，逐步完善\n\n#### 4.术业有专攻\n\n也许你的团队里是开发或者测试中的某一方无法承受压力，从而开始探索App自动化测试。\n开发去做自动化测试的优点在于因为有更丰富的开发经验，测试环境的搭建更为熟练，且因为是自己写的代码，会更了解风险点在哪里，能写出有针对性的case。测试去做自动化测试的优点在于发现更多的边界场景，写出更全面的测试case。\n\n在自动化测试上，开发和测试各具不同的优势，但同时这也是对方的劣势。\n\n测试case一定要越全面越好，而且自动化测试本身就是一个工程项目，在写脚本时，如果更多的考虑一些编程思想，合理的耦合和解耦，将会让之后的脚本编写更便捷。\n所以，非常不建议自动化测试完全单独交给测试人员或开发人员来负责，最好是一种紧密合作的关系。**同时也是应对资源不足的一个解决之道**。虽是测试，但有开发的加入，会让测试工程朝着更优的方向发展。\n\n#### 5.一个巴掌拍不响\n\n首先再次明确我的一个观点：在没有足够的资源的情况下，移动客户端自动化测试，主要针对的应该是回归测试。\n\n自动化测试相比起人工测试，是非常死板的，那么就需要非常“死板”的数据支持.如果是App开发（就像我）去做自动化测试这件事，难道所有数据我都要mock一遍吗？虽说前后端自动化应该分开，前面也说了应该只关心前端逻辑。但一定还是要在真实的服务环境（测试环境，非生产环境）进行测试。\nmock数据过于死板，很多case可能就无法验证了，比如注册场景，要验证注册过的账号无法再注册时的异常提示，mock数据显然较难兼顾正常注册和异常注册两种。而且在真实环境中测试，万一测出来一个后端bug不挺好么。\n而且，手机淘宝这样完全2C的应用直接在生产环境测试好像没什么太大问题，但像蜂鸟配送这样半2C的应用来说就比较尴尬，直接去抢线上单明显不可能，那么在测试环境这个订单谁来发怎么发呢？\n\n所以这个时候你就不能自己单干了，去找测试同学，看能不能搞一个配合自动化测试的测试环境，拿抢单来说，我希望这个环境上永远有好多单让我抢。我就是抢单的app，没单我还玩什么。\n\n如果测试同学搞不定，那么就去拉后端的同学啦，我相信为了项目越来越好，他们是不会拒绝你的。\n\n自动化测试，不仅是自动化测试工具就够了，同样还需要测试环境的支持。\n\n\n### 小结\n\n其实说了这么多，就是想要你降低期望，并付诸行动。\nApp的自动化识别和多平台自然会有大批的自动化工具帮你实现，而学会降低期望的同时也会降低脚本开发和维护的难度。\n\n难道你还在纠结细分case太多的问题？先放一放又如何？反正你都裸奔这么久了，穿裤子不也要先穿个裤衩才行么，裤子慢慢来！\n或者你依然徘徊在投入产出比的问题上？买衣服不也要先试穿才知道码号的吗？\n\nOK，下面我们聊聊这个裤衩，和怎么穿这个裤衩！\n\n## 测试工具\n\n做好了思想工作，具体实现还是需要选择一个具体的测试工具，工具没有好坏，只有适不适合。\nCalabash是我个人建议小微团队使用的测试工具，因为其兼具门槛低、跨平台、脚本维护容易的特性，而这正是小微团队最急需的。\n且其BDD（行为驱动开发）的思想虽然有点乌托邦，但从远瞻的角度来看，实现测试脚本先于程序开发编写的这种先进项目管理可能性也大于其他工具，让测试不仅仅是测试！\n\n下面我会对Calabash的特性做一个简单介绍，详述其优缺点，你可以根据自身团队经验进行选择是否使用，如果喜欢，文末会附上Calabash由浅入深的入门教程，加之更详细的特性介绍和我自己的使用建议。\n\n### Calabash\n谈Calabash前，先要交代清楚Calabash是啥。\n\nCalabash的核心是Cucumber，Cucumber是一个能够用自然语言编写实例的协作工具，其核心思想是行为驱动开发（BDD），回归测试是其自然而然的副带结果。你可以简单的理解为Calabash-android 或 Calabash-iOS是在Cucumber上进行了一次扩展，从而可以对Android或iOS进行自动化测试。\n\n在解释一下BDD，我从网络摘了一段介绍：*你可以在Cucumber中编写用户场景，让它表现出业务规则而不仅仅是UI功能。这样你就能够让业务分析师加入这个过程，在编码工作开始前编写场景。程序员们就能够按照这个清晰的规范进行编码工作了。这种方式就是行为驱动开发（BDD）。*\n\nOK，关于BDD我们就此打住，毕竟还是很未来的事情，下面我们聊点实在的。\n\nCalabash与appium，Espresso类似，都是通过脚本去操作界面，作出点击、滑动等操作，同时可以对界面的上UI组件进行一定识别。run起来就是那么回事，模拟控制手机。主要是脚本的编写上不同，我们来看一下Calabash的脚本，**相信我，爱上它，就从看到它脚本开始**：\n\n\n```\nFeature: Login feature\n\n  Scenario: 登录测试用例\n\n  \tWhen I press view with id \"account_edit\"\n  \tThen I enter \"15104053650流量\" into input field number 1\n\n  \tThen I press \"发送验证码\"\n  \tThen I wait for 5 seconds\n\n  \tWhen I press view with id \"verifying_code_edit\"\n  \tThen I enter \"306423\" into input field number 2\n\n  \tThen I wait for 5 seconds\n\n  \tThen I press view with id \"login_login\"\n\n```\n\n\n我觉得我不需要再解释这脚本的含义了，这就是大白话！！\n**Calabash最大的魅力在于，将难以理解的编程语言转换为谁都可以看得懂得自然语言。从而降低学习门槛和维护难度。**\n**特点1：极高的可读性**，可读性越高的测试脚本，意义越大。当测试脚本的编写先于或与开发同步时，测试脚本也可以成为开发过程中的设计文档及参考手册。\n\n在可读性非常高的基础上，其编写难度也变得非常的低。**特点2：语法简单易懂，谁都能写**。\n\n同时可喜的是，这个代码同时支持Android 和iOS，web也有一定的支持！RN就更不用说了，跑起来的RN就是原生代码！WEEX还要再考察考察~在合理的解耦与耦合的情况下，Android 和iOS只需提供一套各自的View定位封装即可共用一套场景case脚本。**特点3：支持多种平台，代码复用性强**。\n\n\n一段使用自然语言编写的脚本，其底层当然要费一番功夫。上面我们看到一段测试用例是使用Calabash预定义的Steps写的一段测试用例。\n\n而这些大白话一样的Steps的实质是这样的：\n\n```\nThen /^I press \"([^\\\"]*)\"$/ do |identifier|  # ---方法名\n  tap_when_element_exists(\"* marked:'#{identifier}'\")  # ---方法体\nend\n```\n\n很傻瓜的解释一下：你可以很简单的认为上面这一段是一个函数、一个方法。\n第一行就是一个自然语言夹杂着正则符号的方法名，方法名随便起。第二行是用Ruby实现的方法体。\n不要被这段代码吓到，在大部分时候，你都不需要接触到这些大白话的具体实现（Ruby语言），而是直接用大白话写小作文就好了。\n预定义的Steps肯定不能满足我们的需求，所以Calabash灵活的支持**不同程度自定义steps**，样子大概就像上面那样，你可以简单理解为Calabash支持不同程度的，代码到自然语言的转换。最大程度的满足业务需求。\n正是这种灵活的转换方式，让我们有了更多的想象：\n\n**特点4：Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的脚本开发人员** \n再简单解释一下：先让一部分(实际情况可能是一个)人学起来，写出一个个大白话似的Steps。再接纳另一部分人进来，比如其他的开发或测试人员，甚至是产品经理！直接用这些大白话写测试case，熟悉了之后有想法的话再去学自定义Steps。甚至产品都不需要学自定义Steps,给开发提需求好了，当你有一个非常丰富的Steps库的时候，你所烦的无穷无尽的边界case，不过就是全民小作文~\n\n**特点5：自定义语法糖**\nSteps的方法名定义完全自由，在带来可读性提高的同时也降低了Steps的记忆和脚本编写速度。但这其实完全依赖于你定义的规范，你完全可以自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。\n\n还有哦，如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？\n\n**特点6：维护简单，我不知道小作文维护起来有什么难的~**\n\n**特点7：case也有设计感，不在那么枯燥**\n在加一个最起码我觉得很兴奋的特点，考虑复用的话，自定义的Steps就要考虑与业务的解耦问题了，有的要解耦有的却要耦合一点。而且如果为了最小程度修改代码从而保证Android iOS在代码上通用，Android和iOS的开发上就会有更多的交流，测试脚本的编写也会有更通用的设计。这里面就有设计的快感了。\n\n**特点8：除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook**\n\n**特点9：丰富的元素定位辅助方法。**\nApp自动化测试一个普遍的痛点就是元素定位，Calabash有非常多的元素定位辅助方法，且都较为简单且无脑。 \n\n最后我们在看一个从网上摘下来的一段Calabash脚本：\n\n```\nFeature： 登陆\n\n　　Scenario： 输入正确的用户名密码能够正常登陆\n\n　　When 打开登陆页面\n　　And    输入用户名XXX输入密码XXX\n　　And   点击登陆\n　　Then  验证登陆成功\n\n```\n\n完全纯中文的脚本编写有木有？是不看起来屌屌的~恩，虽然博主自身并不建议这样纯中文的step定义，我们就看看，你只要知道Calabash很强大就行了。\n\n\n最后我们总结一下Calabash的大方向的优点：\n\n- 极高的可读性\n- 语法简单易懂，学习门槛低\n- 一种语言支持多种平台，代码复用性强\n- Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的开发\n- 自定义语法糖\n- 小作文维护简单\n- case也有设计感\n- 除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook\n- 非常多的元素定位辅助方法\n- 对代码无侵入性，纯黑盒测试。\n- 用Calabash搭一个自有的云测平台可行性很高\n\n这只是大方向的几个优点，文末会奉上Calabash的入门文章，更详细的介绍Calabash的各种特性，利用这些特性，你会发现Calabash有太多的想象。\n\n### Calabash缺点\n\n说了那么多优点，缺点当然也是有的啦~我们吐槽一下\n#### 资料、Demo稀少\n\nCalabash大概有五年以上的历史，最早的first commit是2012年2月份，对于一个技术工具来说，这已经可以算是很老了，但Calabash依然是一个小众产品，然后导致的问题是资料非常非常少……官方Github只给了很简单很基础的API，还基本没有Demo,(官方Demo就几行代码~) \n\n资料少也意味着后面有很多坑需要自己往过趟，不过有了文末的入门教程，快速上手应该是没问题啦~\n\n我大胆的怀疑了一下Calabash小众的原因，可能大厂还是更钟爱appium这种主流测试框架，毕竟语法复杂也意味着功能强大，而小厂呢，相比起维护一套自动化测试框架，不如就手点点人工测试好了，所以Calabash这样的，就处于一个很尴尬的位置了（这篇文章不就是让你破解这种尴尬的嘛！）\n\n#### 不支持跨进程\n\nCalabash底层是Robotium，Robotium不支持跨进程操作，所以Calabash也不支持。当你跳出当前测试App时，calabash便无法响应并做任何操作了。\n在个别需要跨进程调用业务较多的App中，这个点是很痛的，甚至基本上就可以放弃Calabash了。\n\n以蜂鸟众包为例，需要跨进程的业务有分享和拍照（拍照调用了系统相机），分享对于蜂鸟众包来说是一个很边界的业务，暂不讨论，但拍照影响到了主流程。\n不过如果修改拍照为自定义相机，而是不调用系统相机的话，将不会存在这个问题，并且可以解决不同手机系统相机样式不同，脚本需要进行兼容的困扰。所以即使是为了测试而对业务代码做了这种程度的改动，也是值得的！\n\n另外通过最近研究发现，**Calabash支持跨进程似乎也是有希望的！**Espresso实现跨进程操作的方式是调用了uiautomator的API。而Calabash作为开源项目，想要修改其源码也是完全OK的。 以Android为例，其内部核心是通过java调用Robotium API实现的，所以我们只要修改其源码调用uiautomator的API即可实现跨进程。恩……实现思想是这样的，只是不知道官方为什么没有这样去做，具体情况还待研究……（2015年底之前Calabash相关的博客中可以很容易的找到修改其源码进行功能扩展的博客，但Calabash在2015年年底将Calabash的源码抽离到了另一个项目中，所以这些博客中提到方案便无法使用了，后续的具体实现方式还待研究，详情会在文末的教程中提到）\n\n#### 不够严谨的自然语言\n\n可能大部分人会对Calabash这样的自然语言抱有怀疑，认为Calabash这样Cucumber风格的语言（就是上面的我们看到的测试脚本）不够严谨。无法向代码那样简练且规范严格，在某种程度也降低了编写速度，且非常不够严谨易错度高！\n\n首先要澄清一点的是，Java、Python等隶属编程语言，而Cucumber风格的脚本更倾向于是一种描述性语言。他们是两种不同的领域。\n\n所以不能站在编程语言的角度去要求Cucumber风格的脚本的严谨程度，而“严谨”也不过是作为编程人员的一种惯性思维。\n\n而从记忆与编写速度考虑，还记得我们上面曾说到的语法糖吗？不恰当的定义Steps确实会导致这样的问题。举个例子吧\n\n\t#我跳过欢迎界面\n\tThen I skip welcome page\n    #我完成登录操作\n\tThen I have finished the login\n\n上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：\n\n\n\t#我跳过欢迎界面\n\tThen I pass \"welcome\" scenario\n    #我完成登录操作\n\tThen I pass \"login\" scenario\n\n两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。\n\n当然，确实是因为Calabash过于宽松的语法，导致这个致命的缺点需要通过严格的管理进行约束，稍有不慎会埋有祸根。所以这确实是Calabash的缺点之一。\n\n## End\n\n最后，虽然我个人建议使用Calabash，但对于小微团队，**合适的才是最好的！** 资源紧张情况下想要实行自动化测试，我的建议是在提高人效的基础上调动更多的人力来分摊压力。那么这对低学习门槛和低推广成本的要求就会很高，所以学习门槛和推广成本应该是你选择自动化工具最需要考察的点。\n\n正是因为Calabash的特性非常契合这两点，我才会极力推荐，同时如果你想在未来的某一天尝试一下BDD这种思想，或者想让产品经理参与到这个环节做一些尝试，同样是非常建议使用Calabash的。当然如果你有较为宽松的资源、或者追求更加工程化的自动化测试，还可以选择Appium这样主流的测试工具。还是那句话：**合适的才是最好的！**\n\n最后，奉上Calabash的入门博客：\n\n------\n\n[《Calabash探索1-Run Calabash》](https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/)\n\n[《Calabash探索2-Calabash用法详解》](https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/)\n\n[《Calabash探索3-Calabash进阶》](https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/)\n\n[《Calabash探索4-Calabash踩坑总结》](https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/)\n\n\n\n\n\n","slug":"小微团队怎么玩转App自动化测试","published":1,"updated":"2019-01-02T02:09:31.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspn000wyo9srbtdn2wk","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博客，我会站在小微团队的角度，介绍一下我对App自动化测试的一些看法。在帮助你降低对App自动化测试的期望的同时说服你开始实践App自动化测试。</p>\n<a id=\"more\"></a>\n<p>App自动化测试一直是小微团队很少会去涉足的领域，在互联网快速迭代这个大场景下，随着业务发展，回归压力逐渐增大。相信每次因为回归覆盖不足而导致线上事故，懊恼郁闷到要砸桌子的绝对不止我一个。</p>\n<p>一般情况小微团队的测试包括回归测试都是人工进行的，一些偏离主流程却又比较关键的业务往往是人工回归测试容易遗漏的。人力有穷尽，这个时候自动化测试这个念头就从你的脑袋里冒出来了，然后就是去研究嘛。但可能最终也就止步于研究了。不谈自动化框架的搭建，种种细分的边界case,一个必然很繁琐的东西想一想就更繁琐了。如果你是App开发，本来业务开发上的人手就不是很充足，再去开发自动化脚本，有心无力！如果你是测试，每个迭代的业务需求测试就填满了你的排期，更何况承担的可不只是App测试任务。作为小微团队，自动化我们也想，但我们没有资源……</p>\n<p>首先我们要明白App自动化测试并没有你预想中的那么强大，但如果你像我一样面临着回归测试痛点，它绝对可以满足你的需求。没有那么强大，所以也没有你预想中的那么复杂，同时它的参与者也绝不只应限制在Tester或Developer上，所以在资源上你可以有更灵活的调配。当然，自动化测试是一个长期的过程，它的未来，也绝不仅是回归……</p>\n<p>最后我会为你安利一款偏冷的自动化测试工具：Calabash。并奉上Calabash入门教程博客和一点我的使用心得。介绍Calabash，是因为Calabash的特性在我个人看来更为适合资源紧缺的小微团队。</p>\n<h2 id=\"大话App自动化测试\"><a href=\"#大话App自动化测试\" class=\"headerlink\" title=\"大话App自动化测试\"></a>大话App自动化测试</h2><p>仅代表个人观点，见识还浅，欢迎多多打脸。</p>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p>先说点大家都知道的。以Android为例，从2010年开始，Android开发环境以及其迅猛的态势发展到今天，几近趋于成熟，开发者的目光早已不在局限于这单一的开发平台，开始寻求Android，iOS在开发上的统一：ReactNactive,WEEX,H5……</p>\n<p>开发环境已经成熟，但移动客户端的测试环境却有些滞后。这中间的几座大山是很多团队正在面对且驻足的：</p>\n<p>1.App测试不像服务端测试通常只需对数据本身进行验证即可，App涉及到界面展示及交互，自动化识别难度大。<br>2.互联网企业一直都在追寻快速迭代，且App直接对接用户，App的界面与逻辑变更更是家常便饭，编写自动化测试脚本的稳定性很差，可能设计对界面的一次改动，之前与这个页面挂钩的所有脚本就都废掉了。<br>3.Android iOS 双平台,web页面。多平台的情况下想要依靠一套代码进行自动化测试几乎是不可能的。再考虑需要经常变更，你懂得。<br>4.比起人工来说，自动化测试可能需要为种种边界case编写很多的脚本。同比人工测试，可能需要的只是事先设计几个场景，其他的异常边界case通过测试中人为观察就好了。自动化测试成本倍增！</p>\n<p>所以往往一个完善的移动自动化测试环境需要一个庞大的测试团队支撑，但一个庞大的测试团队只有大公司才能负担的起。移动的自动化测试，一直都在被中小型的创业公司所忽略。小型公司开发自测了事，中型公司依靠测试人员人工操作进行验证。</p>\n<p>自动化测试真的对于小微团队紧闭大门吗？</p>\n<h3 id=\"Just-do-it\"><a href=\"#Just-do-it\" class=\"headerlink\" title=\"Just do it\"></a>Just do it</h3><p>上面说的这些现状只能说是难题，也许现在讨论解决这些问题还早了些。我觉得你有些东西还没确定清楚，要不然先跟着我的思路走一走？等下面一些事情都想明白了，也许这些问题能避也就避过了，需要硬上的，也有足够心理准备了。</p>\n<h4 id=\"1-设定阶段计划试错\"><a href=\"#1-设定阶段计划试错\" class=\"headerlink\" title=\"1.设定阶段计划试错\"></a>1.设定阶段计划试错</h4><p>其实让小微团队面对自动化测试左右徘徊最大的一个问题就是：投入产出比！<br>很难去预估实行自动化测试后，在页面频繁变更与脚本的开发和维护之间，测试或开发人员会不会陷入泥潭。</p>\n<p>但纸上谈兵永远也不会有结果，其他大公司的借鉴意义也不是很强，因为这涉及到团队、资源分配、业务变更频度、测试工具、脚本开发的解耦程度等等。不过自动化测试是一个必然的趋势，所以行动是最首要的！</p>\n<p>你的团队目前到底适不适合，只有试了才知道。不妨先设定几个阶段，然后用第一阶段试错：</p>\n<p><strong>阶段1</strong>：抽出一个人一个迭代的资源完成主流程业务的自动化测试case，试运行两到三个迭代，并在这期间增加主流程异常case。利用这三个迭代来评估后续发展可行性！<br><strong>阶段2-（阶段1成功度过）</strong>：如果你认为阶段1的状态还不错，那么在维护阶段1成果的基础上从剩余业务场景中按照业务关键程度、变更频率来选取一个新的业务，以一个人一个迭代一个业务的节奏编写自动化测试case！<br><strong>阶段2-（阶段1过度失败）</strong>：当然，经过三个迭代的评估，随着异常case增多，同步维护难度越来越大，你可能认为实行自动化测试的成本过大，但也不要轻易放弃这三个迭代的成果。请先利用编程思维检查所有的测试脚本，是否有抽取相似代码，封装特定View操作，抽离与业务无关指令的可能。同时考虑利用全组资源就此维护这套主流程自动化case。直到将来资源充足或找到更好的替代方案后进行阶段3或重新阶段1。<br><strong>阶段3</strong>：大概在5~8个迭代后，你成功撑过了阶段2，说明你的自动化测试环境已经步入正轨，那么这个时候可以按照团队资源情况适当加快自动化case覆盖率！</p>\n<p>利用一人一个迭代的资源进行试错，相信是你可以接受的一个损失。当然，先不要急着做，你也许只是决定了要进行自动化测试，但还是要定一些详细的计划和一些思想、实际行动上的准备！</p>\n<h4 id=\"2-确定明确且简单的目标\"><a href=\"#2-确定明确且简单的目标\" class=\"headerlink\" title=\"2.确定明确且简单的目标\"></a>2.确定明确且简单的目标</h4><p>有了大的计划，还要明确具体的需求，可选的需求大概有这么些：</p>\n<p><strong>1.黑盒测试还是白盒测试</strong><br>虽然是UI自动化测试，但也可以分为黑盒或白盒，这个取决你想要的测试精密度，也就是在这个时候，可以初步确定要使用什么自动化测试工具。比如通常我们为了可以双平台会选择Appium这种可以跨平台的测试工具，但假如你有很高的测试要求，以Android为例，建议你使用Android官方推荐的测试框架：Espresso，直接在Android工程项目中写Test。<br>这样说出来好像谁都明白，但如果你不能在前期就明确你的需求，可能会在后期带来很大的困扰！选择Appium，因为是黑盒，遇到某些特殊的场景或需求，导致个别case无法测试。或者选择了Espresso，但后来发现其实并没有那么精密的测试需求，导致后期无法跨平台或者认为Espresso编写成本过高，还很难移交给测试团队。</p>\n<p><strong>2.前端UI还是整体业务</strong><br>举个例子，抢单并且进行配送这个场景。发现一个订单并点击抢单，然后进行取餐，最后完成配送这一套只能用肉眼观察到的UI层操作，我们暂定为这是前端UI逻辑。但在这一系列操作背后订单状态流转引起其他数据变动，比如：钱包数据变更，活动奖励数据变更，欺诈单判定等等这个范围，就属于整体业务范畴了。<br>而我们需要现在确定的，就是你想要达到的测试期望是UI测试，还是整体业务测试。这直接决定了你测试脚本的复杂度。而我的建议是仅测UI逻辑，也是我想让你降低期望一个点。</p>\n<p>先确定一个明确且简单的目标，然后一头扎进去。如果想的多了，困难也就多了，最后可能也就只是想想了，这就是下面紧接着要说的点：<strong>降低期望</strong>！</p>\n<h4 id=\"3-降低期望\"><a href=\"#3-降低期望\" class=\"headerlink\" title=\"3.降低期望\"></a>3.降低期望</h4><p>在人工（对着手机点点点）测试的环境下，我们通常都是通过操作App进行各种case验证，只要操作app验证通过了那基本可以确定前后端没什么问题了。但这个前提是人工验证是人脑加肉眼，它会有更准确的主观判断。<br>涉及到前后端交互会增加极大的复杂性，你的测试case不会无限多无限精细，但作为人脑你可以在有限的case执行中发现更多不符合常理的bug：文字不合理的折行，不准确的数值显示，按钮颜色不对，Toast展示数量有误等等等。自动化测试会死板的跟着你写的脚本走，你能保证你的case覆盖到了所有了吗？</p>\n<p>这也是谈到自动化测试，好多人都会抛出的一个疑问，那么多异常case怎么写啊，想想都累，考虑一下投入产出比要不还是人工测试吧。</p>\n<p>首先要明确的一点，前后端自动化测试一定要分开，一套解决不了问题，这样在前端测试中可以忽略很多的case。<br>另外自动化测试是一个与项目成长一样的长期过程，自动化完全代替人工依然还需要走一段时间，你不要想着一步到位。<br>依然还是会有很多的case要写对吧？资源不够我们可以先跑通主流程再说，跑通主流程也就意味着脚本依赖（环境搭建，view定位）已经较为成熟了，其他异常case脚本对着主流程脚本修改即可，这个我们慢慢来嘛，而且这个时候你就可以放开给别的开发或测试让他们照猫画虎了。这也就是我们上面说的<strong>阶段1</strong>。</p>\n<p>如果这些问题不能想通，你会发现在App自动化测试条件有限的情况下，并不能实现你想要的结果，从而迫于压力而放弃了。<strong>说服自己降低期望</strong>！</p>\n<ul>\n<li>降低期望，先以回归为目标</li>\n<li>降低期望，前后端自动化测试都要有，一套解决不了问题</li>\n<li>降低期望，客户端自动化测试限制依然很多，人工测试验证不能全部丢下</li>\n<li>降低期望，一口吃不成个胖子，自动化测试也是需要慢慢迭代完善的，先跑通再关心验证异常case。快速迭代，逐步完善</li>\n</ul>\n<h4 id=\"4-术业有专攻\"><a href=\"#4-术业有专攻\" class=\"headerlink\" title=\"4.术业有专攻\"></a>4.术业有专攻</h4><p>也许你的团队里是开发或者测试中的某一方无法承受压力，从而开始探索App自动化测试。<br>开发去做自动化测试的优点在于因为有更丰富的开发经验，测试环境的搭建更为熟练，且因为是自己写的代码，会更了解风险点在哪里，能写出有针对性的case。测试去做自动化测试的优点在于发现更多的边界场景，写出更全面的测试case。</p>\n<p>在自动化测试上，开发和测试各具不同的优势，但同时这也是对方的劣势。</p>\n<p>测试case一定要越全面越好，而且自动化测试本身就是一个工程项目，在写脚本时，如果更多的考虑一些编程思想，合理的耦合和解耦，将会让之后的脚本编写更便捷。<br>所以，非常不建议自动化测试完全单独交给测试人员或开发人员来负责，最好是一种紧密合作的关系。<strong>同时也是应对资源不足的一个解决之道</strong>。虽是测试，但有开发的加入，会让测试工程朝着更优的方向发展。</p>\n<h4 id=\"5-一个巴掌拍不响\"><a href=\"#5-一个巴掌拍不响\" class=\"headerlink\" title=\"5.一个巴掌拍不响\"></a>5.一个巴掌拍不响</h4><p>首先再次明确我的一个观点：在没有足够的资源的情况下，移动客户端自动化测试，主要针对的应该是回归测试。</p>\n<p>自动化测试相比起人工测试，是非常死板的，那么就需要非常“死板”的数据支持.如果是App开发（就像我）去做自动化测试这件事，难道所有数据我都要mock一遍吗？虽说前后端自动化应该分开，前面也说了应该只关心前端逻辑。但一定还是要在真实的服务环境（测试环境，非生产环境）进行测试。<br>mock数据过于死板，很多case可能就无法验证了，比如注册场景，要验证注册过的账号无法再注册时的异常提示，mock数据显然较难兼顾正常注册和异常注册两种。而且在真实环境中测试，万一测出来一个后端bug不挺好么。<br>而且，手机淘宝这样完全2C的应用直接在生产环境测试好像没什么太大问题，但像蜂鸟配送这样半2C的应用来说就比较尴尬，直接去抢线上单明显不可能，那么在测试环境这个订单谁来发怎么发呢？</p>\n<p>所以这个时候你就不能自己单干了，去找测试同学，看能不能搞一个配合自动化测试的测试环境，拿抢单来说，我希望这个环境上永远有好多单让我抢。我就是抢单的app，没单我还玩什么。</p>\n<p>如果测试同学搞不定，那么就去拉后端的同学啦，我相信为了项目越来越好，他们是不会拒绝你的。</p>\n<p>自动化测试，不仅是自动化测试工具就够了，同样还需要测试环境的支持。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>其实说了这么多，就是想要你降低期望，并付诸行动。<br>App的自动化识别和多平台自然会有大批的自动化工具帮你实现，而学会降低期望的同时也会降低脚本开发和维护的难度。</p>\n<p>难道你还在纠结细分case太多的问题？先放一放又如何？反正你都裸奔这么久了，穿裤子不也要先穿个裤衩才行么，裤子慢慢来！<br>或者你依然徘徊在投入产出比的问题上？买衣服不也要先试穿才知道码号的吗？</p>\n<p>OK，下面我们聊聊这个裤衩，和怎么穿这个裤衩！</p>\n<h2 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h2><p>做好了思想工作，具体实现还是需要选择一个具体的测试工具，工具没有好坏，只有适不适合。<br>Calabash是我个人建议小微团队使用的测试工具，因为其兼具门槛低、跨平台、脚本维护容易的特性，而这正是小微团队最急需的。<br>且其BDD（行为驱动开发）的思想虽然有点乌托邦，但从远瞻的角度来看，实现测试脚本先于程序开发编写的这种先进项目管理可能性也大于其他工具，让测试不仅仅是测试！</p>\n<p>下面我会对Calabash的特性做一个简单介绍，详述其优缺点，你可以根据自身团队经验进行选择是否使用，如果喜欢，文末会附上Calabash由浅入深的入门教程，加之更详细的特性介绍和我自己的使用建议。</p>\n<h3 id=\"Calabash\"><a href=\"#Calabash\" class=\"headerlink\" title=\"Calabash\"></a>Calabash</h3><p>谈Calabash前，先要交代清楚Calabash是啥。</p>\n<p>Calabash的核心是Cucumber，Cucumber是一个能够用自然语言编写实例的协作工具，其核心思想是行为驱动开发（BDD），回归测试是其自然而然的副带结果。你可以简单的理解为Calabash-android 或 Calabash-iOS是在Cucumber上进行了一次扩展，从而可以对Android或iOS进行自动化测试。</p>\n<p>在解释一下BDD，我从网络摘了一段介绍：<em>你可以在Cucumber中编写用户场景，让它表现出业务规则而不仅仅是UI功能。这样你就能够让业务分析师加入这个过程，在编码工作开始前编写场景。程序员们就能够按照这个清晰的规范进行编码工作了。这种方式就是行为驱动开发（BDD）。</em></p>\n<p>OK，关于BDD我们就此打住，毕竟还是很未来的事情，下面我们聊点实在的。</p>\n<p>Calabash与appium，Espresso类似，都是通过脚本去操作界面，作出点击、滑动等操作，同时可以对界面的上UI组件进行一定识别。run起来就是那么回事，模拟控制手机。主要是脚本的编写上不同，我们来看一下Calabash的脚本，<strong>相信我，爱上它，就从看到它脚本开始</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Login feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 登录测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">  \tWhen I press view with id &quot;account_edit&quot;</span><br><span class=\"line\">  \tThen I enter &quot;15104053650流量&quot; into input field number 1</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I press &quot;发送验证码&quot;</span><br><span class=\"line\">  \tThen I wait for 5 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">  \tWhen I press view with id &quot;verifying_code_edit&quot;</span><br><span class=\"line\">  \tThen I enter &quot;306423&quot; into input field number 2</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I wait for 5 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I press view with id &quot;login_login&quot;</span><br></pre></td></tr></table></figure>\n<p>我觉得我不需要再解释这脚本的含义了，这就是大白话！！<br><strong>Calabash最大的魅力在于，将难以理解的编程语言转换为谁都可以看得懂得自然语言。从而降低学习门槛和维护难度。</strong><br><strong>特点1：极高的可读性</strong>，可读性越高的测试脚本，意义越大。当测试脚本的编写先于或与开发同步时，测试脚本也可以成为开发过程中的设计文档及参考手册。</p>\n<p>在可读性非常高的基础上，其编写难度也变得非常的低。<strong>特点2：语法简单易懂，谁都能写</strong>。</p>\n<p>同时可喜的是，这个代码同时支持Android 和iOS，web也有一定的支持！RN就更不用说了，跑起来的RN就是原生代码！WEEX还要再考察考察~在合理的解耦与耦合的情况下，Android 和iOS只需提供一套各自的View定位封装即可共用一套场景case脚本。<strong>特点3：支持多种平台，代码复用性强</strong>。</p>\n<p>一段使用自然语言编写的脚本，其底层当然要费一番功夫。上面我们看到一段测试用例是使用Calabash预定义的Steps写的一段测试用例。</p>\n<p>而这些大白话一样的Steps的实质是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I press &quot;([^\\&quot;]*)&quot;$/ do |identifier|  # ---方法名</span><br><span class=\"line\">  tap_when_element_exists(&quot;* marked:&apos;#&#123;identifier&#125;&apos;&quot;)  # ---方法体</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>很傻瓜的解释一下：你可以很简单的认为上面这一段是一个函数、一个方法。<br>第一行就是一个自然语言夹杂着正则符号的方法名，方法名随便起。第二行是用Ruby实现的方法体。<br>不要被这段代码吓到，在大部分时候，你都不需要接触到这些大白话的具体实现（Ruby语言），而是直接用大白话写小作文就好了。<br>预定义的Steps肯定不能满足我们的需求，所以Calabash灵活的支持<strong>不同程度自定义steps</strong>，样子大概就像上面那样，你可以简单理解为Calabash支持不同程度的，代码到自然语言的转换。最大程度的满足业务需求。<br>正是这种灵活的转换方式，让我们有了更多的想象：</p>\n<p><strong>特点4：Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的脚本开发人员</strong><br>再简单解释一下：先让一部分(实际情况可能是一个)人学起来，写出一个个大白话似的Steps。再接纳另一部分人进来，比如其他的开发或测试人员，甚至是产品经理！直接用这些大白话写测试case，熟悉了之后有想法的话再去学自定义Steps。甚至产品都不需要学自定义Steps,给开发提需求好了，当你有一个非常丰富的Steps库的时候，你所烦的无穷无尽的边界case，不过就是全民小作文~</p>\n<p><strong>特点5：自定义语法糖</strong><br>Steps的方法名定义完全自由，在带来可读性提高的同时也降低了Steps的记忆和脚本编写速度。但这其实完全依赖于你定义的规范，你完全可以自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。</p>\n<p>还有哦，如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？</p>\n<p><strong>特点6：维护简单，我不知道小作文维护起来有什么难的~</strong></p>\n<p><strong>特点7：case也有设计感，不在那么枯燥</strong><br>在加一个最起码我觉得很兴奋的特点，考虑复用的话，自定义的Steps就要考虑与业务的解耦问题了，有的要解耦有的却要耦合一点。而且如果为了最小程度修改代码从而保证Android iOS在代码上通用，Android和iOS的开发上就会有更多的交流，测试脚本的编写也会有更通用的设计。这里面就有设计的快感了。</p>\n<p><strong>特点8：除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook</strong></p>\n<p><strong>特点9：丰富的元素定位辅助方法。</strong><br>App自动化测试一个普遍的痛点就是元素定位，Calabash有非常多的元素定位辅助方法，且都较为简单且无脑。 </p>\n<p>最后我们在看一个从网上摘下来的一段Calabash脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature： 登陆</span><br><span class=\"line\"></span><br><span class=\"line\">　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\"></span><br><span class=\"line\">　　When 打开登陆页面</span><br><span class=\"line\">　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">　　And   点击登陆</span><br><span class=\"line\">　　Then  验证登陆成功</span><br></pre></td></tr></table></figure>\n<p>完全纯中文的脚本编写有木有？是不看起来屌屌的~恩，虽然博主自身并不建议这样纯中文的step定义，我们就看看，你只要知道Calabash很强大就行了。</p>\n<p>最后我们总结一下Calabash的大方向的优点：</p>\n<ul>\n<li>极高的可读性</li>\n<li>语法简单易懂，学习门槛低</li>\n<li>一种语言支持多种平台，代码复用性强</li>\n<li>Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的开发</li>\n<li>自定义语法糖</li>\n<li>小作文维护简单</li>\n<li>case也有设计感</li>\n<li>除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook</li>\n<li>非常多的元素定位辅助方法</li>\n<li>对代码无侵入性，纯黑盒测试。</li>\n<li>用Calabash搭一个自有的云测平台可行性很高</li>\n</ul>\n<p>这只是大方向的几个优点，文末会奉上Calabash的入门文章，更详细的介绍Calabash的各种特性，利用这些特性，你会发现Calabash有太多的想象。</p>\n<h3 id=\"Calabash缺点\"><a href=\"#Calabash缺点\" class=\"headerlink\" title=\"Calabash缺点\"></a>Calabash缺点</h3><p>说了那么多优点，缺点当然也是有的啦~我们吐槽一下</p>\n<h4 id=\"资料、Demo稀少\"><a href=\"#资料、Demo稀少\" class=\"headerlink\" title=\"资料、Demo稀少\"></a>资料、Demo稀少</h4><p>Calabash大概有五年以上的历史，最早的first commit是2012年2月份，对于一个技术工具来说，这已经可以算是很老了，但Calabash依然是一个小众产品，然后导致的问题是资料非常非常少……官方Github只给了很简单很基础的API，还基本没有Demo,(官方Demo就几行代码~) </p>\n<p>资料少也意味着后面有很多坑需要自己往过趟，不过有了文末的入门教程，快速上手应该是没问题啦~</p>\n<p>我大胆的怀疑了一下Calabash小众的原因，可能大厂还是更钟爱appium这种主流测试框架，毕竟语法复杂也意味着功能强大，而小厂呢，相比起维护一套自动化测试框架，不如就手点点人工测试好了，所以Calabash这样的，就处于一个很尴尬的位置了（这篇文章不就是让你破解这种尴尬的嘛！）</p>\n<h4 id=\"不支持跨进程\"><a href=\"#不支持跨进程\" class=\"headerlink\" title=\"不支持跨进程\"></a>不支持跨进程</h4><p>Calabash底层是Robotium，Robotium不支持跨进程操作，所以Calabash也不支持。当你跳出当前测试App时，calabash便无法响应并做任何操作了。<br>在个别需要跨进程调用业务较多的App中，这个点是很痛的，甚至基本上就可以放弃Calabash了。</p>\n<p>以蜂鸟众包为例，需要跨进程的业务有分享和拍照（拍照调用了系统相机），分享对于蜂鸟众包来说是一个很边界的业务，暂不讨论，但拍照影响到了主流程。<br>不过如果修改拍照为自定义相机，而是不调用系统相机的话，将不会存在这个问题，并且可以解决不同手机系统相机样式不同，脚本需要进行兼容的困扰。所以即使是为了测试而对业务代码做了这种程度的改动，也是值得的！</p>\n<p>另外通过最近研究发现，<strong>Calabash支持跨进程似乎也是有希望的！</strong>Espresso实现跨进程操作的方式是调用了uiautomator的API。而Calabash作为开源项目，想要修改其源码也是完全OK的。 以Android为例，其内部核心是通过java调用Robotium API实现的，所以我们只要修改其源码调用uiautomator的API即可实现跨进程。恩……实现思想是这样的，只是不知道官方为什么没有这样去做，具体情况还待研究……（2015年底之前Calabash相关的博客中可以很容易的找到修改其源码进行功能扩展的博客，但Calabash在2015年年底将Calabash的源码抽离到了另一个项目中，所以这些博客中提到方案便无法使用了，后续的具体实现方式还待研究，详情会在文末的教程中提到）</p>\n<h4 id=\"不够严谨的自然语言\"><a href=\"#不够严谨的自然语言\" class=\"headerlink\" title=\"不够严谨的自然语言\"></a>不够严谨的自然语言</h4><p>可能大部分人会对Calabash这样的自然语言抱有怀疑，认为Calabash这样Cucumber风格的语言（就是上面的我们看到的测试脚本）不够严谨。无法向代码那样简练且规范严格，在某种程度也降低了编写速度，且非常不够严谨易错度高！</p>\n<p>首先要澄清一点的是，Java、Python等隶属编程语言，而Cucumber风格的脚本更倾向于是一种描述性语言。他们是两种不同的领域。</p>\n<p>所以不能站在编程语言的角度去要求Cucumber风格的脚本的严谨程度，而“严谨”也不过是作为编程人员的一种惯性思维。</p>\n<p>而从记忆与编写速度考虑，还记得我们上面曾说到的语法糖吗？不恰当的定义Steps确实会导致这样的问题。举个例子吧</p>\n<pre><code>#我跳过欢迎界面\nThen I skip welcome page\n#我完成登录操作\nThen I have finished the login\n</code></pre><p>上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：</p>\n<pre><code>#我跳过欢迎界面\nThen I pass &quot;welcome&quot; scenario\n#我完成登录操作\nThen I pass &quot;login&quot; scenario\n</code></pre><p>两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。</p>\n<p>当然，确实是因为Calabash过于宽松的语法，导致这个致命的缺点需要通过严格的管理进行约束，稍有不慎会埋有祸根。所以这确实是Calabash的缺点之一。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>最后，虽然我个人建议使用Calabash，但对于小微团队，<strong>合适的才是最好的！</strong> 资源紧张情况下想要实行自动化测试，我的建议是在提高人效的基础上调动更多的人力来分摊压力。那么这对低学习门槛和低推广成本的要求就会很高，所以学习门槛和推广成本应该是你选择自动化工具最需要考察的点。</p>\n<p>正是因为Calabash的特性非常契合这两点，我才会极力推荐，同时如果你想在未来的某一天尝试一下BDD这种思想，或者想让产品经理参与到这个环节做一些尝试，同样是非常建议使用Calabash的。当然如果你有较为宽松的资源、或者追求更加工程化的自动化测试，还可以选择Appium这样主流的测试工具。还是那句话：<strong>合适的才是最好的！</strong></p>\n<p>最后，奉上Calabash的入门博客：</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇博客，我会站在小微团队的角度，介绍一下我对App自动化测试的一些看法。在帮助你降低对App自动化测试的期望的同时说服你开始实践App自动化测试。</p>","more":"<p>App自动化测试一直是小微团队很少会去涉足的领域，在互联网快速迭代这个大场景下，随着业务发展，回归压力逐渐增大。相信每次因为回归覆盖不足而导致线上事故，懊恼郁闷到要砸桌子的绝对不止我一个。</p>\n<p>一般情况小微团队的测试包括回归测试都是人工进行的，一些偏离主流程却又比较关键的业务往往是人工回归测试容易遗漏的。人力有穷尽，这个时候自动化测试这个念头就从你的脑袋里冒出来了，然后就是去研究嘛。但可能最终也就止步于研究了。不谈自动化框架的搭建，种种细分的边界case,一个必然很繁琐的东西想一想就更繁琐了。如果你是App开发，本来业务开发上的人手就不是很充足，再去开发自动化脚本，有心无力！如果你是测试，每个迭代的业务需求测试就填满了你的排期，更何况承担的可不只是App测试任务。作为小微团队，自动化我们也想，但我们没有资源……</p>\n<p>首先我们要明白App自动化测试并没有你预想中的那么强大，但如果你像我一样面临着回归测试痛点，它绝对可以满足你的需求。没有那么强大，所以也没有你预想中的那么复杂，同时它的参与者也绝不只应限制在Tester或Developer上，所以在资源上你可以有更灵活的调配。当然，自动化测试是一个长期的过程，它的未来，也绝不仅是回归……</p>\n<p>最后我会为你安利一款偏冷的自动化测试工具：Calabash。并奉上Calabash入门教程博客和一点我的使用心得。介绍Calabash，是因为Calabash的特性在我个人看来更为适合资源紧缺的小微团队。</p>\n<h2 id=\"大话App自动化测试\"><a href=\"#大话App自动化测试\" class=\"headerlink\" title=\"大话App自动化测试\"></a>大话App自动化测试</h2><p>仅代表个人观点，见识还浅，欢迎多多打脸。</p>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p>先说点大家都知道的。以Android为例，从2010年开始，Android开发环境以及其迅猛的态势发展到今天，几近趋于成熟，开发者的目光早已不在局限于这单一的开发平台，开始寻求Android，iOS在开发上的统一：ReactNactive,WEEX,H5……</p>\n<p>开发环境已经成熟，但移动客户端的测试环境却有些滞后。这中间的几座大山是很多团队正在面对且驻足的：</p>\n<p>1.App测试不像服务端测试通常只需对数据本身进行验证即可，App涉及到界面展示及交互，自动化识别难度大。<br>2.互联网企业一直都在追寻快速迭代，且App直接对接用户，App的界面与逻辑变更更是家常便饭，编写自动化测试脚本的稳定性很差，可能设计对界面的一次改动，之前与这个页面挂钩的所有脚本就都废掉了。<br>3.Android iOS 双平台,web页面。多平台的情况下想要依靠一套代码进行自动化测试几乎是不可能的。再考虑需要经常变更，你懂得。<br>4.比起人工来说，自动化测试可能需要为种种边界case编写很多的脚本。同比人工测试，可能需要的只是事先设计几个场景，其他的异常边界case通过测试中人为观察就好了。自动化测试成本倍增！</p>\n<p>所以往往一个完善的移动自动化测试环境需要一个庞大的测试团队支撑，但一个庞大的测试团队只有大公司才能负担的起。移动的自动化测试，一直都在被中小型的创业公司所忽略。小型公司开发自测了事，中型公司依靠测试人员人工操作进行验证。</p>\n<p>自动化测试真的对于小微团队紧闭大门吗？</p>\n<h3 id=\"Just-do-it\"><a href=\"#Just-do-it\" class=\"headerlink\" title=\"Just do it\"></a>Just do it</h3><p>上面说的这些现状只能说是难题，也许现在讨论解决这些问题还早了些。我觉得你有些东西还没确定清楚，要不然先跟着我的思路走一走？等下面一些事情都想明白了，也许这些问题能避也就避过了，需要硬上的，也有足够心理准备了。</p>\n<h4 id=\"1-设定阶段计划试错\"><a href=\"#1-设定阶段计划试错\" class=\"headerlink\" title=\"1.设定阶段计划试错\"></a>1.设定阶段计划试错</h4><p>其实让小微团队面对自动化测试左右徘徊最大的一个问题就是：投入产出比！<br>很难去预估实行自动化测试后，在页面频繁变更与脚本的开发和维护之间，测试或开发人员会不会陷入泥潭。</p>\n<p>但纸上谈兵永远也不会有结果，其他大公司的借鉴意义也不是很强，因为这涉及到团队、资源分配、业务变更频度、测试工具、脚本开发的解耦程度等等。不过自动化测试是一个必然的趋势，所以行动是最首要的！</p>\n<p>你的团队目前到底适不适合，只有试了才知道。不妨先设定几个阶段，然后用第一阶段试错：</p>\n<p><strong>阶段1</strong>：抽出一个人一个迭代的资源完成主流程业务的自动化测试case，试运行两到三个迭代，并在这期间增加主流程异常case。利用这三个迭代来评估后续发展可行性！<br><strong>阶段2-（阶段1成功度过）</strong>：如果你认为阶段1的状态还不错，那么在维护阶段1成果的基础上从剩余业务场景中按照业务关键程度、变更频率来选取一个新的业务，以一个人一个迭代一个业务的节奏编写自动化测试case！<br><strong>阶段2-（阶段1过度失败）</strong>：当然，经过三个迭代的评估，随着异常case增多，同步维护难度越来越大，你可能认为实行自动化测试的成本过大，但也不要轻易放弃这三个迭代的成果。请先利用编程思维检查所有的测试脚本，是否有抽取相似代码，封装特定View操作，抽离与业务无关指令的可能。同时考虑利用全组资源就此维护这套主流程自动化case。直到将来资源充足或找到更好的替代方案后进行阶段3或重新阶段1。<br><strong>阶段3</strong>：大概在5~8个迭代后，你成功撑过了阶段2，说明你的自动化测试环境已经步入正轨，那么这个时候可以按照团队资源情况适当加快自动化case覆盖率！</p>\n<p>利用一人一个迭代的资源进行试错，相信是你可以接受的一个损失。当然，先不要急着做，你也许只是决定了要进行自动化测试，但还是要定一些详细的计划和一些思想、实际行动上的准备！</p>\n<h4 id=\"2-确定明确且简单的目标\"><a href=\"#2-确定明确且简单的目标\" class=\"headerlink\" title=\"2.确定明确且简单的目标\"></a>2.确定明确且简单的目标</h4><p>有了大的计划，还要明确具体的需求，可选的需求大概有这么些：</p>\n<p><strong>1.黑盒测试还是白盒测试</strong><br>虽然是UI自动化测试，但也可以分为黑盒或白盒，这个取决你想要的测试精密度，也就是在这个时候，可以初步确定要使用什么自动化测试工具。比如通常我们为了可以双平台会选择Appium这种可以跨平台的测试工具，但假如你有很高的测试要求，以Android为例，建议你使用Android官方推荐的测试框架：Espresso，直接在Android工程项目中写Test。<br>这样说出来好像谁都明白，但如果你不能在前期就明确你的需求，可能会在后期带来很大的困扰！选择Appium，因为是黑盒，遇到某些特殊的场景或需求，导致个别case无法测试。或者选择了Espresso，但后来发现其实并没有那么精密的测试需求，导致后期无法跨平台或者认为Espresso编写成本过高，还很难移交给测试团队。</p>\n<p><strong>2.前端UI还是整体业务</strong><br>举个例子，抢单并且进行配送这个场景。发现一个订单并点击抢单，然后进行取餐，最后完成配送这一套只能用肉眼观察到的UI层操作，我们暂定为这是前端UI逻辑。但在这一系列操作背后订单状态流转引起其他数据变动，比如：钱包数据变更，活动奖励数据变更，欺诈单判定等等这个范围，就属于整体业务范畴了。<br>而我们需要现在确定的，就是你想要达到的测试期望是UI测试，还是整体业务测试。这直接决定了你测试脚本的复杂度。而我的建议是仅测UI逻辑，也是我想让你降低期望一个点。</p>\n<p>先确定一个明确且简单的目标，然后一头扎进去。如果想的多了，困难也就多了，最后可能也就只是想想了，这就是下面紧接着要说的点：<strong>降低期望</strong>！</p>\n<h4 id=\"3-降低期望\"><a href=\"#3-降低期望\" class=\"headerlink\" title=\"3.降低期望\"></a>3.降低期望</h4><p>在人工（对着手机点点点）测试的环境下，我们通常都是通过操作App进行各种case验证，只要操作app验证通过了那基本可以确定前后端没什么问题了。但这个前提是人工验证是人脑加肉眼，它会有更准确的主观判断。<br>涉及到前后端交互会增加极大的复杂性，你的测试case不会无限多无限精细，但作为人脑你可以在有限的case执行中发现更多不符合常理的bug：文字不合理的折行，不准确的数值显示，按钮颜色不对，Toast展示数量有误等等等。自动化测试会死板的跟着你写的脚本走，你能保证你的case覆盖到了所有了吗？</p>\n<p>这也是谈到自动化测试，好多人都会抛出的一个疑问，那么多异常case怎么写啊，想想都累，考虑一下投入产出比要不还是人工测试吧。</p>\n<p>首先要明确的一点，前后端自动化测试一定要分开，一套解决不了问题，这样在前端测试中可以忽略很多的case。<br>另外自动化测试是一个与项目成长一样的长期过程，自动化完全代替人工依然还需要走一段时间，你不要想着一步到位。<br>依然还是会有很多的case要写对吧？资源不够我们可以先跑通主流程再说，跑通主流程也就意味着脚本依赖（环境搭建，view定位）已经较为成熟了，其他异常case脚本对着主流程脚本修改即可，这个我们慢慢来嘛，而且这个时候你就可以放开给别的开发或测试让他们照猫画虎了。这也就是我们上面说的<strong>阶段1</strong>。</p>\n<p>如果这些问题不能想通，你会发现在App自动化测试条件有限的情况下，并不能实现你想要的结果，从而迫于压力而放弃了。<strong>说服自己降低期望</strong>！</p>\n<ul>\n<li>降低期望，先以回归为目标</li>\n<li>降低期望，前后端自动化测试都要有，一套解决不了问题</li>\n<li>降低期望，客户端自动化测试限制依然很多，人工测试验证不能全部丢下</li>\n<li>降低期望，一口吃不成个胖子，自动化测试也是需要慢慢迭代完善的，先跑通再关心验证异常case。快速迭代，逐步完善</li>\n</ul>\n<h4 id=\"4-术业有专攻\"><a href=\"#4-术业有专攻\" class=\"headerlink\" title=\"4.术业有专攻\"></a>4.术业有专攻</h4><p>也许你的团队里是开发或者测试中的某一方无法承受压力，从而开始探索App自动化测试。<br>开发去做自动化测试的优点在于因为有更丰富的开发经验，测试环境的搭建更为熟练，且因为是自己写的代码，会更了解风险点在哪里，能写出有针对性的case。测试去做自动化测试的优点在于发现更多的边界场景，写出更全面的测试case。</p>\n<p>在自动化测试上，开发和测试各具不同的优势，但同时这也是对方的劣势。</p>\n<p>测试case一定要越全面越好，而且自动化测试本身就是一个工程项目，在写脚本时，如果更多的考虑一些编程思想，合理的耦合和解耦，将会让之后的脚本编写更便捷。<br>所以，非常不建议自动化测试完全单独交给测试人员或开发人员来负责，最好是一种紧密合作的关系。<strong>同时也是应对资源不足的一个解决之道</strong>。虽是测试，但有开发的加入，会让测试工程朝着更优的方向发展。</p>\n<h4 id=\"5-一个巴掌拍不响\"><a href=\"#5-一个巴掌拍不响\" class=\"headerlink\" title=\"5.一个巴掌拍不响\"></a>5.一个巴掌拍不响</h4><p>首先再次明确我的一个观点：在没有足够的资源的情况下，移动客户端自动化测试，主要针对的应该是回归测试。</p>\n<p>自动化测试相比起人工测试，是非常死板的，那么就需要非常“死板”的数据支持.如果是App开发（就像我）去做自动化测试这件事，难道所有数据我都要mock一遍吗？虽说前后端自动化应该分开，前面也说了应该只关心前端逻辑。但一定还是要在真实的服务环境（测试环境，非生产环境）进行测试。<br>mock数据过于死板，很多case可能就无法验证了，比如注册场景，要验证注册过的账号无法再注册时的异常提示，mock数据显然较难兼顾正常注册和异常注册两种。而且在真实环境中测试，万一测出来一个后端bug不挺好么。<br>而且，手机淘宝这样完全2C的应用直接在生产环境测试好像没什么太大问题，但像蜂鸟配送这样半2C的应用来说就比较尴尬，直接去抢线上单明显不可能，那么在测试环境这个订单谁来发怎么发呢？</p>\n<p>所以这个时候你就不能自己单干了，去找测试同学，看能不能搞一个配合自动化测试的测试环境，拿抢单来说，我希望这个环境上永远有好多单让我抢。我就是抢单的app，没单我还玩什么。</p>\n<p>如果测试同学搞不定，那么就去拉后端的同学啦，我相信为了项目越来越好，他们是不会拒绝你的。</p>\n<p>自动化测试，不仅是自动化测试工具就够了，同样还需要测试环境的支持。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>其实说了这么多，就是想要你降低期望，并付诸行动。<br>App的自动化识别和多平台自然会有大批的自动化工具帮你实现，而学会降低期望的同时也会降低脚本开发和维护的难度。</p>\n<p>难道你还在纠结细分case太多的问题？先放一放又如何？反正你都裸奔这么久了，穿裤子不也要先穿个裤衩才行么，裤子慢慢来！<br>或者你依然徘徊在投入产出比的问题上？买衣服不也要先试穿才知道码号的吗？</p>\n<p>OK，下面我们聊聊这个裤衩，和怎么穿这个裤衩！</p>\n<h2 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h2><p>做好了思想工作，具体实现还是需要选择一个具体的测试工具，工具没有好坏，只有适不适合。<br>Calabash是我个人建议小微团队使用的测试工具，因为其兼具门槛低、跨平台、脚本维护容易的特性，而这正是小微团队最急需的。<br>且其BDD（行为驱动开发）的思想虽然有点乌托邦，但从远瞻的角度来看，实现测试脚本先于程序开发编写的这种先进项目管理可能性也大于其他工具，让测试不仅仅是测试！</p>\n<p>下面我会对Calabash的特性做一个简单介绍，详述其优缺点，你可以根据自身团队经验进行选择是否使用，如果喜欢，文末会附上Calabash由浅入深的入门教程，加之更详细的特性介绍和我自己的使用建议。</p>\n<h3 id=\"Calabash\"><a href=\"#Calabash\" class=\"headerlink\" title=\"Calabash\"></a>Calabash</h3><p>谈Calabash前，先要交代清楚Calabash是啥。</p>\n<p>Calabash的核心是Cucumber，Cucumber是一个能够用自然语言编写实例的协作工具，其核心思想是行为驱动开发（BDD），回归测试是其自然而然的副带结果。你可以简单的理解为Calabash-android 或 Calabash-iOS是在Cucumber上进行了一次扩展，从而可以对Android或iOS进行自动化测试。</p>\n<p>在解释一下BDD，我从网络摘了一段介绍：<em>你可以在Cucumber中编写用户场景，让它表现出业务规则而不仅仅是UI功能。这样你就能够让业务分析师加入这个过程，在编码工作开始前编写场景。程序员们就能够按照这个清晰的规范进行编码工作了。这种方式就是行为驱动开发（BDD）。</em></p>\n<p>OK，关于BDD我们就此打住，毕竟还是很未来的事情，下面我们聊点实在的。</p>\n<p>Calabash与appium，Espresso类似，都是通过脚本去操作界面，作出点击、滑动等操作，同时可以对界面的上UI组件进行一定识别。run起来就是那么回事，模拟控制手机。主要是脚本的编写上不同，我们来看一下Calabash的脚本，<strong>相信我，爱上它，就从看到它脚本开始</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature: Login feature</span><br><span class=\"line\"></span><br><span class=\"line\">  Scenario: 登录测试用例</span><br><span class=\"line\"></span><br><span class=\"line\">  \tWhen I press view with id &quot;account_edit&quot;</span><br><span class=\"line\">  \tThen I enter &quot;15104053650流量&quot; into input field number 1</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I press &quot;发送验证码&quot;</span><br><span class=\"line\">  \tThen I wait for 5 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">  \tWhen I press view with id &quot;verifying_code_edit&quot;</span><br><span class=\"line\">  \tThen I enter &quot;306423&quot; into input field number 2</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I wait for 5 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">  \tThen I press view with id &quot;login_login&quot;</span><br></pre></td></tr></table></figure>\n<p>我觉得我不需要再解释这脚本的含义了，这就是大白话！！<br><strong>Calabash最大的魅力在于，将难以理解的编程语言转换为谁都可以看得懂得自然语言。从而降低学习门槛和维护难度。</strong><br><strong>特点1：极高的可读性</strong>，可读性越高的测试脚本，意义越大。当测试脚本的编写先于或与开发同步时，测试脚本也可以成为开发过程中的设计文档及参考手册。</p>\n<p>在可读性非常高的基础上，其编写难度也变得非常的低。<strong>特点2：语法简单易懂，谁都能写</strong>。</p>\n<p>同时可喜的是，这个代码同时支持Android 和iOS，web也有一定的支持！RN就更不用说了，跑起来的RN就是原生代码！WEEX还要再考察考察~在合理的解耦与耦合的情况下，Android 和iOS只需提供一套各自的View定位封装即可共用一套场景case脚本。<strong>特点3：支持多种平台，代码复用性强</strong>。</p>\n<p>一段使用自然语言编写的脚本，其底层当然要费一番功夫。上面我们看到一段测试用例是使用Calabash预定义的Steps写的一段测试用例。</p>\n<p>而这些大白话一样的Steps的实质是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Then /^I press &quot;([^\\&quot;]*)&quot;$/ do |identifier|  # ---方法名</span><br><span class=\"line\">  tap_when_element_exists(&quot;* marked:&apos;#&#123;identifier&#125;&apos;&quot;)  # ---方法体</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>很傻瓜的解释一下：你可以很简单的认为上面这一段是一个函数、一个方法。<br>第一行就是一个自然语言夹杂着正则符号的方法名，方法名随便起。第二行是用Ruby实现的方法体。<br>不要被这段代码吓到，在大部分时候，你都不需要接触到这些大白话的具体实现（Ruby语言），而是直接用大白话写小作文就好了。<br>预定义的Steps肯定不能满足我们的需求，所以Calabash灵活的支持<strong>不同程度自定义steps</strong>，样子大概就像上面那样，你可以简单理解为Calabash支持不同程度的，代码到自然语言的转换。最大程度的满足业务需求。<br>正是这种灵活的转换方式，让我们有了更多的想象：</p>\n<p><strong>特点4：Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的脚本开发人员</strong><br>再简单解释一下：先让一部分(实际情况可能是一个)人学起来，写出一个个大白话似的Steps。再接纳另一部分人进来，比如其他的开发或测试人员，甚至是产品经理！直接用这些大白话写测试case，熟悉了之后有想法的话再去学自定义Steps。甚至产品都不需要学自定义Steps,给开发提需求好了，当你有一个非常丰富的Steps库的时候，你所烦的无穷无尽的边界case，不过就是全民小作文~</p>\n<p><strong>特点5：自定义语法糖</strong><br>Steps的方法名定义完全自由，在带来可读性提高的同时也降低了Steps的记忆和脚本编写速度。但这其实完全依赖于你定义的规范，你完全可以自定义一套符合大多数人习惯的语法糖，从而在保证可读性的同时固化大部分指令格式，提高Steps的记忆和脚本编写速度。</p>\n<p>还有哦，如果你一直抱怨现在正在使用的某种语言的某个语法多么的没人性，使用体验糟糕透顶！现在好了，做好开发一套属于自己的语言的准备了嘛？</p>\n<p><strong>特点6：维护简单，我不知道小作文维护起来有什么难的~</strong></p>\n<p><strong>特点7：case也有设计感，不在那么枯燥</strong><br>在加一个最起码我觉得很兴奋的特点，考虑复用的话，自定义的Steps就要考虑与业务的解耦问题了，有的要解耦有的却要耦合一点。而且如果为了最小程度修改代码从而保证Android iOS在代码上通用，Android和iOS的开发上就会有更多的交流，测试脚本的编写也会有更通用的设计。这里面就有设计的快感了。</p>\n<p><strong>特点8：除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook</strong></p>\n<p><strong>特点9：丰富的元素定位辅助方法。</strong><br>App自动化测试一个普遍的痛点就是元素定位，Calabash有非常多的元素定位辅助方法，且都较为简单且无脑。 </p>\n<p>最后我们在看一个从网上摘下来的一段Calabash脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Feature： 登陆</span><br><span class=\"line\"></span><br><span class=\"line\">　　Scenario： 输入正确的用户名密码能够正常登陆</span><br><span class=\"line\"></span><br><span class=\"line\">　　When 打开登陆页面</span><br><span class=\"line\">　　And    输入用户名XXX输入密码XXX</span><br><span class=\"line\">　　And   点击登陆</span><br><span class=\"line\">　　Then  验证登陆成功</span><br></pre></td></tr></table></figure>\n<p>完全纯中文的脚本编写有木有？是不看起来屌屌的~恩，虽然博主自身并不建议这样纯中文的step定义，我们就看看，你只要知道Calabash很强大就行了。</p>\n<p>最后我们总结一下Calabash的大方向的优点：</p>\n<ul>\n<li>极高的可读性</li>\n<li>语法简单易懂，学习门槛低</li>\n<li>一种语言支持多种平台，代码复用性强</li>\n<li>Steps的开发与脚本的开发解耦分离，降低入门门槛，容纳更多的开发</li>\n<li>自定义语法糖</li>\n<li>小作文维护简单</li>\n<li>case也有设计感</li>\n<li>除模拟事件以外，Calabash还支持各种hook，如App生命周期的hook</li>\n<li>非常多的元素定位辅助方法</li>\n<li>对代码无侵入性，纯黑盒测试。</li>\n<li>用Calabash搭一个自有的云测平台可行性很高</li>\n</ul>\n<p>这只是大方向的几个优点，文末会奉上Calabash的入门文章，更详细的介绍Calabash的各种特性，利用这些特性，你会发现Calabash有太多的想象。</p>\n<h3 id=\"Calabash缺点\"><a href=\"#Calabash缺点\" class=\"headerlink\" title=\"Calabash缺点\"></a>Calabash缺点</h3><p>说了那么多优点，缺点当然也是有的啦~我们吐槽一下</p>\n<h4 id=\"资料、Demo稀少\"><a href=\"#资料、Demo稀少\" class=\"headerlink\" title=\"资料、Demo稀少\"></a>资料、Demo稀少</h4><p>Calabash大概有五年以上的历史，最早的first commit是2012年2月份，对于一个技术工具来说，这已经可以算是很老了，但Calabash依然是一个小众产品，然后导致的问题是资料非常非常少……官方Github只给了很简单很基础的API，还基本没有Demo,(官方Demo就几行代码~) </p>\n<p>资料少也意味着后面有很多坑需要自己往过趟，不过有了文末的入门教程，快速上手应该是没问题啦~</p>\n<p>我大胆的怀疑了一下Calabash小众的原因，可能大厂还是更钟爱appium这种主流测试框架，毕竟语法复杂也意味着功能强大，而小厂呢，相比起维护一套自动化测试框架，不如就手点点人工测试好了，所以Calabash这样的，就处于一个很尴尬的位置了（这篇文章不就是让你破解这种尴尬的嘛！）</p>\n<h4 id=\"不支持跨进程\"><a href=\"#不支持跨进程\" class=\"headerlink\" title=\"不支持跨进程\"></a>不支持跨进程</h4><p>Calabash底层是Robotium，Robotium不支持跨进程操作，所以Calabash也不支持。当你跳出当前测试App时，calabash便无法响应并做任何操作了。<br>在个别需要跨进程调用业务较多的App中，这个点是很痛的，甚至基本上就可以放弃Calabash了。</p>\n<p>以蜂鸟众包为例，需要跨进程的业务有分享和拍照（拍照调用了系统相机），分享对于蜂鸟众包来说是一个很边界的业务，暂不讨论，但拍照影响到了主流程。<br>不过如果修改拍照为自定义相机，而是不调用系统相机的话，将不会存在这个问题，并且可以解决不同手机系统相机样式不同，脚本需要进行兼容的困扰。所以即使是为了测试而对业务代码做了这种程度的改动，也是值得的！</p>\n<p>另外通过最近研究发现，<strong>Calabash支持跨进程似乎也是有希望的！</strong>Espresso实现跨进程操作的方式是调用了uiautomator的API。而Calabash作为开源项目，想要修改其源码也是完全OK的。 以Android为例，其内部核心是通过java调用Robotium API实现的，所以我们只要修改其源码调用uiautomator的API即可实现跨进程。恩……实现思想是这样的，只是不知道官方为什么没有这样去做，具体情况还待研究……（2015年底之前Calabash相关的博客中可以很容易的找到修改其源码进行功能扩展的博客，但Calabash在2015年年底将Calabash的源码抽离到了另一个项目中，所以这些博客中提到方案便无法使用了，后续的具体实现方式还待研究，详情会在文末的教程中提到）</p>\n<h4 id=\"不够严谨的自然语言\"><a href=\"#不够严谨的自然语言\" class=\"headerlink\" title=\"不够严谨的自然语言\"></a>不够严谨的自然语言</h4><p>可能大部分人会对Calabash这样的自然语言抱有怀疑，认为Calabash这样Cucumber风格的语言（就是上面的我们看到的测试脚本）不够严谨。无法向代码那样简练且规范严格，在某种程度也降低了编写速度，且非常不够严谨易错度高！</p>\n<p>首先要澄清一点的是，Java、Python等隶属编程语言，而Cucumber风格的脚本更倾向于是一种描述性语言。他们是两种不同的领域。</p>\n<p>所以不能站在编程语言的角度去要求Cucumber风格的脚本的严谨程度，而“严谨”也不过是作为编程人员的一种惯性思维。</p>\n<p>而从记忆与编写速度考虑，还记得我们上面曾说到的语法糖吗？不恰当的定义Steps确实会导致这样的问题。举个例子吧</p>\n<pre><code>#我跳过欢迎界面\nThen I skip welcome page\n#我完成登录操作\nThen I have finished the login\n</code></pre><p>上面是两个滥用自然语言特性的自定义操作。如果你的所有测试脚本都是这样写的，虽然读起来没有问题，但写起来就完全离不开文档了。下面看一下较为建议的写法：</p>\n<pre><code>#我跳过欢迎界面\nThen I pass &quot;welcome&quot; scenario\n#我完成登录操作\nThen I pass &quot;login&quot; scenario\n</code></pre><p>两个Steps的实际含义其实仅只是直接通过某种操作，如果我们规范的定义适合自己的语法糖，非常杂乱的脚本将变得很有规律可循，保证可读性的同时你只需记住几个特定的指令，从而提高脚本编写速度。</p>\n<p>当然，确实是因为Calabash过于宽松的语法，导致这个致命的缺点需要通过严格的管理进行约束，稍有不慎会埋有祸根。所以这确实是Calabash的缺点之一。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>最后，虽然我个人建议使用Calabash，但对于小微团队，<strong>合适的才是最好的！</strong> 资源紧张情况下想要实行自动化测试，我的建议是在提高人效的基础上调动更多的人力来分摊压力。那么这对低学习门槛和低推广成本的要求就会很高，所以学习门槛和推广成本应该是你选择自动化工具最需要考察的点。</p>\n<p>正是因为Calabash的特性非常契合这两点，我才会极力推荐，同时如果你想在未来的某一天尝试一下BDD这种思想，或者想让产品经理参与到这个环节做一些尝试，同样是非常建议使用Calabash的。当然如果你有较为宽松的资源、或者追求更加工程化的自动化测试，还可以选择Appium这样主流的测试工具。还是那句话：<strong>合适的才是最好的！</strong></p>\n<p>最后，奉上Calabash的入门博客：</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/20/Calabash探索1-Run%20Calabash/\">《Calabash探索1-Run Calabash》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/18/Calabash探索2-Calabash用法详解/\">《Calabash探索2-Calabash用法详解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/17/Calabash探索3-Calabash进阶/\">《Calabash探索3-Calabash进阶》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2017/03/16/Calabash探索4-Calabash踩坑总结/\">《Calabash探索4-Calabash踩坑总结》</a></p>"},{"title":"小米神隐模式破解（反系统息屏后网络中断）","date":"2016-01-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n*android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓*\n\n### 背景\n\n  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。\n  \n  在手机息屏后，未加入白名单的应用将会被禁止访问网络。\n  \n  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。\n  \n  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!\n  \n  <!-- more -->\n  \n  \"我们联系下MIUI官方，把我们默认加白名单行不行？\"\t\n  \n  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”\n  \n  “让设计做引导页”\n  \n  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”\n  \n  \n  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）\n  \n **完了，你说怎么办吧？**\n \n **注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！**\n \n **所以我们这里讨论的是，使用alarmManager做定时任务的情况**\n \n### 解决思路\n\n#### 方案1\n\n提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！\n\n额~既然这么简单，那还叫问题吗？\n\n事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。\n\n\n\n#### 方案2\n\nOK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？\n\n1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。\n\n2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。  \n\t点亮代码是这个：\n\t\n\t\tPowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n                AliveApplication.getContext().POWER_SERVICE);\n    \tPowerManager.WakeLock mWakelock = pm.newWakeLock(\n                PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, \"target\");\n    \tmWakelock.acquire();\n    \tmWakelock.release();\n\n\t\t//记得权限\n\t\t<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n\n\t没错，还是PowerManager ，但换了一个参数：\n\n\t\tPowerManager.SCREEN_DIM_WAKE_LOCK\n\t\n\t奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n\n3 ： PowerManager的几个参数及解释：\n\n\t\t//保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    \tPARTIAL_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    \tSCREEN_DIM_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    \tSCREEN_BRIGHT_WAKE_LOCK\n    \t//保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    \tFULL_WAKE_LOCK\n    \t/**\n     \t * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n     \t * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n     \t * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n     \t */\n    \tACQUIRE_CAUSES_WAKEUP\n    \t/**\n     \t * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n     \t * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n    \t */\n    \tON_AFTER_RELEASE\n\n\t结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n\t\n4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！\n\n最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 \n\t\n一个有趣的现象，不知道是系统差别还是Android版本差别。\n\t\n魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。\n\t\n酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。\n\t\n暂时只测试了这两款机器。\n\t\n到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了\n\t\n### 保证用户体验下的解决方案\n- 1.监听网络请求失败后做点亮准备。注意是**“准备“**”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。\n\n- 2.准备后，先做请求积累，当到一个**临界值**时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。\n\n- 3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，**监听屏幕点亮广播**，在用户手动点亮、其他应用点亮时做网络请求\n\n- 4.如果你的请求真的很急切，且**略有些频繁**，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。\n\n- 5.如果你的需求迫切到，**必须定时定点**，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。\n\n- 6.**白名单导航页**还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。\n\n- 7.**公关**也是要的，如果可以直接被系统默认收进白名单皆大欢喜\n\n- 8.记得**区分**是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！\n\n- 9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。\n\n- 10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！\n\n\n\n### 示例代码\n\n最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~\n\n[https://github.com/lizhaoxuan/IamAlive](https://github.com/lizhaoxuan/IamAlive)\n\n对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^\n\n\n\n\n\n\n\n\n\n\n \n","source":"_posts/shenyingpojie.md","raw":"---\ntitle: 小米神隐模式破解（反系统息屏后网络中断）\ndate: 2016-01-17 16:20:58\nauthor : 暴打小女孩\n\ntags: 开发经验\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n*android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓*\n\n### 背景\n\n  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。\n  \n  在手机息屏后，未加入白名单的应用将会被禁止访问网络。\n  \n  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。\n  \n  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!\n  \n  <!-- more -->\n  \n  \"我们联系下MIUI官方，把我们默认加白名单行不行？\"\t\n  \n  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”\n  \n  “让设计做引导页”\n  \n  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”\n  \n  \n  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）\n  \n **完了，你说怎么办吧？**\n \n **注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！**\n \n **所以我们这里讨论的是，使用alarmManager做定时任务的情况**\n \n### 解决思路\n\n#### 方案1\n\n提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！\n\n额~既然这么简单，那还叫问题吗？\n\n事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。\n\n\n\n#### 方案2\n\nOK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？\n\n1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。\n\n2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。  \n\t点亮代码是这个：\n\t\n\t\tPowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n                AliveApplication.getContext().POWER_SERVICE);\n    \tPowerManager.WakeLock mWakelock = pm.newWakeLock(\n                PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, \"target\");\n    \tmWakelock.acquire();\n    \tmWakelock.release();\n\n\t\t//记得权限\n\t\t<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n\n\t没错，还是PowerManager ，但换了一个参数：\n\n\t\tPowerManager.SCREEN_DIM_WAKE_LOCK\n\t\n\t奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n\n3 ： PowerManager的几个参数及解释：\n\n\t\t//保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    \tPARTIAL_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    \tSCREEN_DIM_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    \tSCREEN_BRIGHT_WAKE_LOCK\n    \t//保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    \tFULL_WAKE_LOCK\n    \t/**\n     \t * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n     \t * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n     \t * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n     \t */\n    \tACQUIRE_CAUSES_WAKEUP\n    \t/**\n     \t * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n     \t * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n    \t */\n    \tON_AFTER_RELEASE\n\n\t结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n\t\n4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！\n\n最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 \n\t\n一个有趣的现象，不知道是系统差别还是Android版本差别。\n\t\n魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。\n\t\n酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。\n\t\n暂时只测试了这两款机器。\n\t\n到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了\n\t\n### 保证用户体验下的解决方案\n- 1.监听网络请求失败后做点亮准备。注意是**“准备“**”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。\n\n- 2.准备后，先做请求积累，当到一个**临界值**时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。\n\n- 3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，**监听屏幕点亮广播**，在用户手动点亮、其他应用点亮时做网络请求\n\n- 4.如果你的请求真的很急切，且**略有些频繁**，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。\n\n- 5.如果你的需求迫切到，**必须定时定点**，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。\n\n- 6.**白名单导航页**还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。\n\n- 7.**公关**也是要的，如果可以直接被系统默认收进白名单皆大欢喜\n\n- 8.记得**区分**是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！\n\n- 9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。\n\n- 10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！\n\n\n\n### 示例代码\n\n最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~\n\n[https://github.com/lizhaoxuan/IamAlive](https://github.com/lizhaoxuan/IamAlive)\n\n对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^\n\n\n\n\n\n\n\n\n\n\n \n","slug":"shenyingpojie","published":1,"updated":"2019-01-02T02:09:31.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspp000zyo9sey6fzu1v","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p><em>android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓</em></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。</p>\n<p>  在手机息屏后，未加入白名单的应用将会被禁止访问网络。</p>\n<p>  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。</p>\n<p>  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!</p>\n  <a id=\"more\"></a>\n<p>  “我们联系下MIUI官方，把我们默认加白名单行不行？”    </p>\n<p>  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”</p>\n<p>  “让设计做引导页”</p>\n<p>  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”</p>\n<p>  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）</p>\n<p> <strong>完了，你说怎么办吧？</strong></p>\n<p> <strong>注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！</strong></p>\n<p> <strong>所以我们这里讨论的是，使用alarmManager做定时任务的情况</strong></p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h4><p>提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！</p>\n<p>额~既然这么简单，那还叫问题吗？</p>\n<p>事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h4><p>OK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？</p>\n<p>1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。</p>\n<p>2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。<br>    点亮代码是这个：</p>\n<pre><code>    PowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n            AliveApplication.getContext().POWER_SERVICE);\n    PowerManager.WakeLock mWakelock = pm.newWakeLock(\n            PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;target&quot;);\n    mWakelock.acquire();\n    mWakelock.release();\n\n    //记得权限\n    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;\n\n没错，还是PowerManager ，但换了一个参数：\n\n    PowerManager.SCREEN_DIM_WAKE_LOCK\n\n奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n</code></pre><p>3 ： PowerManager的几个参数及解释：</p>\n<pre><code>    //保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    PARTIAL_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    SCREEN_DIM_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    SCREEN_BRIGHT_WAKE_LOCK\n    //保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    FULL_WAKE_LOCK\n    /**\n      * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n      * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n      * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n      */\n    ACQUIRE_CAUSES_WAKEUP\n    /**\n      * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n      * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n     */\n    ON_AFTER_RELEASE\n\n结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n</code></pre><p>4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！</p>\n<p>最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 </p>\n<p>一个有趣的现象，不知道是系统差别还是Android版本差别。</p>\n<p>魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。</p>\n<p>酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。</p>\n<p>暂时只测试了这两款机器。</p>\n<p>到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了</p>\n<h3 id=\"保证用户体验下的解决方案\"><a href=\"#保证用户体验下的解决方案\" class=\"headerlink\" title=\"保证用户体验下的解决方案\"></a>保证用户体验下的解决方案</h3><ul>\n<li><p>1.监听网络请求失败后做点亮准备。注意是<strong>“准备“</strong>”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。</p>\n</li>\n<li><p>2.准备后，先做请求积累，当到一个<strong>临界值</strong>时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。</p>\n</li>\n<li><p>3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，<strong>监听屏幕点亮广播</strong>，在用户手动点亮、其他应用点亮时做网络请求</p>\n</li>\n<li><p>4.如果你的请求真的很急切，且<strong>略有些频繁</strong>，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。</p>\n</li>\n<li><p>5.如果你的需求迫切到，<strong>必须定时定点</strong>，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。</p>\n</li>\n<li><p>6.<strong>白名单导航页</strong>还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。</p>\n</li>\n<li><p>7.<strong>公关</strong>也是要的，如果可以直接被系统默认收进白名单皆大欢喜</p>\n</li>\n<li><p>8.记得<strong>区分</strong>是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！</p>\n</li>\n<li><p>9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。</p>\n</li>\n<li><p>10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！</p>\n</li>\n</ul>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~</p>\n<p><a href=\"https://github.com/lizhaoxuan/IamAlive\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/IamAlive</a></p>\n<p>对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p><em>android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓</em></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。</p>\n<p>  在手机息屏后，未加入白名单的应用将会被禁止访问网络。</p>\n<p>  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。</p>\n<p>  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!</p>","more":"<p>  “我们联系下MIUI官方，把我们默认加白名单行不行？”    </p>\n<p>  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”</p>\n<p>  “让设计做引导页”</p>\n<p>  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”</p>\n<p>  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）</p>\n<p> <strong>完了，你说怎么办吧？</strong></p>\n<p> <strong>注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！</strong></p>\n<p> <strong>所以我们这里讨论的是，使用alarmManager做定时任务的情况</strong></p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h4><p>提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！</p>\n<p>额~既然这么简单，那还叫问题吗？</p>\n<p>事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h4><p>OK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？</p>\n<p>1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。</p>\n<p>2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。<br>    点亮代码是这个：</p>\n<pre><code>    PowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n            AliveApplication.getContext().POWER_SERVICE);\n    PowerManager.WakeLock mWakelock = pm.newWakeLock(\n            PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;target&quot;);\n    mWakelock.acquire();\n    mWakelock.release();\n\n    //记得权限\n    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;\n\n没错，还是PowerManager ，但换了一个参数：\n\n    PowerManager.SCREEN_DIM_WAKE_LOCK\n\n奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n</code></pre><p>3 ： PowerManager的几个参数及解释：</p>\n<pre><code>    //保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    PARTIAL_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    SCREEN_DIM_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    SCREEN_BRIGHT_WAKE_LOCK\n    //保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    FULL_WAKE_LOCK\n    /**\n      * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n      * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n      * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n      */\n    ACQUIRE_CAUSES_WAKEUP\n    /**\n      * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n      * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n     */\n    ON_AFTER_RELEASE\n\n结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n</code></pre><p>4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！</p>\n<p>最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 </p>\n<p>一个有趣的现象，不知道是系统差别还是Android版本差别。</p>\n<p>魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。</p>\n<p>酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。</p>\n<p>暂时只测试了这两款机器。</p>\n<p>到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了</p>\n<h3 id=\"保证用户体验下的解决方案\"><a href=\"#保证用户体验下的解决方案\" class=\"headerlink\" title=\"保证用户体验下的解决方案\"></a>保证用户体验下的解决方案</h3><ul>\n<li><p>1.监听网络请求失败后做点亮准备。注意是<strong>“准备“</strong>”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。</p>\n</li>\n<li><p>2.准备后，先做请求积累，当到一个<strong>临界值</strong>时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。</p>\n</li>\n<li><p>3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，<strong>监听屏幕点亮广播</strong>，在用户手动点亮、其他应用点亮时做网络请求</p>\n</li>\n<li><p>4.如果你的请求真的很急切，且<strong>略有些频繁</strong>，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。</p>\n</li>\n<li><p>5.如果你的需求迫切到，<strong>必须定时定点</strong>，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。</p>\n</li>\n<li><p>6.<strong>白名单导航页</strong>还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。</p>\n</li>\n<li><p>7.<strong>公关</strong>也是要的，如果可以直接被系统默认收进白名单皆大欢喜</p>\n</li>\n<li><p>8.记得<strong>区分</strong>是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！</p>\n</li>\n<li><p>9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。</p>\n</li>\n<li><p>10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！</p>\n</li>\n</ul>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~</p>\n<p><a href=\"https://github.com/lizhaoxuan/IamAlive\" target=\"_blank\" rel=\"noopener\">https://github.com/lizhaoxuan/IamAlive</a></p>\n<p>对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^</p>"},{"title":"探索Bitmap使用姿势","date":"2017-07-11T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n早些时候对Android下GC调用时机比较好奇，所以写了一些case测试各种情况下Android GC调用时机与现象，感兴趣的话可以跳过去瞅瞅 ： [《Android GC机制实践调研》](https://lizhaoxuan.github.io/2016/02/17/androidgcdiaoyan/)\n\n在这个过程中发现一个让人非常震惊的问题：从资源文件中加载一张110kb的图片创建Bitmap对象，占用的内存高达40MB！\n为什么为什么为什么？？\n\n于是这篇博客便产生了，我希望可以通过一系列测试case，来了解Bitmap在各种场景下的各种使用姿势将会在内存占用和加载速度两方面都有哪些表现，从而从中探索可能的优化点和最佳实践。\n\n\n<!-- more -->\n\n## 各种场景下创建Bitmap内存占用\n\n### 从资源文件创建Bitmap\n\n#### 1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\n\n这里我们准备了一张117.16kb 1200*900的jpg图片放到了res/各种分辨率的drawabe目录下。对他们进行分别加载然后输出各种值进行对比，需要说明一下这里加载的意思可以是：执行`bitmapFactory.decodeResource` 。 与给ImageView设置Resource 、给布局设置背景等创建创建Bitmap或进行图片显示的操作相同。\n\n看下实验数据\n\n\n【努比亚Z9  Nubia NX508J】 分辨率1080 * 1920  像素密度：424ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |38880000b ≈ 37mb|14400b |2700|3600\nmdip|38880000b ≈ 37mb|14400b |2700|3600\nxhdip|9720000b ≈ 9mb|7200b |1350|1800\nxxhdip|4320000b ≈ 4mb|4800b |900|1200\n\n\n38880000b是什么概念？37MB！！\n想一下，你的应用还啥都没干呢，就仅是加载了一张图片将近40MB的内存就被占用了，再加上其他一些操作，内存妥妥的就跳到临界值了，如果再有一些不当的溢出，OOM指日可待！\n\n**似乎，图片放在分辨率越高的文件夹下，内存占用越小**\n\n\n#### 2.不同格式的图片创建Bitmap内存占用大小\n\n上面测试用的是jpg，而通常我们开发中使用的都是png，看到这么大的内存占用，我有想过是否是因为图片格式的问题，于是把这张图片丢到美图秀秀里（美图秀秀真好用），然后分别导出了长宽一样的jpg和png两张图片，放到资源文件夹中进行加载。\n\n```\n【努比亚Z9  Nubia NX508J】\ndrawable_jpg_1.jpg 1200*900  135.76kb\ndrawable_png_1.png 1200*900  1.64mb\n\njpg getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600\npng getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600\n```\n\n内存占用和之前一样，并且虽然png的图片本身高达1.64mb，但内存占用依然只是37mb。\n\n**从资源文件中加载图片的内存占用与图片格式、图片占硬盘大小无关！（但和apk包体积有关）**\n\n#### 3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\n\nAndroid存在着很多分辨率适配问题，不同drawable文件夹也是为了适配而存在的，所以我们还要挑几个分辨率不一样的手机看一下：\n\n【荣耀畅玩4X】  分辨率：1280 * 720   像素密度：267ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |17280000b ≈ 16mb |9600b |1800|2400\nmdip|17280000b ≈ 16mb |9600b |1800|2400\nxhdip|4320000b ≈ 4mb |4800b |900|1200\nxxhdip|1920000b ≈ 2mb |3200b |600|800\n\n\n诶？很明显啊，选一个分辨率低一点的手机，果然相同条件的图片加载内存占用是不一样的。我这正好还有一个和努比亚分辨率一样的手机，用这个也测一下：\n\n【乐视 le x620】  分辨率：1080 * 1920   像素密度：401ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |29773800b ≈ 28mb |12600b |2363|3150\nmdip|29773800b ≈ 28mb |12600b |2363|3150\nxhdip|7440300b ≈ 7mb |6300b |1181|1575\nxxhdip|3309600b ≈ 3mb |4200b |788|1050\n\n问题来了，虽然分辨率是一样的，但是内存占用却不同，关键因素不在分辨率，那在什么呢？\n\n我们都知道我们的应用程序在不同的设备上，Android系统会从不同的资源文件夹下获取图片资源，而其选择的本质不是屏幕的长宽比，是像素密度。\n\n**所以这里的关键在于像素密度！从资源文件中加载图片的内存占用与像素密度有关！**\n\n\nOK,上面的结论都是通过数据推理出来的一些表象现状。这里先进行一个小总结：\n\n- **从资源文件中创建Bitmap，图片所在分辨率越高的drawable文件夹，Bitmap占用内存越小。（单从内存的角度可以这样考量，但从实际应用过程中，所有素材都放到分辨率最高的文件夹并不是合适的做法）**\n- **从资源文件中创建Bitmap，Bitmap占用内存大小与图片宽高极为有关，与图片本身格式以及占硬盘大小无关。**\n- **从资源文件中创建Bitmap，Bitmap占用内存大小与手机像素密度极为有关。**\n\n\n### 从网络或本地存储创建Bitmap\n\n通过资源文件创建Bitmap，Android系统会为了适配不同屏幕，而对图片进行一些调整，导致不同情况下内存占用区别很大。那么如果是从网络或本地存储中创建的Bitmap也会因为设备的像素密度而有很大差异吗？\n\n我们来实验一下，我从网络下载一张图片，然后观察内存情况。\n\n我选了一张216932b ≈ 212kb 1600 *1280 的jpg图片下载，并创建一个Bitmap\n\n```\n【努比亚Z9  Nubia NX508J 分辨率1080 * 1920  像素密度：424ppi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n同一张图片放到资源文件中加载：\ndrawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nmdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nxhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400\nxxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\n```\nBitmap大小还是要比图片本身大出好多，而且似乎和从xxhdip文件夹下加载大小是一样的，这一个示例不足以证明是否和手机分辨率有关，我们换个手机再看看：\n\n```\n【魅族MX6 分辨率1080 * 1920  像素密度：401ppi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n资源文件加载：\ndrawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nmdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nxhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400\nxxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\n```\n好像看起来一样，不过这两台设备分辨率一样，像素密度也差不太多，还是不足以说明问题，我们找个像素密度更低一点的看一下：\n```\n【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n资源文件加载：\ndrawable getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\nmdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\nxhdip getByteCount : 2048000 ≈ 2mb getRowBytes:3200 getHeight:640 getWidth:800\nxxhdip getByteCount : 910364 ≈ 1mb getRowBytes:2132 getHeight:427 getWidth:533\n```\n\n哦~ 这回有点说明性了，即使在像素密度不同情况下，从网络下载的图片创建的Bitmap大小都是固定的，从资源文件中加载则因为像素密度不同会产生很多变化。\n\n从网络直接下载得到的byte数组大小等同于原图片大小，不经处理，直接用byte创建得到Bitmap宽高会以原图片宽高创建，得到的Bitmap所占内存远大于原图在硬盘上的大小。\n\n做个小总结：\n\n- **从网络或本地存储加载图片创建Bitmap,内存占用仅与图片自身宽高有关，与设备像素密度无关。**\n- **从网络或本地读取的byte数组大小等同于图片大小，未经处理创建Bitmap内存占用远大于byte数组大小。**\n\n\n## Bitmap占用内存的大小是如何计算的？\n\n上一节的测试case，帮助我们大概的了解了Bitmap不同场景下创建的一些特性，看起来很有道理，但case覆盖不够充足的归纳法并不足以服人。\n\n但他确实已经激起了我们很浓厚的兴趣，所以下一步我们要通过源码来了解其中真正的原理。\n\nBitmap的源码解析的细节比较繁琐，有兴趣可以一层层追下去，这里就直接放结果了。\n\n还是因为有适配的问题，所以我们还要从两个方面去说明：从网络或本地加载，和从资源文件中加载。\n\n### 从网络或本地存储加载图片\n\n从网络或本地加载图片不会受到设备像素密度影响，其内存占用的大小可以用下面的公式描述：\n\n**size = 实际显示的宽 \\* 实际显示的高 \\* Bitmap.Config **\n\n说到Bitmap.Config，这个又要老生常谈了，Android为图片提供了4种解码格式，不同的解码格式占用的内存大小不同，当然显示效果也不同。\n\nFormat | byte | 说明 \n------ |:-------|:-------|:-------|:-------|\nARGB_8888 | 4b |此配置非常灵活，提供最好的质量。应尽可能使用。\nRGB_565 | 2b |此配置可能会根据源的配置产生轻微的视觉伪影。例如，没有抖动，结果可能会显示绿色的色调。为了获得更好的效果，应该应用抖动。当使用不需要高色彩保真度的不透明位图时，此配置可能很有用。\nARGB_4444 | 2b |如果应用程序需要存储半透明信息，而且还需要节省内存，则此配置最为有用。(已废弃)\nALPHA_8 | 1b |每个像素存储为单透明（alpha）通道。这对于有效地存储掩码是非常有用的。没有存储颜色信息。通过这种配置，每个像素需要1个字节的存储器。\n\n默认是ARGB_8888，虽然一直都在说建议不同情况使用不同的解码格式，但往往因为一些“不可抗拒”的因素，任何时候我们都在使用默认的解码格式。后面第三节会对不同的解码格式进行case测试。\n\n\n### 从资源文件中加载图片\n\n从资源文件中加载图片会受到drawble文件夹不同、设备像素密度影响，公式略微复杂一点：\n\nscaledWidth = int(width \\* targetDensity / density + 0.5f) \nscaledHeight = int(height \\* targetDensity / density + 0.5f) \nsize = scaledWidth \\* scaledHeight \\* Bitmap.Config \n\nwidth和height是原素材大小；\ntargetDensity 是设备像素密度；\ndensity 是素材所在drawable文件夹大小；\n\n这里要说明一下targetDensity 和 density 的值是怎么来的。给一个表来说明：\n\n名称 | density |   像素密度范围:targetDensity\n------ |:-------|:-------|:-------|:-------|\nmdpi | 160dp | 120dp ~ 160dp\nhdpi | 240dp | 160dp ~ 240dp\nxhdpi | 320dp | 240dp ~ 320dp\nxxhdpi | 480dp | 320dp ~ 480dp\nxxxhdpi | 640dp | 480dp ~ 640dp\n\n图片放到了哪个文件夹，density的值就是多少，如果每个文件夹都放了，Android会根据设备的像素密度自动选择对应的文件夹。\n\n而设备的像素密度往往并不会只有160、240、320、480、640这几个，我们可以看到第一节测试数据的几个设备像素密度都是 【努比亚Z9 像素密度：424ppi】 【荣耀畅玩4X 像素密度：267ppi】  【乐视 le x620 像素密度：401ppi】\n\n这些像素密度值是硬件的实际参数，但在系统运行时，硬件需要给Android系统提供一个准确的整数值，通常你可以粗略的将硬件实际像素密度套入上表中，去像素密度范文的最大值。但还是会有一些特殊的设备不会取标准值，比如乐视le x620的像素密度并不是标准的320dp或480dp，而是420dp。\n\n所以设备像素密度在系统运行中的值我们可以通过下面的代码获取：\n\n```\nDisplayMetrics metric = new DisplayMetrics();\nint densityDpi = metric.densityDpi;  // 屏幕密度DPI（120 / 160 / 240）\n```\n\n系统运行中取得的像素密度如下 【努比亚Z9 像素密度：480dp】 【荣耀畅玩4X 像素密度：320dp】  【乐视 le x620 像素密度：420dp】\n如果素材在每个文件夹都放了图片，那么会通过上表的像素密度范围中寻找最佳的素材进行加载。\n\n简单总结一下：\n\n- **Bitmap消耗内存大小主要取决于实际显示的大小和每个像素所占的字节数**\n- **从资源文件加载Bitmap时，还受设备像素密度与图片所在文件夹代表的像素密度之比的影响**\n\n\n## 减少Bitmap的内存占用\n\n呐，现在要进入本文的重头戏了，你当然不会看到现在网上大同小异的什么不实际加载先获取尺寸啊，各种压缩方法啊什么的说教类条目。\n\n\n### 从公式引出的优化策略\n\n第二节我们介绍了Bitmap加载占用内存的计算公式，通过公式我们可以很容易的得出一些减少Bitmap内存占用的方法。\n\n#### 减小图片实际显示的长宽\n\n通常来说我们要显示的图片会大于控件本身的大小，这是一种很明显的浪费，对图片做适当的压缩，贴近控件本身的大小可以有效的减少内存占用。主要用到的技术是 `BitmapFactory.Options.inSampleSize`属性，这个属性在Bitmap优化上已经被讲过无数次了，我们就不多介绍了。关键点：**按照控件本身大小加载图片**\n\n#### 使用更合适的解码格式加载Bitmap\n\nAndroid提供了四种Bitmap解码格式，每种格式占用内存的大小不一样，在合适的场景下选择合适解码格式可以有效的减少内存占用。这个虽然也是老生常谈，但里面会有一些不符合我们默认观念的东西，下面会详细介绍。\n\n#### 为应用提供满足当前设备像素密度的素材\n\nBitmap内存计算公式中除长、宽、解码格式三者的乘积以外，还要乘以targetDensity与density比的平方。这是什么概念呢？\n\n如果我们只提供了低像素密度的素材，那么在高像素密度的设备上将占用更大的内存。\n反之，如果我们只提供了高像素密度的素材，那么在低像素密度的设备上将占用更小的内存。\n\n诶？？？好像发现了什么？？是不是我们只要在xxhdpi甚至xxxxxxxhdpi中放素材，内存占用将会变得非常非常小？？这简直新大陆啊。\n\n如果问题真的这么简单，Android系统本身也不会提供那么多像素密度的文件夹了，口说无凭，我们写个Demo看看效果。\n\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n我将同一张图片分别copy在和xxhdpi文件夹下和mhdpi文件夹下，然后进行显示：\n(上面xxhdpi 下面 mhdpi)\n![mhdpi_xxhdpi](探索Bitmap使用姿势/mhdpi_xxhdpi.png)\n\n很明显的可以看出来与设备像素密度相同的mhdpi文件夹下素材显示正常，xxhdpi已经非常模糊了。\n\n**将素材放到高像素密度文件下，以求减少内存占用是一个愚蠢的行为。**\n\n那问题来了，为了减少apk包大小（或者是懒），大多数开发者都只会在项目中存放一套素材放到某个像素密度的文件夹下。\n这样将引起的问题是：若放到低像素密度文件夹下，遇到高像素密度设备时将占用多余的内存；若放到高像素密度文件夹下，遇到低像素密度设备，素材将会变的模糊。\n\n很痛苦对不对？所以如果对包的大小要求并没有那么严格，设定多套像素密度素材，让targetDensity与density比为1，保证显示效果与内存占用保持在最恰当的平衡才是正道。\n但如果就只能用一套呢？要想办法走歪路了……\n\n素材大部分的应用都是一些尺寸较小控件，小尺寸控件即使图片较为模糊也不会特别明显，所以这些小素材我们可以选择性忽略，是不是有点不放心？我们再跑下Demo看看效果。\n\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n下面是长宽150dp的控件，上面是xxhdpi下的素材，下面是mhdpi的素材。\n\n\n![mhdpi_xxhdpi_150](探索Bitmap使用姿势/mhdpi_xxhdpi_150.png)\n\n相同的设备相同的素材，缩小了控件大小后模糊的是不是不那么明显了？\n\n那么对于大尺寸的控件呢？这里我的建议是放到assets或res/raw、中，从assets中加载图片等同于从网络或本地加载，从raw中通过InputStream加载也可以实现同样的效果，不会受到像素密度干扰。我们可以在assets中放一张相对尺寸较大的图片，然后依照控件大小加载Bitmap，在保证以最优内存占用的同时保证图片不会模糊。\n\n当然如果图片放到了src/drawable文件夹下，通过代码` BitmapFactory.decodeStream(getResources().openRawResource(R.drawable.example));`\n效果等同于放到res/raw，但这时编译器会提示这里期望的是raw类型，一条红色的波浪线总是让人难以接受且这样的图片容易被直接使用而导致上面提到问题。\n\n将上面的代码封装到一个方法里可以避免这条红线，但还是不能避免会有其他的小伙伴直接当做资源使用这张图片。大家自己选择吧\n\n\n下面我们就看看分别放到xxhdpi、assets下面的对比图。\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n上面是xxhdpi下的素材，下面是assets的素材。\n\n![resource_assets](探索Bitmap使用姿势/resource_assets.png)\n\n又见清晰的屁股。\n当然内存占用上上面模糊的图会更小，毕竟targetDensity与density比为0.25，相当于除以4。\n不过这是一种在内存占用、展示效果、Apk包大小三者间较为平和的加载方式。\n\n此类方法适用于：全屏类型的展示素材（Splash、引导图等）、大尺寸的示例图片等。\n\n### 不同解码格式的效果\n\n上面我们遗留一个问题，如何使用更合适的解码格式加载Bitmap？下面就好好聊聊。\n\n一直以来，Bitmap优化老生常谈的一个问题：使用不同的Bitmap解码格式，以降低Bitmap内存占用。但实际过程中我们都希望图片以最优的状况展示给用户，所以用的最多的是ARGB_8888.\n\n这里我好奇的是他们之间究竟有多少差异，分别适应什么场景，我做了一些测试。\n\n奥~测试之前，再把四种解码格式的介绍列一下吧：\n\n- ALPHA_8模式\nALPHA_8模式表示的图片信息中只包含Alpha透明度信息，不包含任何颜色信息，所以ALPHA_8模式只能用在一些特殊场景。\n\n- RGB_565模式\n显然RGB_565模式不能表示所有的RGB颜色，它能表示的颜色数只有32 × 64 × 32 = 65536种，远远小于24位真彩色所能表示的颜色数（256 × 257 × 256 = 16677216）。当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。\n\n- ARGB_4444模式\nARGB_4444已被Android标记为@Deprecated，Android推荐使用ARGB_8888来代替ARGB_4444，原因是ARGB_4444表示出来的图片质量太差。 \n\n- ARGB_8888模式\nARGB_8888模式用8位来表示透明度，有256个透明度等级，用24位来表示R，G，B三个颜色通道，能够完全表示32位真彩色，但同时这种模式占用的内存空间也最大，是RGB_565模式的两倍，是ALPHA_8模式的4倍。\n\n介绍是这么写的，但真实使用情况是怎么样的？我们来测试一下：\n\n我准备了一张图片然后分别使用不同的解码格式进行解码，然后进行展示并输出Bitmap的大小：\n\n![ARGB_8888](探索Bitmap使用姿势/ARGB_8888.png)\n\n最好的解码方式展示最优的效果，当然内存占用也是最大的：1038000 ≈ 0.98mb。\n\n![ARGB_4444](探索Bitmap使用姿势/ARGB_4444.png)\n\n果然是要放弃的解码格式，大腿都花掉了，虽然内存占用小了将近一半，但也不能再用你了。\n\n![RGB_565](探索Bitmap使用姿势/RGB_565.png)\n\n诶？这个看起来好像很不错的样子，内存占用仅有ARGB_8888的四分之一，但现实上几乎看不出什么不同，还是细腻的大腿。赞赞赞。（理论上size的大小不应该只有ARGB_4444的一半，应该是相等的，这个不能理解）\n\n![ALPHA_8](探索Bitmap使用姿势/ALPHA_8.png)\n\n诶诶诶？？ALPHA_8这么强大吗？？？同样的几乎无损图，按照说明它应该是显示最差的啊，不是说不包含颜色的吗？。size的大小和RGB_565一样又是怎么回事？？？\n\n好了，这里简单解释一下，前面三张图重复的展示ARGB_8888、ARGB_4444、RGB_565三种解码格式在内存占用上的不同。ARGB_4444展会效果太差已经是不用质疑的了，但RGB_565内存占用仅有ARGB_8888的四分之一，显示上却没有明显的区别，难道说可以用RGB_565完全的代替ARGB_8888吗？\n\n不不不，当然不是这样的，我们看下RGB_565的解释：*当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。* 之所以我们没有感觉到特别大的区别，原因在与图片本身色调过于单一（满眼黄黄的大腿），RGB_565所能表示的颜色已经够用或者代替的颜色色差足够小。如果你需要展示色彩特别丰富的图片还是会看出区别的。\n\n然后我们再解释一下ALPHA_8的问题。当你设置`op1.inPreferredConfig = Bitmap.Config.ALPHA_8`为某个属性时，并不是说Bitmap解码器必然使用这种解码格式，仅是优先使用这种解码格式。不包含颜色信息的ALPHA_8怎么能解码出来黄黄的大腿呢？ALPHA_8不可以，RGB_565可以。所以解码器使用了RGB_565，具体其内部的优先级和使用策略还没有具体研究。\n\nBitmap解码器最终使用的解码格式在很大程度上取决于图片本身。\n\n既然上面的图片ALPHA_8没法解码，那黑白的二维码图片ALPHA_8可以解码吗？试一下：\n\n![DC_ARGB_8888](探索Bitmap使用姿势/DC_ARGB_8888.png)\n\n挺好的……\n\n![DC_ARGB_4444](探索Bitmap使用姿势/DC_ARGB_4444.png)\n\n简单的二维码图片，ARGB_4444也挑不出啥毛病来……\n\n![DC_RGB_565](探索Bitmap使用姿势/DC_RGB_565.png)\n\n这回size的大小合理了，和ARGB_4444一样。\n\n![DC_ALPHA_8](探索Bitmap使用姿势/DC_ALPHA_8.png)\n\n更小的size，显示效果也无不同。赞！\n\n简单总结一下：\n\n- 设置图片解码格式并不一定会使用这种解码格式，关键取决与图片本身。\n- ALPHA_8适合类似二维码一类的简单黑白图\n- RGB_565似乎可以满足大多数要求不高的展示场景\n\n### Bitmap内存复用\n\n通常来说我们在需要使用一张新的图片时，都会为这个重新分配一块内存,然后创建一个新的Bitmap对象，一个两个不会存在太大的问题，但当有大量的零时Bitmap对象被频繁创建时，将会引起频繁的GC。所以Google在很早之前发布的性能优化典范中推荐开发者使用`inBitmap`属性来对Bitmap做内存复用，通过该属性告知解码器尝试使用已经存在的内存区域，从而避免内存的重新分配。\n\n\n当然`inBitmap`是有较大限制的，有着一定的场景依赖，所以通常被使用的频率不是很高，具体限制我们后面会有简单提到。这里我们先通过Demo测试一下`inBitmap`的复用效果。\n\n首先我用下面的方法测试未复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：\n\n```\nprivate void unRecycle() {\n        byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);\n        imageView.setImageBitmap(BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length));\n        if (index >= 3) {\n            index = 0;\n        }\n    }\n```\n\n![un_recycle](探索Bitmap使用姿势/un_recycle.png)\n\n通过内存监控可知，三张图片依次加载时，内存成阶梯状上升，执行GC后，内存成断崖式下跌。在实际使用过程中，很可能因为内存无法即时回收而导致OOM，或因为大量内存需要回收而引起卡顿。\n\n然后我们在用下面的方法测试复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：\n\n```\nbyte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);\n        if (bitmap == null) {\n            BitmapFactory.Options option1 = new BitmapFactory.Options();\n            option1.inMutable = true;\n            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);\n        } else {\n            BitmapFactory.Options option1 = new BitmapFactory.Options();\n            option1.inBitmap = bitmap;\n            option1.inMutable = true;\n            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);\n        }\n        imageView.setImageBitmap(bitmap);\n        if (index >= 3) {\n            index = 0;\n        }\n```\n\n![recycle](探索Bitmap使用姿势/recycle.png)\n\n通过内存监控可知，仅在第一张图片加载时，系统分配了一块内存给Bitmap，后面两张图没用再重新进行内存分配。避免了大块内存的重新分配和GC回收。\n\n### Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比\n\n这里介绍一个最简单的适合使用`inBitmap`属性的场景：拍照！\n\n设备：【努比亚Z9 像素密度：480dp】\nDemo的界面很简单，一个ImageView用来展示图片，初次进入默认展示示例图片，点击拍照按钮调用系统相机进入拍照界面，成功拍照后将照片展示到ImageView上,可多次拍照，ImageView仅展示最新照片。\n\n**这里我们考察的点是，进入Activity后进行多次拍照，然后观察内存变化。主要关注示例图片的内存占用与拍照后的内存占用。**\n下面是Demo的界面展示，优化前后界面展示保持不变。考虑篇幅问题，这里不再贴代码，仅以文字描述，详细代码可以查看[Demo代码]()。\n\n![take_photo](探索Bitmap使用姿势/take_photo.png) ![take_photo1](探索Bitmap使用姿势/take_photo2.png)\n\n\n#### 老的拍照操作\n先说我们通常最普通的做法，仅做了简单的拍照后图片压缩显示。\n\n1.示例图片放在src/xhdpi文件夹下，通过`photoImg.setImageResource(R.drawable.example);`设置。\n2.拍照后将图片保存为本地文件，在`onActivityResult`回调方法中。以默认长宽1024x768为标准进行压缩，通过`BitmapFactory.decodeStream`创建Bitmap。（默认长宽通常为UED给出的设计稿尺寸）。\n\n然后我们看一下Demo跑起来以后的的内存监控图：\n\n![old_take_photo](探索Bitmap使用姿势/old_take_photo.jpg)\n\n解释一下：\n\n1.第一个内存上升主要是因为页面进入后，加载示例图造成的，大约占用内存8MB左右。src/xhdpi与本次测试的设备像素密度相同，如果xxhdpi像素密度的设备，内存占用更大；如果遇到像素密度更小的设备，则示例图可能会变得模糊。\n\n2.圆圈表示拍照后内存的上升，每一次拍照都将创建一个新的Bitmap，大约占用内存9MB左右。\n\n3.观察第三个圆圈，系统发生一次GC，系统回收一个Bitmap，但显而易见并没有回收干净。\n\n4.观察第五个圆圈，出现一次内存尖峰，再次发生GC，但同样没有回收干净，内存整体呈持续持续上升趋势。\n\n总结：内存并没有泄露，五次拍照均产生的为临时变量，但大内存的占用导致GC回收非常不干净。在实际使用中，未被即时回收的内存将可能导致OOM。\n即使不会引起OOM，大块内存分配引起的GC同样极易引起界面卡顿，GC运行在主线程。\n\n\n#### 新的拍照操作\n\n针对上面老的拍照操作，新的拍照操作主要做了如下优化：\n\n1.不在直接通过`photoImg.setImageResource(R.drawable.example);`设置图片，改为` BitmapFactory.decodeStream(getResources().openRawResource(srcId), null, options);`。 提高Bitmap加载速度的同时（decodeStream直接调用JNI方法），跳过Android系统针对设备像素密度对图片做的优化，直接对图片本身进行操作。\n\n2.以`Config.RGB_565`解码格式进行解码，缩小Bitmap一半内存占用。\n\n3.以ImageView实际大小为标准对示例图与照片做压缩。\n\n4.对多次拍照产生的Bitmap做复用，最终实际仅占用一个Bitmap内存。\n\n我们看下优化后的内存监控图：\n\n![new_take_photo](探索Bitmap使用姿势/new_take_photo.jpg)\n\n内存曲线过于平缓……看的不太清晰……\n\n1.示例图因为经过压缩，且跳过像素密度的适配，最终仅占用约0.3MB内存。\n\n2.因为示例图与压缩后的照片尺寸不一样，不能进行Bitmap复用，所以第一次拍照后又创建了一个Bitmap，大约占用内存1.9MB，之后多次拍照复用第二个Bitmap，没有进行内存分配，所以也没有GC发生。\n\n\n##### 总结\n\n优化结果很明显啦~\n主要的优化点：\n\n- 跳过像素密度适配直接通过 `decodeStream`对图片进行加载。\n- 按照控件大小加载图片。\n- 对Bitmap进行复用。\n\n但里面会有一些坑点：\n\n- 在Activity没有将界面完全展示时，无法获取控件宽高。此类场景如何获取请自行搜索。我在这个Demo中使用的方式是`imageView.post(new Runnable() { void run()}` 。\n- Bitmap复用有较大限制，4.4之前只能复用大小一样的，4.4之后只能复用大小等于或更小的。\n- Bitmap复用有较大限制，只能复用相同解码格式的，可能会有某些图片没有办法用`Config.RGB_565`解码，此时将不能复用。Demo中我用try catch捕获复用失败的异常，然后降级创建新的Bitmap.\n\n\n## Bitmap加载速度探索\n\n上面我们主要分析的是Bitmap占用内存方面的一些场景，在实际使用过程中，除了内存以外，Bitmap的快速加载也是非常值得我们关注的问题。\n\n这里我们仅讨论最常用的三种Bitmap加载方法。\n```\n//从资源文件中加载\nBitmapFactory.decodeResource();\n//从流中加载\nBitmapFactory.decodeStream();\n//从byte[]中加载\nBitmapFactory.decodeByteArray();\n\n```\n\n### 从资源文件中加载与流中加载对比\n\n我将同一张1080x1920 655.45k的图片放在资源文件中和Assets目录下用分别用`BitmapFactory.decodeResource();`和`BitmapFactory.decodeStream();`两种方法加载，然后测算其加载速度。\n\n同时因为每一次Bitmap的加载耗时都不一样，所以我会列出多次执行的数据。\n\n```\n【time1】\n资源文件加载Bitmap 耗时：160ms\ndecodeStream加载本地图片 耗时：57ms\n【time2】\n资源文件加载Bitmap 耗时：157ms\ndecodeStream加载本地图片 耗时：47ms\n【time3】\n资源文件加载Bitmap 耗时：162ms\ndecodeStream加载本地图片 耗时：56ms\n【time4】\n资源文件加载Bitmap 耗时：124ms\ndecodeStream加载本地图片 耗时：43ms\n【time5】\n资源文件加载Bitmap 耗时：123ms\n07decodeStream加载本地图片 耗时：43ms\n\n```\n\n数据已经很明显的说明问题了。因为BitmapFactory.decodeResource()方法会在图片加载完成后做一些适配工作，而decodeStream直接读取了字节码，速度更快。\n\n但因为缺少了适配处理，所以加载的图片是图片原本的大小，在使用中需要对其进行处理。但在加载一些明显图片尺寸大于控件尺寸的场景，decodeStream显然更为合适。\n\n### I/O耗时和图片解码耗时\n\n从接触编程开始，我们都一直在接受I/O是很耗时的观点。那么是否可以假想，在从本地文件中加载图片的场景，从本地读取数据到内存的过程消耗了很重要的一部分时间，无论这段时间多与少，都是一个优化点。\n\nOK，那么接下来我们只要通过测算其具体时间就可以验证假设了。\n\n还是那张图片，我们先从本地读取其为byte[]，然后在从byte[]通过BitmapFactory.decodeByteArray();转为Bitmap。\n\n```\n【time1】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：43ms\n\n【time2】\n读取本地图片到byte[] 耗时：2ms\nbyte[] to Bitmap 耗时：40ms\n\n【time3】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：43ms\n\n【time4】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：39ms\n\n【time5】\n读取本地图片到byte[] 耗时：1\nbyte[] to Bitmap 耗时：39\n\n```\n\n结果还是较为失望的，从本地读取到内存中的时间消耗仅为1ms，主要耗时依然在解码上。\n\n\n### BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比\n\n\nBitmapFactory.decodeStream()直接通过流读取图片字节码，然后进行图片解码操作，对比BitmapFactory.decodeByteArray()，直观上要多出一步本地到内存的过程，虽然从本地读取数据到内存耗时仅为1ms，但我还是想知道这两者的直接对比是怎么样的。\n\n\n```\n【time1】\ndecodeStream加载本地图片 耗时：42ms\n读取本地图片到byte[] 再到Bitmap 耗时：40ms\n读取本地图片到byte[] 耗时：1ms\n\n【time2】\ndecodeStream加载本地图片 耗时：55ms\n读取本地图片到byte[] 再到Bitmap 耗时：44ms\n读取本地图片到byte[] 耗时：1ms\n\n【time3】\ndecodeStream加载本地图片 耗时：43ms\n读取本地图片到byte[] 再到Bitmap 耗时：40ms\n读取本地图片到byte[] 耗时：1ms\n\n【time4】\ndecodeStream加载本地图片 耗时：85ms\n读取本地图片到byte[] 再到Bitmap 耗时：60ms\n读取本地图片到byte[] 耗时：2ms\n\n【time5】\ndecodeStream加载本地图片 耗时：73ms\n读取本地图片到byte[] 再到Bitmap 耗时：57ms\n读取本地图片到byte[] 耗时：2ms\n\n```\n\n时间相差从3ms到20ms都有，虽然不大，但还是有一丢丢改善。\n如果对图片加载速度非常苛刻的话，可以考虑提前将图片缓存到内存中，然后通过BitmapFactory.decodeByteArray()方式进行加载。但这需要消耗额外的内存空间，是典型的空间换时间。但考虑其20ms左右优化效果，考虑这种方式还需谨慎。\n\n\n\n## 新的缓存代替品？\n\n跟上一节。虽然从加载速度考虑，BitmapFactory.decodeByteArray()代替BitmapFactory.decodeStream()的收益不大，但换一种姿势，有没有可能让收益翻番？\n\n\n一直以来图片缓存大多都是指将图片保存到本地或网络，加载后得到Bitmap保存的内存中，其优化通常是指将用过的Bitmap用缓存容器保存起来**避免重复从硬盘或网络加载**。\n\n这样的方式我们关注的更多是减小Bitmap从本地或网络创建的时间，但这样的缓存方式将会占用大量的内存空间，一般情况我们都会选择将六分之一的内存空间划分给图片缓存，**以空间换时间**，其代价还是很大的。\n\n但看过前面的一大波测试数据，我们可以很明显的感受到加载后的Bitmap占用内存大小远大于图片原本大小。究其原因，加载Bitmap会对文件本身做解码以用于显示，类似于解压操作，而图片本身是一种压缩操作。\n\n同时经过前面的测试，也许你发现了一个细节，从网络或本地读取后得到的byte[]大小是图片原本大小，那么是否可以牺牲一些byte[]到Bitmap的转换时间，仅缓存byte[]在内存中？\n\n**以时间换空间策略**，是否可行的关键在于从byte[] - Bitmap的解码时间与解释的内存开销的权衡，我们通过数据来验证。\n我准备了一张png图片，分别导出了不同的分辨率，并且copy一份对png文件进行压缩做对比测试，然后运行代码输出其各方面数据。\n此次测试我们主要考量两个标准：byte[]代替Bitmap节省的空间和byte[]转Bitmap耗费的时间。\n\n图片文件分辨率 | 是否压缩 |   byte.length | bitmap.size | use time\n------ |:-------|:-------|:-------|:-------|\n50*80 | false | 10501b≈10kb | 17600b≈17kb | 1ms\n50*80 | true | 3523b≈3kb | 17600b≈17kb | 1ms\n200*355| false | 140360b≈137kb | 284000b≈277kb | 11ms\n200*355| true |27690b≈27kb | 284000b≈277kb | 3ms\n500*888|  false |870554b≈850kb | 1776000b≈1734kb | 36ms\n500*888|  true |171101b≈167kb | 1776000b≈1734kb | 10ms\n1080*1920|  false |984712b≈961kb | 8294400b≈8100kb | 65ms\n1080*1920| true | 631610b≈616kb | 8294400b≈8100kb | 34ms\n\n我们对上面数据做一个简单的总结：\n\n- png文件压缩不会减少生成的Bitmap大小，但可以明显减少byte大小\n- 分辨率越高，byte[]替换Bitmap节省内存的越明显\n- 分辨率越高，png解码为Bitmap的耗时越久\n- 压缩后可以明显减少解码为Bitmap的耗时（byte[]越小，解码越快）\n\n同时我们也知道byte[]到Bitmap占用的时间并不是一成不变的，也就是说会在不同的设备上有不同的体现，以我目前测试的努比亚Z9来说，不同数据的差异在10~15ms之间徘徊，为了保证测试数据的说服力，我将1080*1920分辨率图片压缩前后的use time的多次数据进行展示：\n\n压缩前 | 压缩后\n------ |:-------|\n 65 | 34 \n 82 | 40\n 81 | 40\n 98 | 41\n 98 | 44\n 87 | 41\n \n另外说道byte[]越小，解码越快的问题，我们不难联想到webp，webp比png,jpg更小，读取后的byte[]也更小，是否解压的更快呢？测试一下：\n\n```\nico_1080_1920.png  bytes:984712b ≈ 961kb  bitmap:8294400b ≈ 8100kb  use:91ms\nico_1080_1920_compress.png  bytes:631610b ≈ 616kb  bitmap:8294400b ≈ 8100kb  use:44ms\nun_compress.webp  bytes:367018b ≈ 358kb  bitmap:8294400b ≈ 8100kb  use:152ms\ncompress.webp  bytes:361200b ≈ 352kb  bitmap:8294400b ≈ 8100kb  use:141ms\n\n```\n结果显而易见，下面两张图是上面两张图的webp版，虽然大幅度减少byte的大小，但解码时间也大幅度增加了。究其原因，webp的高强度压缩增加了解码复杂度，webp在其官网也早已对这种情况进行了说明。\n\n\n而byte[] - Bitmap所消耗的时间对系统流程度的影响又是如何呢？\n\n我写了一个demo，界面如下：\n\n![old_take_photo](探索Bitmap使用姿势/listview.png)\n\n经过实际测试，缓存Bitmap到内存中的策略中，第一次加载图片时，快速滑动列表，会有明显卡顿；但在图片全部缓存后，页面无卡顿。\n\n而缓存byte[]到内存中，在显示时才解码为Bitmap，第一次加载图片时，快速滑动列表，会有明细卡顿；byte[]全部缓存后，普通滑动速度几乎无卡顿；快速滑动有卡顿感。\n\n所以从用户体验的角度上来说，缓存byte[]可能并不适合在图片列表这样可以快速滑动的场景代替Bitmap缓存。\n而在ViewPager这样的场景，因为页面转换不可能像列表一样快速，byte[] - Bitmap所消耗的时间几乎无感，似乎适合。\n但在页面展示如此迟钝的场景，似乎直接从文件中加载Bitmap才是最优的选择。\n\n关于缓存替代品byte[] - Bitmap，仁者见仁智者见智吧。\n\n（要提一点，为了避免byte[] - Bitmap的过程中产生大量的临时Bitmap对象，缓存byte[]的策略中应用了`inBitmap`属性，而这一属性的使用几乎不会影响到Bitmap的加载速度）\n\n\n\n\n\n\n\n\n","source":"_posts/探索Bitmap使用姿势.md","raw":"\n---\ntitle: 探索Bitmap使用姿势\ndate: 2017-7-11 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n早些时候对Android下GC调用时机比较好奇，所以写了一些case测试各种情况下Android GC调用时机与现象，感兴趣的话可以跳过去瞅瞅 ： [《Android GC机制实践调研》](https://lizhaoxuan.github.io/2016/02/17/androidgcdiaoyan/)\n\n在这个过程中发现一个让人非常震惊的问题：从资源文件中加载一张110kb的图片创建Bitmap对象，占用的内存高达40MB！\n为什么为什么为什么？？\n\n于是这篇博客便产生了，我希望可以通过一系列测试case，来了解Bitmap在各种场景下的各种使用姿势将会在内存占用和加载速度两方面都有哪些表现，从而从中探索可能的优化点和最佳实践。\n\n\n<!-- more -->\n\n## 各种场景下创建Bitmap内存占用\n\n### 从资源文件创建Bitmap\n\n#### 1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\n\n这里我们准备了一张117.16kb 1200*900的jpg图片放到了res/各种分辨率的drawabe目录下。对他们进行分别加载然后输出各种值进行对比，需要说明一下这里加载的意思可以是：执行`bitmapFactory.decodeResource` 。 与给ImageView设置Resource 、给布局设置背景等创建创建Bitmap或进行图片显示的操作相同。\n\n看下实验数据\n\n\n【努比亚Z9  Nubia NX508J】 分辨率1080 * 1920  像素密度：424ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |38880000b ≈ 37mb|14400b |2700|3600\nmdip|38880000b ≈ 37mb|14400b |2700|3600\nxhdip|9720000b ≈ 9mb|7200b |1350|1800\nxxhdip|4320000b ≈ 4mb|4800b |900|1200\n\n\n38880000b是什么概念？37MB！！\n想一下，你的应用还啥都没干呢，就仅是加载了一张图片将近40MB的内存就被占用了，再加上其他一些操作，内存妥妥的就跳到临界值了，如果再有一些不当的溢出，OOM指日可待！\n\n**似乎，图片放在分辨率越高的文件夹下，内存占用越小**\n\n\n#### 2.不同格式的图片创建Bitmap内存占用大小\n\n上面测试用的是jpg，而通常我们开发中使用的都是png，看到这么大的内存占用，我有想过是否是因为图片格式的问题，于是把这张图片丢到美图秀秀里（美图秀秀真好用），然后分别导出了长宽一样的jpg和png两张图片，放到资源文件夹中进行加载。\n\n```\n【努比亚Z9  Nubia NX508J】\ndrawable_jpg_1.jpg 1200*900  135.76kb\ndrawable_png_1.png 1200*900  1.64mb\n\njpg getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600\npng getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600\n```\n\n内存占用和之前一样，并且虽然png的图片本身高达1.64mb，但内存占用依然只是37mb。\n\n**从资源文件中加载图片的内存占用与图片格式、图片占硬盘大小无关！（但和apk包体积有关）**\n\n#### 3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\n\nAndroid存在着很多分辨率适配问题，不同drawable文件夹也是为了适配而存在的，所以我们还要挑几个分辨率不一样的手机看一下：\n\n【荣耀畅玩4X】  分辨率：1280 * 720   像素密度：267ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |17280000b ≈ 16mb |9600b |1800|2400\nmdip|17280000b ≈ 16mb |9600b |1800|2400\nxhdip|4320000b ≈ 4mb |4800b |900|1200\nxxhdip|1920000b ≈ 2mb |3200b |600|800\n\n\n诶？很明显啊，选一个分辨率低一点的手机，果然相同条件的图片加载内存占用是不一样的。我这正好还有一个和努比亚分辨率一样的手机，用这个也测一下：\n\n【乐视 le x620】  分辨率：1080 * 1920   像素密度：401ppi\n\n文件夹 | getByteCount | getRowBytes | getHeight | getWidth\n------ |:-------|:-------|:-------|:-------|\ndrawable |29773800b ≈ 28mb |12600b |2363|3150\nmdip|29773800b ≈ 28mb |12600b |2363|3150\nxhdip|7440300b ≈ 7mb |6300b |1181|1575\nxxhdip|3309600b ≈ 3mb |4200b |788|1050\n\n问题来了，虽然分辨率是一样的，但是内存占用却不同，关键因素不在分辨率，那在什么呢？\n\n我们都知道我们的应用程序在不同的设备上，Android系统会从不同的资源文件夹下获取图片资源，而其选择的本质不是屏幕的长宽比，是像素密度。\n\n**所以这里的关键在于像素密度！从资源文件中加载图片的内存占用与像素密度有关！**\n\n\nOK,上面的结论都是通过数据推理出来的一些表象现状。这里先进行一个小总结：\n\n- **从资源文件中创建Bitmap，图片所在分辨率越高的drawable文件夹，Bitmap占用内存越小。（单从内存的角度可以这样考量，但从实际应用过程中，所有素材都放到分辨率最高的文件夹并不是合适的做法）**\n- **从资源文件中创建Bitmap，Bitmap占用内存大小与图片宽高极为有关，与图片本身格式以及占硬盘大小无关。**\n- **从资源文件中创建Bitmap，Bitmap占用内存大小与手机像素密度极为有关。**\n\n\n### 从网络或本地存储创建Bitmap\n\n通过资源文件创建Bitmap，Android系统会为了适配不同屏幕，而对图片进行一些调整，导致不同情况下内存占用区别很大。那么如果是从网络或本地存储中创建的Bitmap也会因为设备的像素密度而有很大差异吗？\n\n我们来实验一下，我从网络下载一张图片，然后观察内存情况。\n\n我选了一张216932b ≈ 212kb 1600 *1280 的jpg图片下载，并创建一个Bitmap\n\n```\n【努比亚Z9  Nubia NX508J 分辨率1080 * 1920  像素密度：424ppi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n同一张图片放到资源文件中加载：\ndrawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nmdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nxhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400\nxxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\n```\nBitmap大小还是要比图片本身大出好多，而且似乎和从xxhdip文件夹下加载大小是一样的，这一个示例不足以证明是否和手机分辨率有关，我们换个手机再看看：\n\n```\n【魅族MX6 分辨率1080 * 1920  像素密度：401ppi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n资源文件加载：\ndrawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nmdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800\nxhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400\nxxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\n```\n好像看起来一样，不过这两台设备分辨率一样，像素密度也差不太多，还是不足以说明问题，我们找个像素密度更低一点的看一下：\n```\n【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n网络下载：\nbyte[] size : 216932 ≈ 212kb\nbitmap size : 8192000 ≈ 7.8125mb\n资源文件加载：\ndrawable getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\nmdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600\nxhdip getByteCount : 2048000 ≈ 2mb getRowBytes:3200 getHeight:640 getWidth:800\nxxhdip getByteCount : 910364 ≈ 1mb getRowBytes:2132 getHeight:427 getWidth:533\n```\n\n哦~ 这回有点说明性了，即使在像素密度不同情况下，从网络下载的图片创建的Bitmap大小都是固定的，从资源文件中加载则因为像素密度不同会产生很多变化。\n\n从网络直接下载得到的byte数组大小等同于原图片大小，不经处理，直接用byte创建得到Bitmap宽高会以原图片宽高创建，得到的Bitmap所占内存远大于原图在硬盘上的大小。\n\n做个小总结：\n\n- **从网络或本地存储加载图片创建Bitmap,内存占用仅与图片自身宽高有关，与设备像素密度无关。**\n- **从网络或本地读取的byte数组大小等同于图片大小，未经处理创建Bitmap内存占用远大于byte数组大小。**\n\n\n## Bitmap占用内存的大小是如何计算的？\n\n上一节的测试case，帮助我们大概的了解了Bitmap不同场景下创建的一些特性，看起来很有道理，但case覆盖不够充足的归纳法并不足以服人。\n\n但他确实已经激起了我们很浓厚的兴趣，所以下一步我们要通过源码来了解其中真正的原理。\n\nBitmap的源码解析的细节比较繁琐，有兴趣可以一层层追下去，这里就直接放结果了。\n\n还是因为有适配的问题，所以我们还要从两个方面去说明：从网络或本地加载，和从资源文件中加载。\n\n### 从网络或本地存储加载图片\n\n从网络或本地加载图片不会受到设备像素密度影响，其内存占用的大小可以用下面的公式描述：\n\n**size = 实际显示的宽 \\* 实际显示的高 \\* Bitmap.Config **\n\n说到Bitmap.Config，这个又要老生常谈了，Android为图片提供了4种解码格式，不同的解码格式占用的内存大小不同，当然显示效果也不同。\n\nFormat | byte | 说明 \n------ |:-------|:-------|:-------|:-------|\nARGB_8888 | 4b |此配置非常灵活，提供最好的质量。应尽可能使用。\nRGB_565 | 2b |此配置可能会根据源的配置产生轻微的视觉伪影。例如，没有抖动，结果可能会显示绿色的色调。为了获得更好的效果，应该应用抖动。当使用不需要高色彩保真度的不透明位图时，此配置可能很有用。\nARGB_4444 | 2b |如果应用程序需要存储半透明信息，而且还需要节省内存，则此配置最为有用。(已废弃)\nALPHA_8 | 1b |每个像素存储为单透明（alpha）通道。这对于有效地存储掩码是非常有用的。没有存储颜色信息。通过这种配置，每个像素需要1个字节的存储器。\n\n默认是ARGB_8888，虽然一直都在说建议不同情况使用不同的解码格式，但往往因为一些“不可抗拒”的因素，任何时候我们都在使用默认的解码格式。后面第三节会对不同的解码格式进行case测试。\n\n\n### 从资源文件中加载图片\n\n从资源文件中加载图片会受到drawble文件夹不同、设备像素密度影响，公式略微复杂一点：\n\nscaledWidth = int(width \\* targetDensity / density + 0.5f) \nscaledHeight = int(height \\* targetDensity / density + 0.5f) \nsize = scaledWidth \\* scaledHeight \\* Bitmap.Config \n\nwidth和height是原素材大小；\ntargetDensity 是设备像素密度；\ndensity 是素材所在drawable文件夹大小；\n\n这里要说明一下targetDensity 和 density 的值是怎么来的。给一个表来说明：\n\n名称 | density |   像素密度范围:targetDensity\n------ |:-------|:-------|:-------|:-------|\nmdpi | 160dp | 120dp ~ 160dp\nhdpi | 240dp | 160dp ~ 240dp\nxhdpi | 320dp | 240dp ~ 320dp\nxxhdpi | 480dp | 320dp ~ 480dp\nxxxhdpi | 640dp | 480dp ~ 640dp\n\n图片放到了哪个文件夹，density的值就是多少，如果每个文件夹都放了，Android会根据设备的像素密度自动选择对应的文件夹。\n\n而设备的像素密度往往并不会只有160、240、320、480、640这几个，我们可以看到第一节测试数据的几个设备像素密度都是 【努比亚Z9 像素密度：424ppi】 【荣耀畅玩4X 像素密度：267ppi】  【乐视 le x620 像素密度：401ppi】\n\n这些像素密度值是硬件的实际参数，但在系统运行时，硬件需要给Android系统提供一个准确的整数值，通常你可以粗略的将硬件实际像素密度套入上表中，去像素密度范文的最大值。但还是会有一些特殊的设备不会取标准值，比如乐视le x620的像素密度并不是标准的320dp或480dp，而是420dp。\n\n所以设备像素密度在系统运行中的值我们可以通过下面的代码获取：\n\n```\nDisplayMetrics metric = new DisplayMetrics();\nint densityDpi = metric.densityDpi;  // 屏幕密度DPI（120 / 160 / 240）\n```\n\n系统运行中取得的像素密度如下 【努比亚Z9 像素密度：480dp】 【荣耀畅玩4X 像素密度：320dp】  【乐视 le x620 像素密度：420dp】\n如果素材在每个文件夹都放了图片，那么会通过上表的像素密度范围中寻找最佳的素材进行加载。\n\n简单总结一下：\n\n- **Bitmap消耗内存大小主要取决于实际显示的大小和每个像素所占的字节数**\n- **从资源文件加载Bitmap时，还受设备像素密度与图片所在文件夹代表的像素密度之比的影响**\n\n\n## 减少Bitmap的内存占用\n\n呐，现在要进入本文的重头戏了，你当然不会看到现在网上大同小异的什么不实际加载先获取尺寸啊，各种压缩方法啊什么的说教类条目。\n\n\n### 从公式引出的优化策略\n\n第二节我们介绍了Bitmap加载占用内存的计算公式，通过公式我们可以很容易的得出一些减少Bitmap内存占用的方法。\n\n#### 减小图片实际显示的长宽\n\n通常来说我们要显示的图片会大于控件本身的大小，这是一种很明显的浪费，对图片做适当的压缩，贴近控件本身的大小可以有效的减少内存占用。主要用到的技术是 `BitmapFactory.Options.inSampleSize`属性，这个属性在Bitmap优化上已经被讲过无数次了，我们就不多介绍了。关键点：**按照控件本身大小加载图片**\n\n#### 使用更合适的解码格式加载Bitmap\n\nAndroid提供了四种Bitmap解码格式，每种格式占用内存的大小不一样，在合适的场景下选择合适解码格式可以有效的减少内存占用。这个虽然也是老生常谈，但里面会有一些不符合我们默认观念的东西，下面会详细介绍。\n\n#### 为应用提供满足当前设备像素密度的素材\n\nBitmap内存计算公式中除长、宽、解码格式三者的乘积以外，还要乘以targetDensity与density比的平方。这是什么概念呢？\n\n如果我们只提供了低像素密度的素材，那么在高像素密度的设备上将占用更大的内存。\n反之，如果我们只提供了高像素密度的素材，那么在低像素密度的设备上将占用更小的内存。\n\n诶？？？好像发现了什么？？是不是我们只要在xxhdpi甚至xxxxxxxhdpi中放素材，内存占用将会变得非常非常小？？这简直新大陆啊。\n\n如果问题真的这么简单，Android系统本身也不会提供那么多像素密度的文件夹了，口说无凭，我们写个Demo看看效果。\n\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n我将同一张图片分别copy在和xxhdpi文件夹下和mhdpi文件夹下，然后进行显示：\n(上面xxhdpi 下面 mhdpi)\n![mhdpi_xxhdpi](探索Bitmap使用姿势/mhdpi_xxhdpi.png)\n\n很明显的可以看出来与设备像素密度相同的mhdpi文件夹下素材显示正常，xxhdpi已经非常模糊了。\n\n**将素材放到高像素密度文件下，以求减少内存占用是一个愚蠢的行为。**\n\n那问题来了，为了减少apk包大小（或者是懒），大多数开发者都只会在项目中存放一套素材放到某个像素密度的文件夹下。\n这样将引起的问题是：若放到低像素密度文件夹下，遇到高像素密度设备时将占用多余的内存；若放到高像素密度文件夹下，遇到低像素密度设备，素材将会变的模糊。\n\n很痛苦对不对？所以如果对包的大小要求并没有那么严格，设定多套像素密度素材，让targetDensity与density比为1，保证显示效果与内存占用保持在最恰当的平衡才是正道。\n但如果就只能用一套呢？要想办法走歪路了……\n\n素材大部分的应用都是一些尺寸较小控件，小尺寸控件即使图片较为模糊也不会特别明显，所以这些小素材我们可以选择性忽略，是不是有点不放心？我们再跑下Demo看看效果。\n\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n下面是长宽150dp的控件，上面是xxhdpi下的素材，下面是mhdpi的素材。\n\n\n![mhdpi_xxhdpi_150](探索Bitmap使用姿势/mhdpi_xxhdpi_150.png)\n\n相同的设备相同的素材，缩小了控件大小后模糊的是不是不那么明显了？\n\n那么对于大尺寸的控件呢？这里我的建议是放到assets或res/raw、中，从assets中加载图片等同于从网络或本地加载，从raw中通过InputStream加载也可以实现同样的效果，不会受到像素密度干扰。我们可以在assets中放一张相对尺寸较大的图片，然后依照控件大小加载Bitmap，在保证以最优内存占用的同时保证图片不会模糊。\n\n当然如果图片放到了src/drawable文件夹下，通过代码` BitmapFactory.decodeStream(getResources().openRawResource(R.drawable.example));`\n效果等同于放到res/raw，但这时编译器会提示这里期望的是raw类型，一条红色的波浪线总是让人难以接受且这样的图片容易被直接使用而导致上面提到问题。\n\n将上面的代码封装到一个方法里可以避免这条红线，但还是不能避免会有其他的小伙伴直接当做资源使用这张图片。大家自己选择吧\n\n\n下面我们就看看分别放到xxhdpi、assets下面的对比图。\n设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】\n上面是xxhdpi下的素材，下面是assets的素材。\n\n![resource_assets](探索Bitmap使用姿势/resource_assets.png)\n\n又见清晰的屁股。\n当然内存占用上上面模糊的图会更小，毕竟targetDensity与density比为0.25，相当于除以4。\n不过这是一种在内存占用、展示效果、Apk包大小三者间较为平和的加载方式。\n\n此类方法适用于：全屏类型的展示素材（Splash、引导图等）、大尺寸的示例图片等。\n\n### 不同解码格式的效果\n\n上面我们遗留一个问题，如何使用更合适的解码格式加载Bitmap？下面就好好聊聊。\n\n一直以来，Bitmap优化老生常谈的一个问题：使用不同的Bitmap解码格式，以降低Bitmap内存占用。但实际过程中我们都希望图片以最优的状况展示给用户，所以用的最多的是ARGB_8888.\n\n这里我好奇的是他们之间究竟有多少差异，分别适应什么场景，我做了一些测试。\n\n奥~测试之前，再把四种解码格式的介绍列一下吧：\n\n- ALPHA_8模式\nALPHA_8模式表示的图片信息中只包含Alpha透明度信息，不包含任何颜色信息，所以ALPHA_8模式只能用在一些特殊场景。\n\n- RGB_565模式\n显然RGB_565模式不能表示所有的RGB颜色，它能表示的颜色数只有32 × 64 × 32 = 65536种，远远小于24位真彩色所能表示的颜色数（256 × 257 × 256 = 16677216）。当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。\n\n- ARGB_4444模式\nARGB_4444已被Android标记为@Deprecated，Android推荐使用ARGB_8888来代替ARGB_4444，原因是ARGB_4444表示出来的图片质量太差。 \n\n- ARGB_8888模式\nARGB_8888模式用8位来表示透明度，有256个透明度等级，用24位来表示R，G，B三个颜色通道，能够完全表示32位真彩色，但同时这种模式占用的内存空间也最大，是RGB_565模式的两倍，是ALPHA_8模式的4倍。\n\n介绍是这么写的，但真实使用情况是怎么样的？我们来测试一下：\n\n我准备了一张图片然后分别使用不同的解码格式进行解码，然后进行展示并输出Bitmap的大小：\n\n![ARGB_8888](探索Bitmap使用姿势/ARGB_8888.png)\n\n最好的解码方式展示最优的效果，当然内存占用也是最大的：1038000 ≈ 0.98mb。\n\n![ARGB_4444](探索Bitmap使用姿势/ARGB_4444.png)\n\n果然是要放弃的解码格式，大腿都花掉了，虽然内存占用小了将近一半，但也不能再用你了。\n\n![RGB_565](探索Bitmap使用姿势/RGB_565.png)\n\n诶？这个看起来好像很不错的样子，内存占用仅有ARGB_8888的四分之一，但现实上几乎看不出什么不同，还是细腻的大腿。赞赞赞。（理论上size的大小不应该只有ARGB_4444的一半，应该是相等的，这个不能理解）\n\n![ALPHA_8](探索Bitmap使用姿势/ALPHA_8.png)\n\n诶诶诶？？ALPHA_8这么强大吗？？？同样的几乎无损图，按照说明它应该是显示最差的啊，不是说不包含颜色的吗？。size的大小和RGB_565一样又是怎么回事？？？\n\n好了，这里简单解释一下，前面三张图重复的展示ARGB_8888、ARGB_4444、RGB_565三种解码格式在内存占用上的不同。ARGB_4444展会效果太差已经是不用质疑的了，但RGB_565内存占用仅有ARGB_8888的四分之一，显示上却没有明显的区别，难道说可以用RGB_565完全的代替ARGB_8888吗？\n\n不不不，当然不是这样的，我们看下RGB_565的解释：*当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。* 之所以我们没有感觉到特别大的区别，原因在与图片本身色调过于单一（满眼黄黄的大腿），RGB_565所能表示的颜色已经够用或者代替的颜色色差足够小。如果你需要展示色彩特别丰富的图片还是会看出区别的。\n\n然后我们再解释一下ALPHA_8的问题。当你设置`op1.inPreferredConfig = Bitmap.Config.ALPHA_8`为某个属性时，并不是说Bitmap解码器必然使用这种解码格式，仅是优先使用这种解码格式。不包含颜色信息的ALPHA_8怎么能解码出来黄黄的大腿呢？ALPHA_8不可以，RGB_565可以。所以解码器使用了RGB_565，具体其内部的优先级和使用策略还没有具体研究。\n\nBitmap解码器最终使用的解码格式在很大程度上取决于图片本身。\n\n既然上面的图片ALPHA_8没法解码，那黑白的二维码图片ALPHA_8可以解码吗？试一下：\n\n![DC_ARGB_8888](探索Bitmap使用姿势/DC_ARGB_8888.png)\n\n挺好的……\n\n![DC_ARGB_4444](探索Bitmap使用姿势/DC_ARGB_4444.png)\n\n简单的二维码图片，ARGB_4444也挑不出啥毛病来……\n\n![DC_RGB_565](探索Bitmap使用姿势/DC_RGB_565.png)\n\n这回size的大小合理了，和ARGB_4444一样。\n\n![DC_ALPHA_8](探索Bitmap使用姿势/DC_ALPHA_8.png)\n\n更小的size，显示效果也无不同。赞！\n\n简单总结一下：\n\n- 设置图片解码格式并不一定会使用这种解码格式，关键取决与图片本身。\n- ALPHA_8适合类似二维码一类的简单黑白图\n- RGB_565似乎可以满足大多数要求不高的展示场景\n\n### Bitmap内存复用\n\n通常来说我们在需要使用一张新的图片时，都会为这个重新分配一块内存,然后创建一个新的Bitmap对象，一个两个不会存在太大的问题，但当有大量的零时Bitmap对象被频繁创建时，将会引起频繁的GC。所以Google在很早之前发布的性能优化典范中推荐开发者使用`inBitmap`属性来对Bitmap做内存复用，通过该属性告知解码器尝试使用已经存在的内存区域，从而避免内存的重新分配。\n\n\n当然`inBitmap`是有较大限制的，有着一定的场景依赖，所以通常被使用的频率不是很高，具体限制我们后面会有简单提到。这里我们先通过Demo测试一下`inBitmap`的复用效果。\n\n首先我用下面的方法测试未复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：\n\n```\nprivate void unRecycle() {\n        byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);\n        imageView.setImageBitmap(BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length));\n        if (index >= 3) {\n            index = 0;\n        }\n    }\n```\n\n![un_recycle](探索Bitmap使用姿势/un_recycle.png)\n\n通过内存监控可知，三张图片依次加载时，内存成阶梯状上升，执行GC后，内存成断崖式下跌。在实际使用过程中，很可能因为内存无法即时回收而导致OOM，或因为大量内存需要回收而引起卡顿。\n\n然后我们在用下面的方法测试复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：\n\n```\nbyte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);\n        if (bitmap == null) {\n            BitmapFactory.Options option1 = new BitmapFactory.Options();\n            option1.inMutable = true;\n            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);\n        } else {\n            BitmapFactory.Options option1 = new BitmapFactory.Options();\n            option1.inBitmap = bitmap;\n            option1.inMutable = true;\n            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);\n        }\n        imageView.setImageBitmap(bitmap);\n        if (index >= 3) {\n            index = 0;\n        }\n```\n\n![recycle](探索Bitmap使用姿势/recycle.png)\n\n通过内存监控可知，仅在第一张图片加载时，系统分配了一块内存给Bitmap，后面两张图没用再重新进行内存分配。避免了大块内存的重新分配和GC回收。\n\n### Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比\n\n这里介绍一个最简单的适合使用`inBitmap`属性的场景：拍照！\n\n设备：【努比亚Z9 像素密度：480dp】\nDemo的界面很简单，一个ImageView用来展示图片，初次进入默认展示示例图片，点击拍照按钮调用系统相机进入拍照界面，成功拍照后将照片展示到ImageView上,可多次拍照，ImageView仅展示最新照片。\n\n**这里我们考察的点是，进入Activity后进行多次拍照，然后观察内存变化。主要关注示例图片的内存占用与拍照后的内存占用。**\n下面是Demo的界面展示，优化前后界面展示保持不变。考虑篇幅问题，这里不再贴代码，仅以文字描述，详细代码可以查看[Demo代码]()。\n\n![take_photo](探索Bitmap使用姿势/take_photo.png) ![take_photo1](探索Bitmap使用姿势/take_photo2.png)\n\n\n#### 老的拍照操作\n先说我们通常最普通的做法，仅做了简单的拍照后图片压缩显示。\n\n1.示例图片放在src/xhdpi文件夹下，通过`photoImg.setImageResource(R.drawable.example);`设置。\n2.拍照后将图片保存为本地文件，在`onActivityResult`回调方法中。以默认长宽1024x768为标准进行压缩，通过`BitmapFactory.decodeStream`创建Bitmap。（默认长宽通常为UED给出的设计稿尺寸）。\n\n然后我们看一下Demo跑起来以后的的内存监控图：\n\n![old_take_photo](探索Bitmap使用姿势/old_take_photo.jpg)\n\n解释一下：\n\n1.第一个内存上升主要是因为页面进入后，加载示例图造成的，大约占用内存8MB左右。src/xhdpi与本次测试的设备像素密度相同，如果xxhdpi像素密度的设备，内存占用更大；如果遇到像素密度更小的设备，则示例图可能会变得模糊。\n\n2.圆圈表示拍照后内存的上升，每一次拍照都将创建一个新的Bitmap，大约占用内存9MB左右。\n\n3.观察第三个圆圈，系统发生一次GC，系统回收一个Bitmap，但显而易见并没有回收干净。\n\n4.观察第五个圆圈，出现一次内存尖峰，再次发生GC，但同样没有回收干净，内存整体呈持续持续上升趋势。\n\n总结：内存并没有泄露，五次拍照均产生的为临时变量，但大内存的占用导致GC回收非常不干净。在实际使用中，未被即时回收的内存将可能导致OOM。\n即使不会引起OOM，大块内存分配引起的GC同样极易引起界面卡顿，GC运行在主线程。\n\n\n#### 新的拍照操作\n\n针对上面老的拍照操作，新的拍照操作主要做了如下优化：\n\n1.不在直接通过`photoImg.setImageResource(R.drawable.example);`设置图片，改为` BitmapFactory.decodeStream(getResources().openRawResource(srcId), null, options);`。 提高Bitmap加载速度的同时（decodeStream直接调用JNI方法），跳过Android系统针对设备像素密度对图片做的优化，直接对图片本身进行操作。\n\n2.以`Config.RGB_565`解码格式进行解码，缩小Bitmap一半内存占用。\n\n3.以ImageView实际大小为标准对示例图与照片做压缩。\n\n4.对多次拍照产生的Bitmap做复用，最终实际仅占用一个Bitmap内存。\n\n我们看下优化后的内存监控图：\n\n![new_take_photo](探索Bitmap使用姿势/new_take_photo.jpg)\n\n内存曲线过于平缓……看的不太清晰……\n\n1.示例图因为经过压缩，且跳过像素密度的适配，最终仅占用约0.3MB内存。\n\n2.因为示例图与压缩后的照片尺寸不一样，不能进行Bitmap复用，所以第一次拍照后又创建了一个Bitmap，大约占用内存1.9MB，之后多次拍照复用第二个Bitmap，没有进行内存分配，所以也没有GC发生。\n\n\n##### 总结\n\n优化结果很明显啦~\n主要的优化点：\n\n- 跳过像素密度适配直接通过 `decodeStream`对图片进行加载。\n- 按照控件大小加载图片。\n- 对Bitmap进行复用。\n\n但里面会有一些坑点：\n\n- 在Activity没有将界面完全展示时，无法获取控件宽高。此类场景如何获取请自行搜索。我在这个Demo中使用的方式是`imageView.post(new Runnable() { void run()}` 。\n- Bitmap复用有较大限制，4.4之前只能复用大小一样的，4.4之后只能复用大小等于或更小的。\n- Bitmap复用有较大限制，只能复用相同解码格式的，可能会有某些图片没有办法用`Config.RGB_565`解码，此时将不能复用。Demo中我用try catch捕获复用失败的异常，然后降级创建新的Bitmap.\n\n\n## Bitmap加载速度探索\n\n上面我们主要分析的是Bitmap占用内存方面的一些场景，在实际使用过程中，除了内存以外，Bitmap的快速加载也是非常值得我们关注的问题。\n\n这里我们仅讨论最常用的三种Bitmap加载方法。\n```\n//从资源文件中加载\nBitmapFactory.decodeResource();\n//从流中加载\nBitmapFactory.decodeStream();\n//从byte[]中加载\nBitmapFactory.decodeByteArray();\n\n```\n\n### 从资源文件中加载与流中加载对比\n\n我将同一张1080x1920 655.45k的图片放在资源文件中和Assets目录下用分别用`BitmapFactory.decodeResource();`和`BitmapFactory.decodeStream();`两种方法加载，然后测算其加载速度。\n\n同时因为每一次Bitmap的加载耗时都不一样，所以我会列出多次执行的数据。\n\n```\n【time1】\n资源文件加载Bitmap 耗时：160ms\ndecodeStream加载本地图片 耗时：57ms\n【time2】\n资源文件加载Bitmap 耗时：157ms\ndecodeStream加载本地图片 耗时：47ms\n【time3】\n资源文件加载Bitmap 耗时：162ms\ndecodeStream加载本地图片 耗时：56ms\n【time4】\n资源文件加载Bitmap 耗时：124ms\ndecodeStream加载本地图片 耗时：43ms\n【time5】\n资源文件加载Bitmap 耗时：123ms\n07decodeStream加载本地图片 耗时：43ms\n\n```\n\n数据已经很明显的说明问题了。因为BitmapFactory.decodeResource()方法会在图片加载完成后做一些适配工作，而decodeStream直接读取了字节码，速度更快。\n\n但因为缺少了适配处理，所以加载的图片是图片原本的大小，在使用中需要对其进行处理。但在加载一些明显图片尺寸大于控件尺寸的场景，decodeStream显然更为合适。\n\n### I/O耗时和图片解码耗时\n\n从接触编程开始，我们都一直在接受I/O是很耗时的观点。那么是否可以假想，在从本地文件中加载图片的场景，从本地读取数据到内存的过程消耗了很重要的一部分时间，无论这段时间多与少，都是一个优化点。\n\nOK，那么接下来我们只要通过测算其具体时间就可以验证假设了。\n\n还是那张图片，我们先从本地读取其为byte[]，然后在从byte[]通过BitmapFactory.decodeByteArray();转为Bitmap。\n\n```\n【time1】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：43ms\n\n【time2】\n读取本地图片到byte[] 耗时：2ms\nbyte[] to Bitmap 耗时：40ms\n\n【time3】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：43ms\n\n【time4】\n读取本地图片到byte[] 耗时：1ms\nbyte[] to Bitmap 耗时：39ms\n\n【time5】\n读取本地图片到byte[] 耗时：1\nbyte[] to Bitmap 耗时：39\n\n```\n\n结果还是较为失望的，从本地读取到内存中的时间消耗仅为1ms，主要耗时依然在解码上。\n\n\n### BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比\n\n\nBitmapFactory.decodeStream()直接通过流读取图片字节码，然后进行图片解码操作，对比BitmapFactory.decodeByteArray()，直观上要多出一步本地到内存的过程，虽然从本地读取数据到内存耗时仅为1ms，但我还是想知道这两者的直接对比是怎么样的。\n\n\n```\n【time1】\ndecodeStream加载本地图片 耗时：42ms\n读取本地图片到byte[] 再到Bitmap 耗时：40ms\n读取本地图片到byte[] 耗时：1ms\n\n【time2】\ndecodeStream加载本地图片 耗时：55ms\n读取本地图片到byte[] 再到Bitmap 耗时：44ms\n读取本地图片到byte[] 耗时：1ms\n\n【time3】\ndecodeStream加载本地图片 耗时：43ms\n读取本地图片到byte[] 再到Bitmap 耗时：40ms\n读取本地图片到byte[] 耗时：1ms\n\n【time4】\ndecodeStream加载本地图片 耗时：85ms\n读取本地图片到byte[] 再到Bitmap 耗时：60ms\n读取本地图片到byte[] 耗时：2ms\n\n【time5】\ndecodeStream加载本地图片 耗时：73ms\n读取本地图片到byte[] 再到Bitmap 耗时：57ms\n读取本地图片到byte[] 耗时：2ms\n\n```\n\n时间相差从3ms到20ms都有，虽然不大，但还是有一丢丢改善。\n如果对图片加载速度非常苛刻的话，可以考虑提前将图片缓存到内存中，然后通过BitmapFactory.decodeByteArray()方式进行加载。但这需要消耗额外的内存空间，是典型的空间换时间。但考虑其20ms左右优化效果，考虑这种方式还需谨慎。\n\n\n\n## 新的缓存代替品？\n\n跟上一节。虽然从加载速度考虑，BitmapFactory.decodeByteArray()代替BitmapFactory.decodeStream()的收益不大，但换一种姿势，有没有可能让收益翻番？\n\n\n一直以来图片缓存大多都是指将图片保存到本地或网络，加载后得到Bitmap保存的内存中，其优化通常是指将用过的Bitmap用缓存容器保存起来**避免重复从硬盘或网络加载**。\n\n这样的方式我们关注的更多是减小Bitmap从本地或网络创建的时间，但这样的缓存方式将会占用大量的内存空间，一般情况我们都会选择将六分之一的内存空间划分给图片缓存，**以空间换时间**，其代价还是很大的。\n\n但看过前面的一大波测试数据，我们可以很明显的感受到加载后的Bitmap占用内存大小远大于图片原本大小。究其原因，加载Bitmap会对文件本身做解码以用于显示，类似于解压操作，而图片本身是一种压缩操作。\n\n同时经过前面的测试，也许你发现了一个细节，从网络或本地读取后得到的byte[]大小是图片原本大小，那么是否可以牺牲一些byte[]到Bitmap的转换时间，仅缓存byte[]在内存中？\n\n**以时间换空间策略**，是否可行的关键在于从byte[] - Bitmap的解码时间与解释的内存开销的权衡，我们通过数据来验证。\n我准备了一张png图片，分别导出了不同的分辨率，并且copy一份对png文件进行压缩做对比测试，然后运行代码输出其各方面数据。\n此次测试我们主要考量两个标准：byte[]代替Bitmap节省的空间和byte[]转Bitmap耗费的时间。\n\n图片文件分辨率 | 是否压缩 |   byte.length | bitmap.size | use time\n------ |:-------|:-------|:-------|:-------|\n50*80 | false | 10501b≈10kb | 17600b≈17kb | 1ms\n50*80 | true | 3523b≈3kb | 17600b≈17kb | 1ms\n200*355| false | 140360b≈137kb | 284000b≈277kb | 11ms\n200*355| true |27690b≈27kb | 284000b≈277kb | 3ms\n500*888|  false |870554b≈850kb | 1776000b≈1734kb | 36ms\n500*888|  true |171101b≈167kb | 1776000b≈1734kb | 10ms\n1080*1920|  false |984712b≈961kb | 8294400b≈8100kb | 65ms\n1080*1920| true | 631610b≈616kb | 8294400b≈8100kb | 34ms\n\n我们对上面数据做一个简单的总结：\n\n- png文件压缩不会减少生成的Bitmap大小，但可以明显减少byte大小\n- 分辨率越高，byte[]替换Bitmap节省内存的越明显\n- 分辨率越高，png解码为Bitmap的耗时越久\n- 压缩后可以明显减少解码为Bitmap的耗时（byte[]越小，解码越快）\n\n同时我们也知道byte[]到Bitmap占用的时间并不是一成不变的，也就是说会在不同的设备上有不同的体现，以我目前测试的努比亚Z9来说，不同数据的差异在10~15ms之间徘徊，为了保证测试数据的说服力，我将1080*1920分辨率图片压缩前后的use time的多次数据进行展示：\n\n压缩前 | 压缩后\n------ |:-------|\n 65 | 34 \n 82 | 40\n 81 | 40\n 98 | 41\n 98 | 44\n 87 | 41\n \n另外说道byte[]越小，解码越快的问题，我们不难联想到webp，webp比png,jpg更小，读取后的byte[]也更小，是否解压的更快呢？测试一下：\n\n```\nico_1080_1920.png  bytes:984712b ≈ 961kb  bitmap:8294400b ≈ 8100kb  use:91ms\nico_1080_1920_compress.png  bytes:631610b ≈ 616kb  bitmap:8294400b ≈ 8100kb  use:44ms\nun_compress.webp  bytes:367018b ≈ 358kb  bitmap:8294400b ≈ 8100kb  use:152ms\ncompress.webp  bytes:361200b ≈ 352kb  bitmap:8294400b ≈ 8100kb  use:141ms\n\n```\n结果显而易见，下面两张图是上面两张图的webp版，虽然大幅度减少byte的大小，但解码时间也大幅度增加了。究其原因，webp的高强度压缩增加了解码复杂度，webp在其官网也早已对这种情况进行了说明。\n\n\n而byte[] - Bitmap所消耗的时间对系统流程度的影响又是如何呢？\n\n我写了一个demo，界面如下：\n\n![old_take_photo](探索Bitmap使用姿势/listview.png)\n\n经过实际测试，缓存Bitmap到内存中的策略中，第一次加载图片时，快速滑动列表，会有明显卡顿；但在图片全部缓存后，页面无卡顿。\n\n而缓存byte[]到内存中，在显示时才解码为Bitmap，第一次加载图片时，快速滑动列表，会有明细卡顿；byte[]全部缓存后，普通滑动速度几乎无卡顿；快速滑动有卡顿感。\n\n所以从用户体验的角度上来说，缓存byte[]可能并不适合在图片列表这样可以快速滑动的场景代替Bitmap缓存。\n而在ViewPager这样的场景，因为页面转换不可能像列表一样快速，byte[] - Bitmap所消耗的时间几乎无感，似乎适合。\n但在页面展示如此迟钝的场景，似乎直接从文件中加载Bitmap才是最优的选择。\n\n关于缓存替代品byte[] - Bitmap，仁者见仁智者见智吧。\n\n（要提一点，为了避免byte[] - Bitmap的过程中产生大量的临时Bitmap对象，缓存byte[]的策略中应用了`inBitmap`属性，而这一属性的使用几乎不会影响到Bitmap的加载速度）\n\n\n\n\n\n\n\n\n","slug":"探索Bitmap使用姿势","published":1,"updated":"2019-01-02T02:09:31.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqelbspr0011yo9sv1rrb1pz","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>早些时候对Android下GC调用时机比较好奇，所以写了一些case测试各种情况下Android GC调用时机与现象，感兴趣的话可以跳过去瞅瞅 ： <a href=\"https://lizhaoxuan.github.io/2016/02/17/androidgcdiaoyan/\">《Android GC机制实践调研》</a></p>\n<p>在这个过程中发现一个让人非常震惊的问题：从资源文件中加载一张110kb的图片创建Bitmap对象，占用的内存高达40MB！<br>为什么为什么为什么？？</p>\n<p>于是这篇博客便产生了，我希望可以通过一系列测试case，来了解Bitmap在各种场景下的各种使用姿势将会在内存占用和加载速度两方面都有哪些表现，从而从中探索可能的优化点和最佳实践。</p>\n<a id=\"more\"></a>\n<h2 id=\"各种场景下创建Bitmap内存占用\"><a href=\"#各种场景下创建Bitmap内存占用\" class=\"headerlink\" title=\"各种场景下创建Bitmap内存占用\"></a>各种场景下创建Bitmap内存占用</h2><h3 id=\"从资源文件创建Bitmap\"><a href=\"#从资源文件创建Bitmap\" class=\"headerlink\" title=\"从资源文件创建Bitmap\"></a>从资源文件创建Bitmap</h3><h4 id=\"1-不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\"><a href=\"#1-不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\" class=\"headerlink\" title=\"1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\"></a>1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小</h4><p>这里我们准备了一张117.16kb 1200*900的jpg图片放到了res/各种分辨率的drawabe目录下。对他们进行分别加载然后输出各种值进行对比，需要说明一下这里加载的意思可以是：执行<code>bitmapFactory.decodeResource</code> 。 与给ImageView设置Resource 、给布局设置背景等创建创建Bitmap或进行图片显示的操作相同。</p>\n<p>看下实验数据</p>\n<p>【努比亚Z9  Nubia NX508J】 分辨率1080 * 1920  像素密度：424ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">38880000b ≈ 37mb</td>\n<td style=\"text-align:left\">14400b</td>\n<td style=\"text-align:left\">2700</td>\n<td style=\"text-align:left\">3600</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">38880000b ≈ 37mb</td>\n<td style=\"text-align:left\">14400b</td>\n<td style=\"text-align:left\">2700</td>\n<td style=\"text-align:left\">3600</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">9720000b ≈ 9mb</td>\n<td style=\"text-align:left\">7200b</td>\n<td style=\"text-align:left\">1350</td>\n<td style=\"text-align:left\">1800</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">4320000b ≈ 4mb</td>\n<td style=\"text-align:left\">4800b</td>\n<td style=\"text-align:left\">900</td>\n<td style=\"text-align:left\">1200</td>\n</tr>\n</tbody>\n</table>\n<p>38880000b是什么概念？37MB！！<br>想一下，你的应用还啥都没干呢，就仅是加载了一张图片将近40MB的内存就被占用了，再加上其他一些操作，内存妥妥的就跳到临界值了，如果再有一些不当的溢出，OOM指日可待！</p>\n<p><strong>似乎，图片放在分辨率越高的文件夹下，内存占用越小</strong></p>\n<h4 id=\"2-不同格式的图片创建Bitmap内存占用大小\"><a href=\"#2-不同格式的图片创建Bitmap内存占用大小\" class=\"headerlink\" title=\"2.不同格式的图片创建Bitmap内存占用大小\"></a>2.不同格式的图片创建Bitmap内存占用大小</h4><p>上面测试用的是jpg，而通常我们开发中使用的都是png，看到这么大的内存占用，我有想过是否是因为图片格式的问题，于是把这张图片丢到美图秀秀里（美图秀秀真好用），然后分别导出了长宽一样的jpg和png两张图片，放到资源文件夹中进行加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【努比亚Z9  Nubia NX508J】</span><br><span class=\"line\">drawable_jpg_1.jpg 1200*900  135.76kb</span><br><span class=\"line\">drawable_png_1.png 1200*900  1.64mb</span><br><span class=\"line\"></span><br><span class=\"line\">jpg getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600</span><br><span class=\"line\">png getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600</span><br></pre></td></tr></table></figure>\n<p>内存占用和之前一样，并且虽然png的图片本身高达1.64mb，但内存占用依然只是37mb。</p>\n<p><strong>从资源文件中加载图片的内存占用与图片格式、图片占硬盘大小无关！（但和apk包体积有关）</strong></p>\n<h4 id=\"3-不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\"><a href=\"#3-不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\" class=\"headerlink\" title=\"3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\"></a>3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小</h4><p>Android存在着很多分辨率适配问题，不同drawable文件夹也是为了适配而存在的，所以我们还要挑几个分辨率不一样的手机看一下：</p>\n<p>【荣耀畅玩4X】  分辨率：1280 * 720   像素密度：267ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">17280000b ≈ 16mb</td>\n<td style=\"text-align:left\">9600b</td>\n<td style=\"text-align:left\">1800</td>\n<td style=\"text-align:left\">2400</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">17280000b ≈ 16mb</td>\n<td style=\"text-align:left\">9600b</td>\n<td style=\"text-align:left\">1800</td>\n<td style=\"text-align:left\">2400</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">4320000b ≈ 4mb</td>\n<td style=\"text-align:left\">4800b</td>\n<td style=\"text-align:left\">900</td>\n<td style=\"text-align:left\">1200</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">1920000b ≈ 2mb</td>\n<td style=\"text-align:left\">3200b</td>\n<td style=\"text-align:left\">600</td>\n<td style=\"text-align:left\">800</td>\n</tr>\n</tbody>\n</table>\n<p>诶？很明显啊，选一个分辨率低一点的手机，果然相同条件的图片加载内存占用是不一样的。我这正好还有一个和努比亚分辨率一样的手机，用这个也测一下：</p>\n<p>【乐视 le x620】  分辨率：1080 * 1920   像素密度：401ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">29773800b ≈ 28mb</td>\n<td style=\"text-align:left\">12600b</td>\n<td style=\"text-align:left\">2363</td>\n<td style=\"text-align:left\">3150</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">29773800b ≈ 28mb</td>\n<td style=\"text-align:left\">12600b</td>\n<td style=\"text-align:left\">2363</td>\n<td style=\"text-align:left\">3150</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">7440300b ≈ 7mb</td>\n<td style=\"text-align:left\">6300b</td>\n<td style=\"text-align:left\">1181</td>\n<td style=\"text-align:left\">1575</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">3309600b ≈ 3mb</td>\n<td style=\"text-align:left\">4200b</td>\n<td style=\"text-align:left\">788</td>\n<td style=\"text-align:left\">1050</td>\n</tr>\n</tbody>\n</table>\n<p>问题来了，虽然分辨率是一样的，但是内存占用却不同，关键因素不在分辨率，那在什么呢？</p>\n<p>我们都知道我们的应用程序在不同的设备上，Android系统会从不同的资源文件夹下获取图片资源，而其选择的本质不是屏幕的长宽比，是像素密度。</p>\n<p><strong>所以这里的关键在于像素密度！从资源文件中加载图片的内存占用与像素密度有关！</strong></p>\n<p>OK,上面的结论都是通过数据推理出来的一些表象现状。这里先进行一个小总结：</p>\n<ul>\n<li><strong>从资源文件中创建Bitmap，图片所在分辨率越高的drawable文件夹，Bitmap占用内存越小。（单从内存的角度可以这样考量，但从实际应用过程中，所有素材都放到分辨率最高的文件夹并不是合适的做法）</strong></li>\n<li><strong>从资源文件中创建Bitmap，Bitmap占用内存大小与图片宽高极为有关，与图片本身格式以及占硬盘大小无关。</strong></li>\n<li><strong>从资源文件中创建Bitmap，Bitmap占用内存大小与手机像素密度极为有关。</strong></li>\n</ul>\n<h3 id=\"从网络或本地存储创建Bitmap\"><a href=\"#从网络或本地存储创建Bitmap\" class=\"headerlink\" title=\"从网络或本地存储创建Bitmap\"></a>从网络或本地存储创建Bitmap</h3><p>通过资源文件创建Bitmap，Android系统会为了适配不同屏幕，而对图片进行一些调整，导致不同情况下内存占用区别很大。那么如果是从网络或本地存储中创建的Bitmap也会因为设备的像素密度而有很大差异吗？</p>\n<p>我们来实验一下，我从网络下载一张图片，然后观察内存情况。</p>\n<p>我选了一张216932b ≈ 212kb 1600 *1280 的jpg图片下载，并创建一个Bitmap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【努比亚Z9  Nubia NX508J 分辨率1080 * 1920  像素密度：424ppi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">同一张图片放到资源文件中加载：</span><br><span class=\"line\">drawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">mdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">xhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400</span><br><span class=\"line\">xxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br></pre></td></tr></table></figure>\n<p>Bitmap大小还是要比图片本身大出好多，而且似乎和从xxhdip文件夹下加载大小是一样的，这一个示例不足以证明是否和手机分辨率有关，我们换个手机再看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【魅族MX6 分辨率1080 * 1920  像素密度：401ppi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">资源文件加载：</span><br><span class=\"line\">drawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">mdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">xhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400</span><br><span class=\"line\">xxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br></pre></td></tr></table></figure>\n<p>好像看起来一样，不过这两台设备分辨率一样，像素密度也差不太多，还是不足以说明问题，我们找个像素密度更低一点的看一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">资源文件加载：</span><br><span class=\"line\">drawable getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br><span class=\"line\">mdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br><span class=\"line\">xhdip getByteCount : 2048000 ≈ 2mb getRowBytes:3200 getHeight:640 getWidth:800</span><br><span class=\"line\">xxhdip getByteCount : 910364 ≈ 1mb getRowBytes:2132 getHeight:427 getWidth:533</span><br></pre></td></tr></table></figure></p>\n<p>哦~ 这回有点说明性了，即使在像素密度不同情况下，从网络下载的图片创建的Bitmap大小都是固定的，从资源文件中加载则因为像素密度不同会产生很多变化。</p>\n<p>从网络直接下载得到的byte数组大小等同于原图片大小，不经处理，直接用byte创建得到Bitmap宽高会以原图片宽高创建，得到的Bitmap所占内存远大于原图在硬盘上的大小。</p>\n<p>做个小总结：</p>\n<ul>\n<li><strong>从网络或本地存储加载图片创建Bitmap,内存占用仅与图片自身宽高有关，与设备像素密度无关。</strong></li>\n<li><strong>从网络或本地读取的byte数组大小等同于图片大小，未经处理创建Bitmap内存占用远大于byte数组大小。</strong></li>\n</ul>\n<h2 id=\"Bitmap占用内存的大小是如何计算的？\"><a href=\"#Bitmap占用内存的大小是如何计算的？\" class=\"headerlink\" title=\"Bitmap占用内存的大小是如何计算的？\"></a>Bitmap占用内存的大小是如何计算的？</h2><p>上一节的测试case，帮助我们大概的了解了Bitmap不同场景下创建的一些特性，看起来很有道理，但case覆盖不够充足的归纳法并不足以服人。</p>\n<p>但他确实已经激起了我们很浓厚的兴趣，所以下一步我们要通过源码来了解其中真正的原理。</p>\n<p>Bitmap的源码解析的细节比较繁琐，有兴趣可以一层层追下去，这里就直接放结果了。</p>\n<p>还是因为有适配的问题，所以我们还要从两个方面去说明：从网络或本地加载，和从资源文件中加载。</p>\n<h3 id=\"从网络或本地存储加载图片\"><a href=\"#从网络或本地存储加载图片\" class=\"headerlink\" title=\"从网络或本地存储加载图片\"></a>从网络或本地存储加载图片</h3><p>从网络或本地加载图片不会受到设备像素密度影响，其内存占用的大小可以用下面的公式描述：</p>\n<p><strong>size = 实际显示的宽 * 实际显示的高 * Bitmap.Config </strong></p>\n<p>说到Bitmap.Config，这个又要老生常谈了，Android为图片提供了4种解码格式，不同的解码格式占用的内存大小不同，当然显示效果也不同。</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th style=\"text-align:left\">byte</th>\n<th style=\"text-align:left\">说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ARGB_8888</td>\n<td style=\"text-align:left\">4b</td>\n<td style=\"text-align:left\">此配置非常灵活，提供最好的质量。应尽可能使用。</td>\n</tr>\n<tr>\n<td>RGB_565</td>\n<td style=\"text-align:left\">2b</td>\n<td style=\"text-align:left\">此配置可能会根据源的配置产生轻微的视觉伪影。例如，没有抖动，结果可能会显示绿色的色调。为了获得更好的效果，应该应用抖动。当使用不需要高色彩保真度的不透明位图时，此配置可能很有用。</td>\n</tr>\n<tr>\n<td>ARGB_4444</td>\n<td style=\"text-align:left\">2b</td>\n<td style=\"text-align:left\">如果应用程序需要存储半透明信息，而且还需要节省内存，则此配置最为有用。(已废弃)</td>\n</tr>\n<tr>\n<td>ALPHA_8</td>\n<td style=\"text-align:left\">1b</td>\n<td style=\"text-align:left\">每个像素存储为单透明（alpha）通道。这对于有效地存储掩码是非常有用的。没有存储颜色信息。通过这种配置，每个像素需要1个字节的存储器。</td>\n</tr>\n</tbody>\n</table>\n<p>默认是ARGB_8888，虽然一直都在说建议不同情况使用不同的解码格式，但往往因为一些“不可抗拒”的因素，任何时候我们都在使用默认的解码格式。后面第三节会对不同的解码格式进行case测试。</p>\n<h3 id=\"从资源文件中加载图片\"><a href=\"#从资源文件中加载图片\" class=\"headerlink\" title=\"从资源文件中加载图片\"></a>从资源文件中加载图片</h3><p>从资源文件中加载图片会受到drawble文件夹不同、设备像素密度影响，公式略微复杂一点：</p>\n<p>scaledWidth = int(width * targetDensity / density + 0.5f)<br>scaledHeight = int(height * targetDensity / density + 0.5f)<br>size = scaledWidth * scaledHeight * Bitmap.Config </p>\n<p>width和height是原素材大小；<br>targetDensity 是设备像素密度；<br>density 是素材所在drawable文件夹大小；</p>\n<p>这里要说明一下targetDensity 和 density 的值是怎么来的。给一个表来说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">density</th>\n<th style=\"text-align:left\">像素密度范围:targetDensity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mdpi</td>\n<td style=\"text-align:left\">160dp</td>\n<td style=\"text-align:left\">120dp ~ 160dp</td>\n</tr>\n<tr>\n<td>hdpi</td>\n<td style=\"text-align:left\">240dp</td>\n<td style=\"text-align:left\">160dp ~ 240dp</td>\n</tr>\n<tr>\n<td>xhdpi</td>\n<td style=\"text-align:left\">320dp</td>\n<td style=\"text-align:left\">240dp ~ 320dp</td>\n</tr>\n<tr>\n<td>xxhdpi</td>\n<td style=\"text-align:left\">480dp</td>\n<td style=\"text-align:left\">320dp ~ 480dp</td>\n</tr>\n<tr>\n<td>xxxhdpi</td>\n<td style=\"text-align:left\">640dp</td>\n<td style=\"text-align:left\">480dp ~ 640dp</td>\n</tr>\n</tbody>\n</table>\n<p>图片放到了哪个文件夹，density的值就是多少，如果每个文件夹都放了，Android会根据设备的像素密度自动选择对应的文件夹。</p>\n<p>而设备的像素密度往往并不会只有160、240、320、480、640这几个，我们可以看到第一节测试数据的几个设备像素密度都是 【努比亚Z9 像素密度：424ppi】 【荣耀畅玩4X 像素密度：267ppi】  【乐视 le x620 像素密度：401ppi】</p>\n<p>这些像素密度值是硬件的实际参数，但在系统运行时，硬件需要给Android系统提供一个准确的整数值，通常你可以粗略的将硬件实际像素密度套入上表中，去像素密度范文的最大值。但还是会有一些特殊的设备不会取标准值，比如乐视le x620的像素密度并不是标准的320dp或480dp，而是420dp。</p>\n<p>所以设备像素密度在系统运行中的值我们可以通过下面的代码获取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayMetrics metric = new DisplayMetrics();</span><br><span class=\"line\">int densityDpi = metric.densityDpi;  // 屏幕密度DPI（120 / 160 / 240）</span><br></pre></td></tr></table></figure>\n<p>系统运行中取得的像素密度如下 【努比亚Z9 像素密度：480dp】 【荣耀畅玩4X 像素密度：320dp】  【乐视 le x620 像素密度：420dp】<br>如果素材在每个文件夹都放了图片，那么会通过上表的像素密度范围中寻找最佳的素材进行加载。</p>\n<p>简单总结一下：</p>\n<ul>\n<li><strong>Bitmap消耗内存大小主要取决于实际显示的大小和每个像素所占的字节数</strong></li>\n<li><strong>从资源文件加载Bitmap时，还受设备像素密度与图片所在文件夹代表的像素密度之比的影响</strong></li>\n</ul>\n<h2 id=\"减少Bitmap的内存占用\"><a href=\"#减少Bitmap的内存占用\" class=\"headerlink\" title=\"减少Bitmap的内存占用\"></a>减少Bitmap的内存占用</h2><p>呐，现在要进入本文的重头戏了，你当然不会看到现在网上大同小异的什么不实际加载先获取尺寸啊，各种压缩方法啊什么的说教类条目。</p>\n<h3 id=\"从公式引出的优化策略\"><a href=\"#从公式引出的优化策略\" class=\"headerlink\" title=\"从公式引出的优化策略\"></a>从公式引出的优化策略</h3><p>第二节我们介绍了Bitmap加载占用内存的计算公式，通过公式我们可以很容易的得出一些减少Bitmap内存占用的方法。</p>\n<h4 id=\"减小图片实际显示的长宽\"><a href=\"#减小图片实际显示的长宽\" class=\"headerlink\" title=\"减小图片实际显示的长宽\"></a>减小图片实际显示的长宽</h4><p>通常来说我们要显示的图片会大于控件本身的大小，这是一种很明显的浪费，对图片做适当的压缩，贴近控件本身的大小可以有效的减少内存占用。主要用到的技术是 <code>BitmapFactory.Options.inSampleSize</code>属性，这个属性在Bitmap优化上已经被讲过无数次了，我们就不多介绍了。关键点：<strong>按照控件本身大小加载图片</strong></p>\n<h4 id=\"使用更合适的解码格式加载Bitmap\"><a href=\"#使用更合适的解码格式加载Bitmap\" class=\"headerlink\" title=\"使用更合适的解码格式加载Bitmap\"></a>使用更合适的解码格式加载Bitmap</h4><p>Android提供了四种Bitmap解码格式，每种格式占用内存的大小不一样，在合适的场景下选择合适解码格式可以有效的减少内存占用。这个虽然也是老生常谈，但里面会有一些不符合我们默认观念的东西，下面会详细介绍。</p>\n<h4 id=\"为应用提供满足当前设备像素密度的素材\"><a href=\"#为应用提供满足当前设备像素密度的素材\" class=\"headerlink\" title=\"为应用提供满足当前设备像素密度的素材\"></a>为应用提供满足当前设备像素密度的素材</h4><p>Bitmap内存计算公式中除长、宽、解码格式三者的乘积以外，还要乘以targetDensity与density比的平方。这是什么概念呢？</p>\n<p>如果我们只提供了低像素密度的素材，那么在高像素密度的设备上将占用更大的内存。<br>反之，如果我们只提供了高像素密度的素材，那么在低像素密度的设备上将占用更小的内存。</p>\n<p>诶？？？好像发现了什么？？是不是我们只要在xxhdpi甚至xxxxxxxhdpi中放素材，内存占用将会变得非常非常小？？这简直新大陆啊。</p>\n<p>如果问题真的这么简单，Android系统本身也不会提供那么多像素密度的文件夹了，口说无凭，我们写个Demo看看效果。</p>\n<p>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>我将同一张图片分别copy在和xxhdpi文件夹下和mhdpi文件夹下，然后进行显示：<br>(上面xxhdpi 下面 mhdpi)<br><img src=\"/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi.png\" alt=\"mhdpi_xxhdpi\"></p>\n<p>很明显的可以看出来与设备像素密度相同的mhdpi文件夹下素材显示正常，xxhdpi已经非常模糊了。</p>\n<p><strong>将素材放到高像素密度文件下，以求减少内存占用是一个愚蠢的行为。</strong></p>\n<p>那问题来了，为了减少apk包大小（或者是懒），大多数开发者都只会在项目中存放一套素材放到某个像素密度的文件夹下。<br>这样将引起的问题是：若放到低像素密度文件夹下，遇到高像素密度设备时将占用多余的内存；若放到高像素密度文件夹下，遇到低像素密度设备，素材将会变的模糊。</p>\n<p>很痛苦对不对？所以如果对包的大小要求并没有那么严格，设定多套像素密度素材，让targetDensity与density比为1，保证显示效果与内存占用保持在最恰当的平衡才是正道。<br>但如果就只能用一套呢？要想办法走歪路了……</p>\n<p>素材大部分的应用都是一些尺寸较小控件，小尺寸控件即使图片较为模糊也不会特别明显，所以这些小素材我们可以选择性忽略，是不是有点不放心？我们再跑下Demo看看效果。</p>\n<p>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>下面是长宽150dp的控件，上面是xxhdpi下的素材，下面是mhdpi的素材。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi_150.png\" alt=\"mhdpi_xxhdpi_150\"></p>\n<p>相同的设备相同的素材，缩小了控件大小后模糊的是不是不那么明显了？</p>\n<p>那么对于大尺寸的控件呢？这里我的建议是放到assets或res/raw、中，从assets中加载图片等同于从网络或本地加载，从raw中通过InputStream加载也可以实现同样的效果，不会受到像素密度干扰。我们可以在assets中放一张相对尺寸较大的图片，然后依照控件大小加载Bitmap，在保证以最优内存占用的同时保证图片不会模糊。</p>\n<p>当然如果图片放到了src/drawable文件夹下，通过代码<code>BitmapFactory.decodeStream(getResources().openRawResource(R.drawable.example));</code><br>效果等同于放到res/raw，但这时编译器会提示这里期望的是raw类型，一条红色的波浪线总是让人难以接受且这样的图片容易被直接使用而导致上面提到问题。</p>\n<p>将上面的代码封装到一个方法里可以避免这条红线，但还是不能避免会有其他的小伙伴直接当做资源使用这张图片。大家自己选择吧</p>\n<p>下面我们就看看分别放到xxhdpi、assets下面的对比图。<br>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>上面是xxhdpi下的素材，下面是assets的素材。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/resource_assets.png\" alt=\"resource_assets\"></p>\n<p>又见清晰的屁股。<br>当然内存占用上上面模糊的图会更小，毕竟targetDensity与density比为0.25，相当于除以4。<br>不过这是一种在内存占用、展示效果、Apk包大小三者间较为平和的加载方式。</p>\n<p>此类方法适用于：全屏类型的展示素材（Splash、引导图等）、大尺寸的示例图片等。</p>\n<h3 id=\"不同解码格式的效果\"><a href=\"#不同解码格式的效果\" class=\"headerlink\" title=\"不同解码格式的效果\"></a>不同解码格式的效果</h3><p>上面我们遗留一个问题，如何使用更合适的解码格式加载Bitmap？下面就好好聊聊。</p>\n<p>一直以来，Bitmap优化老生常谈的一个问题：使用不同的Bitmap解码格式，以降低Bitmap内存占用。但实际过程中我们都希望图片以最优的状况展示给用户，所以用的最多的是ARGB_8888.</p>\n<p>这里我好奇的是他们之间究竟有多少差异，分别适应什么场景，我做了一些测试。</p>\n<p>奥~测试之前，再把四种解码格式的介绍列一下吧：</p>\n<ul>\n<li><p>ALPHA_8模式<br>ALPHA_8模式表示的图片信息中只包含Alpha透明度信息，不包含任何颜色信息，所以ALPHA_8模式只能用在一些特殊场景。</p>\n</li>\n<li><p>RGB_565模式<br>显然RGB_565模式不能表示所有的RGB颜色，它能表示的颜色数只有32 × 64 × 32 = 65536种，远远小于24位真彩色所能表示的颜色数（256 × 257 × 256 = 16677216）。当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。</p>\n</li>\n<li><p>ARGB_4444模式<br>ARGB_4444已被Android标记为@Deprecated，Android推荐使用ARGB_8888来代替ARGB_4444，原因是ARGB_4444表示出来的图片质量太差。 </p>\n</li>\n<li><p>ARGB_8888模式<br>ARGB_8888模式用8位来表示透明度，有256个透明度等级，用24位来表示R，G，B三个颜色通道，能够完全表示32位真彩色，但同时这种模式占用的内存空间也最大，是RGB_565模式的两倍，是ALPHA_8模式的4倍。</p>\n</li>\n</ul>\n<p>介绍是这么写的，但真实使用情况是怎么样的？我们来测试一下：</p>\n<p>我准备了一张图片然后分别使用不同的解码格式进行解码，然后进行展示并输出Bitmap的大小：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ARGB_8888.png\" alt=\"ARGB_8888\"></p>\n<p>最好的解码方式展示最优的效果，当然内存占用也是最大的：1038000 ≈ 0.98mb。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ARGB_4444.png\" alt=\"ARGB_4444\"></p>\n<p>果然是要放弃的解码格式，大腿都花掉了，虽然内存占用小了将近一半，但也不能再用你了。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/RGB_565.png\" alt=\"RGB_565\"></p>\n<p>诶？这个看起来好像很不错的样子，内存占用仅有ARGB_8888的四分之一，但现实上几乎看不出什么不同，还是细腻的大腿。赞赞赞。（理论上size的大小不应该只有ARGB_4444的一半，应该是相等的，这个不能理解）</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ALPHA_8.png\" alt=\"ALPHA_8\"></p>\n<p>诶诶诶？？ALPHA_8这么强大吗？？？同样的几乎无损图，按照说明它应该是显示最差的啊，不是说不包含颜色的吗？。size的大小和RGB_565一样又是怎么回事？？？</p>\n<p>好了，这里简单解释一下，前面三张图重复的展示ARGB_8888、ARGB_4444、RGB_565三种解码格式在内存占用上的不同。ARGB_4444展会效果太差已经是不用质疑的了，但RGB_565内存占用仅有ARGB_8888的四分之一，显示上却没有明显的区别，难道说可以用RGB_565完全的代替ARGB_8888吗？</p>\n<p>不不不，当然不是这样的，我们看下RGB_565的解释：<em>当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。</em> 之所以我们没有感觉到特别大的区别，原因在与图片本身色调过于单一（满眼黄黄的大腿），RGB_565所能表示的颜色已经够用或者代替的颜色色差足够小。如果你需要展示色彩特别丰富的图片还是会看出区别的。</p>\n<p>然后我们再解释一下ALPHA_8的问题。当你设置<code>op1.inPreferredConfig = Bitmap.Config.ALPHA_8</code>为某个属性时，并不是说Bitmap解码器必然使用这种解码格式，仅是优先使用这种解码格式。不包含颜色信息的ALPHA_8怎么能解码出来黄黄的大腿呢？ALPHA_8不可以，RGB_565可以。所以解码器使用了RGB_565，具体其内部的优先级和使用策略还没有具体研究。</p>\n<p>Bitmap解码器最终使用的解码格式在很大程度上取决于图片本身。</p>\n<p>既然上面的图片ALPHA_8没法解码，那黑白的二维码图片ALPHA_8可以解码吗？试一下：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ARGB_8888.png\" alt=\"DC_ARGB_8888\"></p>\n<p>挺好的……</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ARGB_4444.png\" alt=\"DC_ARGB_4444\"></p>\n<p>简单的二维码图片，ARGB_4444也挑不出啥毛病来……</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_RGB_565.png\" alt=\"DC_RGB_565\"></p>\n<p>这回size的大小合理了，和ARGB_4444一样。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ALPHA_8.png\" alt=\"DC_ALPHA_8\"></p>\n<p>更小的size，显示效果也无不同。赞！</p>\n<p>简单总结一下：</p>\n<ul>\n<li>设置图片解码格式并不一定会使用这种解码格式，关键取决与图片本身。</li>\n<li>ALPHA_8适合类似二维码一类的简单黑白图</li>\n<li>RGB_565似乎可以满足大多数要求不高的展示场景</li>\n</ul>\n<h3 id=\"Bitmap内存复用\"><a href=\"#Bitmap内存复用\" class=\"headerlink\" title=\"Bitmap内存复用\"></a>Bitmap内存复用</h3><p>通常来说我们在需要使用一张新的图片时，都会为这个重新分配一块内存,然后创建一个新的Bitmap对象，一个两个不会存在太大的问题，但当有大量的零时Bitmap对象被频繁创建时，将会引起频繁的GC。所以Google在很早之前发布的性能优化典范中推荐开发者使用<code>inBitmap</code>属性来对Bitmap做内存复用，通过该属性告知解码器尝试使用已经存在的内存区域，从而避免内存的重新分配。</p>\n<p>当然<code>inBitmap</code>是有较大限制的，有着一定的场景依赖，所以通常被使用的频率不是很高，具体限制我们后面会有简单提到。这里我们先通过Demo测试一下<code>inBitmap</code>的复用效果。</p>\n<p>首先我用下面的方法测试未复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void unRecycle() &#123;</span><br><span class=\"line\">        byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);</span><br><span class=\"line\">        imageView.setImageBitmap(BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length));</span><br><span class=\"line\">        if (index &gt;= 3) &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/un_recycle.png\" alt=\"un_recycle\"></p>\n<p>通过内存监控可知，三张图片依次加载时，内存成阶梯状上升，执行GC后，内存成断崖式下跌。在实际使用过程中，很可能因为内存无法即时回收而导致OOM，或因为大量内存需要回收而引起卡顿。</p>\n<p>然后我们在用下面的方法测试复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);</span><br><span class=\"line\">        if (bitmap == null) &#123;</span><br><span class=\"line\">            BitmapFactory.Options option1 = new BitmapFactory.Options();</span><br><span class=\"line\">            option1.inMutable = true;</span><br><span class=\"line\">            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            BitmapFactory.Options option1 = new BitmapFactory.Options();</span><br><span class=\"line\">            option1.inBitmap = bitmap;</span><br><span class=\"line\">            option1.inMutable = true;</span><br><span class=\"line\">            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        imageView.setImageBitmap(bitmap);</span><br><span class=\"line\">        if (index &gt;= 3) &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/recycle.png\" alt=\"recycle\"></p>\n<p>通过内存监控可知，仅在第一张图片加载时，系统分配了一块内存给Bitmap，后面两张图没用再重新进行内存分配。避免了大块内存的重新分配和GC回收。</p>\n<h3 id=\"Bitmap复用场景实操-拍照后图片加载与显示的优化对比\"><a href=\"#Bitmap复用场景实操-拍照后图片加载与显示的优化对比\" class=\"headerlink\" title=\"Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比\"></a>Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比</h3><p>这里介绍一个最简单的适合使用<code>inBitmap</code>属性的场景：拍照！</p>\n<p>设备：【努比亚Z9 像素密度：480dp】<br>Demo的界面很简单，一个ImageView用来展示图片，初次进入默认展示示例图片，点击拍照按钮调用系统相机进入拍照界面，成功拍照后将照片展示到ImageView上,可多次拍照，ImageView仅展示最新照片。</p>\n<p><strong>这里我们考察的点是，进入Activity后进行多次拍照，然后观察内存变化。主要关注示例图片的内存占用与拍照后的内存占用。</strong><br>下面是Demo的界面展示，优化前后界面展示保持不变。考虑篇幅问题，这里不再贴代码，仅以文字描述，详细代码可以查看<a href=\"\">Demo代码</a>。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/take_photo.png\" alt=\"take_photo\"> <img src=\"/2017/07/11/探索Bitmap使用姿势/take_photo2.png\" alt=\"take_photo1\"></p>\n<h4 id=\"老的拍照操作\"><a href=\"#老的拍照操作\" class=\"headerlink\" title=\"老的拍照操作\"></a>老的拍照操作</h4><p>先说我们通常最普通的做法，仅做了简单的拍照后图片压缩显示。</p>\n<p>1.示例图片放在src/xhdpi文件夹下，通过<code>photoImg.setImageResource(R.drawable.example);</code>设置。<br>2.拍照后将图片保存为本地文件，在<code>onActivityResult</code>回调方法中。以默认长宽1024x768为标准进行压缩，通过<code>BitmapFactory.decodeStream</code>创建Bitmap。（默认长宽通常为UED给出的设计稿尺寸）。</p>\n<p>然后我们看一下Demo跑起来以后的的内存监控图：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/old_take_photo.jpg\" alt=\"old_take_photo\"></p>\n<p>解释一下：</p>\n<p>1.第一个内存上升主要是因为页面进入后，加载示例图造成的，大约占用内存8MB左右。src/xhdpi与本次测试的设备像素密度相同，如果xxhdpi像素密度的设备，内存占用更大；如果遇到像素密度更小的设备，则示例图可能会变得模糊。</p>\n<p>2.圆圈表示拍照后内存的上升，每一次拍照都将创建一个新的Bitmap，大约占用内存9MB左右。</p>\n<p>3.观察第三个圆圈，系统发生一次GC，系统回收一个Bitmap，但显而易见并没有回收干净。</p>\n<p>4.观察第五个圆圈，出现一次内存尖峰，再次发生GC，但同样没有回收干净，内存整体呈持续持续上升趋势。</p>\n<p>总结：内存并没有泄露，五次拍照均产生的为临时变量，但大内存的占用导致GC回收非常不干净。在实际使用中，未被即时回收的内存将可能导致OOM。<br>即使不会引起OOM，大块内存分配引起的GC同样极易引起界面卡顿，GC运行在主线程。</p>\n<h4 id=\"新的拍照操作\"><a href=\"#新的拍照操作\" class=\"headerlink\" title=\"新的拍照操作\"></a>新的拍照操作</h4><p>针对上面老的拍照操作，新的拍照操作主要做了如下优化：</p>\n<p>1.不在直接通过<code>photoImg.setImageResource(R.drawable.example);</code>设置图片，改为<code>BitmapFactory.decodeStream(getResources().openRawResource(srcId), null, options);</code>。 提高Bitmap加载速度的同时（decodeStream直接调用JNI方法），跳过Android系统针对设备像素密度对图片做的优化，直接对图片本身进行操作。</p>\n<p>2.以<code>Config.RGB_565</code>解码格式进行解码，缩小Bitmap一半内存占用。</p>\n<p>3.以ImageView实际大小为标准对示例图与照片做压缩。</p>\n<p>4.对多次拍照产生的Bitmap做复用，最终实际仅占用一个Bitmap内存。</p>\n<p>我们看下优化后的内存监控图：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/new_take_photo.jpg\" alt=\"new_take_photo\"></p>\n<p>内存曲线过于平缓……看的不太清晰……</p>\n<p>1.示例图因为经过压缩，且跳过像素密度的适配，最终仅占用约0.3MB内存。</p>\n<p>2.因为示例图与压缩后的照片尺寸不一样，不能进行Bitmap复用，所以第一次拍照后又创建了一个Bitmap，大约占用内存1.9MB，之后多次拍照复用第二个Bitmap，没有进行内存分配，所以也没有GC发生。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>优化结果很明显啦~<br>主要的优化点：</p>\n<ul>\n<li>跳过像素密度适配直接通过 <code>decodeStream</code>对图片进行加载。</li>\n<li>按照控件大小加载图片。</li>\n<li>对Bitmap进行复用。</li>\n</ul>\n<p>但里面会有一些坑点：</p>\n<ul>\n<li>在Activity没有将界面完全展示时，无法获取控件宽高。此类场景如何获取请自行搜索。我在这个Demo中使用的方式是<code>imageView.post(new Runnable() { void run()}</code> 。</li>\n<li>Bitmap复用有较大限制，4.4之前只能复用大小一样的，4.4之后只能复用大小等于或更小的。</li>\n<li>Bitmap复用有较大限制，只能复用相同解码格式的，可能会有某些图片没有办法用<code>Config.RGB_565</code>解码，此时将不能复用。Demo中我用try catch捕获复用失败的异常，然后降级创建新的Bitmap.</li>\n</ul>\n<h2 id=\"Bitmap加载速度探索\"><a href=\"#Bitmap加载速度探索\" class=\"headerlink\" title=\"Bitmap加载速度探索\"></a>Bitmap加载速度探索</h2><p>上面我们主要分析的是Bitmap占用内存方面的一些场景，在实际使用过程中，除了内存以外，Bitmap的快速加载也是非常值得我们关注的问题。</p>\n<p>这里我们仅讨论最常用的三种Bitmap加载方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//从资源文件中加载</span><br><span class=\"line\">BitmapFactory.decodeResource();</span><br><span class=\"line\">//从流中加载</span><br><span class=\"line\">BitmapFactory.decodeStream();</span><br><span class=\"line\">//从byte[]中加载</span><br><span class=\"line\">BitmapFactory.decodeByteArray();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从资源文件中加载与流中加载对比\"><a href=\"#从资源文件中加载与流中加载对比\" class=\"headerlink\" title=\"从资源文件中加载与流中加载对比\"></a>从资源文件中加载与流中加载对比</h3><p>我将同一张1080x1920 655.45k的图片放在资源文件中和Assets目录下用分别用<code>BitmapFactory.decodeResource();</code>和<code>BitmapFactory.decodeStream();</code>两种方法加载，然后测算其加载速度。</p>\n<p>同时因为每一次Bitmap的加载耗时都不一样，所以我会列出多次执行的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：160ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：57ms</span><br><span class=\"line\">【time2】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：157ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：47ms</span><br><span class=\"line\">【time3】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：162ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：56ms</span><br><span class=\"line\">【time4】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：124ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：43ms</span><br><span class=\"line\">【time5】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：123ms</span><br><span class=\"line\">07decodeStream加载本地图片 耗时：43ms</span><br></pre></td></tr></table></figure>\n<p>数据已经很明显的说明问题了。因为BitmapFactory.decodeResource()方法会在图片加载完成后做一些适配工作，而decodeStream直接读取了字节码，速度更快。</p>\n<p>但因为缺少了适配处理，所以加载的图片是图片原本的大小，在使用中需要对其进行处理。但在加载一些明显图片尺寸大于控件尺寸的场景，decodeStream显然更为合适。</p>\n<h3 id=\"I-O耗时和图片解码耗时\"><a href=\"#I-O耗时和图片解码耗时\" class=\"headerlink\" title=\"I/O耗时和图片解码耗时\"></a>I/O耗时和图片解码耗时</h3><p>从接触编程开始，我们都一直在接受I/O是很耗时的观点。那么是否可以假想，在从本地文件中加载图片的场景，从本地读取数据到内存的过程消耗了很重要的一部分时间，无论这段时间多与少，都是一个优化点。</p>\n<p>OK，那么接下来我们只要通过测算其具体时间就可以验证假设了。</p>\n<p>还是那张图片，我们先从本地读取其为byte[]，然后在从byte[]通过BitmapFactory.decodeByteArray();转为Bitmap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：43ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time2】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：40ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time3】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：43ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time4】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：39ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time5】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1</span><br><span class=\"line\">byte[] to Bitmap 耗时：39</span><br></pre></td></tr></table></figure>\n<p>结果还是较为失望的，从本地读取到内存中的时间消耗仅为1ms，主要耗时依然在解码上。</p>\n<h3 id=\"BitmapFactory-decodeByteArray-与BitmapFactory-decodeStream-对比\"><a href=\"#BitmapFactory-decodeByteArray-与BitmapFactory-decodeStream-对比\" class=\"headerlink\" title=\"BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比\"></a>BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比</h3><p>BitmapFactory.decodeStream()直接通过流读取图片字节码，然后进行图片解码操作，对比BitmapFactory.decodeByteArray()，直观上要多出一步本地到内存的过程，虽然从本地读取数据到内存耗时仅为1ms，但我还是想知道这两者的直接对比是怎么样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：42ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：40ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time2】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：55ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：44ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time3】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：43ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：40ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time4】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：85ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：60ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time5】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：73ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：57ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br></pre></td></tr></table></figure>\n<p>时间相差从3ms到20ms都有，虽然不大，但还是有一丢丢改善。<br>如果对图片加载速度非常苛刻的话，可以考虑提前将图片缓存到内存中，然后通过BitmapFactory.decodeByteArray()方式进行加载。但这需要消耗额外的内存空间，是典型的空间换时间。但考虑其20ms左右优化效果，考虑这种方式还需谨慎。</p>\n<h2 id=\"新的缓存代替品？\"><a href=\"#新的缓存代替品？\" class=\"headerlink\" title=\"新的缓存代替品？\"></a>新的缓存代替品？</h2><p>跟上一节。虽然从加载速度考虑，BitmapFactory.decodeByteArray()代替BitmapFactory.decodeStream()的收益不大，但换一种姿势，有没有可能让收益翻番？</p>\n<p>一直以来图片缓存大多都是指将图片保存到本地或网络，加载后得到Bitmap保存的内存中，其优化通常是指将用过的Bitmap用缓存容器保存起来<strong>避免重复从硬盘或网络加载</strong>。</p>\n<p>这样的方式我们关注的更多是减小Bitmap从本地或网络创建的时间，但这样的缓存方式将会占用大量的内存空间，一般情况我们都会选择将六分之一的内存空间划分给图片缓存，<strong>以空间换时间</strong>，其代价还是很大的。</p>\n<p>但看过前面的一大波测试数据，我们可以很明显的感受到加载后的Bitmap占用内存大小远大于图片原本大小。究其原因，加载Bitmap会对文件本身做解码以用于显示，类似于解压操作，而图片本身是一种压缩操作。</p>\n<p>同时经过前面的测试，也许你发现了一个细节，从网络或本地读取后得到的byte[]大小是图片原本大小，那么是否可以牺牲一些byte[]到Bitmap的转换时间，仅缓存byte[]在内存中？</p>\n<p><strong>以时间换空间策略</strong>，是否可行的关键在于从byte[] - Bitmap的解码时间与解释的内存开销的权衡，我们通过数据来验证。<br>我准备了一张png图片，分别导出了不同的分辨率，并且copy一份对png文件进行压缩做对比测试，然后运行代码输出其各方面数据。<br>此次测试我们主要考量两个标准：byte[]代替Bitmap节省的空间和byte[]转Bitmap耗费的时间。</p>\n<table>\n<thead>\n<tr>\n<th>图片文件分辨率</th>\n<th style=\"text-align:left\">是否压缩</th>\n<th style=\"text-align:left\">byte.length</th>\n<th style=\"text-align:left\">bitmap.size</th>\n<th style=\"text-align:left\">use time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>50*80</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">10501b≈10kb</td>\n<td style=\"text-align:left\">17600b≈17kb</td>\n<td style=\"text-align:left\">1ms</td>\n</tr>\n<tr>\n<td>50*80</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">3523b≈3kb</td>\n<td style=\"text-align:left\">17600b≈17kb</td>\n<td style=\"text-align:left\">1ms</td>\n</tr>\n<tr>\n<td>200*355</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">140360b≈137kb</td>\n<td style=\"text-align:left\">284000b≈277kb</td>\n<td style=\"text-align:left\">11ms</td>\n</tr>\n<tr>\n<td>200*355</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">27690b≈27kb</td>\n<td style=\"text-align:left\">284000b≈277kb</td>\n<td style=\"text-align:left\">3ms</td>\n</tr>\n<tr>\n<td>500*888</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">870554b≈850kb</td>\n<td style=\"text-align:left\">1776000b≈1734kb</td>\n<td style=\"text-align:left\">36ms</td>\n</tr>\n<tr>\n<td>500*888</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">171101b≈167kb</td>\n<td style=\"text-align:left\">1776000b≈1734kb</td>\n<td style=\"text-align:left\">10ms</td>\n</tr>\n<tr>\n<td>1080*1920</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">984712b≈961kb</td>\n<td style=\"text-align:left\">8294400b≈8100kb</td>\n<td style=\"text-align:left\">65ms</td>\n</tr>\n<tr>\n<td>1080*1920</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">631610b≈616kb</td>\n<td style=\"text-align:left\">8294400b≈8100kb</td>\n<td style=\"text-align:left\">34ms</td>\n</tr>\n</tbody>\n</table>\n<p>我们对上面数据做一个简单的总结：</p>\n<ul>\n<li>png文件压缩不会减少生成的Bitmap大小，但可以明显减少byte大小</li>\n<li>分辨率越高，byte[]替换Bitmap节省内存的越明显</li>\n<li>分辨率越高，png解码为Bitmap的耗时越久</li>\n<li>压缩后可以明显减少解码为Bitmap的耗时（byte[]越小，解码越快）</li>\n</ul>\n<p>同时我们也知道byte[]到Bitmap占用的时间并不是一成不变的，也就是说会在不同的设备上有不同的体现，以我目前测试的努比亚Z9来说，不同数据的差异在10~15ms之间徘徊，为了保证测试数据的说服力，我将1080*1920分辨率图片压缩前后的use time的多次数据进行展示：</p>\n<table>\n<thead>\n<tr>\n<th>压缩前</th>\n<th style=\"text-align:left\">压缩后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 65</td>\n<td style=\"text-align:left\">34 </td>\n</tr>\n<tr>\n<td> 82</td>\n<td style=\"text-align:left\">40</td>\n</tr>\n<tr>\n<td> 81</td>\n<td style=\"text-align:left\">40</td>\n</tr>\n<tr>\n<td> 98</td>\n<td style=\"text-align:left\">41</td>\n</tr>\n<tr>\n<td> 98</td>\n<td style=\"text-align:left\">44</td>\n</tr>\n<tr>\n<td> 87</td>\n<td style=\"text-align:left\">41</td>\n</tr>\n</tbody>\n</table>\n<p>另外说道byte[]越小，解码越快的问题，我们不难联想到webp，webp比png,jpg更小，读取后的byte[]也更小，是否解压的更快呢？测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ico_1080_1920.png  bytes:984712b ≈ 961kb  bitmap:8294400b ≈ 8100kb  use:91ms</span><br><span class=\"line\">ico_1080_1920_compress.png  bytes:631610b ≈ 616kb  bitmap:8294400b ≈ 8100kb  use:44ms</span><br><span class=\"line\">un_compress.webp  bytes:367018b ≈ 358kb  bitmap:8294400b ≈ 8100kb  use:152ms</span><br><span class=\"line\">compress.webp  bytes:361200b ≈ 352kb  bitmap:8294400b ≈ 8100kb  use:141ms</span><br></pre></td></tr></table></figure>\n<p>结果显而易见，下面两张图是上面两张图的webp版，虽然大幅度减少byte的大小，但解码时间也大幅度增加了。究其原因，webp的高强度压缩增加了解码复杂度，webp在其官网也早已对这种情况进行了说明。</p>\n<p>而byte[] - Bitmap所消耗的时间对系统流程度的影响又是如何呢？</p>\n<p>我写了一个demo，界面如下：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/listview.png\" alt=\"old_take_photo\"></p>\n<p>经过实际测试，缓存Bitmap到内存中的策略中，第一次加载图片时，快速滑动列表，会有明显卡顿；但在图片全部缓存后，页面无卡顿。</p>\n<p>而缓存byte[]到内存中，在显示时才解码为Bitmap，第一次加载图片时，快速滑动列表，会有明细卡顿；byte[]全部缓存后，普通滑动速度几乎无卡顿；快速滑动有卡顿感。</p>\n<p>所以从用户体验的角度上来说，缓存byte[]可能并不适合在图片列表这样可以快速滑动的场景代替Bitmap缓存。<br>而在ViewPager这样的场景，因为页面转换不可能像列表一样快速，byte[] - Bitmap所消耗的时间几乎无感，似乎适合。<br>但在页面展示如此迟钝的场景，似乎直接从文件中加载Bitmap才是最优的选择。</p>\n<p>关于缓存替代品byte[] - Bitmap，仁者见仁智者见智吧。</p>\n<p>（要提一点，为了避免byte[] - Bitmap的过程中产生大量的临时Bitmap对象，缓存byte[]的策略中应用了<code>inBitmap</code>属性，而这一属性的使用几乎不会影响到Bitmap的加载速度）</p>\n","site":{"data":{}},"excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>早些时候对Android下GC调用时机比较好奇，所以写了一些case测试各种情况下Android GC调用时机与现象，感兴趣的话可以跳过去瞅瞅 ： <a href=\"https://lizhaoxuan.github.io/2016/02/17/androidgcdiaoyan/\">《Android GC机制实践调研》</a></p>\n<p>在这个过程中发现一个让人非常震惊的问题：从资源文件中加载一张110kb的图片创建Bitmap对象，占用的内存高达40MB！<br>为什么为什么为什么？？</p>\n<p>于是这篇博客便产生了，我希望可以通过一系列测试case，来了解Bitmap在各种场景下的各种使用姿势将会在内存占用和加载速度两方面都有哪些表现，从而从中探索可能的优化点和最佳实践。</p>","more":"<h2 id=\"各种场景下创建Bitmap内存占用\"><a href=\"#各种场景下创建Bitmap内存占用\" class=\"headerlink\" title=\"各种场景下创建Bitmap内存占用\"></a>各种场景下创建Bitmap内存占用</h2><h3 id=\"从资源文件创建Bitmap\"><a href=\"#从资源文件创建Bitmap\" class=\"headerlink\" title=\"从资源文件创建Bitmap\"></a>从资源文件创建Bitmap</h3><h4 id=\"1-不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\"><a href=\"#1-不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\" class=\"headerlink\" title=\"1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小\"></a>1.不同分辨率的drawable文件夹下加载相同素材，Bitmap的内存占用大小</h4><p>这里我们准备了一张117.16kb 1200*900的jpg图片放到了res/各种分辨率的drawabe目录下。对他们进行分别加载然后输出各种值进行对比，需要说明一下这里加载的意思可以是：执行<code>bitmapFactory.decodeResource</code> 。 与给ImageView设置Resource 、给布局设置背景等创建创建Bitmap或进行图片显示的操作相同。</p>\n<p>看下实验数据</p>\n<p>【努比亚Z9  Nubia NX508J】 分辨率1080 * 1920  像素密度：424ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">38880000b ≈ 37mb</td>\n<td style=\"text-align:left\">14400b</td>\n<td style=\"text-align:left\">2700</td>\n<td style=\"text-align:left\">3600</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">38880000b ≈ 37mb</td>\n<td style=\"text-align:left\">14400b</td>\n<td style=\"text-align:left\">2700</td>\n<td style=\"text-align:left\">3600</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">9720000b ≈ 9mb</td>\n<td style=\"text-align:left\">7200b</td>\n<td style=\"text-align:left\">1350</td>\n<td style=\"text-align:left\">1800</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">4320000b ≈ 4mb</td>\n<td style=\"text-align:left\">4800b</td>\n<td style=\"text-align:left\">900</td>\n<td style=\"text-align:left\">1200</td>\n</tr>\n</tbody>\n</table>\n<p>38880000b是什么概念？37MB！！<br>想一下，你的应用还啥都没干呢，就仅是加载了一张图片将近40MB的内存就被占用了，再加上其他一些操作，内存妥妥的就跳到临界值了，如果再有一些不当的溢出，OOM指日可待！</p>\n<p><strong>似乎，图片放在分辨率越高的文件夹下，内存占用越小</strong></p>\n<h4 id=\"2-不同格式的图片创建Bitmap内存占用大小\"><a href=\"#2-不同格式的图片创建Bitmap内存占用大小\" class=\"headerlink\" title=\"2.不同格式的图片创建Bitmap内存占用大小\"></a>2.不同格式的图片创建Bitmap内存占用大小</h4><p>上面测试用的是jpg，而通常我们开发中使用的都是png，看到这么大的内存占用，我有想过是否是因为图片格式的问题，于是把这张图片丢到美图秀秀里（美图秀秀真好用），然后分别导出了长宽一样的jpg和png两张图片，放到资源文件夹中进行加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【努比亚Z9  Nubia NX508J】</span><br><span class=\"line\">drawable_jpg_1.jpg 1200*900  135.76kb</span><br><span class=\"line\">drawable_png_1.png 1200*900  1.64mb</span><br><span class=\"line\"></span><br><span class=\"line\">jpg getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600</span><br><span class=\"line\">png getByteCount : 38880000 getRowBytes:14400 getHeight:2700 getWidth:3600</span><br></pre></td></tr></table></figure>\n<p>内存占用和之前一样，并且虽然png的图片本身高达1.64mb，但内存占用依然只是37mb。</p>\n<p><strong>从资源文件中加载图片的内存占用与图片格式、图片占硬盘大小无关！（但和apk包体积有关）</strong></p>\n<h4 id=\"3-不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\"><a href=\"#3-不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\" class=\"headerlink\" title=\"3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小\"></a>3.不同的分辨率的设备加载同一张素材，Bitmap内存占用大小</h4><p>Android存在着很多分辨率适配问题，不同drawable文件夹也是为了适配而存在的，所以我们还要挑几个分辨率不一样的手机看一下：</p>\n<p>【荣耀畅玩4X】  分辨率：1280 * 720   像素密度：267ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">17280000b ≈ 16mb</td>\n<td style=\"text-align:left\">9600b</td>\n<td style=\"text-align:left\">1800</td>\n<td style=\"text-align:left\">2400</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">17280000b ≈ 16mb</td>\n<td style=\"text-align:left\">9600b</td>\n<td style=\"text-align:left\">1800</td>\n<td style=\"text-align:left\">2400</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">4320000b ≈ 4mb</td>\n<td style=\"text-align:left\">4800b</td>\n<td style=\"text-align:left\">900</td>\n<td style=\"text-align:left\">1200</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">1920000b ≈ 2mb</td>\n<td style=\"text-align:left\">3200b</td>\n<td style=\"text-align:left\">600</td>\n<td style=\"text-align:left\">800</td>\n</tr>\n</tbody>\n</table>\n<p>诶？很明显啊，选一个分辨率低一点的手机，果然相同条件的图片加载内存占用是不一样的。我这正好还有一个和努比亚分辨率一样的手机，用这个也测一下：</p>\n<p>【乐视 le x620】  分辨率：1080 * 1920   像素密度：401ppi</p>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th style=\"text-align:left\">getByteCount</th>\n<th style=\"text-align:left\">getRowBytes</th>\n<th style=\"text-align:left\">getHeight</th>\n<th style=\"text-align:left\">getWidth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawable</td>\n<td style=\"text-align:left\">29773800b ≈ 28mb</td>\n<td style=\"text-align:left\">12600b</td>\n<td style=\"text-align:left\">2363</td>\n<td style=\"text-align:left\">3150</td>\n</tr>\n<tr>\n<td>mdip</td>\n<td style=\"text-align:left\">29773800b ≈ 28mb</td>\n<td style=\"text-align:left\">12600b</td>\n<td style=\"text-align:left\">2363</td>\n<td style=\"text-align:left\">3150</td>\n</tr>\n<tr>\n<td>xhdip</td>\n<td style=\"text-align:left\">7440300b ≈ 7mb</td>\n<td style=\"text-align:left\">6300b</td>\n<td style=\"text-align:left\">1181</td>\n<td style=\"text-align:left\">1575</td>\n</tr>\n<tr>\n<td>xxhdip</td>\n<td style=\"text-align:left\">3309600b ≈ 3mb</td>\n<td style=\"text-align:left\">4200b</td>\n<td style=\"text-align:left\">788</td>\n<td style=\"text-align:left\">1050</td>\n</tr>\n</tbody>\n</table>\n<p>问题来了，虽然分辨率是一样的，但是内存占用却不同，关键因素不在分辨率，那在什么呢？</p>\n<p>我们都知道我们的应用程序在不同的设备上，Android系统会从不同的资源文件夹下获取图片资源，而其选择的本质不是屏幕的长宽比，是像素密度。</p>\n<p><strong>所以这里的关键在于像素密度！从资源文件中加载图片的内存占用与像素密度有关！</strong></p>\n<p>OK,上面的结论都是通过数据推理出来的一些表象现状。这里先进行一个小总结：</p>\n<ul>\n<li><strong>从资源文件中创建Bitmap，图片所在分辨率越高的drawable文件夹，Bitmap占用内存越小。（单从内存的角度可以这样考量，但从实际应用过程中，所有素材都放到分辨率最高的文件夹并不是合适的做法）</strong></li>\n<li><strong>从资源文件中创建Bitmap，Bitmap占用内存大小与图片宽高极为有关，与图片本身格式以及占硬盘大小无关。</strong></li>\n<li><strong>从资源文件中创建Bitmap，Bitmap占用内存大小与手机像素密度极为有关。</strong></li>\n</ul>\n<h3 id=\"从网络或本地存储创建Bitmap\"><a href=\"#从网络或本地存储创建Bitmap\" class=\"headerlink\" title=\"从网络或本地存储创建Bitmap\"></a>从网络或本地存储创建Bitmap</h3><p>通过资源文件创建Bitmap，Android系统会为了适配不同屏幕，而对图片进行一些调整，导致不同情况下内存占用区别很大。那么如果是从网络或本地存储中创建的Bitmap也会因为设备的像素密度而有很大差异吗？</p>\n<p>我们来实验一下，我从网络下载一张图片，然后观察内存情况。</p>\n<p>我选了一张216932b ≈ 212kb 1600 *1280 的jpg图片下载，并创建一个Bitmap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【努比亚Z9  Nubia NX508J 分辨率1080 * 1920  像素密度：424ppi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">同一张图片放到资源文件中加载：</span><br><span class=\"line\">drawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">mdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">xhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400</span><br><span class=\"line\">xxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br></pre></td></tr></table></figure>\n<p>Bitmap大小还是要比图片本身大出好多，而且似乎和从xxhdip文件夹下加载大小是一样的，这一个示例不足以证明是否和手机分辨率有关，我们换个手机再看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【魅族MX6 分辨率1080 * 1920  像素密度：401ppi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">资源文件加载：</span><br><span class=\"line\">drawable getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">mdip getByteCount : 73728000 ≈ 70mb getRowBytes:19200 getHeight:3840 getWidth:4800</span><br><span class=\"line\">xhdip getByteCount : 18432000 ≈ 17.5mb getRowBytes:9600 getHeight:1920 getWidth:2400</span><br><span class=\"line\">xxhdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br></pre></td></tr></table></figure>\n<p>好像看起来一样，不过这两台设备分辨率一样，像素密度也差不太多，还是不足以说明问题，我们找个像素密度更低一点的看一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】</span><br><span class=\"line\">网络下载：</span><br><span class=\"line\">byte[] size : 216932 ≈ 212kb</span><br><span class=\"line\">bitmap size : 8192000 ≈ 7.8125mb</span><br><span class=\"line\">资源文件加载：</span><br><span class=\"line\">drawable getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br><span class=\"line\">mdip getByteCount : 8192000 ≈ 8mb getRowBytes:6400 getHeight:1280 getWidth:1600</span><br><span class=\"line\">xhdip getByteCount : 2048000 ≈ 2mb getRowBytes:3200 getHeight:640 getWidth:800</span><br><span class=\"line\">xxhdip getByteCount : 910364 ≈ 1mb getRowBytes:2132 getHeight:427 getWidth:533</span><br></pre></td></tr></table></figure></p>\n<p>哦~ 这回有点说明性了，即使在像素密度不同情况下，从网络下载的图片创建的Bitmap大小都是固定的，从资源文件中加载则因为像素密度不同会产生很多变化。</p>\n<p>从网络直接下载得到的byte数组大小等同于原图片大小，不经处理，直接用byte创建得到Bitmap宽高会以原图片宽高创建，得到的Bitmap所占内存远大于原图在硬盘上的大小。</p>\n<p>做个小总结：</p>\n<ul>\n<li><strong>从网络或本地存储加载图片创建Bitmap,内存占用仅与图片自身宽高有关，与设备像素密度无关。</strong></li>\n<li><strong>从网络或本地读取的byte数组大小等同于图片大小，未经处理创建Bitmap内存占用远大于byte数组大小。</strong></li>\n</ul>\n<h2 id=\"Bitmap占用内存的大小是如何计算的？\"><a href=\"#Bitmap占用内存的大小是如何计算的？\" class=\"headerlink\" title=\"Bitmap占用内存的大小是如何计算的？\"></a>Bitmap占用内存的大小是如何计算的？</h2><p>上一节的测试case，帮助我们大概的了解了Bitmap不同场景下创建的一些特性，看起来很有道理，但case覆盖不够充足的归纳法并不足以服人。</p>\n<p>但他确实已经激起了我们很浓厚的兴趣，所以下一步我们要通过源码来了解其中真正的原理。</p>\n<p>Bitmap的源码解析的细节比较繁琐，有兴趣可以一层层追下去，这里就直接放结果了。</p>\n<p>还是因为有适配的问题，所以我们还要从两个方面去说明：从网络或本地加载，和从资源文件中加载。</p>\n<h3 id=\"从网络或本地存储加载图片\"><a href=\"#从网络或本地存储加载图片\" class=\"headerlink\" title=\"从网络或本地存储加载图片\"></a>从网络或本地存储加载图片</h3><p>从网络或本地加载图片不会受到设备像素密度影响，其内存占用的大小可以用下面的公式描述：</p>\n<p><strong>size = 实际显示的宽 * 实际显示的高 * Bitmap.Config </strong></p>\n<p>说到Bitmap.Config，这个又要老生常谈了，Android为图片提供了4种解码格式，不同的解码格式占用的内存大小不同，当然显示效果也不同。</p>\n<table>\n<thead>\n<tr>\n<th>Format</th>\n<th style=\"text-align:left\">byte</th>\n<th style=\"text-align:left\">说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ARGB_8888</td>\n<td style=\"text-align:left\">4b</td>\n<td style=\"text-align:left\">此配置非常灵活，提供最好的质量。应尽可能使用。</td>\n</tr>\n<tr>\n<td>RGB_565</td>\n<td style=\"text-align:left\">2b</td>\n<td style=\"text-align:left\">此配置可能会根据源的配置产生轻微的视觉伪影。例如，没有抖动，结果可能会显示绿色的色调。为了获得更好的效果，应该应用抖动。当使用不需要高色彩保真度的不透明位图时，此配置可能很有用。</td>\n</tr>\n<tr>\n<td>ARGB_4444</td>\n<td style=\"text-align:left\">2b</td>\n<td style=\"text-align:left\">如果应用程序需要存储半透明信息，而且还需要节省内存，则此配置最为有用。(已废弃)</td>\n</tr>\n<tr>\n<td>ALPHA_8</td>\n<td style=\"text-align:left\">1b</td>\n<td style=\"text-align:left\">每个像素存储为单透明（alpha）通道。这对于有效地存储掩码是非常有用的。没有存储颜色信息。通过这种配置，每个像素需要1个字节的存储器。</td>\n</tr>\n</tbody>\n</table>\n<p>默认是ARGB_8888，虽然一直都在说建议不同情况使用不同的解码格式，但往往因为一些“不可抗拒”的因素，任何时候我们都在使用默认的解码格式。后面第三节会对不同的解码格式进行case测试。</p>\n<h3 id=\"从资源文件中加载图片\"><a href=\"#从资源文件中加载图片\" class=\"headerlink\" title=\"从资源文件中加载图片\"></a>从资源文件中加载图片</h3><p>从资源文件中加载图片会受到drawble文件夹不同、设备像素密度影响，公式略微复杂一点：</p>\n<p>scaledWidth = int(width * targetDensity / density + 0.5f)<br>scaledHeight = int(height * targetDensity / density + 0.5f)<br>size = scaledWidth * scaledHeight * Bitmap.Config </p>\n<p>width和height是原素材大小；<br>targetDensity 是设备像素密度；<br>density 是素材所在drawable文件夹大小；</p>\n<p>这里要说明一下targetDensity 和 density 的值是怎么来的。给一个表来说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">density</th>\n<th style=\"text-align:left\">像素密度范围:targetDensity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mdpi</td>\n<td style=\"text-align:left\">160dp</td>\n<td style=\"text-align:left\">120dp ~ 160dp</td>\n</tr>\n<tr>\n<td>hdpi</td>\n<td style=\"text-align:left\">240dp</td>\n<td style=\"text-align:left\">160dp ~ 240dp</td>\n</tr>\n<tr>\n<td>xhdpi</td>\n<td style=\"text-align:left\">320dp</td>\n<td style=\"text-align:left\">240dp ~ 320dp</td>\n</tr>\n<tr>\n<td>xxhdpi</td>\n<td style=\"text-align:left\">480dp</td>\n<td style=\"text-align:left\">320dp ~ 480dp</td>\n</tr>\n<tr>\n<td>xxxhdpi</td>\n<td style=\"text-align:left\">640dp</td>\n<td style=\"text-align:left\">480dp ~ 640dp</td>\n</tr>\n</tbody>\n</table>\n<p>图片放到了哪个文件夹，density的值就是多少，如果每个文件夹都放了，Android会根据设备的像素密度自动选择对应的文件夹。</p>\n<p>而设备的像素密度往往并不会只有160、240、320、480、640这几个，我们可以看到第一节测试数据的几个设备像素密度都是 【努比亚Z9 像素密度：424ppi】 【荣耀畅玩4X 像素密度：267ppi】  【乐视 le x620 像素密度：401ppi】</p>\n<p>这些像素密度值是硬件的实际参数，但在系统运行时，硬件需要给Android系统提供一个准确的整数值，通常你可以粗略的将硬件实际像素密度套入上表中，去像素密度范文的最大值。但还是会有一些特殊的设备不会取标准值，比如乐视le x620的像素密度并不是标准的320dp或480dp，而是420dp。</p>\n<p>所以设备像素密度在系统运行中的值我们可以通过下面的代码获取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayMetrics metric = new DisplayMetrics();</span><br><span class=\"line\">int densityDpi = metric.densityDpi;  // 屏幕密度DPI（120 / 160 / 240）</span><br></pre></td></tr></table></figure>\n<p>系统运行中取得的像素密度如下 【努比亚Z9 像素密度：480dp】 【荣耀畅玩4X 像素密度：320dp】  【乐视 le x620 像素密度：420dp】<br>如果素材在每个文件夹都放了图片，那么会通过上表的像素密度范围中寻找最佳的素材进行加载。</p>\n<p>简单总结一下：</p>\n<ul>\n<li><strong>Bitmap消耗内存大小主要取决于实际显示的大小和每个像素所占的字节数</strong></li>\n<li><strong>从资源文件加载Bitmap时，还受设备像素密度与图片所在文件夹代表的像素密度之比的影响</strong></li>\n</ul>\n<h2 id=\"减少Bitmap的内存占用\"><a href=\"#减少Bitmap的内存占用\" class=\"headerlink\" title=\"减少Bitmap的内存占用\"></a>减少Bitmap的内存占用</h2><p>呐，现在要进入本文的重头戏了，你当然不会看到现在网上大同小异的什么不实际加载先获取尺寸啊，各种压缩方法啊什么的说教类条目。</p>\n<h3 id=\"从公式引出的优化策略\"><a href=\"#从公式引出的优化策略\" class=\"headerlink\" title=\"从公式引出的优化策略\"></a>从公式引出的优化策略</h3><p>第二节我们介绍了Bitmap加载占用内存的计算公式，通过公式我们可以很容易的得出一些减少Bitmap内存占用的方法。</p>\n<h4 id=\"减小图片实际显示的长宽\"><a href=\"#减小图片实际显示的长宽\" class=\"headerlink\" title=\"减小图片实际显示的长宽\"></a>减小图片实际显示的长宽</h4><p>通常来说我们要显示的图片会大于控件本身的大小，这是一种很明显的浪费，对图片做适当的压缩，贴近控件本身的大小可以有效的减少内存占用。主要用到的技术是 <code>BitmapFactory.Options.inSampleSize</code>属性，这个属性在Bitmap优化上已经被讲过无数次了，我们就不多介绍了。关键点：<strong>按照控件本身大小加载图片</strong></p>\n<h4 id=\"使用更合适的解码格式加载Bitmap\"><a href=\"#使用更合适的解码格式加载Bitmap\" class=\"headerlink\" title=\"使用更合适的解码格式加载Bitmap\"></a>使用更合适的解码格式加载Bitmap</h4><p>Android提供了四种Bitmap解码格式，每种格式占用内存的大小不一样，在合适的场景下选择合适解码格式可以有效的减少内存占用。这个虽然也是老生常谈，但里面会有一些不符合我们默认观念的东西，下面会详细介绍。</p>\n<h4 id=\"为应用提供满足当前设备像素密度的素材\"><a href=\"#为应用提供满足当前设备像素密度的素材\" class=\"headerlink\" title=\"为应用提供满足当前设备像素密度的素材\"></a>为应用提供满足当前设备像素密度的素材</h4><p>Bitmap内存计算公式中除长、宽、解码格式三者的乘积以外，还要乘以targetDensity与density比的平方。这是什么概念呢？</p>\n<p>如果我们只提供了低像素密度的素材，那么在高像素密度的设备上将占用更大的内存。<br>反之，如果我们只提供了高像素密度的素材，那么在低像素密度的设备上将占用更小的内存。</p>\n<p>诶？？？好像发现了什么？？是不是我们只要在xxhdpi甚至xxxxxxxhdpi中放素材，内存占用将会变得非常非常小？？这简直新大陆啊。</p>\n<p>如果问题真的这么简单，Android系统本身也不会提供那么多像素密度的文件夹了，口说无凭，我们写个Demo看看效果。</p>\n<p>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>我将同一张图片分别copy在和xxhdpi文件夹下和mhdpi文件夹下，然后进行显示：<br>(上面xxhdpi 下面 mhdpi)<br><img src=\"/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi.png\" alt=\"mhdpi_xxhdpi\"></p>\n<p>很明显的可以看出来与设备像素密度相同的mhdpi文件夹下素材显示正常，xxhdpi已经非常模糊了。</p>\n<p><strong>将素材放到高像素密度文件下，以求减少内存占用是一个愚蠢的行为。</strong></p>\n<p>那问题来了，为了减少apk包大小（或者是懒），大多数开发者都只会在项目中存放一套素材放到某个像素密度的文件夹下。<br>这样将引起的问题是：若放到低像素密度文件夹下，遇到高像素密度设备时将占用多余的内存；若放到高像素密度文件夹下，遇到低像素密度设备，素材将会变的模糊。</p>\n<p>很痛苦对不对？所以如果对包的大小要求并没有那么严格，设定多套像素密度素材，让targetDensity与density比为1，保证显示效果与内存占用保持在最恰当的平衡才是正道。<br>但如果就只能用一套呢？要想办法走歪路了……</p>\n<p>素材大部分的应用都是一些尺寸较小控件，小尺寸控件即使图片较为模糊也不会特别明显，所以这些小素材我们可以选择性忽略，是不是有点不放心？我们再跑下Demo看看效果。</p>\n<p>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>下面是长宽150dp的控件，上面是xxhdpi下的素材，下面是mhdpi的素材。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/mhdpi_xxhdpi_150.png\" alt=\"mhdpi_xxhdpi_150\"></p>\n<p>相同的设备相同的素材，缩小了控件大小后模糊的是不是不那么明显了？</p>\n<p>那么对于大尺寸的控件呢？这里我的建议是放到assets或res/raw、中，从assets中加载图片等同于从网络或本地加载，从raw中通过InputStream加载也可以实现同样的效果，不会受到像素密度干扰。我们可以在assets中放一张相对尺寸较大的图片，然后依照控件大小加载Bitmap，在保证以最优内存占用的同时保证图片不会模糊。</p>\n<p>当然如果图片放到了src/drawable文件夹下，通过代码<code>BitmapFactory.decodeStream(getResources().openRawResource(R.drawable.example));</code><br>效果等同于放到res/raw，但这时编译器会提示这里期望的是raw类型，一条红色的波浪线总是让人难以接受且这样的图片容易被直接使用而导致上面提到问题。</p>\n<p>将上面的代码封装到一个方法里可以避免这条红线，但还是不能避免会有其他的小伙伴直接当做资源使用这张图片。大家自己选择吧</p>\n<p>下面我们就看看分别放到xxhdpi、assets下面的对比图。<br>设备信息：【虚拟机-5.4FWVGA 分辨率480 * 584  像素密度：mdpi 】<br>上面是xxhdpi下的素材，下面是assets的素材。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/resource_assets.png\" alt=\"resource_assets\"></p>\n<p>又见清晰的屁股。<br>当然内存占用上上面模糊的图会更小，毕竟targetDensity与density比为0.25，相当于除以4。<br>不过这是一种在内存占用、展示效果、Apk包大小三者间较为平和的加载方式。</p>\n<p>此类方法适用于：全屏类型的展示素材（Splash、引导图等）、大尺寸的示例图片等。</p>\n<h3 id=\"不同解码格式的效果\"><a href=\"#不同解码格式的效果\" class=\"headerlink\" title=\"不同解码格式的效果\"></a>不同解码格式的效果</h3><p>上面我们遗留一个问题，如何使用更合适的解码格式加载Bitmap？下面就好好聊聊。</p>\n<p>一直以来，Bitmap优化老生常谈的一个问题：使用不同的Bitmap解码格式，以降低Bitmap内存占用。但实际过程中我们都希望图片以最优的状况展示给用户，所以用的最多的是ARGB_8888.</p>\n<p>这里我好奇的是他们之间究竟有多少差异，分别适应什么场景，我做了一些测试。</p>\n<p>奥~测试之前，再把四种解码格式的介绍列一下吧：</p>\n<ul>\n<li><p>ALPHA_8模式<br>ALPHA_8模式表示的图片信息中只包含Alpha透明度信息，不包含任何颜色信息，所以ALPHA_8模式只能用在一些特殊场景。</p>\n</li>\n<li><p>RGB_565模式<br>显然RGB_565模式不能表示所有的RGB颜色，它能表示的颜色数只有32 × 64 × 32 = 65536种，远远小于24位真彩色所能表示的颜色数（256 × 257 × 256 = 16677216）。当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。</p>\n</li>\n<li><p>ARGB_4444模式<br>ARGB_4444已被Android标记为@Deprecated，Android推荐使用ARGB_8888来代替ARGB_4444，原因是ARGB_4444表示出来的图片质量太差。 </p>\n</li>\n<li><p>ARGB_8888模式<br>ARGB_8888模式用8位来表示透明度，有256个透明度等级，用24位来表示R，G，B三个颜色通道，能够完全表示32位真彩色，但同时这种模式占用的内存空间也最大，是RGB_565模式的两倍，是ALPHA_8模式的4倍。</p>\n</li>\n</ul>\n<p>介绍是这么写的，但真实使用情况是怎么样的？我们来测试一下：</p>\n<p>我准备了一张图片然后分别使用不同的解码格式进行解码，然后进行展示并输出Bitmap的大小：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ARGB_8888.png\" alt=\"ARGB_8888\"></p>\n<p>最好的解码方式展示最优的效果，当然内存占用也是最大的：1038000 ≈ 0.98mb。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ARGB_4444.png\" alt=\"ARGB_4444\"></p>\n<p>果然是要放弃的解码格式，大腿都花掉了，虽然内存占用小了将近一半，但也不能再用你了。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/RGB_565.png\" alt=\"RGB_565\"></p>\n<p>诶？这个看起来好像很不错的样子，内存占用仅有ARGB_8888的四分之一，但现实上几乎看不出什么不同，还是细腻的大腿。赞赞赞。（理论上size的大小不应该只有ARGB_4444的一半，应该是相等的，这个不能理解）</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/ALPHA_8.png\" alt=\"ALPHA_8\"></p>\n<p>诶诶诶？？ALPHA_8这么强大吗？？？同样的几乎无损图，按照说明它应该是显示最差的啊，不是说不包含颜色的吗？。size的大小和RGB_565一样又是怎么回事？？？</p>\n<p>好了，这里简单解释一下，前面三张图重复的展示ARGB_8888、ARGB_4444、RGB_565三种解码格式在内存占用上的不同。ARGB_4444展会效果太差已经是不用质疑的了，但RGB_565内存占用仅有ARGB_8888的四分之一，显示上却没有明显的区别，难道说可以用RGB_565完全的代替ARGB_8888吗？</p>\n<p>不不不，当然不是这样的，我们看下RGB_565的解释：<em>当图片中某个像素的颜色不在RGB_565模式表示的颜色范围内时，会使用相近的颜色来表示。</em> 之所以我们没有感觉到特别大的区别，原因在与图片本身色调过于单一（满眼黄黄的大腿），RGB_565所能表示的颜色已经够用或者代替的颜色色差足够小。如果你需要展示色彩特别丰富的图片还是会看出区别的。</p>\n<p>然后我们再解释一下ALPHA_8的问题。当你设置<code>op1.inPreferredConfig = Bitmap.Config.ALPHA_8</code>为某个属性时，并不是说Bitmap解码器必然使用这种解码格式，仅是优先使用这种解码格式。不包含颜色信息的ALPHA_8怎么能解码出来黄黄的大腿呢？ALPHA_8不可以，RGB_565可以。所以解码器使用了RGB_565，具体其内部的优先级和使用策略还没有具体研究。</p>\n<p>Bitmap解码器最终使用的解码格式在很大程度上取决于图片本身。</p>\n<p>既然上面的图片ALPHA_8没法解码，那黑白的二维码图片ALPHA_8可以解码吗？试一下：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ARGB_8888.png\" alt=\"DC_ARGB_8888\"></p>\n<p>挺好的……</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ARGB_4444.png\" alt=\"DC_ARGB_4444\"></p>\n<p>简单的二维码图片，ARGB_4444也挑不出啥毛病来……</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_RGB_565.png\" alt=\"DC_RGB_565\"></p>\n<p>这回size的大小合理了，和ARGB_4444一样。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/DC_ALPHA_8.png\" alt=\"DC_ALPHA_8\"></p>\n<p>更小的size，显示效果也无不同。赞！</p>\n<p>简单总结一下：</p>\n<ul>\n<li>设置图片解码格式并不一定会使用这种解码格式，关键取决与图片本身。</li>\n<li>ALPHA_8适合类似二维码一类的简单黑白图</li>\n<li>RGB_565似乎可以满足大多数要求不高的展示场景</li>\n</ul>\n<h3 id=\"Bitmap内存复用\"><a href=\"#Bitmap内存复用\" class=\"headerlink\" title=\"Bitmap内存复用\"></a>Bitmap内存复用</h3><p>通常来说我们在需要使用一张新的图片时，都会为这个重新分配一块内存,然后创建一个新的Bitmap对象，一个两个不会存在太大的问题，但当有大量的零时Bitmap对象被频繁创建时，将会引起频繁的GC。所以Google在很早之前发布的性能优化典范中推荐开发者使用<code>inBitmap</code>属性来对Bitmap做内存复用，通过该属性告知解码器尝试使用已经存在的内存区域，从而避免内存的重新分配。</p>\n<p>当然<code>inBitmap</code>是有较大限制的，有着一定的场景依赖，所以通常被使用的频率不是很高，具体限制我们后面会有简单提到。这里我们先通过Demo测试一下<code>inBitmap</code>的复用效果。</p>\n<p>首先我用下面的方法测试未复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void unRecycle() &#123;</span><br><span class=\"line\">        byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);</span><br><span class=\"line\">        imageView.setImageBitmap(BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length));</span><br><span class=\"line\">        if (index &gt;= 3) &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/un_recycle.png\" alt=\"un_recycle\"></p>\n<p>通过内存监控可知，三张图片依次加载时，内存成阶梯状上升，执行GC后，内存成断崖式下跌。在实际使用过程中，很可能因为内存无法即时回收而导致OOM，或因为大量内存需要回收而引起卡顿。</p>\n<p>然后我们在用下面的方法测试复用Bitmap内存的情况下，在一个ImageView依次显示三张图片时内存占用情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte[] welcome1 = Tool.readFile(this, bitmapPaths[index++]);</span><br><span class=\"line\">        if (bitmap == null) &#123;</span><br><span class=\"line\">            BitmapFactory.Options option1 = new BitmapFactory.Options();</span><br><span class=\"line\">            option1.inMutable = true;</span><br><span class=\"line\">            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            BitmapFactory.Options option1 = new BitmapFactory.Options();</span><br><span class=\"line\">            option1.inBitmap = bitmap;</span><br><span class=\"line\">            option1.inMutable = true;</span><br><span class=\"line\">            bitmap = BitmapFactory.decodeByteArray(welcome1, 0, welcome1.length, option1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        imageView.setImageBitmap(bitmap);</span><br><span class=\"line\">        if (index &gt;= 3) &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/recycle.png\" alt=\"recycle\"></p>\n<p>通过内存监控可知，仅在第一张图片加载时，系统分配了一块内存给Bitmap，后面两张图没用再重新进行内存分配。避免了大块内存的重新分配和GC回收。</p>\n<h3 id=\"Bitmap复用场景实操-拍照后图片加载与显示的优化对比\"><a href=\"#Bitmap复用场景实操-拍照后图片加载与显示的优化对比\" class=\"headerlink\" title=\"Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比\"></a>Bitmap复用场景实操 - 拍照后图片加载与显示的优化对比</h3><p>这里介绍一个最简单的适合使用<code>inBitmap</code>属性的场景：拍照！</p>\n<p>设备：【努比亚Z9 像素密度：480dp】<br>Demo的界面很简单，一个ImageView用来展示图片，初次进入默认展示示例图片，点击拍照按钮调用系统相机进入拍照界面，成功拍照后将照片展示到ImageView上,可多次拍照，ImageView仅展示最新照片。</p>\n<p><strong>这里我们考察的点是，进入Activity后进行多次拍照，然后观察内存变化。主要关注示例图片的内存占用与拍照后的内存占用。</strong><br>下面是Demo的界面展示，优化前后界面展示保持不变。考虑篇幅问题，这里不再贴代码，仅以文字描述，详细代码可以查看<a href=\"\">Demo代码</a>。</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/take_photo.png\" alt=\"take_photo\"> <img src=\"/2017/07/11/探索Bitmap使用姿势/take_photo2.png\" alt=\"take_photo1\"></p>\n<h4 id=\"老的拍照操作\"><a href=\"#老的拍照操作\" class=\"headerlink\" title=\"老的拍照操作\"></a>老的拍照操作</h4><p>先说我们通常最普通的做法，仅做了简单的拍照后图片压缩显示。</p>\n<p>1.示例图片放在src/xhdpi文件夹下，通过<code>photoImg.setImageResource(R.drawable.example);</code>设置。<br>2.拍照后将图片保存为本地文件，在<code>onActivityResult</code>回调方法中。以默认长宽1024x768为标准进行压缩，通过<code>BitmapFactory.decodeStream</code>创建Bitmap。（默认长宽通常为UED给出的设计稿尺寸）。</p>\n<p>然后我们看一下Demo跑起来以后的的内存监控图：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/old_take_photo.jpg\" alt=\"old_take_photo\"></p>\n<p>解释一下：</p>\n<p>1.第一个内存上升主要是因为页面进入后，加载示例图造成的，大约占用内存8MB左右。src/xhdpi与本次测试的设备像素密度相同，如果xxhdpi像素密度的设备，内存占用更大；如果遇到像素密度更小的设备，则示例图可能会变得模糊。</p>\n<p>2.圆圈表示拍照后内存的上升，每一次拍照都将创建一个新的Bitmap，大约占用内存9MB左右。</p>\n<p>3.观察第三个圆圈，系统发生一次GC，系统回收一个Bitmap，但显而易见并没有回收干净。</p>\n<p>4.观察第五个圆圈，出现一次内存尖峰，再次发生GC，但同样没有回收干净，内存整体呈持续持续上升趋势。</p>\n<p>总结：内存并没有泄露，五次拍照均产生的为临时变量，但大内存的占用导致GC回收非常不干净。在实际使用中，未被即时回收的内存将可能导致OOM。<br>即使不会引起OOM，大块内存分配引起的GC同样极易引起界面卡顿，GC运行在主线程。</p>\n<h4 id=\"新的拍照操作\"><a href=\"#新的拍照操作\" class=\"headerlink\" title=\"新的拍照操作\"></a>新的拍照操作</h4><p>针对上面老的拍照操作，新的拍照操作主要做了如下优化：</p>\n<p>1.不在直接通过<code>photoImg.setImageResource(R.drawable.example);</code>设置图片，改为<code>BitmapFactory.decodeStream(getResources().openRawResource(srcId), null, options);</code>。 提高Bitmap加载速度的同时（decodeStream直接调用JNI方法），跳过Android系统针对设备像素密度对图片做的优化，直接对图片本身进行操作。</p>\n<p>2.以<code>Config.RGB_565</code>解码格式进行解码，缩小Bitmap一半内存占用。</p>\n<p>3.以ImageView实际大小为标准对示例图与照片做压缩。</p>\n<p>4.对多次拍照产生的Bitmap做复用，最终实际仅占用一个Bitmap内存。</p>\n<p>我们看下优化后的内存监控图：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/new_take_photo.jpg\" alt=\"new_take_photo\"></p>\n<p>内存曲线过于平缓……看的不太清晰……</p>\n<p>1.示例图因为经过压缩，且跳过像素密度的适配，最终仅占用约0.3MB内存。</p>\n<p>2.因为示例图与压缩后的照片尺寸不一样，不能进行Bitmap复用，所以第一次拍照后又创建了一个Bitmap，大约占用内存1.9MB，之后多次拍照复用第二个Bitmap，没有进行内存分配，所以也没有GC发生。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>优化结果很明显啦~<br>主要的优化点：</p>\n<ul>\n<li>跳过像素密度适配直接通过 <code>decodeStream</code>对图片进行加载。</li>\n<li>按照控件大小加载图片。</li>\n<li>对Bitmap进行复用。</li>\n</ul>\n<p>但里面会有一些坑点：</p>\n<ul>\n<li>在Activity没有将界面完全展示时，无法获取控件宽高。此类场景如何获取请自行搜索。我在这个Demo中使用的方式是<code>imageView.post(new Runnable() { void run()}</code> 。</li>\n<li>Bitmap复用有较大限制，4.4之前只能复用大小一样的，4.4之后只能复用大小等于或更小的。</li>\n<li>Bitmap复用有较大限制，只能复用相同解码格式的，可能会有某些图片没有办法用<code>Config.RGB_565</code>解码，此时将不能复用。Demo中我用try catch捕获复用失败的异常，然后降级创建新的Bitmap.</li>\n</ul>\n<h2 id=\"Bitmap加载速度探索\"><a href=\"#Bitmap加载速度探索\" class=\"headerlink\" title=\"Bitmap加载速度探索\"></a>Bitmap加载速度探索</h2><p>上面我们主要分析的是Bitmap占用内存方面的一些场景，在实际使用过程中，除了内存以外，Bitmap的快速加载也是非常值得我们关注的问题。</p>\n<p>这里我们仅讨论最常用的三种Bitmap加载方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//从资源文件中加载</span><br><span class=\"line\">BitmapFactory.decodeResource();</span><br><span class=\"line\">//从流中加载</span><br><span class=\"line\">BitmapFactory.decodeStream();</span><br><span class=\"line\">//从byte[]中加载</span><br><span class=\"line\">BitmapFactory.decodeByteArray();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"从资源文件中加载与流中加载对比\"><a href=\"#从资源文件中加载与流中加载对比\" class=\"headerlink\" title=\"从资源文件中加载与流中加载对比\"></a>从资源文件中加载与流中加载对比</h3><p>我将同一张1080x1920 655.45k的图片放在资源文件中和Assets目录下用分别用<code>BitmapFactory.decodeResource();</code>和<code>BitmapFactory.decodeStream();</code>两种方法加载，然后测算其加载速度。</p>\n<p>同时因为每一次Bitmap的加载耗时都不一样，所以我会列出多次执行的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：160ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：57ms</span><br><span class=\"line\">【time2】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：157ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：47ms</span><br><span class=\"line\">【time3】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：162ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：56ms</span><br><span class=\"line\">【time4】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：124ms</span><br><span class=\"line\">decodeStream加载本地图片 耗时：43ms</span><br><span class=\"line\">【time5】</span><br><span class=\"line\">资源文件加载Bitmap 耗时：123ms</span><br><span class=\"line\">07decodeStream加载本地图片 耗时：43ms</span><br></pre></td></tr></table></figure>\n<p>数据已经很明显的说明问题了。因为BitmapFactory.decodeResource()方法会在图片加载完成后做一些适配工作，而decodeStream直接读取了字节码，速度更快。</p>\n<p>但因为缺少了适配处理，所以加载的图片是图片原本的大小，在使用中需要对其进行处理。但在加载一些明显图片尺寸大于控件尺寸的场景，decodeStream显然更为合适。</p>\n<h3 id=\"I-O耗时和图片解码耗时\"><a href=\"#I-O耗时和图片解码耗时\" class=\"headerlink\" title=\"I/O耗时和图片解码耗时\"></a>I/O耗时和图片解码耗时</h3><p>从接触编程开始，我们都一直在接受I/O是很耗时的观点。那么是否可以假想，在从本地文件中加载图片的场景，从本地读取数据到内存的过程消耗了很重要的一部分时间，无论这段时间多与少，都是一个优化点。</p>\n<p>OK，那么接下来我们只要通过测算其具体时间就可以验证假设了。</p>\n<p>还是那张图片，我们先从本地读取其为byte[]，然后在从byte[]通过BitmapFactory.decodeByteArray();转为Bitmap。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：43ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time2】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：40ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time3】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：43ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time4】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\">byte[] to Bitmap 耗时：39ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time5】</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1</span><br><span class=\"line\">byte[] to Bitmap 耗时：39</span><br></pre></td></tr></table></figure>\n<p>结果还是较为失望的，从本地读取到内存中的时间消耗仅为1ms，主要耗时依然在解码上。</p>\n<h3 id=\"BitmapFactory-decodeByteArray-与BitmapFactory-decodeStream-对比\"><a href=\"#BitmapFactory-decodeByteArray-与BitmapFactory-decodeStream-对比\" class=\"headerlink\" title=\"BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比\"></a>BitmapFactory.decodeByteArray()与BitmapFactory.decodeStream()对比</h3><p>BitmapFactory.decodeStream()直接通过流读取图片字节码，然后进行图片解码操作，对比BitmapFactory.decodeByteArray()，直观上要多出一步本地到内存的过程，虽然从本地读取数据到内存耗时仅为1ms，但我还是想知道这两者的直接对比是怎么样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【time1】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：42ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：40ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time2】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：55ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：44ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time3】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：43ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：40ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：1ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time4】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：85ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：60ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br><span class=\"line\"></span><br><span class=\"line\">【time5】</span><br><span class=\"line\">decodeStream加载本地图片 耗时：73ms</span><br><span class=\"line\">读取本地图片到byte[] 再到Bitmap 耗时：57ms</span><br><span class=\"line\">读取本地图片到byte[] 耗时：2ms</span><br></pre></td></tr></table></figure>\n<p>时间相差从3ms到20ms都有，虽然不大，但还是有一丢丢改善。<br>如果对图片加载速度非常苛刻的话，可以考虑提前将图片缓存到内存中，然后通过BitmapFactory.decodeByteArray()方式进行加载。但这需要消耗额外的内存空间，是典型的空间换时间。但考虑其20ms左右优化效果，考虑这种方式还需谨慎。</p>\n<h2 id=\"新的缓存代替品？\"><a href=\"#新的缓存代替品？\" class=\"headerlink\" title=\"新的缓存代替品？\"></a>新的缓存代替品？</h2><p>跟上一节。虽然从加载速度考虑，BitmapFactory.decodeByteArray()代替BitmapFactory.decodeStream()的收益不大，但换一种姿势，有没有可能让收益翻番？</p>\n<p>一直以来图片缓存大多都是指将图片保存到本地或网络，加载后得到Bitmap保存的内存中，其优化通常是指将用过的Bitmap用缓存容器保存起来<strong>避免重复从硬盘或网络加载</strong>。</p>\n<p>这样的方式我们关注的更多是减小Bitmap从本地或网络创建的时间，但这样的缓存方式将会占用大量的内存空间，一般情况我们都会选择将六分之一的内存空间划分给图片缓存，<strong>以空间换时间</strong>，其代价还是很大的。</p>\n<p>但看过前面的一大波测试数据，我们可以很明显的感受到加载后的Bitmap占用内存大小远大于图片原本大小。究其原因，加载Bitmap会对文件本身做解码以用于显示，类似于解压操作，而图片本身是一种压缩操作。</p>\n<p>同时经过前面的测试，也许你发现了一个细节，从网络或本地读取后得到的byte[]大小是图片原本大小，那么是否可以牺牲一些byte[]到Bitmap的转换时间，仅缓存byte[]在内存中？</p>\n<p><strong>以时间换空间策略</strong>，是否可行的关键在于从byte[] - Bitmap的解码时间与解释的内存开销的权衡，我们通过数据来验证。<br>我准备了一张png图片，分别导出了不同的分辨率，并且copy一份对png文件进行压缩做对比测试，然后运行代码输出其各方面数据。<br>此次测试我们主要考量两个标准：byte[]代替Bitmap节省的空间和byte[]转Bitmap耗费的时间。</p>\n<table>\n<thead>\n<tr>\n<th>图片文件分辨率</th>\n<th style=\"text-align:left\">是否压缩</th>\n<th style=\"text-align:left\">byte.length</th>\n<th style=\"text-align:left\">bitmap.size</th>\n<th style=\"text-align:left\">use time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>50*80</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">10501b≈10kb</td>\n<td style=\"text-align:left\">17600b≈17kb</td>\n<td style=\"text-align:left\">1ms</td>\n</tr>\n<tr>\n<td>50*80</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">3523b≈3kb</td>\n<td style=\"text-align:left\">17600b≈17kb</td>\n<td style=\"text-align:left\">1ms</td>\n</tr>\n<tr>\n<td>200*355</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">140360b≈137kb</td>\n<td style=\"text-align:left\">284000b≈277kb</td>\n<td style=\"text-align:left\">11ms</td>\n</tr>\n<tr>\n<td>200*355</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">27690b≈27kb</td>\n<td style=\"text-align:left\">284000b≈277kb</td>\n<td style=\"text-align:left\">3ms</td>\n</tr>\n<tr>\n<td>500*888</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">870554b≈850kb</td>\n<td style=\"text-align:left\">1776000b≈1734kb</td>\n<td style=\"text-align:left\">36ms</td>\n</tr>\n<tr>\n<td>500*888</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">171101b≈167kb</td>\n<td style=\"text-align:left\">1776000b≈1734kb</td>\n<td style=\"text-align:left\">10ms</td>\n</tr>\n<tr>\n<td>1080*1920</td>\n<td style=\"text-align:left\">false</td>\n<td style=\"text-align:left\">984712b≈961kb</td>\n<td style=\"text-align:left\">8294400b≈8100kb</td>\n<td style=\"text-align:left\">65ms</td>\n</tr>\n<tr>\n<td>1080*1920</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">631610b≈616kb</td>\n<td style=\"text-align:left\">8294400b≈8100kb</td>\n<td style=\"text-align:left\">34ms</td>\n</tr>\n</tbody>\n</table>\n<p>我们对上面数据做一个简单的总结：</p>\n<ul>\n<li>png文件压缩不会减少生成的Bitmap大小，但可以明显减少byte大小</li>\n<li>分辨率越高，byte[]替换Bitmap节省内存的越明显</li>\n<li>分辨率越高，png解码为Bitmap的耗时越久</li>\n<li>压缩后可以明显减少解码为Bitmap的耗时（byte[]越小，解码越快）</li>\n</ul>\n<p>同时我们也知道byte[]到Bitmap占用的时间并不是一成不变的，也就是说会在不同的设备上有不同的体现，以我目前测试的努比亚Z9来说，不同数据的差异在10~15ms之间徘徊，为了保证测试数据的说服力，我将1080*1920分辨率图片压缩前后的use time的多次数据进行展示：</p>\n<table>\n<thead>\n<tr>\n<th>压缩前</th>\n<th style=\"text-align:left\">压缩后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 65</td>\n<td style=\"text-align:left\">34 </td>\n</tr>\n<tr>\n<td> 82</td>\n<td style=\"text-align:left\">40</td>\n</tr>\n<tr>\n<td> 81</td>\n<td style=\"text-align:left\">40</td>\n</tr>\n<tr>\n<td> 98</td>\n<td style=\"text-align:left\">41</td>\n</tr>\n<tr>\n<td> 98</td>\n<td style=\"text-align:left\">44</td>\n</tr>\n<tr>\n<td> 87</td>\n<td style=\"text-align:left\">41</td>\n</tr>\n</tbody>\n</table>\n<p>另外说道byte[]越小，解码越快的问题，我们不难联想到webp，webp比png,jpg更小，读取后的byte[]也更小，是否解压的更快呢？测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ico_1080_1920.png  bytes:984712b ≈ 961kb  bitmap:8294400b ≈ 8100kb  use:91ms</span><br><span class=\"line\">ico_1080_1920_compress.png  bytes:631610b ≈ 616kb  bitmap:8294400b ≈ 8100kb  use:44ms</span><br><span class=\"line\">un_compress.webp  bytes:367018b ≈ 358kb  bitmap:8294400b ≈ 8100kb  use:152ms</span><br><span class=\"line\">compress.webp  bytes:361200b ≈ 352kb  bitmap:8294400b ≈ 8100kb  use:141ms</span><br></pre></td></tr></table></figure>\n<p>结果显而易见，下面两张图是上面两张图的webp版，虽然大幅度减少byte的大小，但解码时间也大幅度增加了。究其原因，webp的高强度压缩增加了解码复杂度，webp在其官网也早已对这种情况进行了说明。</p>\n<p>而byte[] - Bitmap所消耗的时间对系统流程度的影响又是如何呢？</p>\n<p>我写了一个demo，界面如下：</p>\n<p><img src=\"/2017/07/11/探索Bitmap使用姿势/listview.png\" alt=\"old_take_photo\"></p>\n<p>经过实际测试，缓存Bitmap到内存中的策略中，第一次加载图片时，快速滑动列表，会有明显卡顿；但在图片全部缓存后，页面无卡顿。</p>\n<p>而缓存byte[]到内存中，在显示时才解码为Bitmap，第一次加载图片时，快速滑动列表，会有明细卡顿；byte[]全部缓存后，普通滑动速度几乎无卡顿；快速滑动有卡顿感。</p>\n<p>所以从用户体验的角度上来说，缓存byte[]可能并不适合在图片列表这样可以快速滑动的场景代替Bitmap缓存。<br>而在ViewPager这样的场景，因为页面转换不可能像列表一样快速，byte[] - Bitmap所消耗的时间几乎无感，似乎适合。<br>但在页面展示如此迟钝的场景，似乎直接从文件中加载Bitmap才是最优的选择。</p>\n<p>关于缓存替代品byte[] - Bitmap，仁者见仁智者见智吧。</p>\n<p>（要提一点，为了避免byte[] - Bitmap的过程中产生大量的临时Bitmap对象，缓存byte[]的策略中应用了<code>inBitmap</code>属性，而这一属性的使用几乎不会影响到Bitmap的加载速度）</p>"}],"PostAsset":[{"_id":"source/_posts/AccessibilityService分析与防御/accessibility整体流程.png","slug":"accessibility整体流程.png","post":"cjqelbso90000yo9s1cydiys5","modified":0,"renderable":0},{"_id":"source/_posts/AccessibilityService分析与防御/外挂简史.png","slug":"外挂简史.png","post":"cjqelbso90000yo9s1cydiys5","modified":0,"renderable":0},{"_id":"source/_posts/AccessibilityService分析与防御/AccessibilityInteractionClient.png","slug":"AccessibilityInteractionClient.png","post":"cjqelbso90000yo9s1cydiys5","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/listview.png","slug":"listview.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/mhdpi_xxhdpi_150.png","slug":"mhdpi_xxhdpi_150.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/ARGB_4444.png","slug":"ARGB_4444.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/take_photo2.png","slug":"take_photo2.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/Calabash探索2-Calabash用法详解/uiautomatorviewer.jpg","slug":"uiautomatorviewer.jpg","post":"cjqelbsop0004yo9sl7ymwydb","modified":0,"renderable":0},{"_id":"source/_posts/Java内存管理的一些小疑问/method_end.png","slug":"method_end.png","post":"cjqelbsov0009yo9sxtho4a6r","modified":0,"renderable":0},{"_id":"source/_posts/Java内存管理的一些小疑问/method_start.png","slug":"method_start.png","post":"cjqelbsov0009yo9sxtho4a6r","modified":0,"renderable":0},{"_id":"source/_posts/AccessibilityService分析与防御/accessibility流程图.png","slug":"accessibility流程图.png","post":"cjqelbso90000yo9s1cydiys5","modified":0,"renderable":0},{"_id":"source/_posts/AccessibilityService分析与防御/accessibility类图.png","slug":"accessibility类图.png","post":"cjqelbso90000yo9s1cydiys5","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/ALPHA_8.png","slug":"ALPHA_8.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/ARGB_8888.png","slug":"ARGB_8888.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ALPHA_8.png","slug":"DC_ALPHA_8.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ARGB_4444.png","slug":"DC_ARGB_4444.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/DC_ARGB_8888.png","slug":"DC_ARGB_8888.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/DC_RGB_565.png","slug":"DC_RGB_565.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/RGB_565.png","slug":"RGB_565.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/mhdpi_xxhdpi.png","slug":"mhdpi_xxhdpi.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/new_take_photo.jpg","slug":"new_take_photo.jpg","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/old_list_view.jpg","slug":"old_list_view.jpg","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/old_take_photo.jpg","slug":"old_take_photo.jpg","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/recycle.png","slug":"recycle.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/resource_assets.png","slug":"resource_assets.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/take_photo.png","slug":"take_photo.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0},{"_id":"source/_posts/探索Bitmap使用姿势/un_recycle.png","slug":"un_recycle.png","post":"cjqelbspr0011yo9sv1rrb1pz","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjqelbso90000yo9s1cydiys5","tag_id":"cjqelbsoj0002yo9si9ouor38","_id":"cjqelbsou0007yo9se7eri84e"},{"post_id":"cjqelbsou0008yo9sejkd4ae0","tag_id":"cjqelbsos0005yo9sib3lifwx","_id":"cjqelbsox000byo9s69h5exl1"},{"post_id":"cjqelbsoe0001yo9s874rlrqp","tag_id":"cjqelbsos0005yo9sib3lifwx","_id":"cjqelbsp3000dyo9szva39vxk"},{"post_id":"cjqelbsox000cyo9s5whqmua1","tag_id":"cjqelbsow000ayo9siai5d1e2","_id":"cjqelbspa000gyo9s7pnfcwot"},{"post_id":"cjqelbsom0003yo9sal2fisf2","tag_id":"cjqelbsow000ayo9siai5d1e2","_id":"cjqelbspe000iyo9sdud0yygf"},{"post_id":"cjqelbsp5000eyo9sj529du5b","tag_id":"cjqelbsow000ayo9siai5d1e2","_id":"cjqelbspf000lyo9sitotw57o"},{"post_id":"cjqelbsop0004yo9sl7ymwydb","tag_id":"cjqelbsos0005yo9sib3lifwx","_id":"cjqelbsph000nyo9se8ufvtmk"},{"post_id":"cjqelbsos0006yo9sqfjwrsmv","tag_id":"cjqelbsos0005yo9sib3lifwx","_id":"cjqelbspk000ryo9sbm2nusnn"},{"post_id":"cjqelbsov0009yo9sxtho4a6r","tag_id":"cjqelbsow000ayo9siai5d1e2","_id":"cjqelbspn000vyo9s312yp18v"},{"post_id":"cjqelbspm000uyo9s27p1ngki","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspp000xyo9s8li4w1mw"},{"post_id":"cjqelbspc000hyo9syt87p5gh","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspq0010yo9sitb0w216"},{"post_id":"cjqelbspn000wyo9srbtdn2wk","tag_id":"cjqelbsos0005yo9sib3lifwx","_id":"cjqelbsps0012yo9sfhb0yzcv"},{"post_id":"cjqelbspr0011yo9sv1rrb1pz","tag_id":"cjqelbsow000ayo9siai5d1e2","_id":"cjqelbspt0014yo9s3a1mpdo9"},{"post_id":"cjqelbspe000jyo9srp0gtg1n","tag_id":"cjqelbspp000yyo9sgx2rqkpr","_id":"cjqelbspt0015yo9s6aa4ddke"},{"post_id":"cjqelbspg000myo9s5uuy41m4","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspu0017yo9sbqyduhkn"},{"post_id":"cjqelbsph000oyo9syb5zmjkp","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspv0019yo9s8m9edstn"},{"post_id":"cjqelbspj000qyo9sbhqx1me5","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspx001byo9sfs2amw94"},{"post_id":"cjqelbspk000syo9sbg0icqs3","tag_id":"cjqelbspm000tyo9sdnkb21rw","_id":"cjqelbspx001dyo9sxc8awhtv"},{"post_id":"cjqelbspp000zyo9sey6fzu1v","tag_id":"cjqelbspx001cyo9sqjobjnkh","_id":"cjqelbspy001eyo9sqpq697mu"}],"Tag":[{"name":"RTFSC","_id":"cjqelbsoj0002yo9si9ouor38"},{"name":"测试","_id":"cjqelbsos0005yo9sib3lifwx"},{"name":"性能优化","_id":"cjqelbsow000ayo9siai5d1e2"},{"name":"APT","_id":"cjqelbspm000tyo9sdnkb21rw"},{"name":"GC","_id":"cjqelbspp000yyo9sgx2rqkpr"},{"name":"开发经验","_id":"cjqelbspx001cyo9sqjobjnkh"}]}}