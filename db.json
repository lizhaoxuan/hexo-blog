{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpeg","path":"uploads/avatar.jpeg","modified":0,"renderable":0},{"_id":"source/uploads/github.jpg","path":"uploads/github.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"d717e5587c08897b552013b10fcee20842bca247","modified":1484543208000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1470715068000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1470715068000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1470715068000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1470715068000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1470715068000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1470715068000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1470715068000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1470715068000},{"_id":"themes/next/_config.yml","hash":"1fc244626864acff5cc9e49b3a1cb42f1dc5764e","modified":1470724414000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1470715068000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1470715068000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1470715068000},{"_id":"source/_posts/SoftWidget.md","hash":"cee089ae1c60c54ee13550291e7ff3280c8f3a7e","modified":1484543451000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1470728679000},{"_id":"source/_posts/AndroidCoding-performance-specification.md","hash":"b099d84e7e1c50a8f1bfb423dc810551c01e6a5a","modified":1484543615000},{"_id":"source/_posts/android-rendering-performance-optimization.md","hash":"c8c8cf9c0dfb2e2a53603f812349992f9e363bb5","modified":1484543620000},{"_id":"source/_posts/androidgcdiaoyan.md","hash":"88d98815cea4d204c5d7f87653998fa61388f81b","modified":1484543609000},{"_id":"source/_posts/apt-Climbed-out-of-the-pit.md","hash":"4ec241c0a6c49c06db629e790fb328dd236b235f","modified":1484543599000},{"_id":"source/_posts/apt-Grammar-explanation.md","hash":"018cdddc955be240a6d1b9fcb111fde60d6ae59b","modified":1484543591000},{"_id":"source/_posts/apt-run_demo.md","hash":"68b3d869e9ea8dd85ec3550de13fa04348f71f5c","modified":1484543585000},{"_id":"source/_posts/apt-run_project.md","hash":"468b287d62ba6eacbe3e367423a4ab19b00f3106","modified":1484543578000},{"_id":"source/_posts/apt-wathapt.md","hash":"97f016f5f2a1a719722a7c7b2ddec397bb20d6b9","modified":1484543572000},{"_id":"source/_posts/apt_usage_scenario.md","hash":"846e16eff14fffb52c51a33eef487b493b410614","modified":1484543604000},{"_id":"source/_posts/shenyingpojie.md","hash":"1f73ade0ed54ae51b90f120f87a0a011f3e3e263","modified":1484543567000},{"_id":"source/uploads/avatar.jpeg","hash":"860069e392644dacd83560ea2022f3801fdf7c31","modified":1470725450000},{"_id":"source/uploads/github.jpg","hash":"5847934c28a6782834aeec7d6facc03af0b12109","modified":1470725450000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1470715068000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1470715068000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1470713932000},{"_id":"themes/next/.git/index","hash":"9316c665d75e975ba431249be7823106c1d997cb","modified":1470725450000},{"_id":"themes/next/.git/packed-refs","hash":"c260c6d28e96faeec8fe2ead52f6103d079e2f0c","modified":1470715068000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1470715068000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1470715068000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1470715068000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1470715068000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1470715068000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1470715068000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1470715068000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1470715068000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1470715068000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1470715068000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1470715068000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"fb9e42066d94d274fa3d796212a38ea6062d336e","modified":1470722912000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1470715068000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1470715068000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1470715068000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1470715068000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1470715068000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1470715068000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1470715068000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1470715068000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1470715068000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1470715068000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1470715068000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1470715068000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1470715068000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1470713932000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1470713932000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1470713932000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1470713932000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1470713932000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1470713932000},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1470713932000},{"_id":"themes/next/.git/logs/HEAD","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1470715068000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1470715068000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1470715068000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1470715068000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1470715068000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1470715068000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1470715068000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1470715068000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1470715068000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1470715068000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1470715068000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1470715068000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470715068000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1470715068000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1470715068000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470715068000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1470715068000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1470715068000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1470715068000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1470715068000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1470715068000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1470715068000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1470715068000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1470715068000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1470715068000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1470715068000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1470715068000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1470715068000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1470715068000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1470715068000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1470715068000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1470715068000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1470715068000},{"_id":"themes/next/.git/refs/heads/master","hash":"283a77b25951fbb3b2f10b4be4c80b6519ac6011","modified":1470715068000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1470715068000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1470715068000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1470715068000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1470715068000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1470715068000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1470715068000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1470715068000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1470715068000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1470715068000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1470715068000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1470715068000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1470715068000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1470715068000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1470715068000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1470715068000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1470715068000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1470715068000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1470715068000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1470715068000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1470715068000},{"_id":"themes/next/.git/objects/pack/pack-cac37be495ab9113fb6349c68fcebc6570e46a40.idx","hash":"8adeb1e30572f74956250af17ab3a24629569ea8","modified":1470715068000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1470715068000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1470715068000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1470715068000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1470715068000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1470715068000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1470715068000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1470715068000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1470715068000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1470715068000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"af5201a0b49d427f8cf08860ef2a851ceb746bb0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1470715068000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1470715068000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470715068000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1470715068000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1470715068000},{"_id":"themes/next/.git/objects/pack/pack-cac37be495ab9113fb6349c68fcebc6570e46a40.pack","hash":"cd51eed195cfe87382bd7d2c6adc4392b4f87641","modified":1470715068000},{"_id":"public/archives/page/2/index.html","hash":"68b28002f6daea90c3561e54b6d813c83069bada","modified":1484543482587},{"_id":"public/archives/2015/index.html","hash":"4bdf8e46fa3f14b0fb500f1a632973b5f02f7d5f","modified":1484543482588},{"_id":"public/archives/2015/09/index.html","hash":"483c0e179a618341f1f0b330ec232d3d61f1c4bf","modified":1484543482588},{"_id":"public/archives/2016/01/index.html","hash":"b40ac64a9c32977193b6cc49074ff984525b3a7f","modified":1484543482588},{"_id":"public/archives/2016/02/index.html","hash":"0ec9d19fa32029762a45b42410991aa22d8c08aa","modified":1484543482588},{"_id":"public/archives/2016/03/index.html","hash":"743502297b44a3e7f75692406fd92e5394665baa","modified":1484543482588},{"_id":"public/archives/2016/08/index.html","hash":"0865f2e8beff55390bf1fdb06a30376fae6e98e8","modified":1484543482588},{"_id":"public/page/2/index.html","hash":"e22bd0cf54b98995a0d6c886d3451853031a6e35","modified":1484543482588},{"_id":"public/tags/性能优化/index.html","hash":"61d20047ad24b1713acde5b0be756a5c9cd7753e","modified":1484543482588},{"_id":"public/tags/GC/index.html","hash":"de5eee103fce4c517d39a74a8b4f9cf519b59164","modified":1484543482589},{"_id":"public/tags/开发经验/index.html","hash":"631edfd59d1fb0334a3a528d7e858f2265dc0a85","modified":1484543482589},{"_id":"public/2016/08/26/apt_usage_scenario/index.html","hash":"ee74ef5a3aa76afa86bddc02f02e36403676f65d","modified":1484543693860},{"_id":"public/2016/07/17/apt-wathapt/index.html","hash":"a4933a327a7eee1f78cc753634b084ec11a18250","modified":1484543693860},{"_id":"public/2016/07/17/apt-run_demo/index.html","hash":"e2db845408fc0e438a37edf0a4c1e9adfa330106","modified":1484543693860},{"_id":"public/2016/07/17/apt-run_project/index.html","hash":"6152b94d2111a800a6ea8c62e93fed05abf58738","modified":1484543693860},{"_id":"public/2016/07/17/apt-Climbed-out-of-the-pit/index.html","hash":"d1ec9c3e3508751bffe048cff9d3ca901f691b41","modified":1484543693860},{"_id":"public/2016/07/17/apt-Grammar-explanation/index.html","hash":"6cfc822882293705cc0fa31de6f0dc09017e009c","modified":1484543693860},{"_id":"public/2016/03/17/AndroidCoding-performance-specification/index.html","hash":"afb248742b3fb7ddeb58c6ab6515d57f6a8d4893","modified":1484543693860},{"_id":"public/2016/02/17/androidgcdiaoyan/index.html","hash":"9c63df576d2b9d1a314fa0485a40dbd3b05f6217","modified":1484543693860},{"_id":"public/2016/01/17/shenyingpojie/index.html","hash":"9d754185f237ceac8d71cdeb43aed69a507e578d","modified":1484543693860},{"_id":"public/2015/09/10/android-rendering-performance-optimization/index.html","hash":"c86168a09bf6c606430e971202c439306e279858","modified":1484543693861},{"_id":"public/2015/09/09/SoftWidget/index.html","hash":"143440fb168a1530fcaad7108cae89aec41e031a","modified":1484543482589},{"_id":"public/archives/index.html","hash":"7f5c92835ca62695c14625ee437b71d417da8b4e","modified":1484543482589},{"_id":"public/archives/2016/index.html","hash":"4f41de6bdbb7efb074e1ce7215575c7561f0b0b9","modified":1484543482589},{"_id":"public/archives/2016/07/index.html","hash":"92e6096a46fd6ee8ceeba501ec7c243d34e86a22","modified":1484543482590},{"_id":"public/index.html","hash":"6c3f50381ecf06cd8c03faf648e3c5412bbd5d95","modified":1484543693861},{"_id":"public/tags/APT/index.html","hash":"cc698034c38b1ee48b40c218b38013100c42cc0b","modified":1484543482590},{"_id":"public/uploads/avatar.jpeg","hash":"860069e392644dacd83560ea2022f3801fdf7c31","modified":1484543482633},{"_id":"public/uploads/github.jpg","hash":"5847934c28a6782834aeec7d6facc03af0b12109","modified":1484543482633},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1484543482633},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1484543482633},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1484543482633},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1484543482633},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1484543482633},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1484543482633},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1484543482633},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1484543482633},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484543482634},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1484543482634},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1484543482634},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1484543482634},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1484543482634},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1484543482634},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1484543482634},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1484543482634},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1484543482634},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1484543482634},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1484543482634},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1484543482634},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1484543482634},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1484543482634},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1484543482634},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1484543482634},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1484543483368},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1484543483379},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1484543483381},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1484543483390},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1484543483390},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1484543483390},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1484543483390},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1484543483390},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1484543483390},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1484543483390},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1484543483390},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1484543483390},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1484543483390},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1484543483390},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1484543483390},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1484543483390},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1484543483391},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1484543483391},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1484543483391},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1484543483391},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1484543483391},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1484543483391},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1484543483391},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1484543483391},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1484543483391},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1484543483391},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1484543483391},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1484543483391},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1484543483391},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1484543483391},{"_id":"public/css/main.css","hash":"19531993f39a6ed8d76a62ee19925b80f87dd065","modified":1484543483391},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1484543483391},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1484543483391},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1484543483391},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1484543483391},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1484543483391},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1484543483391},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1484543483391},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1484543483391},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1484543483391},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1484543483392},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1484543483406}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Android过度绘制深度优化---View提前绘制","date":"2015-09-09T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 概述\n\n上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  **背景-background**（背景包括背景图片、颜色、形状、边框等等）。\n\n\n那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   **Android过度绘制深度优化---View提前绘制**\n\n先说原理：**不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！**\n\n<!-- more -->\n\n\n先上效果图：\n优化前   &  优化后：\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />        <img src=\"http://img.blog.csdn.net/20151103211244952\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />\n\n**Tips：**\n1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。\n2.优化后的图片，为了突出所以添加了带图案的背景图片\n\n**颜色说明：**\n优化前：\n\n- Window（无色） 绘制一次\n- 背景（蓝色） 绘制2次\n- Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次\n- 输入框本身，按钮文字 （红色） 绘制三次\n- 输入框内部文字 （深红色）  绘制四次\n\n优化后：\n\n- 背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。\n- Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。\n- 文本框上面的图片和文字（绿色）绘制三次\n\n## 要点\n\nView提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：\n\n- View的提前绘制只能应用到那些静态的View\n- View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）\n- 界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。**如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。**\n- 对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。**通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）**\n\n也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。\n\n另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：\n1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。\n2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？\n\n## 正文\n啊，好吧，废话说的有点多了，下面我们上代码。\n\nGithub链接：[https://github.com/lizhaoxuan/SoftWidgetDemo.git](https://github.com/lizhaoxuan/SoftWidgetDemo.git\n)\n\n首先看目录结构：\n\n<img src=\"http://img.blog.csdn.net/20151107151634177\" width = \"180\" height = \"230\" alt=\"图片名称\" align=center />\n\n有四个核心类：\nDrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。\nPaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状\n\nSRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局\n\n然后看布局文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    android:padding=\"10dp\">\n\t\n\t    <ImageView\n\t        android:id=\"@+id/logoView\"\n\t        android:layout_width=\"100dp\"\n\t        android:layout_height=\"100dp\"\n\t        android:layout_centerHorizontal=\"true\"\n\t        android:layout_marginTop=\"80dp\"\n\t        android:src=\"@drawable/logo\"/>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/accountLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"50dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/logoView\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_user\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/accountEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"账号\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\" />\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/passwordLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"3dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/accountLayout\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_password\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/passwordEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"密码\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\"\n\t            android:inputType=\"textPassword\"/>\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n\t        android:id=\"@+id/login_btn\"\n\t        android:layout_width=\"fill_parent\"\n\t        android:layout_height=\"50dp\"\n\t        android:layout_marginTop=\"20dp\"\n\t        android:layout_below=\"@id/passwordLayout\"\n\t        android:layout_alignLeft=\"@id/passwordLayout\"\n\t        android:layout_alignRight=\"@id/passwordLayout\"\n\t        android:layout_gravity=\"center\"\n\t        android:text=\"登录\"\n\t        android:textColor=\"@color/white\"\n\t        android:textSize=\"20sp\"\n\t        app:backgroundColor=\"#af0308\"/>\n\t\n\t\n\t    <TextView\n\t        android:id=\"@+id/forgetText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentLeft=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginLeft=\"10dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"忘记密码\"/>\n\t\n\t    <TextView\n\t        android:id=\"@+id/registerText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentRight=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"注册\"/>\n\t</RelativeLayout>\n\n这里要说一下：\n不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。\n不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。\nButton 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);\n\n通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。\n\n\n*DrawingCanvas.java:*\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Bitmap;\n\timport android.graphics.Canvas;\n\timport android.graphics.Rect;\n\timport android.graphics.RectF;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/11.\n\t * 在这上面进行提前绘制\n\t */\n\tpublic class DrawingCanvas extends Canvas {\n\t\n\t    private Bitmap output;\n\t    private Rect rect;\n\t    private RectF rectF;\n\t    private DrawingCanvas(Bitmap output_, float width_, float height_){\n\t        super(output_);\n\t        output = output_;\n\t        rect = new Rect(0,0,(int)width_,(int)height_);\n\t        rectF = new RectF(0, 0, width_, height_);\n\t    }\n\t\n\t    public static DrawingCanvas instance(float width_ , float height_){\n\t        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n\t                Bitmap.Config.ARGB_8888);\n\t        return new DrawingCanvas(bitmap,width_,height_);\n\t    }\n\t\n\t\n\t    public Bitmap getOutput(){\n\t        return output;\n\t    }\n\t    public Rect getRect(){\n\t        return rect;\n\t    }\n\t    public RectF getRectF(){\n\t        return rectF;\n\t    }\n\t}\n\n这个类继承了Canvas，并且已经传入一个Bitmap\t\t\t\n\n\t\tsuper(output_);\n所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。\n\n*PaintBox.java:*\n\n\t\n\t\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Paint;\n\t\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 用来画图的盒子，里面放着画图的方法\n\t */\n\tpublic class PaintBox {\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\t\n\t        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t        paint.setStyle(Paint.Style.FILL);\n\t        paint.setAntiAlias(true);\n\t        paint.setColor(color);\n\t        paint.setAlpha(alpha);\n\t        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t        \n\t    }\n\t\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     * @param border 带边框\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n\t        if(border){\n\t            Paint paint = new Paint();\n\t            paint.setStyle(Paint.Style.FILL);\n\t            paint.setAntiAlias(true);\n\t            paint.setColor(color);\n\t            paint.setAlpha(30);\n\t            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t            paint.setStyle(Paint.Style.STROKE);\n\t            paint.setAlpha(70);\n\t            paint.setStrokeWidth(4);\n\t            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n\t        }else{\n\t            drawRoundRect(canvas,color,alpha);\n\t        }\n\t\n\t\n\t    }\n\t\n\t    /**\n\t     * 填充颜色\n\t     * @param canvas \n\t     * @param color\n\t     */\n\t    public static void drawColor(DrawingCanvas canvas ,int color ){\n\t        Paint paint = new Paint();\n\t        paint.setAntiAlias(true);\n\t        paint.setFilterBitmap(true);\n\t        paint.setDither(true);\n\t        paint.setColor(color);\n\t        canvas.drawPaint(paint);\n\t    }\n\t\n\t\n\t    /**\n\t     * 写字在View正中间\n\t     * @param canvas  画布\n\t     * @param text   文字\n\t     * @param color  文字颜色\n\t     * @param size   文字大小\n\t     */\n\t    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n\t        //创建画笔\n\t        Paint pp = new Paint();\n\t        pp.setAntiAlias(true);\n\t        pp.setColor(color);\n\t        pp.setStrokeWidth(3);\n\t        pp.setTextSize(size);\n\t        pp.setTextAlign(Paint.Align.CENTER);\n\t        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n\t        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n\t        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n\t    }\n\t}\n\n这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。\n值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。\n\n最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.\n\n*SRoundRect_Button.java:*\n\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\t\n\timport android.content.Context;\n\timport android.content.res.Resources;\n\timport android.content.res.TypedArray;\n\timport android.graphics.Canvas;\n\timport android.util.AttributeSet;\n\timport android.widget.Button;\n\t\n\timport com.example.zhaoxuanli.softwidgetdemo.R;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n\t */\n\t\n\t//\n\t//字符编码 UTF-8  无BOM\n\tpublic class SRoundRect_Button extends Button {\n\t    private String text;\n\t    private int textColor;\n\t    private int textSize;\n\t    private int backgroundColor;\n\t    /**\n\t     * 提前绘制的画布\n\t     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n\t     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n\t     * 反编译Path源码后，这里是采用软引用的\n\t     */\n\t    private DrawingCanvas localDrawingCanvas;  \n\t\n\t    /**\n\t     * 一下是超类的三个构造方法\n\t     * @param context\n\t     */\n\t    public SRoundRect_Button(Context context) {\n\t        super(context);\n\t        init(context,null , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init(context,attrs , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n\t        super(context, attrs, defStyle);\n\t        init(context, attrs , defStyle);\n\t    }\n\t\n\t    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n\t        this.setBackgroundResource(0);  //去掉Button原来的背景\n\t        if(null == attrs)\n\t            return ;\n\t\n\t        /**\n\t         * View属性的提取\n\t         */\n\t        Resources resources = getResources();\n\t        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n\t        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n\t        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n\t        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n\t        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\t\n\t\n\t    }\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        //取得View的长宽信息，因为每一次View的载入长款\n\t        float width = this.getWidth();\n\t        float height = this.getHeight();\n\t        /**\n\t         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n\t         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n\t         */\n\t        if(localDrawingCanvas==null){\n\t            localDrawingCanvas = DrawingCanvas.instance(width,height);\n\t            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n\t            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n\t        }\n\t\n\t\n\t        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n\t    }\n\t}\n\n这就是一个提前绘制的自定义控件的实现了。\n\n## End\n\n这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？\n因为实现不了这个效果，所以只能添加了自定义属性\n\n\t<attr name=\"backgroundPic\" format=\"reference\"/>\n    <attr name=\"backgroundColor\" format=\"color\"/>\n   \n感觉很Low啊这样！！！还期待大神帮解决。\n\n设计一个可以直接使用的重绘控件库，是一个长久的目标呀~\n\n\n","source":"_posts/SoftWidget.md","raw":"\n---\ntitle: Android过度绘制深度优化---View提前绘制\ndate: 2015-9-9 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 概述\n\n上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  **背景-background**（背景包括背景图片、颜色、形状、边框等等）。\n\n\n那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   **Android过度绘制深度优化---View提前绘制**\n\n先说原理：**不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！**\n\n<!-- more -->\n\n\n先上效果图：\n优化前   &  优化后：\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />        <img src=\"http://img.blog.csdn.net/20151103211244952\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />\n\n**Tips：**\n1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。\n2.优化后的图片，为了突出所以添加了带图案的背景图片\n\n**颜色说明：**\n优化前：\n\n- Window（无色） 绘制一次\n- 背景（蓝色） 绘制2次\n- Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次\n- 输入框本身，按钮文字 （红色） 绘制三次\n- 输入框内部文字 （深红色）  绘制四次\n\n优化后：\n\n- 背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。\n- Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。\n- 文本框上面的图片和文字（绿色）绘制三次\n\n## 要点\n\nView提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：\n\n- View的提前绘制只能应用到那些静态的View\n- View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）\n- 界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。**如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。**\n- 对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。**通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）**\n\n也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。\n\n另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：\n1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。\n2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？\n\n## 正文\n啊，好吧，废话说的有点多了，下面我们上代码。\n\nGithub链接：[https://github.com/lizhaoxuan/SoftWidgetDemo.git](https://github.com/lizhaoxuan/SoftWidgetDemo.git\n)\n\n首先看目录结构：\n\n<img src=\"http://img.blog.csdn.net/20151107151634177\" width = \"180\" height = \"230\" alt=\"图片名称\" align=center />\n\n有四个核心类：\nDrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。\nPaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状\n\nSRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局\n\n然后看布局文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    android:padding=\"10dp\">\n\t\n\t    <ImageView\n\t        android:id=\"@+id/logoView\"\n\t        android:layout_width=\"100dp\"\n\t        android:layout_height=\"100dp\"\n\t        android:layout_centerHorizontal=\"true\"\n\t        android:layout_marginTop=\"80dp\"\n\t        android:src=\"@drawable/logo\"/>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/accountLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"50dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/logoView\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_user\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/accountEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"账号\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\" />\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n\t        android:id=\"@+id/passwordLayout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"40dp\"\n\t        android:layout_marginTop=\"3dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:layout_marginLeft=\"20dp\"\n\t        android:layout_below=\"@id/accountLayout\"\n\t        android:orientation=\"horizontal\"\n\t        android:paddingLeft=\"6dip\"\n\t        android:paddingRight=\"6dip\"\n\t        android:paddingTop=\"8dip\"\n\t        app:bgcolor=\"#CFCFCF\">\n\t\n\t        <ImageView\n\t            android:layout_width=\"wrap_content\"\n\t            android:layout_height=\"22dip\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginLeft=\"8dip\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:paddingBottom=\"6dip\"\n\t            android:src=\"@drawable/ic_login_password\" />\n\t\n\t        <EditText\n\t            android:id=\"@+id/passwordEdit\"\n\t            android:layout_width=\"0dp\"\n\t            android:layout_height=\"wrap_content\"\n\t            android:layout_gravity=\"center_vertical\"\n\t            android:layout_marginRight=\"8dip\"\n\t            android:layout_weight=\"1\"\n\t            android:background=\"@null\"\n\t            android:digits=\"\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-\"\n\t            android:hint=\"密码\"\n\t            android:imeOptions=\"actionNext\"\n\t            android:paddingBottom=\"8dip\"\n\t            android:singleLine=\"true\"\n\t            android:textColor=\"@color/black\"\n\t            android:textCursorDrawable=\"@null\"\n\t            android:inputType=\"textPassword\"/>\n\t    </com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout>\n\t\n\t    <com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n\t        android:id=\"@+id/login_btn\"\n\t        android:layout_width=\"fill_parent\"\n\t        android:layout_height=\"50dp\"\n\t        android:layout_marginTop=\"20dp\"\n\t        android:layout_below=\"@id/passwordLayout\"\n\t        android:layout_alignLeft=\"@id/passwordLayout\"\n\t        android:layout_alignRight=\"@id/passwordLayout\"\n\t        android:layout_gravity=\"center\"\n\t        android:text=\"登录\"\n\t        android:textColor=\"@color/white\"\n\t        android:textSize=\"20sp\"\n\t        app:backgroundColor=\"#af0308\"/>\n\t\n\t\n\t    <TextView\n\t        android:id=\"@+id/forgetText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentLeft=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginLeft=\"10dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"忘记密码\"/>\n\t\n\t    <TextView\n\t        android:id=\"@+id/registerText\"\n\t        android:layout_width=\"wrap_content\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:layout_alignParentBottom=\"true\"\n\t        android:layout_alignParentRight=\"true\"\n\t        android:layout_marginBottom=\"15dp\"\n\t        android:layout_marginRight=\"20dp\"\n\t        android:gravity=\"center\"\n\t        android:textColor=\"#af0308\"\n\t        android:textSize=\"15sp\"\n\t        android:text=\"注册\"/>\n\t</RelativeLayout>\n\n这里要说一下：\n不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。\n不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。\nButton 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);\n\n通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。\n\n\n*DrawingCanvas.java:*\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Bitmap;\n\timport android.graphics.Canvas;\n\timport android.graphics.Rect;\n\timport android.graphics.RectF;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/11.\n\t * 在这上面进行提前绘制\n\t */\n\tpublic class DrawingCanvas extends Canvas {\n\t\n\t    private Bitmap output;\n\t    private Rect rect;\n\t    private RectF rectF;\n\t    private DrawingCanvas(Bitmap output_, float width_, float height_){\n\t        super(output_);\n\t        output = output_;\n\t        rect = new Rect(0,0,(int)width_,(int)height_);\n\t        rectF = new RectF(0, 0, width_, height_);\n\t    }\n\t\n\t    public static DrawingCanvas instance(float width_ , float height_){\n\t        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n\t                Bitmap.Config.ARGB_8888);\n\t        return new DrawingCanvas(bitmap,width_,height_);\n\t    }\n\t\n\t\n\t    public Bitmap getOutput(){\n\t        return output;\n\t    }\n\t    public Rect getRect(){\n\t        return rect;\n\t    }\n\t    public RectF getRectF(){\n\t        return rectF;\n\t    }\n\t}\n\n这个类继承了Canvas，并且已经传入一个Bitmap\t\t\t\n\n\t\tsuper(output_);\n所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。\n\n*PaintBox.java:*\n\n\t\n\t\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\t\n\timport android.graphics.Paint;\n\t\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 用来画图的盒子，里面放着画图的方法\n\t */\n\tpublic class PaintBox {\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\t\n\t        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t        paint.setStyle(Paint.Style.FILL);\n\t        paint.setAntiAlias(true);\n\t        paint.setColor(color);\n\t        paint.setAlpha(alpha);\n\t        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t        \n\t    }\n\t\n\t    /**\n\t     * 画圆角矩形\n\t     * @param canvas 画布\n\t     * @param color 填充颜色\n\t     * @param alpha 透明度\n\t     * @param border 带边框\n\t     */\n\t    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n\t        if(border){\n\t            Paint paint = new Paint();\n\t            paint.setStyle(Paint.Style.FILL);\n\t            paint.setAntiAlias(true);\n\t            paint.setColor(color);\n\t            paint.setAlpha(30);\n\t            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\t\n\t            paint.setStyle(Paint.Style.STROKE);\n\t            paint.setAlpha(70);\n\t            paint.setStrokeWidth(4);\n\t            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n\t        }else{\n\t            drawRoundRect(canvas,color,alpha);\n\t        }\n\t\n\t\n\t    }\n\t\n\t    /**\n\t     * 填充颜色\n\t     * @param canvas \n\t     * @param color\n\t     */\n\t    public static void drawColor(DrawingCanvas canvas ,int color ){\n\t        Paint paint = new Paint();\n\t        paint.setAntiAlias(true);\n\t        paint.setFilterBitmap(true);\n\t        paint.setDither(true);\n\t        paint.setColor(color);\n\t        canvas.drawPaint(paint);\n\t    }\n\t\n\t\n\t    /**\n\t     * 写字在View正中间\n\t     * @param canvas  画布\n\t     * @param text   文字\n\t     * @param color  文字颜色\n\t     * @param size   文字大小\n\t     */\n\t    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n\t        //创建画笔\n\t        Paint pp = new Paint();\n\t        pp.setAntiAlias(true);\n\t        pp.setColor(color);\n\t        pp.setStrokeWidth(3);\n\t        pp.setTextSize(size);\n\t        pp.setTextAlign(Paint.Align.CENTER);\n\t        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n\t        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n\t        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n\t    }\n\t}\n\n这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。\n值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。\n\n最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.\n\n*SRoundRect_Button.java:*\n\n\n\tpackage com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\t\n\timport android.content.Context;\n\timport android.content.res.Resources;\n\timport android.content.res.TypedArray;\n\timport android.graphics.Canvas;\n\timport android.util.AttributeSet;\n\timport android.widget.Button;\n\t\n\timport com.example.zhaoxuanli.softwidgetdemo.R;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\n\timport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\t\n\t/**\n\t * Created by zhaoxuan.li on 2015/8/12.\n\t * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n\t */\n\t\n\t//\n\t//字符编码 UTF-8  无BOM\n\tpublic class SRoundRect_Button extends Button {\n\t    private String text;\n\t    private int textColor;\n\t    private int textSize;\n\t    private int backgroundColor;\n\t    /**\n\t     * 提前绘制的画布\n\t     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n\t     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n\t     * 反编译Path源码后，这里是采用软引用的\n\t     */\n\t    private DrawingCanvas localDrawingCanvas;  \n\t\n\t    /**\n\t     * 一下是超类的三个构造方法\n\t     * @param context\n\t     */\n\t    public SRoundRect_Button(Context context) {\n\t        super(context);\n\t        init(context,null , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        init(context,attrs , 0);\n\t    }\n\t\n\t    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n\t        super(context, attrs, defStyle);\n\t        init(context, attrs , defStyle);\n\t    }\n\t\n\t    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n\t        this.setBackgroundResource(0);  //去掉Button原来的背景\n\t        if(null == attrs)\n\t            return ;\n\t\n\t        /**\n\t         * View属性的提取\n\t         */\n\t        Resources resources = getResources();\n\t        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n\t        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n\t        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n\t        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n\t        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\t\n\t\n\t    }\n\t\n\t    @Override\n\t    protected void onDraw(Canvas canvas) {\n\t        //取得View的长宽信息，因为每一次View的载入长款\n\t        float width = this.getWidth();\n\t        float height = this.getHeight();\n\t        /**\n\t         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n\t         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n\t         */\n\t        if(localDrawingCanvas==null){\n\t            localDrawingCanvas = DrawingCanvas.instance(width,height);\n\t            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n\t            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n\t        }\n\t\n\t\n\t        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n\t    }\n\t}\n\n这就是一个提前绘制的自定义控件的实现了。\n\n## End\n\n这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？\n因为实现不了这个效果，所以只能添加了自定义属性\n\n\t<attr name=\"backgroundPic\" format=\"reference\"/>\n    <attr name=\"backgroundColor\" format=\"color\"/>\n   \n感觉很Low啊这样！！！还期待大神帮解决。\n\n设计一个可以直接使用的重绘控件库，是一个长久的目标呀~\n\n\n","slug":"SoftWidget","published":1,"updated":"2017-01-16T05:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixzmux2s0000q4chvmenediw","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  <strong>背景-background</strong>（背景包括背景图片、颜色、形状、边框等等）。</p>\n<p>那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   <strong>Android过度绘制深度优化—View提前绘制</strong></p>\n<p>先说原理：<strong>不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！</strong></p>\n<a id=\"more\"></a>\n<p>先上效果图：<br>优化前   &amp;  优化后：<br><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\">        <img src=\"http://img.blog.csdn.net/20151103211244952\" width=\"150\" height=\"250\" alt=\"图片名称\" align=\"center\"></p>\n<p><strong>Tips：</strong><br>1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。<br>2.优化后的图片，为了突出所以添加了带图案的背景图片</p>\n<p><strong>颜色说明：</strong><br>优化前：</p>\n<ul>\n<li>Window（无色） 绘制一次</li>\n<li>背景（蓝色） 绘制2次</li>\n<li>Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次</li>\n<li>输入框本身，按钮文字 （红色） 绘制三次</li>\n<li>输入框内部文字 （深红色）  绘制四次</li>\n</ul>\n<p>优化后：</p>\n<ul>\n<li>背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。</li>\n<li>Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。</li>\n<li>文本框上面的图片和文字（绿色）绘制三次</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><p>View提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：</p>\n<ul>\n<li>View的提前绘制只能应用到那些静态的View</li>\n<li>View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）</li>\n<li>界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。<strong>如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。</strong></li>\n<li>对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。<strong>通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）</strong></li>\n</ul>\n<p>也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。</p>\n<p>另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：<br>1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。<br>2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>啊，好吧，废话说的有点多了，下面我们上代码。</p>\n<p>Github链接：<a href=\"https://github.com/lizhaoxuan/SoftWidgetDemo.git\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/SoftWidgetDemo.git</a></p>\n<p>首先看目录结构：</p>\n<p><img src=\"http://img.blog.csdn.net/20151107151634177\" width=\"180\" height=\"230\" alt=\"图片名称\" align=\"center\"></p>\n<p>有四个核心类：<br>DrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。<br>PaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状</p>\n<p>SRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局</p>\n<p>然后看布局文件：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/logoView&quot;\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;100dp&quot;\n        android:layout_centerHorizontal=&quot;true&quot;\n        android:layout_marginTop=&quot;80dp&quot;\n        android:src=&quot;@drawable/logo&quot;/&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/accountLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;50dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/logoView&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_user&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/accountEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;账号&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot; /&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/passwordLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;3dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/accountLayout&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_password&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/passwordEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;密码&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot;\n            android:inputType=&quot;textPassword&quot;/&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n        android:id=&quot;@+id/login_btn&quot;\n        android:layout_width=&quot;fill_parent&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;20dp&quot;\n        android:layout_below=&quot;@id/passwordLayout&quot;\n        android:layout_alignLeft=&quot;@id/passwordLayout&quot;\n        android:layout_alignRight=&quot;@id/passwordLayout&quot;\n        android:layout_gravity=&quot;center&quot;\n        android:text=&quot;登录&quot;\n        android:textColor=&quot;@color/white&quot;\n        android:textSize=&quot;20sp&quot;\n        app:backgroundColor=&quot;#af0308&quot;/&gt;\n\n\n    &lt;TextView\n        android:id=&quot;@+id/forgetText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentLeft=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;忘记密码&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/registerText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentRight=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;注册&quot;/&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>这里要说一下：<br>不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。<br>不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。<br>Button 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);</p>\n<p>通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。</p>\n<p><em>DrawingCanvas.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\n\n/**\n * Created by zhaoxuan.li on 2015/8/11.\n * 在这上面进行提前绘制\n */\npublic class DrawingCanvas extends Canvas {\n\n    private Bitmap output;\n    private Rect rect;\n    private RectF rectF;\n    private DrawingCanvas(Bitmap output_, float width_, float height_){\n        super(output_);\n        output = output_;\n        rect = new Rect(0,0,(int)width_,(int)height_);\n        rectF = new RectF(0, 0, width_, height_);\n    }\n\n    public static DrawingCanvas instance(float width_ , float height_){\n        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n                Bitmap.Config.ARGB_8888);\n        return new DrawingCanvas(bitmap,width_,height_);\n    }\n\n\n    public Bitmap getOutput(){\n        return output;\n    }\n    public Rect getRect(){\n        return rect;\n    }\n    public RectF getRectF(){\n        return rectF;\n    }\n}\n</code></pre><p>这个类继承了Canvas，并且已经传入一个Bitmap            </p>\n<pre><code>super(output_);\n</code></pre><p>所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。</p>\n<p><em>PaintBox.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Paint;\n\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 用来画图的盒子，里面放着画图的方法\n */\npublic class PaintBox {\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\n        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        paint.setStyle(Paint.Style.FILL);\n        paint.setAntiAlias(true);\n        paint.setColor(color);\n        paint.setAlpha(alpha);\n        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n\n    }\n\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     * @param border 带边框\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n        if(border){\n            Paint paint = new Paint();\n            paint.setStyle(Paint.Style.FILL);\n            paint.setAntiAlias(true);\n            paint.setColor(color);\n            paint.setAlpha(30);\n            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n            paint.setStyle(Paint.Style.STROKE);\n            paint.setAlpha(70);\n            paint.setStrokeWidth(4);\n            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n        }else{\n            drawRoundRect(canvas,color,alpha);\n        }\n\n\n    }\n\n    /**\n     * 填充颜色\n     * @param canvas \n     * @param color\n     */\n    public static void drawColor(DrawingCanvas canvas ,int color ){\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        paint.setDither(true);\n        paint.setColor(color);\n        canvas.drawPaint(paint);\n    }\n\n\n    /**\n     * 写字在View正中间\n     * @param canvas  画布\n     * @param text   文字\n     * @param color  文字颜色\n     * @param size   文字大小\n     */\n    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n        //创建画笔\n        Paint pp = new Paint();\n        pp.setAntiAlias(true);\n        pp.setColor(color);\n        pp.setStrokeWidth(3);\n        pp.setTextSize(size);\n        pp.setTextAlign(Paint.Align.CENTER);\n        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n    }\n}\n</code></pre><p>这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。<br>值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。</p>\n<p>最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.</p>\n<p><em>SRoundRect_Button.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.util.AttributeSet;\nimport android.widget.Button;\n\nimport com.example.zhaoxuanli.softwidgetdemo.R;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n */\n\n//\n//字符编码 UTF-8  无BOM\npublic class SRoundRect_Button extends Button {\n    private String text;\n    private int textColor;\n    private int textSize;\n    private int backgroundColor;\n    /**\n     * 提前绘制的画布\n     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n     * 反编译Path源码后，这里是采用软引用的\n     */\n    private DrawingCanvas localDrawingCanvas;  \n\n    /**\n     * 一下是超类的三个构造方法\n     * @param context\n     */\n    public SRoundRect_Button(Context context) {\n        super(context);\n        init(context,null , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context,attrs , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs , defStyle);\n    }\n\n    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n        this.setBackgroundResource(0);  //去掉Button原来的背景\n        if(null == attrs)\n            return ;\n\n        /**\n         * View属性的提取\n         */\n        Resources resources = getResources();\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        //取得View的长宽信息，因为每一次View的载入长款\n        float width = this.getWidth();\n        float height = this.getHeight();\n        /**\n         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n         */\n        if(localDrawingCanvas==null){\n            localDrawingCanvas = DrawingCanvas.instance(width,height);\n            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n        }\n\n\n        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n    }\n}\n</code></pre><p>这就是一个提前绘制的自定义控件的实现了。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？<br>因为实现不了这个效果，所以只能添加了自定义属性</p>\n<pre><code>&lt;attr name=&quot;backgroundPic&quot; format=&quot;reference&quot;/&gt;\n&lt;attr name=&quot;backgroundColor&quot; format=&quot;color&quot;/&gt;\n</code></pre><p>感觉很Low啊这样！！！还期待大神帮解决。</p>\n<p>设计一个可以直接使用的重绘控件库，是一个长久的目标呀~</p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>上一篇文章对过度绘制和View优化做了大概的简介和介绍。我们知道，引起过度绘制的根本原因是  <strong>背景-background</strong>（背景包括背景图片、颜色、形状、边框等等）。</p>\n<p>那么通常你在网络查找过度绘制优化策略，不外乎减少View的层叠、多余的控件、一个多余的背景设置等等。可如果你真的去审查代码，会发现你并没有多少可优化的地方。这个时候，你就需要   <strong>Android过度绘制深度优化—View提前绘制</strong></p>\n<p>先说原理：<strong>不做处理的View绘制过程像一把刷子一层层去绘制View，第一层刷一个形状，第二层刷背景图片/颜色，第三层刷文字等等，那么，如果我们将View提前画好，然后交给系统去绘制。这样不管你的View之前刷过多少次，系统只需要绘制一次。这样，过度绘制就可以轻松解决啦！</strong></p>","more":"<p>先上效果图：<br>优化前   &amp;  优化后：<br><img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center />        <img src=\"http://img.blog.csdn.net/20151103211244952\" width = \"150\" height = \"250\" alt=\"图片名称\" align=center /></p>\n<p><strong>Tips：</strong><br>1.首先控件的实现方式略有不同（带图标的输入框），但对我们这片文章讲的东西并没有冲突。<br>2.优化后的图片，为了突出所以添加了带图案的背景图片</p>\n<p><strong>颜色说明：</strong><br>优化前：</p>\n<ul>\n<li>Window（无色） 绘制一次</li>\n<li>背景（蓝色） 绘制2次</li>\n<li>Logo,输入框带小图标的背景，按钮,忘记密码（绿色）绘制三次</li>\n<li>输入框本身，按钮文字 （红色） 绘制三次</li>\n<li>输入框内部文字 （深红色）  绘制四次</li>\n</ul>\n<p>优化后：</p>\n<ul>\n<li>背景（无色） 绘制一次   ： 背景设置到主题后，将取代原本Window默认背景。</li>\n<li>Logo，按钮，带形状和颜色的输入框背景，忘记密码文字 （蓝色） 绘制两次： 这里我们对输入框和按钮进行了提前绘制，并去掉了按钮默认背景，所以按钮加其内部文字只绘制一次。带形状、颜色的输入框只绘制一次。</li>\n<li>文本框上面的图片和文字（绿色）绘制三次</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><p>View提前绘制可以从根本上去解决问题过度绘制问题，但并不是没有代价的，但你在做优化前，需要注意一下几个点：</p>\n<ul>\n<li>View的提前绘制只能应用到那些静态的View</li>\n<li>View的提前绘制并不能加过View的绘制速度，甚至会有小幅度的绘制时间增加。（提前在内存中进行View的绘制是有代价的）</li>\n<li>界面是有一定刷新频率的，每一次刷新都会调用View的onDraw方法，而View提前绘制就是在onDraw中进行。所以你需要考虑效率和性能问题。<strong>如：避免在onDraw创建对象，避免在onDraw进行绘制，应在构造函数中画好，交给onDraw。</strong></li>\n<li>对于登录界面，提前绘制的工作量和其收益比起来是得不偿失的，所以你需要进行权衡，哪里需要提前绘制。<strong>通常我是这样做的：大量被重用的控件，非常复杂的布局，布局之上有动画效果（过度绘制对动画的影响是极大的）</strong></li>\n</ul>\n<p>也许在你看到View的提前绘制是有代价的，就决定不在进行优化，这是错误的。除非极其复杂的View，负责提前绘制带来收益是绝对大于那多出来的一丢丢绘制时间的。</p>\n<p>另外即使类似于登录界面这样的简单布局没有必要进行过度绘制优化，但依然有大量的优秀公司进行了优化。我认为有两个点：<br>1.登录界面是应用打开的第一个界面，也是整个应用最简单的界面之一，用它来试手肯定是第一选择。<br>2.这是一个态度和逼格的问题。打开过度绘制调试后，别人家的应用蓝蓝的，怎么你的应用就是红彤彤一片？</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>啊，好吧，废话说的有点多了，下面我们上代码。</p>\n<p>Github链接：<a href=\"https://github.com/lizhaoxuan/SoftWidgetDemo.git\">https://github.com/lizhaoxuan/SoftWidgetDemo.git</a></p>\n<p>首先看目录结构：</p>\n<p><img src=\"http://img.blog.csdn.net/20151107151634177\" width = \"180\" height = \"230\" alt=\"图片名称\" align=center /></p>\n<p>有四个核心类：<br>DrawingCanvas.java 我们提前绘制就在这个类上画，然后交给onDraw，一气呵成。<br>PaintBox.java 里面包含了几个绘制方法，比如画背景颜色和形状</p>\n<p>SRoundRect_Button.java  SRoundRect_LinearLayout.java 是两个自定义控件，从名字上可以看出来，两个圆角矩形的按钮和线性布局</p>\n<p>然后看布局文件：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:padding=&quot;10dp&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/logoView&quot;\n        android:layout_width=&quot;100dp&quot;\n        android:layout_height=&quot;100dp&quot;\n        android:layout_centerHorizontal=&quot;true&quot;\n        android:layout_marginTop=&quot;80dp&quot;\n        android:src=&quot;@drawable/logo&quot;/&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/accountLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;50dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/logoView&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_user&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/accountEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;账号&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot; /&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout\n        android:id=&quot;@+id/passwordLayout&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;40dp&quot;\n        android:layout_marginTop=&quot;3dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:layout_marginLeft=&quot;20dp&quot;\n        android:layout_below=&quot;@id/accountLayout&quot;\n        android:orientation=&quot;horizontal&quot;\n        android:paddingLeft=&quot;6dip&quot;\n        android:paddingRight=&quot;6dip&quot;\n        android:paddingTop=&quot;8dip&quot;\n        app:bgcolor=&quot;#CFCFCF&quot;&gt;\n\n        &lt;ImageView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;22dip&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginLeft=&quot;8dip&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:paddingBottom=&quot;6dip&quot;\n            android:src=&quot;@drawable/ic_login_password&quot; /&gt;\n\n        &lt;EditText\n            android:id=&quot;@+id/passwordEdit&quot;\n            android:layout_width=&quot;0dp&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:layout_gravity=&quot;center_vertical&quot;\n            android:layout_marginRight=&quot;8dip&quot;\n            android:layout_weight=&quot;1&quot;\n            android:background=&quot;@null&quot;\n            android:digits=&quot;\\@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,_-&quot;\n            android:hint=&quot;密码&quot;\n            android:imeOptions=&quot;actionNext&quot;\n            android:paddingBottom=&quot;8dip&quot;\n            android:singleLine=&quot;true&quot;\n            android:textColor=&quot;@color/black&quot;\n            android:textCursorDrawable=&quot;@null&quot;\n            android:inputType=&quot;textPassword&quot;/&gt;\n    &lt;/com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_LinearLayout&gt;\n\n    &lt;com.example.zhaoxuanli.softwidgetdemo.soft.widget.SRoundRect_Button\n        android:id=&quot;@+id/login_btn&quot;\n        android:layout_width=&quot;fill_parent&quot;\n        android:layout_height=&quot;50dp&quot;\n        android:layout_marginTop=&quot;20dp&quot;\n        android:layout_below=&quot;@id/passwordLayout&quot;\n        android:layout_alignLeft=&quot;@id/passwordLayout&quot;\n        android:layout_alignRight=&quot;@id/passwordLayout&quot;\n        android:layout_gravity=&quot;center&quot;\n        android:text=&quot;登录&quot;\n        android:textColor=&quot;@color/white&quot;\n        android:textSize=&quot;20sp&quot;\n        app:backgroundColor=&quot;#af0308&quot;/&gt;\n\n\n    &lt;TextView\n        android:id=&quot;@+id/forgetText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentLeft=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginLeft=&quot;10dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;忘记密码&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/registerText&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:layout_alignParentRight=&quot;true&quot;\n        android:layout_marginBottom=&quot;15dp&quot;\n        android:layout_marginRight=&quot;20dp&quot;\n        android:gravity=&quot;center&quot;\n        android:textColor=&quot;#af0308&quot;\n        android:textSize=&quot;15sp&quot;\n        android:text=&quot;注册&quot;/&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>这里要说一下：<br>不加背景和形状的TextView 不需要进行优化，它只进行一次绘制。<br>不加形状的ImageView不需要进行优化，即使设置了background或src属性，也只绘制一次。<br>Button 本身是有背景的，所以你需要手动将它原来的背景去掉，在代码里：this.setBackgroundResource(0);</p>\n<p>通过代码我们可以看到，输入框的布局和Button是自定义控件，所以我对这两个做了提前绘制优化。理论上来说是可以将小图标也提前绘制进去的，这样输入框的小图标也将是蓝色，但计算位置复杂，也不利于扩展。</p>\n<p><em>DrawingCanvas.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\n\n/**\n * Created by zhaoxuan.li on 2015/8/11.\n * 在这上面进行提前绘制\n */\npublic class DrawingCanvas extends Canvas {\n\n    private Bitmap output;\n    private Rect rect;\n    private RectF rectF;\n    private DrawingCanvas(Bitmap output_, float width_, float height_){\n        super(output_);\n        output = output_;\n        rect = new Rect(0,0,(int)width_,(int)height_);\n        rectF = new RectF(0, 0, width_, height_);\n    }\n\n    public static DrawingCanvas instance(float width_ , float height_){\n        Bitmap bitmap = Bitmap.createBitmap((int) width_, (int) height_,\n                Bitmap.Config.ARGB_8888);\n        return new DrawingCanvas(bitmap,width_,height_);\n    }\n\n\n    public Bitmap getOutput(){\n        return output;\n    }\n    public Rect getRect(){\n        return rect;\n    }\n    public RectF getRectF(){\n        return rectF;\n    }\n}\n</code></pre><p>这个类继承了Canvas，并且已经传入一个Bitmap            </p>\n<pre><code>super(output_);\n</code></pre><p>所以我们可以直接在这上面画画。并且还提供了一些Rect，RectF 属性，供之后进行绘制时使用。</p>\n<p><em>PaintBox.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox;\n\nimport android.graphics.Paint;\n\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 用来画图的盒子，里面放着画图的方法\n */\npublic class PaintBox {\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha){\n\n        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        paint.setStyle(Paint.Style.FILL);\n        paint.setAntiAlias(true);\n        paint.setColor(color);\n        paint.setAlpha(alpha);\n        canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n\n    }\n\n    /**\n     * 画圆角矩形\n     * @param canvas 画布\n     * @param color 填充颜色\n     * @param alpha 透明度\n     * @param border 带边框\n     */\n    public static void drawRoundRect(DrawingCanvas canvas ,int color , int alpha,boolean border){\n        if(border){\n            Paint paint = new Paint();\n            paint.setStyle(Paint.Style.FILL);\n            paint.setAntiAlias(true);\n            paint.setColor(color);\n            paint.setAlpha(30);\n            canvas.drawRoundRect(canvas.getRectF(), 20, 20, paint);\n\n            paint.setStyle(Paint.Style.STROKE);\n            paint.setAlpha(70);\n            paint.setStrokeWidth(4);\n            canvas.drawRoundRect(canvas.getRectF(),20,20,paint);\n        }else{\n            drawRoundRect(canvas,color,alpha);\n        }\n\n\n    }\n\n    /**\n     * 填充颜色\n     * @param canvas \n     * @param color\n     */\n    public static void drawColor(DrawingCanvas canvas ,int color ){\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        paint.setDither(true);\n        paint.setColor(color);\n        canvas.drawPaint(paint);\n    }\n\n\n    /**\n     * 写字在View正中间\n     * @param canvas  画布\n     * @param text   文字\n     * @param color  文字颜色\n     * @param size   文字大小\n     */\n    public static void drawTextCenter(DrawingCanvas canvas , String text , int color,int size){\n        //创建画笔\n        Paint pp = new Paint();\n        pp.setAntiAlias(true);\n        pp.setColor(color);\n        pp.setStrokeWidth(3);\n        pp.setTextSize(size);\n        pp.setTextAlign(Paint.Align.CENTER);\n        Paint.FontMetricsInt fontMetrics = pp.getFontMetricsInt();\n        float vertical = canvas.getRectF().top + (canvas.getRectF().bottom - canvas.getRectF().top - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;\n        canvas.drawText(text, canvas.getRectF().centerX(), vertical, pp);\n    }\n}\n</code></pre><p>这个类比较简单了，你有什么需求，就在这里创建一个方法就好了，然后传入一个Canvas和一些必要参数，它帮你把你需要的东西画到Canvas上。<br>值得注意的是最后一个方法：drawTextCenter。 将文字绘制到View中间。这个是没有直接办法实现的，所以你需要计算一下位置。</p>\n<p>最后是我们的自定义控件，篇幅太长，所以我们只看一个Button的，LinearLayout的可以下载代码看.</p>\n<p><em>SRoundRect_Button.java:</em></p>\n<pre><code>package com.example.zhaoxuanli.softwidgetdemo.soft.widget;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.util.AttributeSet;\nimport android.widget.Button;\n\nimport com.example.zhaoxuanli.softwidgetdemo.R;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.DrawingCanvas;\nimport com.example.zhaoxuanli.softwidgetdemo.soft.widget.PaintBox.PaintBox;\n\n/**\n * Created by zhaoxuan.li on 2015/8/12.\n * 圆角矩形Button，无边框。  可以放一个颜色当做背景，\n */\n\n//\n//字符编码 UTF-8  无BOM\npublic class SRoundRect_Button extends Button {\n    private String text;\n    private int textColor;\n    private int textSize;\n    private int backgroundColor;\n    /**\n     * 提前绘制的画布\n     * 之前为了追求性能，所以用了软引用，但是在红米2上发现Bug\n     * DrawingCanvas被系统收回了，导致空指针异常。这里还要好好研究一下\n     * 反编译Path源码后，这里是采用软引用的\n     */\n    private DrawingCanvas localDrawingCanvas;  \n\n    /**\n     * 一下是超类的三个构造方法\n     * @param context\n     */\n    public SRoundRect_Button(Context context) {\n        super(context);\n        init(context,null , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context,attrs , 0);\n    }\n\n    public SRoundRect_Button(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(context, attrs , defStyle);\n    }\n\n    private void init(Context context , AttributeSet attrs , int defStyle ){   //初始化操作\n        this.setBackgroundResource(0);  //去掉Button原来的背景\n        if(null == attrs)\n            return ;\n\n        /**\n         * View属性的提取\n         */\n        Resources resources = getResources();\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SRoundRect_Button);\n        text = a.getString(R.styleable.SRoundRect_Button_android_text);\n        textColor = a.getColor(R.styleable.SRoundRect_Button_android_textColor, resources.getColor(R.color.white));\n        textSize = a.getDimensionPixelSize(R.styleable.SRoundRect_Button_android_textSize, 20);\n        backgroundColor = a.getColor(R.styleable.SRoundRect_Button_backgroundColor, 0Xaf0308);\n\n\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        //取得View的长宽信息，因为每一次View的载入长款\n        float width = this.getWidth();\n        float height = this.getHeight();\n        /**\n         * 因为界面有一定的刷新率，每一次刷新都会调用onDraw方法\n         * 所以为了效率和性能考虑，需要做一些判断避免重复判断\n         */\n        if(localDrawingCanvas==null){\n            localDrawingCanvas = DrawingCanvas.instance(width,height);\n            PaintBox.drawRoundRect(localDrawingCanvas, backgroundColor, 30);\n            PaintBox.drawTextCenter(localDrawingCanvas,text,textColor,textSize);\n        }\n\n\n        canvas.drawBitmap(localDrawingCanvas.getOutput(),0,0,null);\n    }\n}\n</code></pre><p>这就是一个提前绘制的自定义控件的实现了。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>这里有一个疑问：android:background 属性，我们可以设置图片、颜色、甚至是xml写得背景。这个究竟是如何实现的？<br>因为实现不了这个效果，所以只能添加了自定义属性</p>\n<pre><code>&lt;attr name=&quot;backgroundPic&quot; format=&quot;reference&quot;/&gt;\n&lt;attr name=&quot;backgroundColor&quot; format=&quot;color&quot;/&gt;\n</code></pre><p>感觉很Low啊这样！！！还期待大神帮解决。</p>\n<p>设计一个可以直接使用的重绘控件库，是一个长久的目标呀~</p>"},{"title":"Android之GPU过度绘制与图形渲染优化","date":"2015-09-10T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n本文主要对过度绘制和图形渲染做一个概念性的描述。\n\n同时以案例方式列出一些简单适用的优化措施。\n\n如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：\n\n[优化Android过度绘制]()\n\n另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 [Android 性能优化典范](http://www.oschina.net/news/60157/android-performance-patterns)\n\n\n<!-- more -->\n\n## 概念\n\n\n### GPU过度绘制\n\n是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。\n\t\n**仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！**\n\n还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！\n\n\n### 图形渲染优化\t\n\n一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。\n\n\n## 关键点/字\n\n\n- 过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。\n\n- 调试GPU过渡绘制颜色区域说明    \n\n\t- 无/白色：绘制1次\n\t- 蓝色：绘制2次（理想状态）\n\t- 绿色：绘制3次\n\t- 浅红：绘制4次（要优化了）\n\t- 深红：绘制5次或5次以上。（必须要优化了）\n\n\t![](http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg)\n\n\n- 调试Hierarchy Viewer 颜色说明\t\t\t\t\t\n\t\t\t\n\t下方三个原点从左到右：测量、布局、画图时间\n\t\n\t- 红色：该View所用时间超过大部分View很多\n\t- 黄色：该View所用时间超过大部分View\n\t- 绿色：该View所用时间低于大部分View\n\t\t\n   ![调试Hierarchy Viewer颜色说明](http://img.blog.csdn.net/20151016211507297)\n\n- 引起过度绘制的两个主要因素：层级与背景图片\n\t\n\t- 层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。\n\t- 改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层\n\t- 值得注意的是，背景图片的绘制是及其耗时的\n\n- 一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。\n\n\t- 浅层布局效率高于深层布局\n\t- 布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout > RelativeLayout\n    - 基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。\n\t- 但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。\n\n## 优化措施\n\n- 在Theme中给activity增加背景。使用WindowBackground属性。\n\n\t背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。\n\n\n- 减少层级，没必要的背景图\n\n\t如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景\n\n- 避免使布局太深，而应该让布局更浅更深\n\n\t用相对布局替换线性布局\n\n- 无用的子节点、父节点删除\n\n\t没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：\n\t\n\t1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView\n\t\t\n\t2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。\n\n- 对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局\n\n- 避免出现多个使用layout-weight属性的的LinearLayout。\n\n\t首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。\n\t\n\n- 合并作为根节点的帧布局(Framelayout)  \n\t\t\n\t你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。\n\t\n\t如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。\n\t\n\t更有效的方式是使用<merge />标签替换该< Framelayout />标签 。\n\n- 使用组合控件\n\n\t首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。\n\t\n\t但它会让你的布局文件看起来非常的清晰。\n\t\n\t并且对于一些条状的控件。类似与下图这样的控件。\n\t\n\t当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。\n\t\n\t使用组合控件包装你的view，既符合封装的特性，又可以减少代码量\n\n**重要的东西放到最后说：**\n\n- **重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。**\n\n\t说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）\n\t\t\n\t那么这是你需要终极绝招：View提前绘制。\n\t\n\t不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。\n\t\n\t楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。\n\t\t\n\n\n\n\n## 案例说明 – 登录界面\n\n为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。\n\n开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。\n\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n<img src=\"http://img.blog.csdn.net/20151016211551825\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n\n惊讶吗？没关系，我们也可以做到。\n\n之后再看我们的UI层级图：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211744054)\n\n下面我们一步步分析优化。\n\n\n### 优化1\n\n**优化布局结构，解决过深的UI层级图，与无用的子节点**\n\n- \t过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差\n\n![](http://img.blog.csdn.net/20151016211802245)\n\n**优化方案1：**采用相对布局，使得布局变浅变宽。最大可以保证只有两层。\n\n\n**优化方案2：**观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。\n\n\n无用的子节点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211827892)\n\n一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。\n\n\n### 优化2\n**子view过久的测量时间。**\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211844469)\n\n查看其代码：\n\n\t<com.envision.mobile.ui.widget.EditView    \n        android:id=\"@+id/login_name\"    \n        android:layout_width=\"0dp\"    \n        android:layout_height=\"wrap_content\"   \n        android:layout_gravity=\"center_vertical\"    \n        android:layout_marginRight=\"8dip\"   \n        android:layout_weight=\"1\"    \n        android:background=\"@null\"       \n        android:hint=\"@string/hint_login_name\"    \n        android:imeOptions=\"actionNext\"    \n        android:paddingBottom=\"8dip\"   \n        android:singleLine=\"true\"   \n        android:textColor=\"@color/white\"   \n        android:textColorHint=\"@color/white_trans_88\"    \n        android:textCursorDrawable=\"@null\" />   \n\n**android:layout_weight=\"1\"  属性导致过久的测量时间。**   \n\n\n### 优化3\n\n在Theme中给activity添加背景。减少一层绘制\n\n\t\t<style name=\"AppTheme\" parent=\"AppBaseTheme\">\n\t\t    <item name=\"android:windowBackground\">\n\t\t\t@drawable/bg_homepage\n\t\t\t</item>\n\t\t</style>\n\n\n### 优化4\n\n**重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。**\n\n这里代码量较大，我们放到另一篇文章中讲： \n\nhttp://blog.csdn.net/u010255127/article/details/49702663\n\n## 最终优化效果\t\n没有红色，最高是绿色\n（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）\n\n![这里写图片描述](http://img.blog.csdn.net/20151103211244952)\n\n\n\n## 测试数据\n\n【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）\n原始状况：\n\n\tonCreate 到 onStart ： 381  370 \n\tonCreate 到 onResume ：383  373\n\tonStart 到 onResume ： 2     3\n\n\n在theme加背景\n\n\tonCreate 到 onStart ： 274  295\n\tonCreate 到 onResume ：277  298\n\tonStart 到 onResume ：  3    3\n\n\n\n仅修改布局层次(去掉两个不必要透明布局)\n\n\tonCreate 到 onStart ： 272   276\n\tonCreate 到 onResume ：274  279\n\tonStart 到 onResume ：  2     3\n\n\n\n替换自定义 提前绘制控件\n\n\tonCreate 到 onStart ：  289  299  294\n\tonCreate 到 onResume ：  292 302  296\n\tonStart 到 onResume ：   3    3    2\n\n\n## 结论\n\n我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。\n去掉不必要的布局和View，虽然效果甚微，但也减少了。\n\n最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。\n另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……\n\n\n最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。\n\n我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。\n\n","source":"_posts/android-rendering-performance-optimization.md","raw":"\n---\ntitle: Android之GPU过度绘制与图形渲染优化\ndate: 2015-9-10 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n## 前言\n\n本文主要对过度绘制和图形渲染做一个概念性的描述。\n\n同时以案例方式列出一些简单适用的优化措施。\n\n如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：\n\n[优化Android过度绘制]()\n\n另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 [Android 性能优化典范](http://www.oschina.net/news/60157/android-performance-patterns)\n\n\n<!-- more -->\n\n## 概念\n\n\n### GPU过度绘制\n\n是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。\n\t\n**仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！**\n\n还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！\n\n\n### 图形渲染优化\t\n\n一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。\n\n\n## 关键点/字\n\n\n- 过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。\n\n- 调试GPU过渡绘制颜色区域说明    \n\n\t- 无/白色：绘制1次\n\t- 蓝色：绘制2次（理想状态）\n\t- 绿色：绘制3次\n\t- 浅红：绘制4次（要优化了）\n\t- 深红：绘制5次或5次以上。（必须要优化了）\n\n\t![](http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg)\n\n\n- 调试Hierarchy Viewer 颜色说明\t\t\t\t\t\n\t\t\t\n\t下方三个原点从左到右：测量、布局、画图时间\n\t\n\t- 红色：该View所用时间超过大部分View很多\n\t- 黄色：该View所用时间超过大部分View\n\t- 绿色：该View所用时间低于大部分View\n\t\t\n   ![调试Hierarchy Viewer颜色说明](http://img.blog.csdn.net/20151016211507297)\n\n- 引起过度绘制的两个主要因素：层级与背景图片\n\t\n\t- 层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。\n\t- 改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层\n\t- 值得注意的是，背景图片的绘制是及其耗时的\n\n- 一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。\n\n\t- 浅层布局效率高于深层布局\n\t- 布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout > RelativeLayout\n    - 基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。\n\t- 但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。\n\n## 优化措施\n\n- 在Theme中给activity增加背景。使用WindowBackground属性。\n\n\t背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。\n\n\n- 减少层级，没必要的背景图\n\n\t如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景\n\n- 避免使布局太深，而应该让布局更浅更深\n\n\t用相对布局替换线性布局\n\n- 无用的子节点、父节点删除\n\n\t没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：\n\t\n\t1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView\n\t\t\n\t2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。\n\n- 对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局\n\n- 避免出现多个使用layout-weight属性的的LinearLayout。\n\n\t首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。\n\t\n\n- 合并作为根节点的帧布局(Framelayout)  \n\t\t\n\t你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。\n\t\n\t如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。\n\t\n\t更有效的方式是使用<merge />标签替换该< Framelayout />标签 。\n\n- 使用组合控件\n\n\t首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。\n\t\n\t但它会让你的布局文件看起来非常的清晰。\n\t\n\t并且对于一些条状的控件。类似与下图这样的控件。\n\t\n\t当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。\n\t\n\t使用组合控件包装你的view，既符合封装的特性，又可以减少代码量\n\n**重要的东西放到最后说：**\n\n- **重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。**\n\n\t说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）\n\t\t\n\t那么这是你需要终极绝招：View提前绘制。\n\t\n\t不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。\n\t\n\t楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。\n\t\t\n\n\n\n\n## 案例说明 – 登录界面\n\n为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。\n\n开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。\n\n<img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n<img src=\"http://img.blog.csdn.net/20151016211551825\" width = \"200\" height = \"350\" alt=\"图片名称\"  />\n\n\n惊讶吗？没关系，我们也可以做到。\n\n之后再看我们的UI层级图：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211744054)\n\n下面我们一步步分析优化。\n\n\n### 优化1\n\n**优化布局结构，解决过深的UI层级图，与无用的子节点**\n\n- \t过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差\n\n![](http://img.blog.csdn.net/20151016211802245)\n\n**优化方案1：**采用相对布局，使得布局变浅变宽。最大可以保证只有两层。\n\n\n**优化方案2：**观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。\n\n\n无用的子节点：\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211827892)\n\n一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。\n\n\n### 优化2\n**子view过久的测量时间。**\n\n![这里写图片描述](http://img.blog.csdn.net/20151016211844469)\n\n查看其代码：\n\n\t<com.envision.mobile.ui.widget.EditView    \n        android:id=\"@+id/login_name\"    \n        android:layout_width=\"0dp\"    \n        android:layout_height=\"wrap_content\"   \n        android:layout_gravity=\"center_vertical\"    \n        android:layout_marginRight=\"8dip\"   \n        android:layout_weight=\"1\"    \n        android:background=\"@null\"       \n        android:hint=\"@string/hint_login_name\"    \n        android:imeOptions=\"actionNext\"    \n        android:paddingBottom=\"8dip\"   \n        android:singleLine=\"true\"   \n        android:textColor=\"@color/white\"   \n        android:textColorHint=\"@color/white_trans_88\"    \n        android:textCursorDrawable=\"@null\" />   \n\n**android:layout_weight=\"1\"  属性导致过久的测量时间。**   \n\n\n### 优化3\n\n在Theme中给activity添加背景。减少一层绘制\n\n\t\t<style name=\"AppTheme\" parent=\"AppBaseTheme\">\n\t\t    <item name=\"android:windowBackground\">\n\t\t\t@drawable/bg_homepage\n\t\t\t</item>\n\t\t</style>\n\n\n### 优化4\n\n**重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。**\n\n这里代码量较大，我们放到另一篇文章中讲： \n\nhttp://blog.csdn.net/u010255127/article/details/49702663\n\n## 最终优化效果\t\n没有红色，最高是绿色\n（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）\n\n![这里写图片描述](http://img.blog.csdn.net/20151103211244952)\n\n\n\n## 测试数据\n\n【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）\n原始状况：\n\n\tonCreate 到 onStart ： 381  370 \n\tonCreate 到 onResume ：383  373\n\tonStart 到 onResume ： 2     3\n\n\n在theme加背景\n\n\tonCreate 到 onStart ： 274  295\n\tonCreate 到 onResume ：277  298\n\tonStart 到 onResume ：  3    3\n\n\n\n仅修改布局层次(去掉两个不必要透明布局)\n\n\tonCreate 到 onStart ： 272   276\n\tonCreate 到 onResume ：274  279\n\tonStart 到 onResume ：  2     3\n\n\n\n替换自定义 提前绘制控件\n\n\tonCreate 到 onStart ：  289  299  294\n\tonCreate 到 onResume ：  292 302  296\n\tonStart 到 onResume ：   3    3    2\n\n\n## 结论\n\n我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。\n去掉不必要的布局和View，虽然效果甚微，但也减少了。\n\n最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。\n另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……\n\n\n最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。\n\n我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。\n\n","slug":"android-rendering-performance-optimization","published":1,"updated":"2017-01-16T05:13:40.000Z","_id":"cixzmux2x0001q4chtp1qazq2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要对过度绘制和图形渲染做一个概念性的描述。</p>\n<p>同时以案例方式列出一些简单适用的优化措施。</p>\n<p>如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：</p>\n<p><a href=\"\">优化Android过度绘制</a></p>\n<p>另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 <a href=\"http://www.oschina.net/news/60157/android-performance-patterns\" target=\"_blank\" rel=\"external\">Android 性能优化典范</a></p>\n<a id=\"more\"></a>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"GPU过度绘制\"><a href=\"#GPU过度绘制\" class=\"headerlink\" title=\"GPU过度绘制\"></a>GPU过度绘制</h3><p>是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。</p>\n<p><strong>仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！</strong></p>\n<p>还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！</p>\n<h3 id=\"图形渲染优化\"><a href=\"#图形渲染优化\" class=\"headerlink\" title=\"图形渲染优化\"></a>图形渲染优化</h3><p>一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。</p>\n<h2 id=\"关键点-字\"><a href=\"#关键点-字\" class=\"headerlink\" title=\"关键点/字\"></a>关键点/字</h2><ul>\n<li><p>过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。</p>\n</li>\n<li><p>调试GPU过渡绘制颜色区域说明    </p>\n<ul>\n<li>无/白色：绘制1次</li>\n<li>蓝色：绘制2次（理想状态）</li>\n<li>绿色：绘制3次</li>\n<li>浅红：绘制4次（要优化了）</li>\n<li><p>深红：绘制5次或5次以上。（必须要优化了）</p>\n<p><img src=\"http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>调试Hierarchy Viewer 颜色说明                    </p>\n<p>  下方三个原点从左到右：测量、布局、画图时间</p>\n<ul>\n<li>红色：该View所用时间超过大部分View很多</li>\n<li>黄色：该View所用时间超过大部分View</li>\n<li><p>绿色：该View所用时间低于大部分View</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211507297\" alt=\"调试Hierarchy Viewer颜色说明\"></p>\n</li>\n</ul>\n</li>\n<li><p>引起过度绘制的两个主要因素：层级与背景图片</p>\n<ul>\n<li>层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。</li>\n<li>改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层</li>\n<li>值得注意的是，背景图片的绘制是及其耗时的</li>\n</ul>\n</li>\n<li><p>一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。</p>\n<ul>\n<li>浅层布局效率高于深层布局</li>\n<li>布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout &gt; RelativeLayout</li>\n<li>基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。</li>\n<li>但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h2><ul>\n<li><p>在Theme中给activity增加背景。使用WindowBackground属性。</p>\n<p>  背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。</p>\n</li>\n</ul>\n<ul>\n<li><p>减少层级，没必要的背景图</p>\n<p>  如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景</p>\n</li>\n<li><p>避免使布局太深，而应该让布局更浅更深</p>\n<p>  用相对布局替换线性布局</p>\n</li>\n<li><p>无用的子节点、父节点删除</p>\n<p>  没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：</p>\n<p>  1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView</p>\n<p>  2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。</p>\n</li>\n<li><p>对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局</include></p>\n</li>\n<li><p>避免出现多个使用layout-weight属性的的LinearLayout。</p>\n<p>  首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。</p>\n</li>\n</ul>\n<ul>\n<li><p>合并作为根节点的帧布局(Framelayout)  </p>\n<p>  你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。</p>\n<p>  如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。</p>\n<p>  更有效的方式是使用<merge>标签替换该&lt; Framelayout /&gt;标签 。</merge></p>\n</li>\n<li><p>使用组合控件</p>\n<p>  首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。</p>\n<p>  但它会让你的布局文件看起来非常的清晰。</p>\n<p>  并且对于一些条状的控件。类似与下图这样的控件。</p>\n<p>  当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。</p>\n<p>  使用组合控件包装你的view，既符合封装的特性，又可以减少代码量</p>\n</li>\n</ul>\n<p><strong>重要的东西放到最后说：</strong></p>\n<ul>\n<li><p><strong>重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。</strong></p>\n<p>  说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）</p>\n<p>  那么这是你需要终极绝招：View提前绘制。</p>\n<p>  不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。</p>\n<p>  楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。</p>\n</li>\n</ul>\n<h2 id=\"案例说明-–-登录界面\"><a href=\"#案例说明-–-登录界面\" class=\"headerlink\" title=\"案例说明 – 登录界面\"></a>案例说明 – 登录界面</h2><p>为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。</p>\n<p>开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211615749\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211551825\" width=\"200\" height=\"350\" alt=\"图片名称\"></p>\n<p>惊讶吗？没关系，我们也可以做到。</p>\n<p>之后再看我们的UI层级图：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211744054\" alt=\"这里写图片描述\"></p>\n<p>下面我们一步步分析优化。</p>\n<h3 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h3><p><strong>优化布局结构，解决过深的UI层级图，与无用的子节点</strong></p>\n<ul>\n<li>过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20151016211802245\" alt=\"\"></p>\n<p><strong>优化方案1：</strong>采用相对布局，使得布局变浅变宽。最大可以保证只有两层。</p>\n<p><strong>优化方案2：</strong>观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。</p>\n<p>无用的子节点：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211827892\" alt=\"这里写图片描述\"></p>\n<p>一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。</p>\n<h3 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h3><p><strong>子view过久的测量时间。</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211844469\" alt=\"这里写图片描述\"></p>\n<p>查看其代码：</p>\n<pre><code>&lt;com.envision.mobile.ui.widget.EditView    \n    android:id=&quot;@+id/login_name&quot;    \n    android:layout_width=&quot;0dp&quot;    \n    android:layout_height=&quot;wrap_content&quot;   \n    android:layout_gravity=&quot;center_vertical&quot;    \n    android:layout_marginRight=&quot;8dip&quot;   \n    android:layout_weight=&quot;1&quot;    \n    android:background=&quot;@null&quot;       \n    android:hint=&quot;@string/hint_login_name&quot;    \n    android:imeOptions=&quot;actionNext&quot;    \n    android:paddingBottom=&quot;8dip&quot;   \n    android:singleLine=&quot;true&quot;   \n    android:textColor=&quot;@color/white&quot;   \n    android:textColorHint=&quot;@color/white_trans_88&quot;    \n    android:textCursorDrawable=&quot;@null&quot; /&gt;   \n</code></pre><p><strong>android:layout_weight=”1”  属性导致过久的测量时间。</strong>   </p>\n<h3 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h3><p>在Theme中给activity添加背景。减少一层绘制</p>\n<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;\n    @drawable/bg_homepage\n    &lt;/item&gt;\n&lt;/style&gt;\n</code></pre><h3 id=\"优化4\"><a href=\"#优化4\" class=\"headerlink\" title=\"优化4\"></a>优化4</h3><p><strong>重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。</strong></p>\n<p>这里代码量较大，我们放到另一篇文章中讲： </p>\n<p><a href=\"http://blog.csdn.net/u010255127/article/details/49702663\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u010255127/article/details/49702663</a></p>\n<h2 id=\"最终优化效果\"><a href=\"#最终优化效果\" class=\"headerlink\" title=\"最终优化效果\"></a>最终优化效果</h2><p>没有红色，最高是绿色<br>（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211244952\" alt=\"这里写图片描述\"></p>\n<h2 id=\"测试数据\"><a href=\"#测试数据\" class=\"headerlink\" title=\"测试数据\"></a>测试数据</h2><p>【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）<br>原始状况：</p>\n<pre><code>onCreate 到 onStart ： 381  370 \nonCreate 到 onResume ：383  373\nonStart 到 onResume ： 2     3\n</code></pre><p>在theme加背景</p>\n<pre><code>onCreate 到 onStart ： 274  295\nonCreate 到 onResume ：277  298\nonStart 到 onResume ：  3    3\n</code></pre><p>仅修改布局层次(去掉两个不必要透明布局)</p>\n<pre><code>onCreate 到 onStart ： 272   276\nonCreate 到 onResume ：274  279\nonStart 到 onResume ：  2     3\n</code></pre><p>替换自定义 提前绘制控件</p>\n<pre><code>onCreate 到 onStart ：  289  299  294\nonCreate 到 onResume ：  292 302  296\nonStart 到 onResume ：   3    3    2\n</code></pre><h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。<br>去掉不必要的布局和View，虽然效果甚微，但也减少了。</p>\n<p>最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。<br>另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……</p>\n<p>最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。</p>\n<p>我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。</p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要对过度绘制和图形渲染做一个概念性的描述。</p>\n<p>同时以案例方式列出一些简单适用的优化措施。</p>\n<p>如果你已对过度绘制有过一些了解，那么你应该明白，仅是简单的层级优化对过度绘制的改善是很小的。所以，这时候你可以参考这篇文章：</p>\n<p><a href=\"\">优化Android过度绘制</a></p>\n<p>另外如果你还想知道更多关于View优化原理，可以参考 Google 发布的 <a href=\"http://www.oschina.net/news/60157/android-performance-patterns\">Android 性能优化典范</a></p>","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"GPU过度绘制\"><a href=\"#GPU过度绘制\" class=\"headerlink\" title=\"GPU过度绘制\"></a>GPU过度绘制</h3><p>是指在一个像素点上绘制多次（超过一次）。举一个简单的例子：显示一个什么都没有做的activity界面算作画了1层，给activity加一个背景是第2层，在上面放了一个Text View（有背景的Text View）是第3层，Text View显示文本就是第4层 。</p>\n<p><strong>仅仅只是为了显示一个文本，却在同一个像素点绘制了四次,这是一定要优化的！</strong></p>\n<p>还有，过度绘制对动画性能的影响是极其严重的。如果你想要流畅的动画效果，那么一定不能忽视过度绘制！！</p>\n<h3 id=\"图形渲染优化\"><a href=\"#图形渲染优化\" class=\"headerlink\" title=\"图形渲染优化\"></a>图形渲染优化</h3><p>一个View的绘制过程：测量、布局、画图。三者的累积时间，就是一个View的最终绘制时间 。 过多的层级、无用的子节点父节点、过于依赖系统计算位置的布局属性（如： weight）。都会引起上述三个过程时间的增加。</p>\n<h2 id=\"关键点-字\"><a href=\"#关键点-字\" class=\"headerlink\" title=\"关键点/字\"></a>关键点/字</h2><ul>\n<li><p>过渡绘制优化与图形渲染优化都其目的都是为了提供一个高效的UI。其目的相似，优化方式也有相同之处，所以一起进行总结。</p>\n</li>\n<li><p>调试GPU过渡绘制颜色区域说明    </p>\n<ul>\n<li>无/白色：绘制1次</li>\n<li>蓝色：绘制2次（理想状态）</li>\n<li>绿色：绘制3次</li>\n<li>浅红：绘制4次（要优化了）</li>\n<li><p>深红：绘制5次或5次以上。（必须要优化了）</p>\n<p><img src=\"http://img2.ph.126.net/HqqBm8xVjCUwd4EHSaQhgA==/6631820931164660027.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>调试Hierarchy Viewer 颜色说明                    </p>\n<p>  下方三个原点从左到右：测量、布局、画图时间</p>\n<ul>\n<li>红色：该View所用时间超过大部分View很多</li>\n<li>黄色：该View所用时间超过大部分View</li>\n<li><p>绿色：该View所用时间低于大部分View</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211507297\" alt=\"调试Hierarchy Viewer颜色说明\"></p>\n</li>\n</ul>\n</li>\n<li><p>引起过度绘制的两个主要因素：层级与背景图片</p>\n<ul>\n<li>层级为透明时（不添加背景），不会引起过度绘制，但会引起测量、布局、画图时间的显著提高。</li>\n<li>改变View形状，也算是绘制一层。添加一个椭圆形的黑色背景，算作两层</li>\n<li>值得注意的是，背景图片的绘制是及其耗时的</li>\n</ul>\n</li>\n<li><p>一个通常的错误观念就是使用基本的布局结构(例如：LinearLayout、FrameLayout等)能够在大多数情况下产生高效率的布局。</p>\n<ul>\n<li>浅层布局效率高于深层布局</li>\n<li>布局嵌套层数相同情况效率对比：LinearLayout ≈ FrameLayout &gt; RelativeLayout</li>\n<li>基本的线性布局会导致过于累赘的层级嵌套结构。使用相对布局优化。</li>\n<li>但并不是所有情况下都应该用相对布局。（相对布局过于复杂，且通读性差）应考虑权衡关系。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h2><ul>\n<li><p>在Theme中给activity增加背景。使用WindowBackground属性。</p>\n<p>  背景的绘制是非常耗时的，在Theme中添加背景，不算绘制一层，并且View渲染时间减少很多。</p>\n</li>\n</ul>\n<ul>\n<li><p>减少层级，没必要的背景图</p>\n<p>  如果一个View和它所在的Layout的颜色相同，就不需要给两个都设置背景</p>\n</li>\n<li><p>避免使布局太深，而应该让布局更浅更深</p>\n<p>  用相对布局替换线性布局</p>\n</li>\n<li><p>无用的子节点、父节点删除</p>\n<p>  没有免费的午餐，性能优化最重要的一点便是：不要做多余的事情。举例：</p>\n<p>  1.想要设置控件之间的间距，使用 margin 或 padding 之类的属性，而不是填充一个透明的TextView</p>\n<p>  2.如果你需要的效果仅是一张图片加一串文字。那么不需要使用两个控件：TextView+ImageView.  TextView一个控件足以。</p>\n</li>\n<li><p>对于要被<include>的布局，如果没有背景或Padding，使用 merge 标签作为根布局</p>\n</li>\n<li><p>避免出现多个使用layout-weight属性的的LinearLayout。</p>\n<p>  首先我们必须要承认layout-weight的灵活性，但在使用时，请再三考虑是否真的有必要。weight将导致大量的系统开销，每个子项目都要测量两次。</p>\n</li>\n</ul>\n<ul>\n<li><p>合并作为根节点的帧布局(Framelayout)  </p>\n<p>  你需要知道的一个知识点：Activity或Fragment的默认根布局是FrameLayout。</p>\n<p>  如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等。</p>\n<p>  更有效的方式是使用<merge />标签替换该&lt; Framelayout /&gt;标签 。</p>\n</li>\n<li><p>使用组合控件</p>\n<p>  首先说明的是，组合控件并不会减少过度绘制，也不会减少View的绘制时间。</p>\n<p>  但它会让你的布局文件看起来非常的清晰。</p>\n<p>  并且对于一些条状的控件。类似与下图这样的控件。</p>\n<p>  当你需要给这样的控件添加点击事件时，你可能需要给一个layout,两个TextView都添加。</p>\n<p>  使用组合控件包装你的view，既符合封装的特性，又可以减少代码量</p>\n</li>\n</ul>\n<p><strong>重要的东西放到最后说：</strong></p>\n<ul>\n<li><p><strong>重绘控件，提前绘制控件背景与形状，使得View在放到界面上之前就已经画好。极为有效的避免过度绘制。</strong></p>\n<p>  说实话，直接使用原生控件很难避免过度绘制：一个Button，继承与TextView，所以直接就已经被绘制了两次（TextView一次，加Button背景第二次）</p>\n<p>  那么这是你需要终极绝招：View提前绘制。</p>\n<p>  不过需要你抉择的是，提前绘制是一项复杂的工作，所以在复杂布局中使用OK，过于简单的布局就没有必要了。且View提前绘制的适用场景是静态View（不会平凡变化的View）。</p>\n<p>  楼主正在努力将提前绘制控件类库化，但目前较为遗憾的是，很难抽取提前绘制控件的相同点。不同需求画法是不一样的。</p>\n</li>\n</ul>\n<h2 id=\"案例说明-–-登录界面\"><a href=\"#案例说明-–-登录界面\" class=\"headerlink\" title=\"案例说明 – 登录界面\"></a>案例说明 – 登录界面</h2><p>为了简化解说，我们使用登录界面作为案例。但对于 控件的提前绘制来说，在登录界面投入和产出并不等比，控件提前绘制，你应该关注复杂的界面，尤其是这复杂的界面上还有动画效果。</p>\n<p>开启过度绘制检测后 ,上边是我们未经优化的界面。下边是QQ空间的登录界面。</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211615749\" width = \"200\" height = \"350\" alt=\"图片名称\"  /></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211551825\" width = \"200\" height = \"350\" alt=\"图片名称\"  /></p>\n<p>惊讶吗？没关系，我们也可以做到。</p>\n<p>之后再看我们的UI层级图：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211744054\" alt=\"这里写图片描述\"></p>\n<p>下面我们一步步分析优化。</p>\n<h3 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h3><p><strong>优化布局结构，解决过深的UI层级图，与无用的子节点</strong></p>\n<ul>\n<li>过深的LinearLayout嵌套LinearLayout 嵌套LinearLayout 。并且通读性较差</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20151016211802245\" alt=\"\"></p>\n<p><strong>优化方案1：</strong>采用相对布局，使得布局变浅变宽。最大可以保证只有两层。</p>\n<p><strong>优化方案2：</strong>观察可以得知，布局整体大方向为垂直线性，采用组合控件（带小图标的输入框作为一个整体控件）加垂直线性布局。</p>\n<p>无用的子节点：</p>\n<p><img src=\"http://img.blog.csdn.net/20151016211827892\" alt=\"这里写图片描述\"></p>\n<p>一个布局里只放了一个Button按钮，次布局为无用的子节点，去掉。</p>\n<h3 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h3><p><strong>子view过久的测量时间。</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20151016211844469\" alt=\"这里写图片描述\"></p>\n<p>查看其代码：</p>\n<pre><code>&lt;com.envision.mobile.ui.widget.EditView    \n    android:id=&quot;@+id/login_name&quot;    \n    android:layout_width=&quot;0dp&quot;    \n    android:layout_height=&quot;wrap_content&quot;   \n    android:layout_gravity=&quot;center_vertical&quot;    \n    android:layout_marginRight=&quot;8dip&quot;   \n    android:layout_weight=&quot;1&quot;    \n    android:background=&quot;@null&quot;       \n    android:hint=&quot;@string/hint_login_name&quot;    \n    android:imeOptions=&quot;actionNext&quot;    \n    android:paddingBottom=&quot;8dip&quot;   \n    android:singleLine=&quot;true&quot;   \n    android:textColor=&quot;@color/white&quot;   \n    android:textColorHint=&quot;@color/white_trans_88&quot;    \n    android:textCursorDrawable=&quot;@null&quot; /&gt;   \n</code></pre><p><strong>android:layout_weight=”1”  属性导致过久的测量时间。</strong>   </p>\n<h3 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h3><p>在Theme中给activity添加背景。减少一层绘制</p>\n<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;\n    @drawable/bg_homepage\n    &lt;/item&gt;\n&lt;/style&gt;\n</code></pre><h3 id=\"优化4\"><a href=\"#优化4\" class=\"headerlink\" title=\"优化4\"></a>优化4</h3><p><strong>重绘控件，提前为控件绘制背景或形状，在控件放到布局上时，就已经被绘制好。</strong></p>\n<p>这里代码量较大，我们放到另一篇文章中讲： </p>\n<p><a href=\"http://blog.csdn.net/u010255127/article/details/49702663\">http://blog.csdn.net/u010255127/article/details/49702663</a></p>\n<h2 id=\"最终优化效果\"><a href=\"#最终优化效果\" class=\"headerlink\" title=\"最终优化效果\"></a>最终优化效果</h2><p>没有红色，最高是绿色<br>（替换了一些控件和实现方式，不对本文所讲述的内容有影响，我们只看过度绘制检测）</p>\n<p><img src=\"http://img.blog.csdn.net/20151103211244952\" alt=\"这里写图片描述\"></p>\n<h2 id=\"测试数据\"><a href=\"#测试数据\" class=\"headerlink\" title=\"测试数据\"></a>测试数据</h2><p>【时间计算】 单位 /ms （测算时间受手机性能影响，数据较为不稳定，需多次测量）<br>原始状况：</p>\n<pre><code>onCreate 到 onStart ： 381  370 \nonCreate 到 onResume ：383  373\nonStart 到 onResume ： 2     3\n</code></pre><p>在theme加背景</p>\n<pre><code>onCreate 到 onStart ： 274  295\nonCreate 到 onResume ：277  298\nonStart 到 onResume ：  3    3\n</code></pre><p>仅修改布局层次(去掉两个不必要透明布局)</p>\n<pre><code>onCreate 到 onStart ： 272   276\nonCreate 到 onResume ：274  279\nonStart 到 onResume ：  2     3\n</code></pre><p>替换自定义 提前绘制控件</p>\n<pre><code>onCreate 到 onStart ：  289  299  294\nonCreate 到 onResume ：  292 302  296\nonStart 到 onResume ：   3    3    2\n</code></pre><h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们可以很清晰看到当我们把背景设置到Theme中时，View绘制时间减少的非常明显。<br>去掉不必要的布局和View，虽然效果甚微，但也减少了。</p>\n<p>最后，虽然提前绘制控件并没有起到减少绘制时间的作用，甚至还稍加了一点时间（内存中绘图）。但减少了过度绘制，对界面运行的流畅度起到的作用非常大的。<br>另外，我们绘制逻辑还有很大优化的空间，这个任重而道远……</p>\n<p>最后提一小点，WebView里面的Html页面，过度绘制是检测不到的，也就是说，如果你的Html页面里叠加了100层，那过度绘制检测看起来也是一层。</p>\n<p>我所认为的是：对Android系统来说，WebView是一个单层的View，所以不会涉及到过度绘制，但是对于WebView本身来说，View树过深也是有性能问题的。</p>"},{"title":"Android性能编码规范","date":"2016-03-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 前言\n\n一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。\n\n但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。\n\n<!-- more -->\n\n传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。\n\n本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。\n\n值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。\n\n<br/>\n\n### 编码之初\n\n#### 对于布局内容的数量要求\n\t\t\n单个Activity显示的视图一般情况少于20，层数少于4。\n对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。\n\t\t\n\n**Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单**\n\n#### 将Acitivity 中的Window 的背景图设置为空。\n\ngetWindow().setBackgroundDrawable(null); \n\nandroid的默认背景不为空。\n\n#### 将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\n\nTheme设置属性\n\n\t\t<item name=\"android:windowBackground\">src_image</item>\n\n#### ~~采用硬件加速~~\n\nandroidmanifest.xml中application添加 \n\n\t\tandroid:hardwareAccelerated=\"true\"。\n需要注意的是：android 3.0以上才可以使用。\n\n\n\t\t\n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。\n\t\t\n我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。\n\n<br/><br/>\n\n### 禁止（避免）操作\n\n**核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为**\n\n\n\n\n\n#### 禁止在单例模式中引用Activity的context。使用Application。\n\n如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。\n\n\t\tSingleton instance = Singleton.getInstance(this); // 禁止操作\n\t\t\n是使用 getApplicationContext()  这样就能避免内存泄露。\n\n\t\tSingleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n\t\t\n\n\n#### 禁止使用枚举\n\n枚举将造成大量的内存浪费\n\n\n#### 禁止使用异步回调，\n\n异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。\n\n\n#### 禁止static引用资源耗费过多的实例\n\n例如：context  , Activity\n\t\t\n对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；\n\t\t\n\t\t\n#### ~~禁止内部的Getters/Setters~~\n\n~~对于类的成员我们需要提供Get和Set方法~~\n\n~~但在类内部，应该避免使用Get和Set方法~~\n\t\t\n#### 禁止在非常复杂的布局上使用动画\n\n#### 避免在循环（for、while、listView - getView方法、onDraw）里创建对象\n\n#### 避免在onDraw里创建对象 \n\n对于onDraw中 Paint 我们可以这样优化\n\t\t\n\t\tprivate Paint paint = new Paint();\n\t\t\n\t\tpublic on Draw(){\n\t\t\tpaint.setColor(mBorderColor);\n\t\t}\t\t\n\n#### 避免使用static成员对象\n\nstatic生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)\n\n#### 避免使用浮点数\n\n浮点数会比整型慢两倍\n\n#### 避免Timer.schedule，对于延时操作，可用以下方式代替\n\t\t\n\t\tScheduledExecutorService, \n\t\thandler.postDelayed, \n\t\thandler.postAtTime , \n\t\thandler.sendMessageDelayed ,  \n\t\tView.postDelayed，      \n\t\tAlarmManager\n\n\n#### 避免加载过大图片。压缩或者使用对象池后再使用\n\n\n#### 慎用异常\n\t\t\n原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。\n\n构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。\n\n\t\t\n#### 避免使用递归\n\n\n#### 避免使用轮询\n\n如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。\n\n#### 避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\n\n### 优化操作\n\n\n  <最优替换/>\n  \n#### 当数据量在100以内时，使用ArrayMap代替HashMap\n\n#### 为了避免自动装箱，当数量在1000以下时，使用如下容器\n\t\t\n\t\ta)SparseBoolMap <bool , obj>\n\t\tb)SparseIntMap <int , obj>\n\t\tc)SparseLongMap <long , obj>\n\t\td)LongSparseMap <long ,obj>\n\n#### 字符串拼接用StringBuilder或StringBuffer\n\n\t\t//这种string第一次初始化的情况下，下面得效率更高\n\t\tString str1 = \"abc\"+“def”+\"hij\";\n\t\t//非并发情况 ， StringBuilder效率更优\n\t\tStringBuilder str2 = str3 + str1 + \"builder\" ;\n\t\t//并发情况使用 StringBuffer\n\t\tStringBuffer str2 = str1 + \"buffer\" ;\n  \n#### 文件、网络IO缓存，使用有缓存机制的输入流\n\n\t\tBufferedInputStream替代InputStream\n\t\tBufferedReader替代Reader\n\t\tBufferedReader替代BufferedInputStream. \n \n \n#### 用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\n\n两个平行数组一定比一个对象数组的效率高。\n但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好\n \n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n#### 在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\n\n因为⼦子类会有⾃自⼰己的属性创建需要更多开销。\n\n#### 在使用Factory或类似Factory模式的情况。\n\n少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。\n\t\t\n\t\tpublic static Credit createCredit(){\n\t\t\treturn new Credit();\n\t\t}\n\t\t\n改写为：\n\t\t\n\t\tprivate static Credit BaseCredit = new Credit();\n\t\tpublic static Credit createCredit(){\n\t\t\treturn (Credit)BaseCredit.clone();\n\t\t}\n\n**你必须要注意的：clone是浅拷贝。**\n \n <优化操作/>\n \n#### 尽量使用局部变量  \n\n#### for循环要求 \n\n禁止在for循环的第二个条件中调用任何方法，应这样做\n\n\t\tint size = array.length;\n\t\tfor(int i = 0; i< size;i++)\n\t\t//替代：\n\t\tfor(int i =0;i < array.length;i++)\n\t\t\n在不需要使用下标的情况下，建议使用for_each循环\n\t\t\n\t\t\n#### 如果没有特殊需求，使用基本数据类型，而非对象类型。\n\n基本类似指：int , double , char等。\n\t\t\n\t\t\n#### 静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\n\n如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。\n\t\t\n\t\t\n#### 对于使用超过两次的对象成员， 将成员缓存到本地。\n\t\t\n反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中\n\n例：多次比较目标时间和当前时间差。\t\t\n\t\t\n#### 当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\n\n\t\tObject ob = new Object();\n\t\tint value;\n\t\tif(i>0)\n\t\t\tvalue = ob.getVlaue();\n\t\t\n\t\t改写为：\n\t\tint value;\n\t\t\n\t\tif(i>0){\n\t\t\tObject ob = new Object();   //用到时加载\n\t\t\tvalue = ob.getVlaue();\n\t\t}\n\n#### 不在使用的变量，手动置为null\n\t\t\n通常对于对象成员如此使用，局部变量不需要\n\t\t\n\t\tthis.object = null；\n\t\t\n\n#### 常量用 static final修饰\t\n\t\n<缓存/> \n\n#### 消息缓存，从handler消息池中取预存的Message\n\n\t\thandler.sendMessage(handler.obtainMessage(0, object)); \n   \n#### 尽量使用对象池机制\n\n对象池机制可以有效避免内存抖动提升性能\n\t\t\n优化：我们可以对对象进行预加载，有效提高程序首次运行速度\n\t\t\n警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系\n\n#### 使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\n\t\t\n通常，我们可以通过 objcet = null ; 来去掉对象的引用。\n\t\t\n\n\n#### 禁止将View添加到没有清除机制的容器里\n\n\t\t如：WeakHashMap，没有清除机制，易引起内存溢出\n\n<图片/>\n\n#### 对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\n\n\t\titmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\n\t\tscaledSrcBmp.getHeight(),Config.ARGB_8888);\n\t\t\n- ARGB_8888\t\t32Bit\t\t\n\n\t(这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)\n\t\n- RGB_565\t\t16Bit\t\n\n\t(对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的 \n从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)\n\t\n- ARGB_4444\t\t16Bit\t\t\n\n\t(这种格式的图片，看起来质量太差，已经不推荐使用)\n\t\n- ALPHA_8\t\t8Bit  \t\t\n\n\t(此时图片只有alpha值，没有RGB值， )\n\t\n\t\t\n\t\t\t\n\t\t\n#### 对于图片缩放，提供一下几种方式和其各自优缺点。\n\n\t\t/* \n\t\t *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n\t\t*/\n\t\tcreateScaleBitmap(inBmp , 64 , 128);\n\t\t/*\n\t\t *2.\t inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n\t\t*/\n\t\tmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \n\t\tmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n\n  \n\n#### Bitmap使用结束后，recycle（）释放内存\n\n\t\tBitmap.recycle();\n\n#### 相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\n\nBitmap提供了对图片更多的操作。\n同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。\n\n<布局/>\n\n#### 慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\n\n#### 避免多个线性布局嵌套，使用相对布局减少层级\n\n#### 对于TextView和ImageView组成的Layout，直接使用TextView替换\n\n\t\t<TextView\n    \t\tandroid:id=\"@+id/nameText\"\n    \t\tandroid:layout_width=\"wrap_content\"\n    \t\tandroid:layout_height=\"wrap_content\"\n    \t\tandroid:text=\"暴打小女孩\"\n    \t\tandroid:layout_marginBottom=\"center\"\n    \t\tandroid:gravity=\"center\"\n  \t \t\tandroid:drawableTop=\"@drawable/icon\"/>  //将图片置于上方  \n  \t\n  \t \t\t\n#### 默认不会显示的布局使用 viewstub 标签\n\n**但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE**\n\n\t\t<ViewStub\n\t\t\tandroid:id=\"@+id/network_error_layout\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\"\n\t\t\tandroid:layout=\"@layout/network_error\" />\n\t\t\t\n\t\t//非显示的转换ViewStub 获取\n\t\tView viewStub = findViewById(R.id.network_error_layout);\n\t\tviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\n\t\tnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局    \t\t\n#### 对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\n\n\t\tclass test{\n\t\t\tprivate View view = null;\n\t\t\tpublic void getView(){\n\t\t\t\tview = findViewById(R.id.network_error_layout);\n\t\t\t}\n\t\t\tpubli void showView(){\n\t\t\t\tview.setVisiblity(View.VIWIBLE);\n\t\t\t}\n\t\t}\n\t\t\n#### 对于重复出现超过2-3次的子布局，用 include 实现复用。\n\t\t\n\t\t<include layout=\"@layout/foot.xml\" />\n\n#### 当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\n\n要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少\n\n\t\t<merge xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\" >\n\t\t\t<Button\n\t\t\t\tandroid:id=\"@+id/button\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_above=\"@+id/text\"/>\n\t\t\t<TextView\n\t\t\t\tandroid:id=\"@+id/text\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_alignParentBottom=\"true\"\n\t\t\t\tandroid:text=\"@string/app_name\" />\n\t\t</merge>\n\n\n\n\n\n<br/><br/>\n\n### 性能优化策略\n\n- 减少过渡绘制，可以极大提高动画效率\n- 使用简单的动画效果，如：位置移动，慎用改变内容的动画效率\n\n\t\t动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n\t\t（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\t\t\n\t\t不改变内容，DsiplayList不会重建，提高动画效率\n\n- 捆绑非及时的网络请求，统一执行。\n- 网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。\n- 回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输\n\n### 性能优化心得\n\n<br/>\n\n在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。\n\n其实这是一个不那么准确的误区。\n\n手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）\n\n那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。\n\n世上没有免费得午餐，对象创建后总是要回收的---GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。\n\n所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。\n\n\n\n<br/><br/>\n### 参考资料\n<br/>\n\n[Android性能优化典范（一)](http://www.cnblogs.com/hanyonglu/p/4244035.html)\n\n[Android性能优化典范（二)](http://hukai.me/android-performance-patterns-season-2/)\n\n[Android性能优化典范（三)](http://hukai.me/android-performance-patterns-season-3/)\n\n\n\n<br/><br/>\n\n\n\n### 相关知识详述   \n\n#### 为什么将背景设置在主题可以减少加载时间？\n回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？\n\t\t\nResterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。\n\t\t\nCPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。\n\t\t\n然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。\n\t\t\n在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。\n\n\n\n#### 为什么禁止onDraw创建对象？\n\n首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。\n\t\t\n如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n\n\n#### 为什么要尽量使用局部变量？\n\nAndroid系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，\n\t\t\n同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。\n\n\n![image](http://images.cnitblog.com/blog/56846/201501/231407350162907.png)\n\n\n\n\n\n\n\n\n\n\t\t\n","source":"_posts/AndroidCoding-performance-specification.md","raw":"---\ntitle: Android性能编码规范\ndate: 2016-03-17 16:20:58\nauthor : 暴打小女孩\n\ntags: 性能优化\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 前言\n\n一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。\n\n但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。\n\n<!-- more -->\n\n传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。\n\n本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。\n\n值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。\n\n<br/>\n\n### 编码之初\n\n#### 对于布局内容的数量要求\n\t\t\n单个Activity显示的视图一般情况少于20，层数少于4。\n对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。\n\t\t\n\n**Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单**\n\n#### 将Acitivity 中的Window 的背景图设置为空。\n\ngetWindow().setBackgroundDrawable(null); \n\nandroid的默认背景不为空。\n\n#### 将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\n\nTheme设置属性\n\n\t\t<item name=\"android:windowBackground\">src_image</item>\n\n#### ~~采用硬件加速~~\n\nandroidmanifest.xml中application添加 \n\n\t\tandroid:hardwareAccelerated=\"true\"。\n需要注意的是：android 3.0以上才可以使用。\n\n\n\t\t\n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。\n\t\t\n我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。\n\n<br/><br/>\n\n### 禁止（避免）操作\n\n**核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为**\n\n\n\n\n\n#### 禁止在单例模式中引用Activity的context。使用Application。\n\n如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。\n\n\t\tSingleton instance = Singleton.getInstance(this); // 禁止操作\n\t\t\n是使用 getApplicationContext()  这样就能避免内存泄露。\n\n\t\tSingleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n\t\t\n\n\n#### 禁止使用枚举\n\n枚举将造成大量的内存浪费\n\n\n#### 禁止使用异步回调，\n\n异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。\n\n\n#### 禁止static引用资源耗费过多的实例\n\n例如：context  , Activity\n\t\t\n对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；\n\t\t\n\t\t\n#### ~~禁止内部的Getters/Setters~~\n\n~~对于类的成员我们需要提供Get和Set方法~~\n\n~~但在类内部，应该避免使用Get和Set方法~~\n\t\t\n#### 禁止在非常复杂的布局上使用动画\n\n#### 避免在循环（for、while、listView - getView方法、onDraw）里创建对象\n\n#### 避免在onDraw里创建对象 \n\n对于onDraw中 Paint 我们可以这样优化\n\t\t\n\t\tprivate Paint paint = new Paint();\n\t\t\n\t\tpublic on Draw(){\n\t\t\tpaint.setColor(mBorderColor);\n\t\t}\t\t\n\n#### 避免使用static成员对象\n\nstatic生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)\n\n#### 避免使用浮点数\n\n浮点数会比整型慢两倍\n\n#### 避免Timer.schedule，对于延时操作，可用以下方式代替\n\t\t\n\t\tScheduledExecutorService, \n\t\thandler.postDelayed, \n\t\thandler.postAtTime , \n\t\thandler.sendMessageDelayed ,  \n\t\tView.postDelayed，      \n\t\tAlarmManager\n\n\n#### 避免加载过大图片。压缩或者使用对象池后再使用\n\n\n#### 慎用异常\n\t\t\n原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。\n\n构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。\n\n\t\t\n#### 避免使用递归\n\n\n#### 避免使用轮询\n\n如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。\n\n#### 避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\n\n### 优化操作\n\n\n  <最优替换/>\n  \n#### 当数据量在100以内时，使用ArrayMap代替HashMap\n\n#### 为了避免自动装箱，当数量在1000以下时，使用如下容器\n\t\t\n\t\ta)SparseBoolMap <bool , obj>\n\t\tb)SparseIntMap <int , obj>\n\t\tc)SparseLongMap <long , obj>\n\t\td)LongSparseMap <long ,obj>\n\n#### 字符串拼接用StringBuilder或StringBuffer\n\n\t\t//这种string第一次初始化的情况下，下面得效率更高\n\t\tString str1 = \"abc\"+“def”+\"hij\";\n\t\t//非并发情况 ， StringBuilder效率更优\n\t\tStringBuilder str2 = str3 + str1 + \"builder\" ;\n\t\t//并发情况使用 StringBuffer\n\t\tStringBuffer str2 = str1 + \"buffer\" ;\n  \n#### 文件、网络IO缓存，使用有缓存机制的输入流\n\n\t\tBufferedInputStream替代InputStream\n\t\tBufferedReader替代Reader\n\t\tBufferedReader替代BufferedInputStream. \n \n \n#### 用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\n\n两个平行数组一定比一个对象数组的效率高。\n但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好\n \n#### 考虑使用Webp代替传统png图片。\n\npng虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。\n\n#### 在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\n\n因为⼦子类会有⾃自⼰己的属性创建需要更多开销。\n\n#### 在使用Factory或类似Factory模式的情况。\n\n少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。\n\t\t\n\t\tpublic static Credit createCredit(){\n\t\t\treturn new Credit();\n\t\t}\n\t\t\n改写为：\n\t\t\n\t\tprivate static Credit BaseCredit = new Credit();\n\t\tpublic static Credit createCredit(){\n\t\t\treturn (Credit)BaseCredit.clone();\n\t\t}\n\n**你必须要注意的：clone是浅拷贝。**\n \n <优化操作/>\n \n#### 尽量使用局部变量  \n\n#### for循环要求 \n\n禁止在for循环的第二个条件中调用任何方法，应这样做\n\n\t\tint size = array.length;\n\t\tfor(int i = 0; i< size;i++)\n\t\t//替代：\n\t\tfor(int i =0;i < array.length;i++)\n\t\t\n在不需要使用下标的情况下，建议使用for_each循环\n\t\t\n\t\t\n#### 如果没有特殊需求，使用基本数据类型，而非对象类型。\n\n基本类似指：int , double , char等。\n\t\t\n\t\t\n#### 静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\n\n如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。\n\t\t\n\t\t\n#### 对于使用超过两次的对象成员， 将成员缓存到本地。\n\t\t\n反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中\n\n例：多次比较目标时间和当前时间差。\t\t\n\t\t\n#### 当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\n\n\t\tObject ob = new Object();\n\t\tint value;\n\t\tif(i>0)\n\t\t\tvalue = ob.getVlaue();\n\t\t\n\t\t改写为：\n\t\tint value;\n\t\t\n\t\tif(i>0){\n\t\t\tObject ob = new Object();   //用到时加载\n\t\t\tvalue = ob.getVlaue();\n\t\t}\n\n#### 不在使用的变量，手动置为null\n\t\t\n通常对于对象成员如此使用，局部变量不需要\n\t\t\n\t\tthis.object = null；\n\t\t\n\n#### 常量用 static final修饰\t\n\t\n<缓存/> \n\n#### 消息缓存，从handler消息池中取预存的Message\n\n\t\thandler.sendMessage(handler.obtainMessage(0, object)); \n   \n#### 尽量使用对象池机制\n\n对象池机制可以有效避免内存抖动提升性能\n\t\t\n优化：我们可以对对象进行预加载，有效提高程序首次运行速度\n\t\t\n警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系\n\n#### 使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\n\t\t\n通常，我们可以通过 objcet = null ; 来去掉对象的引用。\n\t\t\n\n\n#### 禁止将View添加到没有清除机制的容器里\n\n\t\t如：WeakHashMap，没有清除机制，易引起内存溢出\n\n<图片/>\n\n#### 对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\n\n\t\titmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\n\t\tscaledSrcBmp.getHeight(),Config.ARGB_8888);\n\t\t\n- ARGB_8888\t\t32Bit\t\t\n\n\t(这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)\n\t\n- RGB_565\t\t16Bit\t\n\n\t(对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的 \n从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)\n\t\n- ARGB_4444\t\t16Bit\t\t\n\n\t(这种格式的图片，看起来质量太差，已经不推荐使用)\n\t\n- ALPHA_8\t\t8Bit  \t\t\n\n\t(此时图片只有alpha值，没有RGB值， )\n\t\n\t\t\n\t\t\t\n\t\t\n#### 对于图片缩放，提供一下几种方式和其各自优缺点。\n\n\t\t/* \n\t\t *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n\t\t*/\n\t\tcreateScaleBitmap(inBmp , 64 , 128);\n\t\t/*\n\t\t *2.\t inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n\t\t*/\n\t\tmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \n\t\tmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n\n  \n\n#### Bitmap使用结束后，recycle（）释放内存\n\n\t\tBitmap.recycle();\n\n#### 相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\n\nBitmap提供了对图片更多的操作。\n同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。\n\n<布局/>\n\n#### 慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\n\n#### 避免多个线性布局嵌套，使用相对布局减少层级\n\n#### 对于TextView和ImageView组成的Layout，直接使用TextView替换\n\n\t\t<TextView\n    \t\tandroid:id=\"@+id/nameText\"\n    \t\tandroid:layout_width=\"wrap_content\"\n    \t\tandroid:layout_height=\"wrap_content\"\n    \t\tandroid:text=\"暴打小女孩\"\n    \t\tandroid:layout_marginBottom=\"center\"\n    \t\tandroid:gravity=\"center\"\n  \t \t\tandroid:drawableTop=\"@drawable/icon\"/>  //将图片置于上方  \n  \t\n  \t \t\t\n#### 默认不会显示的布局使用 viewstub 标签\n\n**但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE**\n\n\t\t<ViewStub\n\t\t\tandroid:id=\"@+id/network_error_layout\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\"\n\t\t\tandroid:layout=\"@layout/network_error\" />\n\t\t\t\n\t\t//非显示的转换ViewStub 获取\n\t\tView viewStub = findViewById(R.id.network_error_layout);\n\t\tviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\n\t\tnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局    \t\t\n#### 对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\n\n\t\tclass test{\n\t\t\tprivate View view = null;\n\t\t\tpublic void getView(){\n\t\t\t\tview = findViewById(R.id.network_error_layout);\n\t\t\t}\n\t\t\tpubli void showView(){\n\t\t\t\tview.setVisiblity(View.VIWIBLE);\n\t\t\t}\n\t\t}\n\t\t\n#### 对于重复出现超过2-3次的子布局，用 include 实现复用。\n\t\t\n\t\t<include layout=\"@layout/foot.xml\" />\n\n#### 当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\n\n要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少\n\n\t\t<merge xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"match_parent\" >\n\t\t\t<Button\n\t\t\t\tandroid:id=\"@+id/button\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_above=\"@+id/text\"/>\n\t\t\t<TextView\n\t\t\t\tandroid:id=\"@+id/text\"\n\t\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\t\tandroid:layout_height=\"@dimen/dp_40\"\n\t\t\t\tandroid:layout_alignParentBottom=\"true\"\n\t\t\t\tandroid:text=\"@string/app_name\" />\n\t\t</merge>\n\n\n\n\n\n<br/><br/>\n\n### 性能优化策略\n\n- 减少过渡绘制，可以极大提高动画效率\n- 使用简单的动画效果，如：位置移动，慎用改变内容的动画效率\n\n\t\t动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n\t\t（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\t\t\n\t\t不改变内容，DsiplayList不会重建，提高动画效率\n\n- 捆绑非及时的网络请求，统一执行。\n- 网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。\n- 回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输\n\n### 性能优化心得\n\n<br/>\n\n在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。\n\n其实这是一个不那么准确的误区。\n\n手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）\n\n那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。\n\n世上没有免费得午餐，对象创建后总是要回收的---GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。\n\n所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。\n\n\n\n<br/><br/>\n### 参考资料\n<br/>\n\n[Android性能优化典范（一)](http://www.cnblogs.com/hanyonglu/p/4244035.html)\n\n[Android性能优化典范（二)](http://hukai.me/android-performance-patterns-season-2/)\n\n[Android性能优化典范（三)](http://hukai.me/android-performance-patterns-season-3/)\n\n\n\n<br/><br/>\n\n\n\n### 相关知识详述   \n\n#### 为什么将背景设置在主题可以减少加载时间？\n回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？\n\t\t\nResterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。\n\t\t\nCPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。\n\t\t\n然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。\n\t\t\n在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。\n\n\n\n#### 为什么禁止onDraw创建对象？\n\n首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。\n\t\t\n如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n\n\n#### 为什么要尽量使用局部变量？\n\nAndroid系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，\n\t\t\n同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。\n\n\n![image](http://images.cnitblog.com/blog/56846/201501/231407350162907.png)\n\n\n\n\n\n\n\n\n\n\t\t\n","slug":"AndroidCoding-performance-specification","published":1,"updated":"2017-01-16T05:13:35.000Z","_id":"cixzmux350003q4ch5zg378sh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。</p>\n<p>但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。</p>\n<a id=\"more\"></a>\n<p>传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。</p>\n<p>本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。</p>\n<p>值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。</p>\n<p><br></p>\n<h3 id=\"编码之初\"><a href=\"#编码之初\" class=\"headerlink\" title=\"编码之初\"></a>编码之初</h3><h4 id=\"对于布局内容的数量要求\"><a href=\"#对于布局内容的数量要求\" class=\"headerlink\" title=\"对于布局内容的数量要求\"></a>对于布局内容的数量要求</h4><p>单个Activity显示的视图一般情况少于20，层数少于4。<br>对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。</p>\n<p><strong>Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单</strong></p>\n<h4 id=\"将Acitivity-中的Window-的背景图设置为空。\"><a href=\"#将Acitivity-中的Window-的背景图设置为空。\" class=\"headerlink\" title=\"将Acitivity 中的Window 的背景图设置为空。\"></a>将Acitivity 中的Window 的背景图设置为空。</h4><p>getWindow().setBackgroundDrawable(null); </p>\n<p>android的默认背景不为空。</p>\n<h4 id=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"><a href=\"#将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\" class=\"headerlink\" title=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"></a>将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。</h4><p>Theme设置属性</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;src_image&lt;/item&gt;\n</code></pre><h4 id=\"采用硬件加速\"><a href=\"#采用硬件加速\" class=\"headerlink\" title=\"采用硬件加速\"></a><del>采用硬件加速</del></h4><p>androidmanifest.xml中application添加 </p>\n<pre><code>android:hardwareAccelerated=&quot;true&quot;。\n</code></pre><p>需要注意的是：android 3.0以上才可以使用。</p>\n<h4 id=\"考虑使用Webp代替传统png图片。\"><a href=\"#考虑使用Webp代替传统png图片。\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<p>但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。</p>\n<p>我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。</p>\n<p><br><br></p>\n<h3 id=\"禁止（避免）操作\"><a href=\"#禁止（避免）操作\" class=\"headerlink\" title=\"禁止（避免）操作\"></a>禁止（避免）操作</h3><p><strong>核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为</strong></p>\n<h4 id=\"禁止在单例模式中引用Activity的context。使用Application。\"><a href=\"#禁止在单例模式中引用Activity的context。使用Application。\" class=\"headerlink\" title=\"禁止在单例模式中引用Activity的context。使用Application。\"></a>禁止在单例模式中引用Activity的context。使用Application。</h4><p>如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。</p>\n<pre><code>Singleton instance = Singleton.getInstance(this); // 禁止操作\n</code></pre><p>是使用 getApplicationContext()  这样就能避免内存泄露。</p>\n<pre><code>Singleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n</code></pre><h4 id=\"禁止使用枚举\"><a href=\"#禁止使用枚举\" class=\"headerlink\" title=\"禁止使用枚举\"></a>禁止使用枚举</h4><p>枚举将造成大量的内存浪费</p>\n<h4 id=\"禁止使用异步回调，\"><a href=\"#禁止使用异步回调，\" class=\"headerlink\" title=\"禁止使用异步回调，\"></a>禁止使用异步回调，</h4><p>异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。</p>\n<h4 id=\"禁止static引用资源耗费过多的实例\"><a href=\"#禁止static引用资源耗费过多的实例\" class=\"headerlink\" title=\"禁止static引用资源耗费过多的实例\"></a>禁止static引用资源耗费过多的实例</h4><p>例如：context  , Activity</p>\n<p>对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；</p>\n<h4 id=\"禁止内部的Getters-Setters\"><a href=\"#禁止内部的Getters-Setters\" class=\"headerlink\" title=\"禁止内部的Getters/Setters\"></a><del>禁止内部的Getters/Setters</del></h4><p><del>对于类的成员我们需要提供Get和Set方法</del></p>\n<p><del>但在类内部，应该避免使用Get和Set方法</del></p>\n<h4 id=\"禁止在非常复杂的布局上使用动画\"><a href=\"#禁止在非常复杂的布局上使用动画\" class=\"headerlink\" title=\"禁止在非常复杂的布局上使用动画\"></a>禁止在非常复杂的布局上使用动画</h4><h4 id=\"避免在循环（for、while、listView-getView方法、onDraw）里创建对象\"><a href=\"#避免在循环（for、while、listView-getView方法、onDraw）里创建对象\" class=\"headerlink\" title=\"避免在循环（for、while、listView - getView方法、onDraw）里创建对象\"></a>避免在循环（for、while、listView - getView方法、onDraw）里创建对象</h4><h4 id=\"避免在onDraw里创建对象\"><a href=\"#避免在onDraw里创建对象\" class=\"headerlink\" title=\"避免在onDraw里创建对象\"></a>避免在onDraw里创建对象</h4><p>对于onDraw中 Paint 我们可以这样优化</p>\n<pre><code>private Paint paint = new Paint();\n\npublic on Draw(){\n    paint.setColor(mBorderColor);\n}        \n</code></pre><h4 id=\"避免使用static成员对象\"><a href=\"#避免使用static成员对象\" class=\"headerlink\" title=\"避免使用static成员对象\"></a>避免使用static成员对象</h4><p>static生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)</p>\n<h4 id=\"避免使用浮点数\"><a href=\"#避免使用浮点数\" class=\"headerlink\" title=\"避免使用浮点数\"></a>避免使用浮点数</h4><p>浮点数会比整型慢两倍</p>\n<h4 id=\"避免Timer-schedule，对于延时操作，可用以下方式代替\"><a href=\"#避免Timer-schedule，对于延时操作，可用以下方式代替\" class=\"headerlink\" title=\"避免Timer.schedule，对于延时操作，可用以下方式代替\"></a>避免Timer.schedule，对于延时操作，可用以下方式代替</h4><pre><code>ScheduledExecutorService, \nhandler.postDelayed, \nhandler.postAtTime , \nhandler.sendMessageDelayed ,  \nView.postDelayed，      \nAlarmManager\n</code></pre><h4 id=\"避免加载过大图片。压缩或者使用对象池后再使用\"><a href=\"#避免加载过大图片。压缩或者使用对象池后再使用\" class=\"headerlink\" title=\"避免加载过大图片。压缩或者使用对象池后再使用\"></a>避免加载过大图片。压缩或者使用对象池后再使用</h4><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。</p>\n<p>构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。</p>\n<h4 id=\"避免使用递归\"><a href=\"#避免使用递归\" class=\"headerlink\" title=\"避免使用递归\"></a>避免使用递归</h4><h4 id=\"避免使用轮询\"><a href=\"#避免使用轮询\" class=\"headerlink\" title=\"避免使用轮询\"></a>避免使用轮询</h4><p>如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。</p>\n<h4 id=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\"><a href=\"#避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\" class=\"headerlink\" title=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\"></a>避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask</h4><h3 id=\"优化操作\"><a href=\"#优化操作\" class=\"headerlink\" title=\"优化操作\"></a>优化操作</h3><p>  &lt;最优替换/&gt;</p>\n<h4 id=\"当数据量在100以内时，使用ArrayMap代替HashMap\"><a href=\"#当数据量在100以内时，使用ArrayMap代替HashMap\" class=\"headerlink\" title=\"当数据量在100以内时，使用ArrayMap代替HashMap\"></a>当数据量在100以内时，使用ArrayMap代替HashMap</h4><h4 id=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"><a href=\"#为了避免自动装箱，当数量在1000以下时，使用如下容器\" class=\"headerlink\" title=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"></a>为了避免自动装箱，当数量在1000以下时，使用如下容器</h4><pre><code>a)SparseBoolMap &lt;bool , obj&gt;\nb)SparseIntMap &lt;int , obj&gt;\nc)SparseLongMap &lt;long , obj&gt;\nd)LongSparseMap &lt;long ,obj&gt;\n</code></pre><h4 id=\"字符串拼接用StringBuilder或StringBuffer\"><a href=\"#字符串拼接用StringBuilder或StringBuffer\" class=\"headerlink\" title=\"字符串拼接用StringBuilder或StringBuffer\"></a>字符串拼接用StringBuilder或StringBuffer</h4><pre><code>//这种string第一次初始化的情况下，下面得效率更高\nString str1 = &quot;abc&quot;+“def”+&quot;hij&quot;;\n//非并发情况 ， StringBuilder效率更优\nStringBuilder str2 = str3 + str1 + &quot;builder&quot; ;\n//并发情况使用 StringBuffer\nStringBuffer str2 = str1 + &quot;buffer&quot; ;\n</code></pre><h4 id=\"文件、网络IO缓存，使用有缓存机制的输入流\"><a href=\"#文件、网络IO缓存，使用有缓存机制的输入流\" class=\"headerlink\" title=\"文件、网络IO缓存，使用有缓存机制的输入流\"></a>文件、网络IO缓存，使用有缓存机制的输入流</h4><pre><code>BufferedInputStream替代InputStream\nBufferedReader替代Reader\nBufferedReader替代BufferedInputStream. \n</code></pre><h4 id=\"用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\"><a href=\"#用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\" class=\"headerlink\" title=\"用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\"></a>用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)</h4><p>两个平行数组一定比一个对象数组的效率高。<br>但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好</p>\n<h4 id=\"考虑使用Webp代替传统png图片。-1\"><a href=\"#考虑使用Webp代替传统png图片。-1\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<h4 id=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\"><a href=\"#在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\" class=\"headerlink\" title=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\"></a>在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。</h4><p>因为⼦子类会有⾃自⼰己的属性创建需要更多开销。</p>\n<h4 id=\"在使用Factory或类似Factory模式的情况。\"><a href=\"#在使用Factory或类似Factory模式的情况。\" class=\"headerlink\" title=\"在使用Factory或类似Factory模式的情况。\"></a>在使用Factory或类似Factory模式的情况。</h4><p>少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。</p>\n<pre><code>public static Credit createCredit(){\n    return new Credit();\n}\n</code></pre><p>改写为：</p>\n<pre><code>private static Credit BaseCredit = new Credit();\npublic static Credit createCredit(){\n    return (Credit)BaseCredit.clone();\n}\n</code></pre><p><strong>你必须要注意的：clone是浅拷贝。</strong></p>\n<p> &lt;优化操作/&gt;</p>\n<h4 id=\"尽量使用局部变量\"><a href=\"#尽量使用局部变量\" class=\"headerlink\" title=\"尽量使用局部变量\"></a>尽量使用局部变量</h4><h4 id=\"for循环要求\"><a href=\"#for循环要求\" class=\"headerlink\" title=\"for循环要求\"></a>for循环要求</h4><p>禁止在for循环的第二个条件中调用任何方法，应这样做</p>\n<pre><code>int size = array.length;\nfor(int i = 0; i&lt; size;i++)\n//替代：\nfor(int i =0;i &lt; array.length;i++)\n</code></pre><p>在不需要使用下标的情况下，建议使用for_each循环</p>\n<h4 id=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"><a href=\"#如果没有特殊需求，使用基本数据类型，而非对象类型。\" class=\"headerlink\" title=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"></a>如果没有特殊需求，使用基本数据类型，而非对象类型。</h4><p>基本类似指：int , double , char等。</p>\n<h4 id=\"静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\"><a href=\"#静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\" class=\"headerlink\" title=\"静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\"></a>静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）</h4><p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。</p>\n<h4 id=\"对于使用超过两次的对象成员，-将成员缓存到本地。\"><a href=\"#对于使用超过两次的对象成员，-将成员缓存到本地。\" class=\"headerlink\" title=\"对于使用超过两次的对象成员， 将成员缓存到本地。\"></a>对于使用超过两次的对象成员， 将成员缓存到本地。</h4><p>反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中</p>\n<p>例：多次比较目标时间和当前时间差。        </p>\n<h4 id=\"当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\"><a href=\"#当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\" class=\"headerlink\" title=\"当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\"></a>当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成</h4><pre><code>Object ob = new Object();\nint value;\nif(i&gt;0)\n    value = ob.getVlaue();\n\n改写为：\nint value;\n\nif(i&gt;0){\n    Object ob = new Object();   //用到时加载\n    value = ob.getVlaue();\n}\n</code></pre><h4 id=\"不在使用的变量，手动置为null\"><a href=\"#不在使用的变量，手动置为null\" class=\"headerlink\" title=\"不在使用的变量，手动置为null\"></a>不在使用的变量，手动置为null</h4><p>通常对于对象成员如此使用，局部变量不需要</p>\n<pre><code>this.object = null；\n</code></pre><h4 id=\"常量用-static-final修饰\"><a href=\"#常量用-static-final修饰\" class=\"headerlink\" title=\"常量用 static final修饰\"></a>常量用 static final修饰</h4><p>&lt;缓存/&gt; </p>\n<h4 id=\"消息缓存，从handler消息池中取预存的Message\"><a href=\"#消息缓存，从handler消息池中取预存的Message\" class=\"headerlink\" title=\"消息缓存，从handler消息池中取预存的Message\"></a>消息缓存，从handler消息池中取预存的Message</h4><pre><code>handler.sendMessage(handler.obtainMessage(0, object)); \n</code></pre><h4 id=\"尽量使用对象池机制\"><a href=\"#尽量使用对象池机制\" class=\"headerlink\" title=\"尽量使用对象池机制\"></a>尽量使用对象池机制</h4><p>对象池机制可以有效避免内存抖动提升性能</p>\n<p>优化：我们可以对对象进行预加载，有效提高程序首次运行速度</p>\n<p>警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系</p>\n<h4 id=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"><a href=\"#使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\" class=\"headerlink\" title=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"></a>使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系</h4><p>通常，我们可以通过 objcet = null ; 来去掉对象的引用。</p>\n<h4 id=\"禁止将View添加到没有清除机制的容器里\"><a href=\"#禁止将View添加到没有清除机制的容器里\" class=\"headerlink\" title=\"禁止将View添加到没有清除机制的容器里\"></a>禁止将View添加到没有清除机制的容器里</h4><pre><code>如：WeakHashMap，没有清除机制，易引起内存溢出\n</code></pre><p>&lt;图片/&gt;</p>\n<h4 id=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"><a href=\"#对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\" class=\"headerlink\" title=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"></a>对于不同目的的图片需求（Bitmap），使用不同的图片解码格式</h4><pre><code>itmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\nscaledSrcBmp.getHeight(),Config.ARGB_8888);\n</code></pre><ul>\n<li><p>ARGB_8888        32Bit        </p>\n<p>  (这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)</p>\n</li>\n<li><p>RGB_565        16Bit    </p>\n<p>  (对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的<br>从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)</p>\n</li>\n<li><p>ARGB_4444        16Bit        </p>\n<p>  (这种格式的图片，看起来质量太差，已经不推荐使用)</p>\n</li>\n<li><p>ALPHA_8        8Bit          </p>\n<p>  (此时图片只有alpha值，没有RGB值， )</p>\n</li>\n</ul>\n<h4 id=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"><a href=\"#对于图片缩放，提供一下几种方式和其各自优缺点。\" class=\"headerlink\" title=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"></a>对于图片缩放，提供一下几种方式和其各自优缺点。</h4><pre><code>/* \n *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n*/\ncreateScaleBitmap(inBmp , 64 , 128);\n/*\n *2.     inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n*/\nmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \nmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n</code></pre><h4 id=\"Bitmap使用结束后，recycle（）释放内存\"><a href=\"#Bitmap使用结束后，recycle（）释放内存\" class=\"headerlink\" title=\"Bitmap使用结束后，recycle（）释放内存\"></a>Bitmap使用结束后，recycle（）释放内存</h4><pre><code>Bitmap.recycle();\n</code></pre><h4 id=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"><a href=\"#相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\" class=\"headerlink\" title=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"></a>相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable</h4><p>Bitmap提供了对图片更多的操作。<br>同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。</p>\n<p>&lt;布局/&gt;</p>\n<h4 id=\"慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\"><a href=\"#慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\" class=\"headerlink\" title=\"慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\"></a>慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果</h4><h4 id=\"避免多个线性布局嵌套，使用相对布局减少层级\"><a href=\"#避免多个线性布局嵌套，使用相对布局减少层级\" class=\"headerlink\" title=\"避免多个线性布局嵌套，使用相对布局减少层级\"></a>避免多个线性布局嵌套，使用相对布局减少层级</h4><h4 id=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"><a href=\"#对于TextView和ImageView组成的Layout，直接使用TextView替换\" class=\"headerlink\" title=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"></a>对于TextView和ImageView组成的Layout，直接使用TextView替换</h4><pre><code>&lt;TextView\n    android:id=&quot;@+id/nameText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;暴打小女孩&quot;\n    android:layout_marginBottom=&quot;center&quot;\n    android:gravity=&quot;center&quot;\n       android:drawableTop=&quot;@drawable/icon&quot;/&gt;  //将图片置于上方  \n</code></pre><h4 id=\"默认不会显示的布局使用-viewstub-标签\"><a href=\"#默认不会显示的布局使用-viewstub-标签\" class=\"headerlink\" title=\"默认不会显示的布局使用 viewstub 标签\"></a>默认不会显示的布局使用 viewstub 标签</h4><p><strong>但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE</strong></p>\n<pre><code>&lt;ViewStub\n    android:id=&quot;@+id/network_error_layout&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:layout=&quot;@layout/network_error&quot; /&gt;\n\n//非显示的转换ViewStub 获取\nView viewStub = findViewById(R.id.network_error_layout);\nviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\nnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局            \n</code></pre><h4 id=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"><a href=\"#对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\" class=\"headerlink\" title=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"></a>对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载</h4><pre><code>class test{\n    private View view = null;\n    public void getView(){\n        view = findViewById(R.id.network_error_layout);\n    }\n    publi void showView(){\n        view.setVisiblity(View.VIWIBLE);\n    }\n}\n</code></pre><h4 id=\"对于重复出现超过2-3次的子布局，用-include-实现复用。\"><a href=\"#对于重复出现超过2-3次的子布局，用-include-实现复用。\" class=\"headerlink\" title=\"对于重复出现超过2-3次的子布局，用 include 实现复用。\"></a>对于重复出现超过2-3次的子布局，用 include 实现复用。</h4><pre><code>&lt;include layout=&quot;@layout/foot.xml&quot; /&gt;\n</code></pre><h4 id=\"当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\"><a href=\"#当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\" class=\"headerlink\" title=\"当复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\"></a>当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点</include></h4><p>要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少</p>\n<pre><code>&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot; &gt;\n    &lt;Button\n        android:id=&quot;@+id/button&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_above=&quot;@+id/text&quot;/&gt;\n    &lt;TextView\n        android:id=&quot;@+id/text&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:text=&quot;@string/app_name&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p><br><br></p>\n<h3 id=\"性能优化策略\"><a href=\"#性能优化策略\" class=\"headerlink\" title=\"性能优化策略\"></a>性能优化策略</h3><ul>\n<li>减少过渡绘制，可以极大提高动画效率</li>\n<li><p>使用简单的动画效果，如：位置移动，慎用改变内容的动画效率</p>\n<pre><code>动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\n不改变内容，DsiplayList不会重建，提高动画效率\n</code></pre></li>\n<li><p>捆绑非及时的网络请求，统一执行。</p>\n</li>\n<li>网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。</li>\n<li>回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输</li>\n</ul>\n<h3 id=\"性能优化心得\"><a href=\"#性能优化心得\" class=\"headerlink\" title=\"性能优化心得\"></a>性能优化心得</h3><p><br></p>\n<p>在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。</p>\n<p>其实这是一个不那么准确的误区。</p>\n<p>手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）</p>\n<p>那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。</p>\n<p>世上没有免费得午餐，对象创建后总是要回收的—GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。</p>\n<p>所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。</p>\n<p><br><br></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><br></p>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/p/4244035.html\" target=\"_blank\" rel=\"external\">Android性能优化典范（一)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-2/\" target=\"_blank\" rel=\"external\">Android性能优化典范（二)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-3/\" target=\"_blank\" rel=\"external\">Android性能优化典范（三)</a></p>\n<p><br><br></p>\n<h3 id=\"相关知识详述\"><a href=\"#相关知识详述\" class=\"headerlink\" title=\"相关知识详述\"></a>相关知识详述</h3><h4 id=\"为什么将背景设置在主题可以减少加载时间？\"><a href=\"#为什么将背景设置在主题可以减少加载时间？\" class=\"headerlink\" title=\"为什么将背景设置在主题可以减少加载时间？\"></a>为什么将背景设置在主题可以减少加载时间？</h4><p>回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？</p>\n<p>Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>\n<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>\n<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>\n<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。</p>\n<h4 id=\"为什么禁止onDraw创建对象？\"><a href=\"#为什么禁止onDraw创建对象？\" class=\"headerlink\" title=\"为什么禁止onDraw创建对象？\"></a>为什么禁止onDraw创建对象？</h4><p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>\n<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>\n<h4 id=\"为什么要尽量使用局部变量？\"><a href=\"#为什么要尽量使用局部变量？\" class=\"headerlink\" title=\"为什么要尽量使用局部变量？\"></a>为什么要尽量使用局部变量？</h4><p>Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，</p>\n<p>同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>\n<p><img src=\"http://images.cnitblog.com/blog/56846/201501/231407350162907.png\" alt=\"image\"></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>一个一般事实:只有当发现“严重”的性能问题时，我们才会开始着手进行性能优化，此时虽然可以针对性的解决程序严重性能问题。但在继续优化过程中，面对无数细小的“不良”代码，却又力不从心。相比得到的些微性能改善，庞大的工作量不得不令人放弃。</p>\n<p>但同样不得不承认的是，无数细小的不良代码所累加的性能问题是不可忽视的。面对这样一个问题，也许最佳的解决办法便是从编码之初上着手进行。</p>","more":"<p>传统的编码规范仅只是为了阅读规定了代码的编写格式，无数的性能优化博客则更多的是一种性能优化策略。一个应用的性能更多的是依靠程序员自身积累及习惯。</p>\n<p>本文目的是为了从编码初始硬性的对某些将会影响程序性能的操作进行规范，杜绝使用一定会引起性能问题的代码，以及给出更优的建议代码。</p>\n<p>值得注意的是，为了保证新的编码规范不会引起开发者强烈的反感与束缚，规范中并未涉及过于复杂与细化的编码操作，更多的是一种在原来基础上更优的代码替换。同时避免出现泛泛而谈的理论点，而是具体到固定代码如何做。本文并未对操作进行优先级划分，明确的优先级划分一定程度会引起开发者的惰性心理。每一种优化都很重要，笔者已经做了一定排序，排在前面的是你应该先注意的。</p>\n<p><br/></p>\n<h3 id=\"编码之初\"><a href=\"#编码之初\" class=\"headerlink\" title=\"编码之初\"></a>编码之初</h3><h4 id=\"对于布局内容的数量要求\"><a href=\"#对于布局内容的数量要求\" class=\"headerlink\" title=\"对于布局内容的数量要求\"></a>对于布局内容的数量要求</h4><p>单个Activity显示的视图一般情况少于20，层数少于4。<br>对于Adapter控件，如ListView ，item的布局层数一般情况为2，不得超过3。</p>\n<p><strong>Activity加载中，背景的加载极其耗时，对其进行优化效果明显且工作简单</strong></p>\n<h4 id=\"将Acitivity-中的Window-的背景图设置为空。\"><a href=\"#将Acitivity-中的Window-的背景图设置为空。\" class=\"headerlink\" title=\"将Acitivity 中的Window 的背景图设置为空。\"></a>将Acitivity 中的Window 的背景图设置为空。</h4><p>getWindow().setBackgroundDrawable(null); </p>\n<p>android的默认背景不为空。</p>\n<h4 id=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"><a href=\"#将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\" class=\"headerlink\" title=\"将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。\"></a>将Activity的背景放到Activity的Theme中设置。同时避免fragment和activity背景重复设置。</h4><p>Theme设置属性</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;src_image&lt;/item&gt;\n</code></pre><h4 id=\"采用硬件加速\"><a href=\"#采用硬件加速\" class=\"headerlink\" title=\"采用硬件加速\"></a><del>采用硬件加速</del></h4><p>androidmanifest.xml中application添加 </p>\n<pre><code>android:hardwareAccelerated=&quot;true&quot;。\n</code></pre><p>需要注意的是：android 3.0以上才可以使用。</p>\n<h4 id=\"考虑使用Webp代替传统png图片。\"><a href=\"#考虑使用Webp代替传统png图片。\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<p>但你需要提前知道的是：编译器并不能预览webp格式的图片，所以在预览布局时，并不能显示你的素材。不过手机上是可以正常显示的。</p>\n<p>我的建议：在类似于表情库这样量大，且不需要预览的素材使用webp格式。还有背景这样体积大，但不影响布局预览的素材。</p>\n<p><br/><br/></p>\n<h3 id=\"禁止（避免）操作\"><a href=\"#禁止（避免）操作\" class=\"headerlink\" title=\"禁止（避免）操作\"></a>禁止（避免）操作</h3><p><strong>核心：少的对象创建，意味着少的GC操作。  杜绝引起内存溢出、内存抖动的操作行为</strong></p>\n<h4 id=\"禁止在单例模式中引用Activity的context。使用Application。\"><a href=\"#禁止在单例模式中引用Activity的context。使用Application。\" class=\"headerlink\" title=\"禁止在单例模式中引用Activity的context。使用Application。\"></a>禁止在单例模式中引用Activity的context。使用Application。</h4><p>如果在某个Activity中使用一下代码 就会造成该Activity一直被 Singleton 引用着，不能释放。</p>\n<pre><code>Singleton instance = Singleton.getInstance(this); // 禁止操作\n</code></pre><p>是使用 getApplicationContext()  这样就能避免内存泄露。</p>\n<pre><code>Singleton instance = Singleton.getInstance(getApplicationContext()); //建议操作\n</code></pre><h4 id=\"禁止使用枚举\"><a href=\"#禁止使用枚举\" class=\"headerlink\" title=\"禁止使用枚举\"></a>禁止使用枚举</h4><p>枚举将造成大量的内存浪费</p>\n<h4 id=\"禁止使用异步回调，\"><a href=\"#禁止使用异步回调，\" class=\"headerlink\" title=\"禁止使用异步回调，\"></a>禁止使用异步回调，</h4><p>异步回调被执行的时间不确定,很有可能发生在activity已经被销毁之后,这不仅仅很容易引起crash,还很容易发生内存泄露。</p>\n<h4 id=\"禁止static引用资源耗费过多的实例\"><a href=\"#禁止static引用资源耗费过多的实例\" class=\"headerlink\" title=\"禁止static引用资源耗费过多的实例\"></a>禁止static引用资源耗费过多的实例</h4><p>例如：context  , Activity</p>\n<p>对于某些不得不出现static引用context的情况，在onDestroy()方法中，解除Activity与static的绑定关系,从而去除static对Activity的引用，使Context能够被回收；</p>\n<h4 id=\"禁止内部的Getters-Setters\"><a href=\"#禁止内部的Getters-Setters\" class=\"headerlink\" title=\"禁止内部的Getters/Setters\"></a><del>禁止内部的Getters/Setters</del></h4><p><del>对于类的成员我们需要提供Get和Set方法</del></p>\n<p><del>但在类内部，应该避免使用Get和Set方法</del></p>\n<h4 id=\"禁止在非常复杂的布局上使用动画\"><a href=\"#禁止在非常复杂的布局上使用动画\" class=\"headerlink\" title=\"禁止在非常复杂的布局上使用动画\"></a>禁止在非常复杂的布局上使用动画</h4><h4 id=\"避免在循环（for、while、listView-getView方法、onDraw）里创建对象\"><a href=\"#避免在循环（for、while、listView-getView方法、onDraw）里创建对象\" class=\"headerlink\" title=\"避免在循环（for、while、listView - getView方法、onDraw）里创建对象\"></a>避免在循环（for、while、listView - getView方法、onDraw）里创建对象</h4><h4 id=\"避免在onDraw里创建对象\"><a href=\"#避免在onDraw里创建对象\" class=\"headerlink\" title=\"避免在onDraw里创建对象\"></a>避免在onDraw里创建对象</h4><p>对于onDraw中 Paint 我们可以这样优化</p>\n<pre><code>private Paint paint = new Paint();\n\npublic on Draw(){\n    paint.setColor(mBorderColor);\n}        \n</code></pre><h4 id=\"避免使用static成员对象\"><a href=\"#避免使用static成员对象\" class=\"headerlink\" title=\"避免使用static成员对象\"></a>避免使用static成员对象</h4><p>static生命周期过长，对于需要传递的对象，使用(Intent)和(Handler)</p>\n<h4 id=\"避免使用浮点数\"><a href=\"#避免使用浮点数\" class=\"headerlink\" title=\"避免使用浮点数\"></a>避免使用浮点数</h4><p>浮点数会比整型慢两倍</p>\n<h4 id=\"避免Timer-schedule，对于延时操作，可用以下方式代替\"><a href=\"#避免Timer-schedule，对于延时操作，可用以下方式代替\" class=\"headerlink\" title=\"避免Timer.schedule，对于延时操作，可用以下方式代替\"></a>避免Timer.schedule，对于延时操作，可用以下方式代替</h4><pre><code>ScheduledExecutorService, \nhandler.postDelayed, \nhandler.postAtTime , \nhandler.sendMessageDelayed ,  \nView.postDelayed，      \nAlarmManager\n</code></pre><h4 id=\"避免加载过大图片。压缩或者使用对象池后再使用\"><a href=\"#避免加载过大图片。压缩或者使用对象池后再使用\" class=\"headerlink\" title=\"避免加载过大图片。压缩或者使用对象池后再使用\"></a>避免加载过大图片。压缩或者使用对象池后再使用</h4><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>原因：创建一个异常时,需收集一个栈记录(stack track),用于描述异常是在何处创建的。</p>\n<p>构建这些此栈时需要为运行时栈做一份快照,这一部分开销很大。</p>\n<h4 id=\"避免使用递归\"><a href=\"#避免使用递归\" class=\"headerlink\" title=\"避免使用递归\"></a>避免使用递归</h4><h4 id=\"避免使用轮询\"><a href=\"#避免使用轮询\" class=\"headerlink\" title=\"避免使用轮询\"></a>避免使用轮询</h4><p>如果一定要使用，使用AlarmManager,或将多个轮询整合为一个轮询。并且添加轮询停止逻辑，在不必要的情况下停止轮询。</p>\n<h4 id=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\"><a href=\"#避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler-Thread-AsyncTask\" class=\"headerlink\" title=\"避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask\"></a>避免长周期内部类、匿名内部类长时间持有外部类对象导致相关资源无法释放。如：Handler, Thread , AsyncTask</h4><h3 id=\"优化操作\"><a href=\"#优化操作\" class=\"headerlink\" title=\"优化操作\"></a>优化操作</h3><p>  &lt;最优替换/&gt;</p>\n<h4 id=\"当数据量在100以内时，使用ArrayMap代替HashMap\"><a href=\"#当数据量在100以内时，使用ArrayMap代替HashMap\" class=\"headerlink\" title=\"当数据量在100以内时，使用ArrayMap代替HashMap\"></a>当数据量在100以内时，使用ArrayMap代替HashMap</h4><h4 id=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"><a href=\"#为了避免自动装箱，当数量在1000以下时，使用如下容器\" class=\"headerlink\" title=\"为了避免自动装箱，当数量在1000以下时，使用如下容器\"></a>为了避免自动装箱，当数量在1000以下时，使用如下容器</h4><pre><code>a)SparseBoolMap &lt;bool , obj&gt;\nb)SparseIntMap &lt;int , obj&gt;\nc)SparseLongMap &lt;long , obj&gt;\nd)LongSparseMap &lt;long ,obj&gt;\n</code></pre><h4 id=\"字符串拼接用StringBuilder或StringBuffer\"><a href=\"#字符串拼接用StringBuilder或StringBuffer\" class=\"headerlink\" title=\"字符串拼接用StringBuilder或StringBuffer\"></a>字符串拼接用StringBuilder或StringBuffer</h4><pre><code>//这种string第一次初始化的情况下，下面得效率更高\nString str1 = &quot;abc&quot;+“def”+&quot;hij&quot;;\n//非并发情况 ， StringBuilder效率更优\nStringBuilder str2 = str3 + str1 + &quot;builder&quot; ;\n//并发情况使用 StringBuffer\nStringBuffer str2 = str1 + &quot;buffer&quot; ;\n</code></pre><h4 id=\"文件、网络IO缓存，使用有缓存机制的输入流\"><a href=\"#文件、网络IO缓存，使用有缓存机制的输入流\" class=\"headerlink\" title=\"文件、网络IO缓存，使用有缓存机制的输入流\"></a>文件、网络IO缓存，使用有缓存机制的输入流</h4><pre><code>BufferedInputStream替代InputStream\nBufferedReader替代Reader\nBufferedReader替代BufferedInputStream. \n</code></pre><h4 id=\"用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\"><a href=\"#用两个平行的基本类型数组int-int-，代替一个对象Array-int-int\" class=\"headerlink\" title=\"用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)\"></a>用两个平行的基本类型数组int[] int[]，代替一个对象Array(int , int)</h4><p>两个平行数组一定比一个对象数组的效率高。<br>但是如果是建立一个供第三方调用的API接口，需要牺牲一定效率保证接口友好</p>\n<h4 id=\"考虑使用Webp代替传统png图片。-1\"><a href=\"#考虑使用Webp代替传统png图片。-1\" class=\"headerlink\" title=\"考虑使用Webp代替传统png图片。\"></a>考虑使用Webp代替传统png图片。</h4><p>png虽能提供无损的图片，但相对于JPEG过大。Webp是既保持png优点，又能减少图片大小的新型格式。</p>\n<h4 id=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\"><a href=\"#在使用线程池的情况中，除需要设置优先级的线程使⽤用new-Thread创建外-其余线程创建使用new-Runnable。\" class=\"headerlink\" title=\"在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。\"></a>在使用线程池的情况中，除需要设置优先级的线程使⽤用new Thread创建外,其余线程创建使用new Runnable。</h4><p>因为⼦子类会有⾃自⼰己的属性创建需要更多开销。</p>\n<h4 id=\"在使用Factory或类似Factory模式的情况。\"><a href=\"#在使用Factory或类似Factory模式的情况。\" class=\"headerlink\" title=\"在使用Factory或类似Factory模式的情况。\"></a>在使用Factory或类似Factory模式的情况。</h4><p>少用new关键字创建对象，使用new，构造函数链中得所有构造函数都会被自动调用。</p>\n<pre><code>public static Credit createCredit(){\n    return new Credit();\n}\n</code></pre><p>改写为：</p>\n<pre><code>private static Credit BaseCredit = new Credit();\npublic static Credit createCredit(){\n    return (Credit)BaseCredit.clone();\n}\n</code></pre><p><strong>你必须要注意的：clone是浅拷贝。</strong></p>\n<p> &lt;优化操作/&gt;</p>\n<h4 id=\"尽量使用局部变量\"><a href=\"#尽量使用局部变量\" class=\"headerlink\" title=\"尽量使用局部变量\"></a>尽量使用局部变量</h4><h4 id=\"for循环要求\"><a href=\"#for循环要求\" class=\"headerlink\" title=\"for循环要求\"></a>for循环要求</h4><p>禁止在for循环的第二个条件中调用任何方法，应这样做</p>\n<pre><code>int size = array.length;\nfor(int i = 0; i&lt; size;i++)\n//替代：\nfor(int i =0;i &lt; array.length;i++)\n</code></pre><p>在不需要使用下标的情况下，建议使用for_each循环</p>\n<h4 id=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"><a href=\"#如果没有特殊需求，使用基本数据类型，而非对象类型。\" class=\"headerlink\" title=\"如果没有特殊需求，使用基本数据类型，而非对象类型。\"></a>如果没有特殊需求，使用基本数据类型，而非对象类型。</h4><p>基本类似指：int , double , char等。</p>\n<h4 id=\"静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\"><a href=\"#静态方法代替-虚拟对象执行方法（虚拟对象执行方法new-Object1-tool1-）\" class=\"headerlink\" title=\"静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）\"></a>静态方法代替 虚拟对象执行方法（虚拟对象执行方法new Object1().tool1();）</h4><p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。</p>\n<h4 id=\"对于使用超过两次的对象成员，-将成员缓存到本地。\"><a href=\"#对于使用超过两次的对象成员，-将成员缓存到本地。\" class=\"headerlink\" title=\"对于使用超过两次的对象成员， 将成员缓存到本地。\"></a>对于使用超过两次的对象成员， 将成员缓存到本地。</h4><p>反复使用的变量，保存到本地成为临时变量活成员变量后进行操作。尤其是在循环中</p>\n<p>例：多次比较目标时间和当前时间差。        </p>\n<h4 id=\"当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\"><a href=\"#当new的对象并不是100-一定会被用到时，在使用时创建-有效减少不必要的对象生成\" class=\"headerlink\" title=\"当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成\"></a>当new的对象并不是100%一定会被用到时，在使用时创建,有效减少不必要的对象生成</h4><pre><code>Object ob = new Object();\nint value;\nif(i&gt;0)\n    value = ob.getVlaue();\n\n改写为：\nint value;\n\nif(i&gt;0){\n    Object ob = new Object();   //用到时加载\n    value = ob.getVlaue();\n}\n</code></pre><h4 id=\"不在使用的变量，手动置为null\"><a href=\"#不在使用的变量，手动置为null\" class=\"headerlink\" title=\"不在使用的变量，手动置为null\"></a>不在使用的变量，手动置为null</h4><p>通常对于对象成员如此使用，局部变量不需要</p>\n<pre><code>this.object = null；\n</code></pre><h4 id=\"常量用-static-final修饰\"><a href=\"#常量用-static-final修饰\" class=\"headerlink\" title=\"常量用 static final修饰\"></a>常量用 static final修饰</h4><p>&lt;缓存/&gt; </p>\n<h4 id=\"消息缓存，从handler消息池中取预存的Message\"><a href=\"#消息缓存，从handler消息池中取预存的Message\" class=\"headerlink\" title=\"消息缓存，从handler消息池中取预存的Message\"></a>消息缓存，从handler消息池中取预存的Message</h4><pre><code>handler.sendMessage(handler.obtainMessage(0, object)); \n</code></pre><h4 id=\"尽量使用对象池机制\"><a href=\"#尽量使用对象池机制\" class=\"headerlink\" title=\"尽量使用对象池机制\"></a>尽量使用对象池机制</h4><p>对象池机制可以有效避免内存抖动提升性能</p>\n<p>优化：我们可以对对象进行预加载，有效提高程序首次运行速度</p>\n<p>警告：为避免内存泄露，需要保证所有对象和外部对象没有引用关系</p>\n<h4 id=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"><a href=\"#使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\" class=\"headerlink\" title=\"使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系\"></a>使用对象池时，在使用结束后，需要保证对象池中对象和外部对象没有引用关系</h4><p>通常，我们可以通过 objcet = null ; 来去掉对象的引用。</p>\n<h4 id=\"禁止将View添加到没有清除机制的容器里\"><a href=\"#禁止将View添加到没有清除机制的容器里\" class=\"headerlink\" title=\"禁止将View添加到没有清除机制的容器里\"></a>禁止将View添加到没有清除机制的容器里</h4><pre><code>如：WeakHashMap，没有清除机制，易引起内存溢出\n</code></pre><p>&lt;图片/&gt;</p>\n<h4 id=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"><a href=\"#对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\" class=\"headerlink\" title=\"对于不同目的的图片需求（Bitmap），使用不同的图片解码格式\"></a>对于不同目的的图片需求（Bitmap），使用不同的图片解码格式</h4><pre><code>itmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(),\nscaledSrcBmp.getHeight(),Config.ARGB_8888);\n</code></pre><ul>\n<li><p>ARGB_8888        32Bit        </p>\n<p>  (这是一种高质量的图片格式，电脑上普通采用的格式。它也是Android手机上一个BitMap的)</p>\n</li>\n<li><p>RGB_565        16Bit    </p>\n<p>  (对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销。因此它是一个不错的选择。另外我们通过android.content.res.Resources来取得一个张图片时，它也是以该格式来构建BitMap的<br>从 Android4.0 开始，该选项无效。即使设置为该值，系统任然会采用  ARGB_8888 来构造图片)</p>\n</li>\n<li><p>ARGB_4444        16Bit        </p>\n<p>  (这种格式的图片，看起来质量太差，已经不推荐使用)</p>\n</li>\n<li><p>ALPHA_8        8Bit          </p>\n<p>  (此时图片只有alpha值，没有RGB值， )</p>\n</li>\n</ul>\n<h4 id=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"><a href=\"#对于图片缩放，提供一下几种方式和其各自优缺点。\" class=\"headerlink\" title=\"对于图片缩放，提供一下几种方式和其各自优缺点。\"></a>对于图片缩放，提供一下几种方式和其各自优缺点。</h4><pre><code>/* \n *1.  Android自带缩放API ,使用方便，但需要一次性讲图片读入内存，对于过大图片容易引起内存溢出\n*/\ncreateScaleBitmap(inBmp , 64 , 128);\n/*\n *2.     inSimpleSize可以等比例缩放图片，参数表示 1/n.同时避免把原图加载到内存中  \n*/\nmBitmapOptions.inSimpleSize = 4 ;  //原图 1/4 \nmBitmap = BitmapFactory.decodeFile(fileName,mBitmapOptions);\n</code></pre><h4 id=\"Bitmap使用结束后，recycle（）释放内存\"><a href=\"#Bitmap使用结束后，recycle（）释放内存\" class=\"headerlink\" title=\"Bitmap使用结束后，recycle（）释放内存\"></a>Bitmap使用结束后，recycle（）释放内存</h4><pre><code>Bitmap.recycle();\n</code></pre><h4 id=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"><a href=\"#相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\" class=\"headerlink\" title=\"相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable\"></a>相同图片Bitmap占用内存量要比Drawable大，可以的话尽量使用Drawable</h4><p>Bitmap提供了对图片更多的操作。<br>同时Bitmap可以无条件的任意转为Drawable。但反过来就不行了，并不是任何一个Drawable都可以转为Bitmap,其转换关系类似于子类与父类之间转换，但本质有区别。</p>\n<p>&lt;布局/&gt;</p>\n<h4 id=\"慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\"><a href=\"#慎用layout-weight属性，用相对布局替换线性布局亦可实现相同效果\" class=\"headerlink\" title=\"慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果\"></a>慎用layout_weight属性，用相对布局替换线性布局亦可实现相同效果</h4><h4 id=\"避免多个线性布局嵌套，使用相对布局减少层级\"><a href=\"#避免多个线性布局嵌套，使用相对布局减少层级\" class=\"headerlink\" title=\"避免多个线性布局嵌套，使用相对布局减少层级\"></a>避免多个线性布局嵌套，使用相对布局减少层级</h4><h4 id=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"><a href=\"#对于TextView和ImageView组成的Layout，直接使用TextView替换\" class=\"headerlink\" title=\"对于TextView和ImageView组成的Layout，直接使用TextView替换\"></a>对于TextView和ImageView组成的Layout，直接使用TextView替换</h4><pre><code>&lt;TextView\n    android:id=&quot;@+id/nameText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;暴打小女孩&quot;\n    android:layout_marginBottom=&quot;center&quot;\n    android:gravity=&quot;center&quot;\n       android:drawableTop=&quot;@drawable/icon&quot;/&gt;  //将图片置于上方  \n</code></pre><h4 id=\"默认不会显示的布局使用-viewstub-标签\"><a href=\"#默认不会显示的布局使用-viewstub-标签\" class=\"headerlink\" title=\"默认不会显示的布局使用 viewstub 标签\"></a>默认不会显示的布局使用 viewstub 标签</h4><p><strong>但是并没有发现使用viewstub和GONE在效率上的区别，还是更倾向于使用GONE</strong></p>\n<pre><code>&lt;ViewStub\n    android:id=&quot;@+id/network_error_layout&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:layout=&quot;@layout/network_error&quot; /&gt;\n\n//非显示的转换ViewStub 获取\nView viewStub = findViewById(R.id.network_error_layout);\nviewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换\nnetworkErrorView = findViewById(R.id.network_error_layout); // 获取 展开后的布局            \n</code></pre><h4 id=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"><a href=\"#对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\" class=\"headerlink\" title=\"对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载\"></a>对于两次以上相同的infalte操作，用成员变量代替局部变量，避免重复加载</h4><pre><code>class test{\n    private View view = null;\n    public void getView(){\n        view = findViewById(R.id.network_error_layout);\n    }\n    publi void showView(){\n        view.setVisiblity(View.VIWIBLE);\n    }\n}\n</code></pre><h4 id=\"对于重复出现超过2-3次的子布局，用-include-实现复用。\"><a href=\"#对于重复出现超过2-3次的子布局，用-include-实现复用。\" class=\"headerlink\" title=\"对于重复出现超过2-3次的子布局，用 include 实现复用。\"></a>对于重复出现超过2-3次的子布局，用 include 实现复用。</h4><pre><code>&lt;include layout=&quot;@layout/foot.xml&quot; /&gt;\n</code></pre><h4 id=\"当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\"><a href=\"#当复用的布局中子View对所依赖的根节点要求不高时，使用-merge-作为根节点\" class=\"headerlink\" title=\"当复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点\"></a>当<include>复用的布局中子View对所依赖的根节点要求不高时，使用 merge 作为根节点</h4><p>要求不高标准：非复杂结构布局，无Background,padding等属性，且子View数量较少</p>\n<pre><code>&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot; &gt;\n    &lt;Button\n        android:id=&quot;@+id/button&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_above=&quot;@+id/text&quot;/&gt;\n    &lt;TextView\n        android:id=&quot;@+id/text&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/dp_40&quot;\n        android:layout_alignParentBottom=&quot;true&quot;\n        android:text=&quot;@string/app_name&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p><br/><br/></p>\n<h3 id=\"性能优化策略\"><a href=\"#性能优化策略\" class=\"headerlink\" title=\"性能优化策略\"></a>性能优化策略</h3><ul>\n<li>减少过渡绘制，可以极大提高动画效率</li>\n<li><p>使用简单的动画效果，如：位置移动，慎用改变内容的动画效率</p>\n<pre><code>动画的绘制过程：创建DisplayList → 渲染DisplayList → 更新到屏幕。\n（DisplayList:DisplayList帮助完成把XML布局文件转换成GPU能识别并绘制的对象）\n\n不改变内容，DsiplayList不会重建，提高动画效率\n</code></pre></li>\n<li><p>捆绑非及时的网络请求，统一执行。</p>\n</li>\n<li>网络数据的预取：预先判断此次请求后，后续零散请求是否很有可能马上被触发，对此类数据进行预取。</li>\n<li>回退机制：对于轮询式的网络请求，服务器端判断此次请求和上次请求数据是否发生变化，负责不传输</li>\n</ul>\n<h3 id=\"性能优化心得\"><a href=\"#性能优化心得\" class=\"headerlink\" title=\"性能优化心得\"></a>性能优化心得</h3><p><br/></p>\n<p>在Android系统 ，一个大多数人存在的误区：手机变卡 = 内存不足。所以才依靠第三方的软件不停的清理手机内存。依照这个惯性心理，我们在做性能优化过程中，优化的方向变成了尽量少的使用内存资源。</p>\n<p>其实这是一个不那么准确的误区。</p>\n<p>手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机依然卡）</p>\n<p>那么如何优化CPU呢？其实还是在内存上做，但重点不一样了，我们不能因为怕占内存而把所有数据存到本地存储（有点极端了，只是举一个例子），用一次取一次，这是极其耗时的。内存我们是一定要用的，数据存于内存，CPU读取快，应用运行便流畅。避免大量占用内存的原因不是怕内存满载，而是要避免 GC 。</p>\n<p>世上没有免费得午餐，对象创建后总是要回收的—GC。那么GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到用户体验。</p>\n<p>所以，如何让CPU的使用率更高，不做无用功。如何更高效的利用内存，避免大量的GC，就是需要我们优化的地方了。</p>\n<p><br/><br/></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><br/></p>\n<p><a href=\"http://www.cnblogs.com/hanyonglu/p/4244035.html\">Android性能优化典范（一)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-2/\">Android性能优化典范（二)</a></p>\n<p><a href=\"http://hukai.me/android-performance-patterns-season-3/\">Android性能优化典范（三)</a></p>\n<p><br/><br/></p>\n<h3 id=\"相关知识详述\"><a href=\"#相关知识详述\" class=\"headerlink\" title=\"相关知识详述\"></a>相关知识详述</h3><h4 id=\"为什么将背景设置在主题可以减少加载时间？\"><a href=\"#为什么将背景设置在主题可以减少加载时间？\" class=\"headerlink\" title=\"为什么将背景设置在主题可以减少加载时间？\"></a>为什么将背景设置在主题可以减少加载时间？</h4><p>回答这个问题，我们先要知道 activity的画面是如何绘制到屏幕上的？</p>\n<p>Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>\n<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>\n<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>\n<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。</p>\n<h4 id=\"为什么禁止onDraw创建对象？\"><a href=\"#为什么禁止onDraw创建对象？\" class=\"headerlink\" title=\"为什么禁止onDraw创建对象？\"></a>为什么禁止onDraw创建对象？</h4><p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>\n<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>\n<h4 id=\"为什么要尽量使用局部变量？\"><a href=\"#为什么要尽量使用局部变量？\" class=\"headerlink\" title=\"为什么要尽量使用局部变量？\"></a>为什么要尽量使用局部变量？</h4><p>Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，</p>\n<p>同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>\n<p><img src=\"http://images.cnitblog.com/blog/56846/201501/231407350162907.png\" alt=\"image\"></p>"},{"title":"Android GC机制实践调研","date":"2016-02-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~\n\n网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：\n\n- System.gc(),真的是随叫随到？\n- 软引用弱引用的错误使用\n- 你觉得内存释放了，它就真的释放了么?\n\n\n幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。\n\n<!-- more -->\n\n***测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。***\n\n### 概要\n\n本次测试从以下几个方面对Android GC 进行调研\n\n- 主动调用System.gc()，不同状态的GC时机\n- 空白Activity所占内存大小及GC时机\n- 大内存量的Activity的GC时机\n- 奔溃临界值下，对象置NULL，是否还会引起内存溢出\n- 内存抖动\n- 软引用、弱引用的使用\n\n**本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛**\n\n\n### 主动调用GC下的GC时机\n\n<img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width = \"250\" height = \"150\" alt=\"红米-初始内存值\" align=center />\n\n（红米初始内存值）\n\n\n#### 测试1：创建临时变量，通过主动调用System.gc()观察\n\n<img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width = \"250\" height = \"200\" alt=\"创建临时变量\" align=center />\n\n可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，**内存增加量是远大于图片大小的**。\n\n\t\t//并没有进行显示，仅是创建一个图片\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n2分钟后内存一直维持在这个水平，**临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方**\n\n<img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width = \"250\" height = \"200\" alt=\"主动调用GC\" align=center />\n\n**之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。**\n\n\n#### 测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\n\n<img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width = \"250\" height = \"200\" alt=\"创建类成员变量\" align=center />\n\n\n        this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        \n        //置NULL\n        this.bitmap = null;\n        \n        //GC\n        System.gc();\n        \n\n\n<img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width = \"250\" height = \"200\" alt=\"置NULL后销毁\" align=center />\n\n\n**GC依然没有被触发**\n\n**发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了**\n\n#### 测试3：不停的初始化类成员变量\n\n也就是说不停的调用下面代码\n\n\tthis.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n\n\n\n<img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width = \"500\" height = \"200\" alt=\"多次初始化类成员\" align=center />\n\n\n可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。\n\n**内存占用只有达到一定限度时，GC才会开始执行。**\n\n期间也创建过临时变量，GC也多次调用后全无反应。\n\n\n### 空Activity占用的内存大小及销毁时间\n\n\n<img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width = \"150\" height = \"150\" alt=\"初始\" align=center />\n\n初始值\n\n<img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width = \"150\" height = \"150\" alt=\"初次打开\" align=center />\n\n初次打开\n\n<img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n<img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n\n初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）\n\n**一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右**\n\n迷之增长……\n\n\n### 非空Activity的销毁\n\n\n通过下面代码增加Activity内存占用量\n\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n            this.bitmapList.add(bmp);\n        }\n        \n <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \n 之后执行\n \n \t\tSystem.gc();\n        finish();\n        \n  无任何反应。\n  \n  **无论Activity是否占用大量内存，其销毁的时间都是迟钝的。**\n  \n  \n  \n### 濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\n\n经测算，当前测试机在190MB+时，将会内存溢出崩溃。\n\n\n <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\n\n对象置NULL\n\n\tthis.bitmapList = null;\n\n\n再次增加并显示\n\n\tthis.img.setImageResource(R.drawable.big_254);\n\n\n<img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n欣喜的事情发生了，**“类成员置NULL，对防止内存溢出崩溃是有必要的”**\n\n\n\n### 循环内创建（big or small）对象是否会引起内存抖动\n\n\n<img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n        }\n\n创建“小（1MB左右）”对象 \n\n<img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        }\n\n循环内创建“大（10MB左右）”对象会引起严重的内存抖动\n\n\n**无论对象大小，都应避免在循环内创建对象**\n\n\n### 软引用弱引用的错误使用\n\n这个错误似乎很少会有人犯，但感觉还是列出来比较好\n\n\n\t//错误使用\n\tprivate SoftReference<List<Bitmap>> softReference = new SoftReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    private WeakReference<List<Bitmap>> weakReference = new WeakReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    \n    \n    //正确使用\n    private List<SoftReference<Bitmap>> listRefrence = new ArrayList<>();\n\n\n用上述错误使用方式代码的两种情况\n\n\tList<Bitmap> list = softReference.get();\n        if (list == null) {\n            list = new ArrayList<>();\n            softReference = new SoftReference<>(list);\n        }\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list.add(bmp);\n        }\n\n\tList<Bitmap> list = null;\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list = weakReference.get();\n            if (list == null) {\n                list = new ArrayList<>();\n                weakReference = new WeakReference<>(list);\n            }\n            list.add(bmp);\n        }\n        \n      \n\n<img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \t\n内存会一直暴涨到奔溃。软引用弱引用并不会被收回\n\n\t//正确使用\n\tResources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            right.add(new SoftReference<>(bmp));\n        }\n\n\n<img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。**\n\n<img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~**\n\n\n### 结论\n\n\n- 不同系统不同型号的手机的GC机制是不同的\n\t- System.gc()调用结果不同（立即GC或无反应）\n\t- 废弃内存回收频率不同\n\t- 大规模GC临界值不同\n- 对于加载图片来说，内存增加量是远大于图片大小的。\n- 临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。\n- System.gc()并不是立刻执行GC的。\n- 每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的\n- 有时，内存占用只有达到一定限度时，GC才会开始被触发。\n- 一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右\n- 无论Activity是否占用大量内存，其销毁的时间都是迟钝的。\n- 类成员置NULL，对防止内存溢出崩溃是有必要的\n- 无论对象大小，都应避免在循环内创建对象\n- 注意软引用与弱引用的正确使用\n\n\n**最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。**\n\n[Demo代码https://github.com/lizhaoxuan/Android-GC-Research](https://github.com/lizhaoxuan/Android-GC-Research)\n\n\n\n\n\n\t\n","source":"_posts/androidgcdiaoyan.md","raw":"---\ntitle: Android GC机制实践调研\ndate: 2016-02-17 16:20:58\nauthor : 暴打小女孩\n\ntags: GC\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~\n\n网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：\n\n- System.gc(),真的是随叫随到？\n- 软引用弱引用的错误使用\n- 你觉得内存释放了，它就真的释放了么?\n\n\n幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。\n\n<!-- more -->\n\n***测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。***\n\n### 概要\n\n本次测试从以下几个方面对Android GC 进行调研\n\n- 主动调用System.gc()，不同状态的GC时机\n- 空白Activity所占内存大小及GC时机\n- 大内存量的Activity的GC时机\n- 奔溃临界值下，对象置NULL，是否还会引起内存溢出\n- 内存抖动\n- 软引用、弱引用的使用\n\n**本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛**\n\n\n### 主动调用GC下的GC时机\n\n<img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width = \"250\" height = \"150\" alt=\"红米-初始内存值\" align=center />\n\n（红米初始内存值）\n\n\n#### 测试1：创建临时变量，通过主动调用System.gc()观察\n\n<img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width = \"250\" height = \"200\" alt=\"创建临时变量\" align=center />\n\n可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，**内存增加量是远大于图片大小的**。\n\n\t\t//并没有进行显示，仅是创建一个图片\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n2分钟后内存一直维持在这个水平，**临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方**\n\n<img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width = \"250\" height = \"200\" alt=\"主动调用GC\" align=center />\n\n**之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。**\n\n\n#### 测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\n\n<img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width = \"250\" height = \"200\" alt=\"创建类成员变量\" align=center />\n\n\n        this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        \n        //置NULL\n        this.bitmap = null;\n        \n        //GC\n        System.gc();\n        \n\n\n<img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width = \"250\" height = \"200\" alt=\"置NULL后销毁\" align=center />\n\n\n**GC依然没有被触发**\n\n**发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了**\n\n#### 测试3：不停的初始化类成员变量\n\n也就是说不停的调用下面代码\n\n\tthis.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n\n\n\n<img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width = \"500\" height = \"200\" alt=\"多次初始化类成员\" align=center />\n\n\n可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。\n\n**内存占用只有达到一定限度时，GC才会开始执行。**\n\n期间也创建过临时变量，GC也多次调用后全无反应。\n\n\n### 空Activity占用的内存大小及销毁时间\n\n\n<img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width = \"150\" height = \"150\" alt=\"初始\" align=center />\n\n初始值\n\n<img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width = \"150\" height = \"150\" alt=\"初次打开\" align=center />\n\n初次打开\n\n<img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n<img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n返回后再次打开\n\n\n初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）\n\n**一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右**\n\n迷之增长……\n\n\n### 非空Activity的销毁\n\n\n通过下面代码增加Activity内存占用量\n\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n            this.bitmapList.add(bmp);\n        }\n        \n <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \n 之后执行\n \n \t\tSystem.gc();\n        finish();\n        \n  无任何反应。\n  \n  **无论Activity是否占用大量内存，其销毁的时间都是迟钝的。**\n  \n  \n  \n### 濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\n\n经测算，当前测试机在190MB+时，将会内存溢出崩溃。\n\n\n <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\n\n对象置NULL\n\n\tthis.bitmapList = null;\n\n\n再次增加并显示\n\n\tthis.img.setImageResource(R.drawable.big_254);\n\n\n<img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n欣喜的事情发生了，**“类成员置NULL，对防止内存溢出崩溃是有必要的”**\n\n\n\n### 循环内创建（big or small）对象是否会引起内存抖动\n\n\n<img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n        }\n\n创建“小（1MB左右）”对象 \n\n<img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n\tfor (int i = 0; i < 20; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n        }\n\n循环内创建“大（10MB左右）”对象会引起严重的内存抖动\n\n\n**无论对象大小，都应避免在循环内创建对象**\n\n\n### 软引用弱引用的错误使用\n\n这个错误似乎很少会有人犯，但感觉还是列出来比较好\n\n\n\t//错误使用\n\tprivate SoftReference<List<Bitmap>> softReference = new SoftReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    private WeakReference<List<Bitmap>> weakReference = new WeakReference<List<Bitmap>>(new ArrayList<Bitmap>());\n    \n    \n    //正确使用\n    private List<SoftReference<Bitmap>> listRefrence = new ArrayList<>();\n\n\n用上述错误使用方式代码的两种情况\n\n\tList<Bitmap> list = softReference.get();\n        if (list == null) {\n            list = new ArrayList<>();\n            softReference = new SoftReference<>(list);\n        }\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list.add(bmp);\n        }\n\n\tList<Bitmap> list = null;\n        Resources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            list = weakReference.get();\n            if (list == null) {\n                list = new ArrayList<>();\n                weakReference = new WeakReference<>(list);\n            }\n            list.add(bmp);\n        }\n        \n      \n\n<img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n \t\n内存会一直暴涨到奔溃。软引用弱引用并不会被收回\n\n\t//正确使用\n\tResources res = getResources();\n        for (int i = 0; i < 10; i++) {\n            Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n            right.add(new SoftReference<>(bmp));\n        }\n\n\n<img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。**\n\n<img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center />\n\n**WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~**\n\n\n### 结论\n\n\n- 不同系统不同型号的手机的GC机制是不同的\n\t- System.gc()调用结果不同（立即GC或无反应）\n\t- 废弃内存回收频率不同\n\t- 大规模GC临界值不同\n- 对于加载图片来说，内存增加量是远大于图片大小的。\n- 临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。\n- System.gc()并不是立刻执行GC的。\n- 每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的\n- 有时，内存占用只有达到一定限度时，GC才会开始被触发。\n- 一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右\n- 无论Activity是否占用大量内存，其销毁的时间都是迟钝的。\n- 类成员置NULL，对防止内存溢出崩溃是有必要的\n- 无论对象大小，都应避免在循环内创建对象\n- 注意软引用与弱引用的正确使用\n\n\n**最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。**\n\n[Demo代码https://github.com/lizhaoxuan/Android-GC-Research](https://github.com/lizhaoxuan/Android-GC-Research)\n\n\n\n\n\n\t\n","slug":"androidgcdiaoyan","published":1,"updated":"2017-01-16T05:13:29.000Z","_id":"cixzmux360004q4chuuaml16z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p>众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~</p>\n<p>网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：</p>\n<ul>\n<li>System.gc(),真的是随叫随到？</li>\n<li>软引用弱引用的错误使用</li>\n<li>你觉得内存释放了，它就真的释放了么?</li>\n</ul>\n<p>幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。</p>\n<a id=\"more\"></a>\n<p><strong><em>测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。</em></strong></p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>本次测试从以下几个方面对Android GC 进行调研</p>\n<ul>\n<li>主动调用System.gc()，不同状态的GC时机</li>\n<li>空白Activity所占内存大小及GC时机</li>\n<li>大内存量的Activity的GC时机</li>\n<li>奔溃临界值下，对象置NULL，是否还会引起内存溢出</li>\n<li>内存抖动</li>\n<li>软引用、弱引用的使用</li>\n</ul>\n<p><strong>本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛</strong></p>\n<h3 id=\"主动调用GC下的GC时机\"><a href=\"#主动调用GC下的GC时机\" class=\"headerlink\" title=\"主动调用GC下的GC时机\"></a>主动调用GC下的GC时机</h3><p><img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width=\"250\" height=\"150\" alt=\"红米-初始内存值\" align=\"center\"></p>\n<p>（红米初始内存值）</p>\n<h4 id=\"测试1：创建临时变量，通过主动调用System-gc-观察\"><a href=\"#测试1：创建临时变量，通过主动调用System-gc-观察\" class=\"headerlink\" title=\"测试1：创建临时变量，通过主动调用System.gc()观察\"></a>测试1：创建临时变量，通过主动调用System.gc()观察</h4><p><img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width=\"250\" height=\"200\" alt=\"创建临时变量\" align=\"center\"></p>\n<p>可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，<strong>内存增加量是远大于图片大小的</strong>。</p>\n<pre><code>//并没有进行显示，仅是创建一个图片\nBitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p>2分钟后内存一直维持在这个水平，<strong>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方</strong></p>\n<p><img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width=\"250\" height=\"200\" alt=\"主动调用GC\" align=\"center\"></p>\n<p><strong>之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。</strong></p>\n<h4 id=\"测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\"><a href=\"#测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\" class=\"headerlink\" title=\"测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\"></a>测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察</h4><p><img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width=\"250\" height=\"200\" alt=\"创建类成员变量\" align=\"center\"></p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n//置NULL\nthis.bitmap = null;\n\n//GC\nSystem.gc();\n</code></pre><p><img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width=\"250\" height=\"200\" alt=\"置NULL后销毁\" align=\"center\"></p>\n<p><strong>GC依然没有被触发</strong></p>\n<p><strong>发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了</strong></p>\n<h4 id=\"测试3：不停的初始化类成员变量\"><a href=\"#测试3：不停的初始化类成员变量\" class=\"headerlink\" title=\"测试3：不停的初始化类成员变量\"></a>测试3：不停的初始化类成员变量</h4><p>也就是说不停的调用下面代码</p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width=\"500\" height=\"200\" alt=\"多次初始化类成员\" align=\"center\"></p>\n<p>可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。</p>\n<p><strong>内存占用只有达到一定限度时，GC才会开始执行。</strong></p>\n<p>期间也创建过临时变量，GC也多次调用后全无反应。</p>\n<h3 id=\"空Activity占用的内存大小及销毁时间\"><a href=\"#空Activity占用的内存大小及销毁时间\" class=\"headerlink\" title=\"空Activity占用的内存大小及销毁时间\"></a>空Activity占用的内存大小及销毁时间</h3><p><img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width=\"150\" height=\"150\" alt=\"初始\" align=\"center\"></p>\n<p>初始值</p>\n<p><img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width=\"150\" height=\"150\" alt=\"初次打开\" align=\"center\"></p>\n<p>初次打开</p>\n<p><img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p><img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>返回后再次打开</p>\n<p>初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）</p>\n<p><strong>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</strong></p>\n<p>迷之增长……</p>\n<h3 id=\"非空Activity的销毁\"><a href=\"#非空Activity的销毁\" class=\"headerlink\" title=\"非空Activity的销毁\"></a>非空Activity的销毁</h3><p>通过下面代码增加Activity内存占用量</p>\n<pre><code>Resources res = getResources();\nfor (int i = 0; i &lt; 10; i++) {\n    Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n    this.bitmapList.add(bmp);\n}\n</code></pre><p> <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width=\"150\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p> 之后执行</p>\n<pre><code> System.gc();\nfinish();\n</code></pre><p>  无任何反应。</p>\n<p>  <strong>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</strong></p>\n<h3 id=\"濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\"><a href=\"#濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\" class=\"headerlink\" title=\"濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\"></a>濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出</h3><p>经测算，当前测试机在190MB+时，将会内存溢出崩溃。</p>\n<p> <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>对象置NULL</p>\n<pre><code>this.bitmapList = null;\n</code></pre><p>再次增加并显示</p>\n<pre><code>this.img.setImageResource(R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>欣喜的事情发生了，<strong>“类成员置NULL，对防止内存溢出崩溃是有必要的”</strong></p>\n<h3 id=\"循环内创建（big-or-small）对象是否会引起内存抖动\"><a href=\"#循环内创建（big-or-small）对象是否会引起内存抖动\" class=\"headerlink\" title=\"循环内创建（big or small）对象是否会引起内存抖动\"></a>循环内创建（big or small）对象是否会引起内存抖动</h3><p><img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n    }\n</code></pre><p>创建“小（1MB左右）”对象 </p>\n<p><img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n    }\n</code></pre><p>循环内创建“大（10MB左右）”对象会引起严重的内存抖动</p>\n<p><strong>无论对象大小，都应避免在循环内创建对象</strong></p>\n<h3 id=\"软引用弱引用的错误使用\"><a href=\"#软引用弱引用的错误使用\" class=\"headerlink\" title=\"软引用弱引用的错误使用\"></a>软引用弱引用的错误使用</h3><p>这个错误似乎很少会有人犯，但感觉还是列出来比较好</p>\n<pre><code>//错误使用\nprivate SoftReference&lt;List&lt;Bitmap&gt;&gt; softReference = new SoftReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\nprivate WeakReference&lt;List&lt;Bitmap&gt;&gt; weakReference = new WeakReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\n\n\n//正确使用\nprivate List&lt;SoftReference&lt;Bitmap&gt;&gt; listRefrence = new ArrayList&lt;&gt;();\n</code></pre><p>用上述错误使用方式代码的两种情况</p>\n<pre><code>List&lt;Bitmap&gt; list = softReference.get();\n    if (list == null) {\n        list = new ArrayList&lt;&gt;();\n        softReference = new SoftReference&lt;&gt;(list);\n    }\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list.add(bmp);\n    }\n\nList&lt;Bitmap&gt; list = null;\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list = weakReference.get();\n        if (list == null) {\n            list = new ArrayList&lt;&gt;();\n            weakReference = new WeakReference&lt;&gt;(list);\n        }\n        list.add(bmp);\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p>内存会一直暴涨到奔溃。软引用弱引用并不会被收回</p>\n<pre><code>//正确使用\nResources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        right.add(new SoftReference&lt;&gt;(bmp));\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。</strong></p>\n<p><img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width=\"250\" height=\"150\" alt=\"返回后再次打开\" align=\"center\"></p>\n<p><strong>WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>不同系统不同型号的手机的GC机制是不同的<ul>\n<li>System.gc()调用结果不同（立即GC或无反应）</li>\n<li>废弃内存回收频率不同</li>\n<li>大规模GC临界值不同</li>\n</ul>\n</li>\n<li>对于加载图片来说，内存增加量是远大于图片大小的。</li>\n<li>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。</li>\n<li>System.gc()并不是立刻执行GC的。</li>\n<li>每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的</li>\n<li>有时，内存占用只有达到一定限度时，GC才会开始被触发。</li>\n<li>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</li>\n<li>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</li>\n<li>类成员置NULL，对防止内存溢出崩溃是有必要的</li>\n<li>无论对象大小，都应避免在循环内创建对象</li>\n<li>注意软引用与弱引用的正确使用</li>\n</ul>\n<p><strong>最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-GC-Research\" target=\"_blank\" rel=\"external\">Demo代码https://github.com/lizhaoxuan/Android-GC-Research</a></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p>众所周知，java GC 是影响Android应用性能的主要因素之一。完全交给系统管理的GC往往不尽如人意，而开发者却也毫无办法，只能对着GC迎合啊迎合，想着办法把GC哄开心了呗~</p>\n<p>网上也不乏众多的android 内存优化文章，成为开发者的编码守则。但不管怎么遵守，内存管理依然像一个黑盒子一样，反正我是写着不踏实。就比如下面这几种情况：</p>\n<ul>\n<li>System.gc(),真的是随叫随到？</li>\n<li>软引用弱引用的错误使用</li>\n<li>你觉得内存释放了，它就真的释放了么?</li>\n</ul>\n<p>幸得Android Monitor 提供了内存监视器，起码打开了一个窗口可以让我们看看当前应用的内存到底是什么样的。 那么现在我们就来通过一个小Demo，看看android 的GC到底是怎么样吧。</p>","more":"<p><strong><em>测试过程中，很悲痛的验证了不同设备不同系统的GC机制是不一样的，我把它粗糙的区分为灵敏型和不灵敏性，所以，我们开发中还是小心小心再小心吧……例如：某些机型System.gc()会被立刻触发，有些机型毫无响应。</em></strong></p>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>本次测试从以下几个方面对Android GC 进行调研</p>\n<ul>\n<li>主动调用System.gc()，不同状态的GC时机</li>\n<li>空白Activity所占内存大小及GC时机</li>\n<li>大内存量的Activity的GC时机</li>\n<li>奔溃临界值下，对象置NULL，是否还会引起内存溢出</li>\n<li>内存抖动</li>\n<li>软引用、弱引用的使用</li>\n</ul>\n<p><strong>本次测试采用两款手机：红米3 .低端机型，手机内存值较低，测试环境更加严苛</strong></p>\n<h3 id=\"主动调用GC下的GC时机\"><a href=\"#主动调用GC下的GC时机\" class=\"headerlink\" title=\"主动调用GC下的GC时机\"></a>主动调用GC下的GC时机</h3><p><img src=\"http://img2.ph.126.net/K7Q7D5OLxL2nqgtP9ItXtw==/6631554849350641553.png\" width = \"250\" height = \"150\" alt=\"红米-初始内存值\" align=center /></p>\n<p>（红米初始内存值）</p>\n<h4 id=\"测试1：创建临时变量，通过主动调用System-gc-观察\"><a href=\"#测试1：创建临时变量，通过主动调用System-gc-观察\" class=\"headerlink\" title=\"测试1：创建临时变量，通过主动调用System.gc()观察\"></a>测试1：创建临时变量，通过主动调用System.gc()观察</h4><p><img src=\"http://img2.ph.126.net/TslV5cRuca6OkzBQ1aE_kQ==/6631772552652944693.png\" width = \"250\" height = \"200\" alt=\"创建临时变量\" align=center /></p>\n<p>可以看到内存立刻增加了十几MB，这里我创建了一个Bitmap加载了一张比较大的图片117.16KB，<strong>内存增加量是远大于图片大小的</strong>。</p>\n<pre><code>//并没有进行显示，仅是创建一个图片\nBitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p>2分钟后内存一直维持在这个水平，<strong>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方</strong></p>\n<p><img src=\"http://img2.ph.126.net/d5cIKUN7owo1Lx_AbIIy9Q==/6631652705885517209.png\" width = \"250\" height = \"200\" alt=\"主动调用GC\" align=center /></p>\n<p><strong>之后我们多次调用System.gc()，内存监视窗口是没有任何反应的。</strong></p>\n<h4 id=\"测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\"><a href=\"#测试2：初始化类成员变量，置NULL后，主动调用System-gc-观察\" class=\"headerlink\" title=\"测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察\"></a>测试2：初始化类成员变量，置NULL后，主动调用System.gc()观察</h4><p><img src=\"http://img0.ph.126.net/mPTcmWGbUrUlvpgyDy9oyw==/6631601028839009163.png\" width = \"250\" height = \"200\" alt=\"创建类成员变量\" align=center /></p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n\n//置NULL\nthis.bitmap = null;\n\n//GC\nSystem.gc();\n</code></pre><p><img src=\"http://img1.ph.126.net/zE33pF2ch1sPmvU6Z48kNQ==/6631804438490152210.png\" width = \"250\" height = \"200\" alt=\"置NULL后销毁\" align=center /></p>\n<p><strong>GC依然没有被触发</strong></p>\n<p><strong>发现更有意思的问题，每点击一次按钮，内存消耗增加0.02MB,世界上果然没有免费的午餐，点击事件又有新的对象产生了</strong></p>\n<h4 id=\"测试3：不停的初始化类成员变量\"><a href=\"#测试3：不停的初始化类成员变量\" class=\"headerlink\" title=\"测试3：不停的初始化类成员变量\"></a>测试3：不停的初始化类成员变量</h4><p>也就是说不停的调用下面代码</p>\n<pre><code>this.bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/iV9aVKjF_j4tIFtN02g34A==/6631763756559918878.jpg\" width = \"500\" height = \"200\" alt=\"多次初始化类成员\" align=center /></p>\n<p>可以看到一串有趣的现象，似乎只有在内存值在41.78以上时，GC才会被触发。</p>\n<p><strong>内存占用只有达到一定限度时，GC才会开始执行。</strong></p>\n<p>期间也创建过临时变量，GC也多次调用后全无反应。</p>\n<h3 id=\"空Activity占用的内存大小及销毁时间\"><a href=\"#空Activity占用的内存大小及销毁时间\" class=\"headerlink\" title=\"空Activity占用的内存大小及销毁时间\"></a>空Activity占用的内存大小及销毁时间</h3><p><img src=\"http://img2.ph.126.net/yjZGCVaIhaEz83K8xb9LvQ==/6631495475722745750.png\" width = \"150\" height = \"150\" alt=\"初始\" align=center /></p>\n<p>初始值</p>\n<p><img src=\"http://img1.ph.126.net/zmrZbtadOQbmyN4n6OLwuQ==/6631804438490152216.png\" width = \"150\" height = \"150\" alt=\"初次打开\" align=center /></p>\n<p>初次打开</p>\n<p><img src=\"http://img2.ph.126.net/bCzvPTK4Suj_HnUIgE0UFw==/6631653805397144960.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p>返回后再次打开</p>\n<p><img src=\"http://img0.ph.126.net/ntkgGBiAHQBFYOHJ8HnQVQ==/6631822030676193801.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p>返回后再次打开</p>\n<p>初始（9.00MB）~ 初次打开（9.40MB）~ 返回后再次打开（9.55MB）~ 返回后再次打开（9.69MB）</p>\n<p><strong>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</strong></p>\n<p>迷之增长……</p>\n<h3 id=\"非空Activity的销毁\"><a href=\"#非空Activity的销毁\" class=\"headerlink\" title=\"非空Activity的销毁\"></a>非空Activity的销毁</h3><p>通过下面代码增加Activity内存占用量</p>\n<pre><code>Resources res = getResources();\nfor (int i = 0; i &lt; 10; i++) {\n    Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.test_100);\n    this.bitmapList.add(bmp);\n}\n</code></pre><p> <img src=\"http://img2.ph.126.net/DDuC2UhymeHruBwxoCwemg==/6631728572187818831.png\" width = \"150\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p> 之后执行</p>\n<pre><code> System.gc();\nfinish();\n</code></pre><p>  无任何反应。</p>\n<p>  <strong>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</strong></p>\n<h3 id=\"濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\"><a href=\"#濒临临界值情况下，对象-NULL，再次消耗内存是否会溢出\" class=\"headerlink\" title=\"濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出\"></a>濒临临界值情况下，对象=NULL，再次消耗内存是否会溢出</h3><p>经测算，当前测试机在190MB+时，将会内存溢出崩溃。</p>\n<p> <img src=\"http://img2.ph.126.net/UdnKhp9rjfY4M8PxO1Dnhw==/6631709880490161458.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p>对象置NULL</p>\n<pre><code>this.bitmapList = null;\n</code></pre><p>再次增加并显示</p>\n<pre><code>this.img.setImageResource(R.drawable.big_254);\n</code></pre><p><img src=\"http://img2.ph.126.net/sOz4fddKuIWH_1dnJnLCtg==/6631763756559918881.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p>欣喜的事情发生了，<strong>“类成员置NULL，对防止内存溢出崩溃是有必要的”</strong></p>\n<h3 id=\"循环内创建（big-or-small）对象是否会引起内存抖动\"><a href=\"#循环内创建（big-or-small）对象是否会引起内存抖动\" class=\"headerlink\" title=\"循环内创建（big or small）对象是否会引起内存抖动\"></a>循环内创建（big or small）对象是否会引起内存抖动</h3><p><img src=\"http://img1.ph.126.net/_Q1HJ5I0geb4eyHoloph6g==/6631698885373879888.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.test_100);\n    }\n</code></pre><p>创建“小（1MB左右）”对象 </p>\n<p><img src=\"http://img2.ph.126.net/1UmCr_BsgGyA0Ljk7Eihvg==/6631630715652961007.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<pre><code>for (int i = 0; i &lt; 20; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(getResources(), R.drawable.big_254);\n    }\n</code></pre><p>循环内创建“大（10MB左右）”对象会引起严重的内存抖动</p>\n<p><strong>无论对象大小，都应避免在循环内创建对象</strong></p>\n<h3 id=\"软引用弱引用的错误使用\"><a href=\"#软引用弱引用的错误使用\" class=\"headerlink\" title=\"软引用弱引用的错误使用\"></a>软引用弱引用的错误使用</h3><p>这个错误似乎很少会有人犯，但感觉还是列出来比较好</p>\n<pre><code>//错误使用\nprivate SoftReference&lt;List&lt;Bitmap&gt;&gt; softReference = new SoftReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\nprivate WeakReference&lt;List&lt;Bitmap&gt;&gt; weakReference = new WeakReference&lt;List&lt;Bitmap&gt;&gt;(new ArrayList&lt;Bitmap&gt;());\n\n\n//正确使用\nprivate List&lt;SoftReference&lt;Bitmap&gt;&gt; listRefrence = new ArrayList&lt;&gt;();\n</code></pre><p>用上述错误使用方式代码的两种情况</p>\n<pre><code>List&lt;Bitmap&gt; list = softReference.get();\n    if (list == null) {\n        list = new ArrayList&lt;&gt;();\n        softReference = new SoftReference&lt;&gt;(list);\n    }\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list.add(bmp);\n    }\n\nList&lt;Bitmap&gt; list = null;\n    Resources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        list = weakReference.get();\n        if (list == null) {\n            list = new ArrayList&lt;&gt;();\n            weakReference = new WeakReference&lt;&gt;(list);\n        }\n        list.add(bmp);\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/F2UDo2Wffl2iep4aog04Hg==/6631718676583178933.png\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p>内存会一直暴涨到奔溃。软引用弱引用并不会被收回</p>\n<pre><code>//正确使用\nResources res = getResources();\n    for (int i = 0; i &lt; 10; i++) {\n        Bitmap bmp = BitmapFactory.decodeResource(res, R.drawable.big_254);\n        right.add(new SoftReference&lt;&gt;(bmp));\n    }\n</code></pre><p><img src=\"http://img2.ph.126.net/o96gsLvjTz9Xdl2Z5nca3g==/6631764856071546647.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p><strong>SoftReference 可以看到明显的内存抖动，但是内存不会暴涨。</strong></p>\n<p><img src=\"http://img0.ph.126.net/sCccZcFlApzYMD_wylzafA==/6631718676583178928.jpg\" width = \"250\" height = \"150\" alt=\"返回后再次打开\" align=center /></p>\n<p><strong>WeakReference 和 SoftReference 不同的是，牙更深一点，销毁平率更大，验证了弱引用比软引用更容易被销毁~</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>不同系统不同型号的手机的GC机制是不同的<ul>\n<li>System.gc()调用结果不同（立即GC或无反应）</li>\n<li>废弃内存回收频率不同</li>\n<li>大规模GC临界值不同</li>\n</ul>\n</li>\n<li>对于加载图片来说，内存增加量是远大于图片大小的。</li>\n<li>临时变量的GC时机是完全不能保证的，我们可以理解为，GC线程还没有转到这个地方。</li>\n<li>System.gc()并不是立刻执行GC的。</li>\n<li>每点击一次按钮，内存消耗增加0.02MB,世界上没有免费的午餐，点击事件内部是会有新的对象产生的</li>\n<li>有时，内存占用只有达到一定限度时，GC才会开始被触发。</li>\n<li>一个空白Activity的内存占用量是0.4MB,返回后再次进入每次增加0.15MB左右，返回键每次增加0~0.01MB左右</li>\n<li>无论Activity是否占用大量内存，其销毁的时间都是迟钝的。</li>\n<li>类成员置NULL，对防止内存溢出崩溃是有必要的</li>\n<li>无论对象大小，都应避免在循环内创建对象</li>\n<li>注意软引用与弱引用的正确使用</li>\n</ul>\n<p><strong>最后告诫一点：尽量不要在应用中调用System.gc(); 如果调用了System.gc()可能会为系统性能带来严重的波动，即便调用System.gc()系统也未必立即响应去执行垃圾回收。</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-GC-Research\">Demo代码https://github.com/lizhaoxuan/Android-GC-Research</a></p>"},{"title":"Android编译时注解框架4-爬坑","date":"2016-07-17T07:30:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。\n\n这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）\n\n随时踩坑，随时更新~\n\n<!-- more -->\n\n\n### 坑1：无法引入javax包下的类库\n\n编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。\n\n![](http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg)\n\n\n#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。\n\n----------------\n\n### 坑2：Build通过，编译失败\n\n报错信息： **finished with non-zero exit value 2**\n\n\tError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\t> com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2\n\n\n![](http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg)\n\n\t\n这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。\n\n开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑3：只能成功运行一次，修改代码后再运行就报错\n\n报错内容同 **坑2** 相同。\n\napp Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n\n错误提示：\n\n\t错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑5：成功运行，没有任何报错，但也没有任何预期结果。\n\n这是比较容易忽视的两个问题。\n\n#####Check 1:检查是否添加了配置文件：*javax.annotation.processing.Processor*\n\n（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）\n\n#####Check 2:检查是否重写了*getSupportedAnnotationTypes*方法：*javax.annotation.processing.Processor*\n\n重写该方法告诉*Processor*它需要处理哪些注解。\n\t\n----------------\n\t\n### 坑6：替换APT jar包后，apt代码并没有被执行。\n\n#####解决： 尝试 clean项目 ，并重新编译。\n\t\n----------------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n《Android编译时注解框架-爬坑》\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\t\n\t\n\t\n\t\n\t","source":"_posts/apt-Climbed-out-of-the-pit.md","raw":"---\ntitle: Android编译时注解框架4-爬坑\ndate: 2016-07-17 15:30:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。\n\n这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）\n\n随时踩坑，随时更新~\n\n<!-- more -->\n\n\n### 坑1：无法引入javax包下的类库\n\n编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。\n\n![](http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg)\n\n\n#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。\n\n----------------\n\n### 坑2：Build通过，编译失败\n\n报错信息： **finished with non-zero exit value 2**\n\n\tError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\t> com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command '/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java'' finished with non-zero exit value 2\n\n\n![](http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg)\n\n\t\n这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。\n\n开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑3：只能成功运行一次，修改代码后再运行就报错\n\n报错内容同 **坑2** 相同。\n\napp Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n\n错误提示：\n\n\t错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n\n#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。\n\n----------------\n\n### 坑5：成功运行，没有任何报错，但也没有任何预期结果。\n\n这是比较容易忽视的两个问题。\n\n#####Check 1:检查是否添加了配置文件：*javax.annotation.processing.Processor*\n\n（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）\n\n#####Check 2:检查是否重写了*getSupportedAnnotationTypes*方法：*javax.annotation.processing.Processor*\n\n重写该方法告诉*Processor*它需要处理哪些注解。\n\t\n----------------\n\t\n### 坑6：替换APT jar包后，apt代码并没有被执行。\n\n#####解决： 尝试 clean项目 ，并重新编译。\n\t\n----------------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n《Android编译时注解框架-爬坑》\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\t\n\t\n\t\n\t\n\t","slug":"apt-Climbed-out-of-the-pit","published":1,"updated":"2017-01-16T05:13:19.000Z","_id":"cixzmux380006q4chllhwxoyo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。</p>\n<p>这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）</p>\n<p>随时踩坑，随时更新~</p>\n<a id=\"more\"></a>\n<h3 id=\"坑1：无法引入javax包下的类库\"><a href=\"#坑1：无法引入javax包下的类库\" class=\"headerlink\" title=\"坑1：无法引入javax包下的类库\"></a>坑1：无法引入javax包下的类库</h3><p>编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。</p>\n<p><img src=\"http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg\" alt=\"\"></p>\n<p>#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。</p>\n<hr>\n<h3 id=\"坑2：Build通过，编译失败\"><a href=\"#坑2：Build通过，编译失败\" class=\"headerlink\" title=\"坑2：Build通过，编译失败\"></a>坑2：Build通过，编译失败</h3><p>报错信息： <strong>finished with non-zero exit value 2</strong></p>\n<pre><code>Error:Execution failed for task &apos;:app:transformClassesWithDexForDebug&apos;.\n&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java&apos;&apos; finished with non-zero exit value 2\n</code></pre><p><img src=\"http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg\" alt=\"\"></p>\n<p>这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。</p>\n<p>开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑3：只能成功运行一次，修改代码后再运行就报错\"><a href=\"#坑3：只能成功运行一次，修改代码后再运行就报错\" class=\"headerlink\" title=\"坑3：只能成功运行一次，修改代码后再运行就报错\"></a>坑3：只能成功运行一次，修改代码后再运行就报错</h3><p>报错内容同 <strong>坑2</strong> 相同。</p>\n<p>app Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\"><a href=\"#坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\" class=\"headerlink\" title=\"坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\"></a>坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误</h3><p>错误提示：</p>\n<pre><code>错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n</code></pre><p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"><a href=\"#坑5：成功运行，没有任何报错，但也没有任何预期结果。\" class=\"headerlink\" title=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"></a>坑5：成功运行，没有任何报错，但也没有任何预期结果。</h3><p>这是比较容易忽视的两个问题。</p>\n<p>#####Check 1:检查是否添加了配置文件：<em>javax.annotation.processing.Processor</em></p>\n<p>（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）</p>\n<p>#####Check 2:检查是否重写了<em>getSupportedAnnotationTypes</em>方法：<em>javax.annotation.processing.Processor</em></p>\n<p>重写该方法告诉<em>Processor</em>它需要处理哪些注解。</p>\n<hr>\n<h3 id=\"坑6：替换APT-jar包后，apt代码并没有被执行。\"><a href=\"#坑6：替换APT-jar包后，apt代码并没有被执行。\" class=\"headerlink\" title=\"坑6：替换APT jar包后，apt代码并没有被执行。\"></a>坑6：替换APT jar包后，apt代码并没有被执行。</h3><p>#####解决： 尝试 clean项目 ，并重新编译。</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p>《Android编译时注解框架-爬坑》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为有关APT的资料过少，又因为是Java Moudle +Android Moudle的使用方式，在项目编写过程中，会有一些匪夷所思的奇怪问题~入门阶段真的是步履维艰。</p>\n<p>这篇博客就是编写《Android编译时注解框架》系列中，将所遇到的一些坑列举出来，并给出一些绕过坑的方法。（注意哦~是绕过，坑还在，没有填~因为不知道这坑咋来的……）</p>\n<p>随时踩坑，随时更新~</p>","more":"<h3 id=\"坑1：无法引入javax包下的类库\"><a href=\"#坑1：无法引入javax包下的类库\" class=\"headerlink\" title=\"坑1：无法引入javax包下的类库\"></a>坑1：无法引入javax包下的类库</h3><p>编写编译时注解框架时，需要用到javax包下的一些类库，但是引入包时却提示没有。</p>\n<p><img src=\"http://img1.ph.126.net/31LiF8uDczvrBRXGdUS3sA==/6631518565466913139.jpeg\" alt=\"\"></p>\n<p>#####解决：javax包属于java,Android核心库中没有。所以不能直接在app Module和Android Library中使用，必须要创建一个Java Library。然后由Java Library导出jar包使用。</p>\n<hr>\n<h3 id=\"坑2：Build通过，编译失败\"><a href=\"#坑2：Build通过，编译失败\" class=\"headerlink\" title=\"坑2：Build通过，编译失败\"></a>坑2：Build通过，编译失败</h3><p>报错信息： <strong>finished with non-zero exit value 2</strong></p>\n<pre><code>Error:Execution failed for task &apos;:app:transformClassesWithDexForDebug&apos;.\n&gt; com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/bin/java&apos;&apos; finished with non-zero exit value 2\n</code></pre><p><img src=\"http://img0.ph.126.net/wKyp9tTXrwzlx7JyoMhu-g==/6631819831652925888.jpg\" alt=\"\"></p>\n<p>这个问题引起了很大程度的误解，因为是看错误信息是jdk的错误，关注点一直放到了jdk版本上。</p>\n<p>开始换了jdk版本为1.8。成功运行了一次，但是之后修改代码又报错了。</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑3：只能成功运行一次，修改代码后再运行就报错\"><a href=\"#坑3：只能成功运行一次，修改代码后再运行就报错\" class=\"headerlink\" title=\"坑3：只能成功运行一次，修改代码后再运行就报错\"></a>坑3：只能成功运行一次，修改代码后再运行就报错</h3><p>报错内容同 <strong>坑2</strong> 相同。</p>\n<p>app Moudle直接引用 apt Module 可以成功运行一次，但再次修改apt Module代码后，运行就会报错，代码再修改回来，就又可以运行了。（就好像一次性项目一样……）</p>\n<p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\"><a href=\"#坑4：错误-javax-annotation-processing-Processor-Error-reading-configuration-file时抛出异常错误\" class=\"headerlink\" title=\"坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\"></a>坑4：错误: javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误</h3><p>错误提示：</p>\n<pre><code>错误: 服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Error reading configuration file时抛出异常错误\n</code></pre><p>#####解决： app Moudle不能直接引用 apt Module（编写注解处理代码的Module），需要apt Module导出jar包，app Moudle引入jar包才可以。</p>\n<hr>\n<h3 id=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"><a href=\"#坑5：成功运行，没有任何报错，但也没有任何预期结果。\" class=\"headerlink\" title=\"坑5：成功运行，没有任何报错，但也没有任何预期结果。\"></a>坑5：成功运行，没有任何报错，但也没有任何预期结果。</h3><p>这是比较容易忽视的两个问题。</p>\n<p>#####Check 1:检查是否添加了配置文件：<em>javax.annotation.processing.Processor</em></p>\n<p>（添加方式请看 前一篇 《Android编译时注解框架-Run Demo》）</p>\n<p>#####Check 2:检查是否重写了<em>getSupportedAnnotationTypes</em>方法：<em>javax.annotation.processing.Processor</em></p>\n<p>重写该方法告诉<em>Processor</em>它需要处理哪些注解。</p>\n<hr>\n<h3 id=\"坑6：替换APT-jar包后，apt代码并没有被执行。\"><a href=\"#坑6：替换APT-jar包后，apt代码并没有被执行。\" class=\"headerlink\" title=\"坑6：替换APT jar包后，apt代码并没有被执行。\"></a>坑6：替换APT jar包后，apt代码并没有被执行。</h3><p>#####解决： 尝试 clean项目 ，并重新编译。</p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p>《Android编译时注解框架-爬坑》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架5-语法讲解","date":"2016-07-17T07:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……\n\n这里对猜对的结果进行一个总结，让后来者可以更快的上手。\n\n<!-- more -->\n\n第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。\n\n\n\n### 自定义注解相关\n\n定义注解格式：   public @interface 注解名 {定义体}\n\nAnnotation里面的参数该设定: \n\n第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　\n\n第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1,name = \"asd\")\n\tclass Test{\n\t}\n\t\n如果只有一个参数，建议设置为value\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Println {\n\t    int value();\n\t}\n\t\n\t//使用\n\t@Println(1)\n\tclass Test{\n\t}\n\t\n参数为value时，可以直接写入参数,使用时不在需要key=value写法。\n但当有多个参数时，不可以再使用value。\n\n\t\n#### @Retention\n\n这个在第一章有讲。申明该注解属于什么类型注解\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）\n\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t运行时注解，一般在运行时通过反射去识别的注解。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t编译时注解，在编译时处理。\n\t\n#### @Target(ElementType.TYPE)\n\n表示该注解用来修饰哪些元素。并可以修饰多个\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\n\tpublic @interface GetMsg {\n\t    int id();\n\t    String name() default \"default\";\n\t}\n\n例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。\n\n\t@GetMsg(1)\n    public void printError(){\n        //TODO ~\n    }\n    \n    @GetMsg(1)  //编译器会报错\n    class Test{\n     \t//TODO ~\n    }\n    \n- @Target(ElementType.TYPE)\n\n\t接口、类、枚举、注解\n\t\n- @Target(ElementType.FIELD) \n\n\t字段、枚举的常量\n\t\n- @Target(ElementType.METHOD) \n\n\t方法\n\t\n- @Target(ElementType.PARAMETER)\n\t\n\t方法参数 \n\t\n- @Target(ElementType.CONSTRUCTOR) \n\n\t构造函数 \n\n- @Target(ElementType.LOCAL_VARIABLE)\n\n\t局部变量 \n\n- @Target(ElementType.ANNOTATION_TYPE)\n\n\t注解 \n\t\n- @Target(ElementType.package) \n\n\t包 \n\t\n\t\n#### @Inherited\n\n该注解的字面意识是继承，但你要知道**注解是不可以继承的**。\n\n@Inherited是在继承结构中使用的注解。\n\n如果你的注解是这样定义的：\n\n\t@Inherited\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Test {\n\t\t//...\n\t}\n\n当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。\n\n*这里感谢 豪哥 @刘志豪 的排疑解惑~*\n\n#### 注解的默认值\n\n注解可以设置默认值，有默认值的参数可以不写。\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1) //name有默认值可以不写\n\tclass Test{\n\t}\n\n\n#### “注解的继承”（依赖倒置？）\n\n这里讲的继承并不是通过@Inherited修饰的注解。\n\n这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。\n\n先看代码。\n\n\t@Target(METHOD)\n\t@Retention(CLASS)\n\t@ListenerClass(\n\t    targetType = \"android.view.View\",\n    \tsetter = \"setOnClickListener\",\n    \ttype = \"butterknife.internal.DebouncingOnClickListener\",\n    \tmethod = @ListenerMethod(\n        \tname = \"doClick\",\n        \tparameters = \"android.view.View\"\n    \t)\n\t)\n\tpublic @interface OnClick {\n  \t\t/** View IDs to which the method will be bound. */\n  \t\tint[] value() default { View.NO_ID };\n\t}\n\t\n\n这是ButterKnife的OnClick 注解。特殊的地方在于**@OnClick修饰了注解@ListenerClass**，并且设置了一些只属于@OnClick的属性。\n\n那这样的作用是什么呢？\n\n凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。\n\n这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。\n\n\n### 处理器类Processor编写\n\n自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。\n\nAbstractProcessor有两个重要的方法需要重写。\n\n![](http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg)\n\n\n#### 重写getSupportedAnnotationTypes方法：\n\n通过重写该方法，告知Processor哪些注解需要处理。\n\n返回一个Set集合，集合内容为自定义注解的包名+类名。\n\n建议项目中这样编写：\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        //需要全类名\n        types.add(GetMsg.class.getCanonicalName()); \n        types.add(Println.class.getCanonicalName());\n        return types;\n    }\n    \n另外如果注解数量很少的话，可以通过另一种方式实现：\n\n\t//在只有一到两个注解需要处理时，可以这样编写：\n\t@SupportedAnnotationTypes(\"com.example.annotation.SetContentView\")\n\t@SupportedSourceVersion(SourceVersion.RELEASE_7)\n\tpublic class ContentViewProcessor extends AbstractProcessor {\n\t\n\t}\n\t\n#### 重写process方法：\n\n所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        \n        \n        return false;\n    }\n\n先简单解释下这个方法的参数和返回值。\n\n**参数** *Set<? extends TypeElement> annotations* ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）\n**参数** *RoundEnvironment roundEnv* ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。\n\n例：\t\t\n\n\tfor (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n\t\t//所有被使用的@GetMsg\n\t}\n\n**返回值** 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理\n\n### 输出Log\n\n虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。\n\n**Processor日志输出的位置在编译器下方的Messages窗口中。**\n\nProcessor支持最基础的System.out方法。\n\n同样Processor也有自己的Log输出工具: Messager。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n    \t\n    \t//取得Messager对象\n        Messager messager = processingEnv.getMessager();\n        \n        //输出日志\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + element.getSimpleName().toString());\n        }\n\n同Log类似，Messager也有日志级别的选择。\n\n- Diagnostic.Kind.ERROR \n- Diagnostic.Kind.WARNING \n- Diagnostic.Kind.MANDATORY_WARNING \n- Diagnostic.Kind.NOTE \n- Diagnostic.Kind.OTHER \n\n他们的输出样式如图：\n\n\n\n\n![](http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg)\n\n![](http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg)\n\n**注意：当没有属于该Process处理的注解被使用时，process不会执行。**\n\n**注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。**\n\n这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？\n\n### 用生成的代码来生成代码\n\nAPT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？\n\n同样可以被扫描到，并且用于代码生成。其过程如下：\n\nAPT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。\n\n同样你肯定也会发现一个问题，这不很容易会变成死循环吗？\n\n**没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！**\n\n\n### Element\n\nElement也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。\n\nElement的官方注释：\n\nRepresents a program element such as a package, class, or method.\nEach element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).\n\n表示一个程序元素，比如包、类或者方法。\n\n例如：取得所有修饰了@OnceClick的元素。\n\t\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\t//OnceClick.class是@Target(METHOD)\n\t\t//则该element是可以强转为表示方法的ExecutableElement\n\t\tExecutableElement method = （ExecutableElement）element;\n\t\t//如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n\t\t//但有例外情况，我们稍后列举\n\t\tTypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n\t}\n\nElement的子类有：\n\n- ExecutableElement\n\t\n\t表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\t\n\t对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)\n\n- PackageElement;\n\n\t表示一个包程序元素。提供对有关包极其成员的信息访问。\n\t\n\t对应@Target(ElementType.PACKAGE)\n\n- TypeElement;\n\n\t表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。\n\t\n\t对应@Target(ElementType.TYPE)\n\t\n\t**注意：枚举类型是一种类，而注解类型是一种接口。**\n\n- TypeParameterElement;\n\n\t表示一般类、接口、方法或构造方法元素的类型参数。\n\t\n\t对应@Target(ElementType.PARAMETER)\n\n- VariableElement;\n\n\t表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。\n\t\n\t对应@Target(ElementType.LOCAL_VARIABLE)\n\t\n例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：\n\nElement 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\tExecutableElement method = (ExecutableElement)element;\n\t}\n\n\n接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。\n\n### 修饰方法的注解和ExecutableElement\n\n当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。\n\n如何获取：\n\n\t//OnceClick.class 以 @Target(ElementType.METHOD)修饰\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n\t\t//对于Element直接强转\n        ExecutableElement executableElement = (ExecutableElement) element;\n        \n        //非对应的Element，通过getEnclosingElement转换获取\n        TypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n                    \n        //当(ExecutableElement) element成立时，使用(PackageElement) element\n        //            .getEnclosingElement();将报错。\n        //需要使用elementUtils来获取\n        Elements elementUtils = processingEnv.getElementUtils();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\t\t\n\t\t//全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //方法名\n        String methodName = executableElement.getSimpleName().toString();\n\n\t\t//取得方法参数列表\n\t\tList<? extends VariableElement> methodParameters = executableElement.getParameters();\n\t\t//参数类型列表\n\t\tList<String> types = new ArrayList<>();\n        for (VariableElement variableElement : methodParameters) {\n            TypeMirror methodParameterType = variableElement.asType();\n            if (methodParameterType instanceof TypeVariable) {\n                TypeVariable typeVariable = (TypeVariable) methodParameterType;\n                methodParameterType = typeVariable.getUpperBound();\n                \n            }\n            //参数名\n            String parameterName = variableElement.getSimpleName().toString();\n            //参数类型\n            String parameteKind = methodParameterType.toString();\n            types.add(methodParameterType.toString());\n        }\n\t}\n\n\n### 修饰属性、类成员的注解和VariableElement\n\n\n当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名\n\n如何获取：\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n\t\t//ElementType.FIELD注解可以直接强转VariableElement\n\t\tVariableElement variableElement = (VariableElement) element;\n\t\t\n        TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //类成员名\n        String variableName = variableElement.getSimpleName().toString();\n        \n        //类成员类型\n        TypeMirror typeMirror = variableElement.asType();\n        String type = typeMirror.toString();\n        \n\t}\n\t\n\t\n### 修饰类的注解和TypeElement\n\n\n当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。\n\n如何获取：\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n\t\t//ElementType.TYPE注解可以直接强转TypeElement\n        TypeElement classElement = (TypeElement) element;\n        \n        PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n                    \n        //全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n \t\t//父类名\n \t\tString superClassName = classElement.getSuperclass().toString();\n        \n\t}\n\t\n\t\n<br/>\n\n-------------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n《Android编译时注解框架-语法讲解》\n\n\n\t\n","source":"_posts/apt-Grammar-explanation.md","raw":"---\ntitle: Android编译时注解框架5-语法讲解\ndate: 2016-07-17 15:20:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……\n\n这里对猜对的结果进行一个总结，让后来者可以更快的上手。\n\n<!-- more -->\n\n第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。\n\n\n\n### 自定义注解相关\n\n定义注解格式：   public @interface 注解名 {定义体}\n\nAnnotation里面的参数该设定: \n\n第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　\n\n第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1,name = \"asd\")\n\tclass Test{\n\t}\n\t\n如果只有一个参数，建议设置为value\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Println {\n\t    int value();\n\t}\n\t\n\t//使用\n\t@Println(1)\n\tclass Test{\n\t}\n\t\n参数为value时，可以直接写入参数,使用时不在需要key=value写法。\n但当有多个参数时，不可以再使用value。\n\n\t\n#### @Retention\n\n这个在第一章有讲。申明该注解属于什么类型注解\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）\n\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t运行时注解，一般在运行时通过反射去识别的注解。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t编译时注解，在编译时处理。\n\t\n#### @Target(ElementType.TYPE)\n\n表示该注解用来修饰哪些元素。并可以修饰多个\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\n\tpublic @interface GetMsg {\n\t    int id();\n\t    String name() default \"default\";\n\t}\n\n例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。\n\n\t@GetMsg(1)\n    public void printError(){\n        //TODO ~\n    }\n    \n    @GetMsg(1)  //编译器会报错\n    class Test{\n     \t//TODO ~\n    }\n    \n- @Target(ElementType.TYPE)\n\n\t接口、类、枚举、注解\n\t\n- @Target(ElementType.FIELD) \n\n\t字段、枚举的常量\n\t\n- @Target(ElementType.METHOD) \n\n\t方法\n\t\n- @Target(ElementType.PARAMETER)\n\t\n\t方法参数 \n\t\n- @Target(ElementType.CONSTRUCTOR) \n\n\t构造函数 \n\n- @Target(ElementType.LOCAL_VARIABLE)\n\n\t局部变量 \n\n- @Target(ElementType.ANNOTATION_TYPE)\n\n\t注解 \n\t\n- @Target(ElementType.package) \n\n\t包 \n\t\n\t\n#### @Inherited\n\n该注解的字面意识是继承，但你要知道**注解是不可以继承的**。\n\n@Inherited是在继承结构中使用的注解。\n\n如果你的注解是这样定义的：\n\n\t@Inherited\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface Test {\n\t\t//...\n\t}\n\n当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。\n\n*这里感谢 豪哥 @刘志豪 的排疑解惑~*\n\n#### 注解的默认值\n\n注解可以设置默认值，有默认值的参数可以不写。\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.TYPE)\n\tpublic @interface GetMsg {\n\t    int id();  //注解参数\n\t    String name() default \"default\";\n\t}\n\t\n\t//使用\n\t@GetMsg(id = 1) //name有默认值可以不写\n\tclass Test{\n\t}\n\n\n#### “注解的继承”（依赖倒置？）\n\n这里讲的继承并不是通过@Inherited修饰的注解。\n\n这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。\n\n先看代码。\n\n\t@Target(METHOD)\n\t@Retention(CLASS)\n\t@ListenerClass(\n\t    targetType = \"android.view.View\",\n    \tsetter = \"setOnClickListener\",\n    \ttype = \"butterknife.internal.DebouncingOnClickListener\",\n    \tmethod = @ListenerMethod(\n        \tname = \"doClick\",\n        \tparameters = \"android.view.View\"\n    \t)\n\t)\n\tpublic @interface OnClick {\n  \t\t/** View IDs to which the method will be bound. */\n  \t\tint[] value() default { View.NO_ID };\n\t}\n\t\n\n这是ButterKnife的OnClick 注解。特殊的地方在于**@OnClick修饰了注解@ListenerClass**，并且设置了一些只属于@OnClick的属性。\n\n那这样的作用是什么呢？\n\n凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。\n\n这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。\n\n\n### 处理器类Processor编写\n\n自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。\n\nAbstractProcessor有两个重要的方法需要重写。\n\n![](http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg)\n\n\n#### 重写getSupportedAnnotationTypes方法：\n\n通过重写该方法，告知Processor哪些注解需要处理。\n\n返回一个Set集合，集合内容为自定义注解的包名+类名。\n\n建议项目中这样编写：\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        //需要全类名\n        types.add(GetMsg.class.getCanonicalName()); \n        types.add(Println.class.getCanonicalName());\n        return types;\n    }\n    \n另外如果注解数量很少的话，可以通过另一种方式实现：\n\n\t//在只有一到两个注解需要处理时，可以这样编写：\n\t@SupportedAnnotationTypes(\"com.example.annotation.SetContentView\")\n\t@SupportedSourceVersion(SourceVersion.RELEASE_7)\n\tpublic class ContentViewProcessor extends AbstractProcessor {\n\t\n\t}\n\t\n#### 重写process方法：\n\n所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        \n        \n        return false;\n    }\n\n先简单解释下这个方法的参数和返回值。\n\n**参数** *Set<? extends TypeElement> annotations* ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）\n**参数** *RoundEnvironment roundEnv* ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。\n\n例：\t\t\n\n\tfor (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n\t\t//所有被使用的@GetMsg\n\t}\n\n**返回值** 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理\n\n### 输出Log\n\n虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。\n\n**Processor日志输出的位置在编译器下方的Messages窗口中。**\n\nProcessor支持最基础的System.out方法。\n\n同样Processor也有自己的Log输出工具: Messager。\n\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n    \t\n    \t//取得Messager对象\n        Messager messager = processingEnv.getMessager();\n        \n        //输出日志\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + element.getSimpleName().toString());\n        }\n\n同Log类似，Messager也有日志级别的选择。\n\n- Diagnostic.Kind.ERROR \n- Diagnostic.Kind.WARNING \n- Diagnostic.Kind.MANDATORY_WARNING \n- Diagnostic.Kind.NOTE \n- Diagnostic.Kind.OTHER \n\n他们的输出样式如图：\n\n\n\n\n![](http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg)\n\n![](http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg)\n\n**注意：当没有属于该Process处理的注解被使用时，process不会执行。**\n\n**注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。**\n\n这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？\n\n### 用生成的代码来生成代码\n\nAPT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？\n\n同样可以被扫描到，并且用于代码生成。其过程如下：\n\nAPT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。\n\n同样你肯定也会发现一个问题，这不很容易会变成死循环吗？\n\n**没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！**\n\n\n### Element\n\nElement也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。\n\nElement的官方注释：\n\nRepresents a program element such as a package, class, or method.\nEach element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).\n\n表示一个程序元素，比如包、类或者方法。\n\n例如：取得所有修饰了@OnceClick的元素。\n\t\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\t//OnceClick.class是@Target(METHOD)\n\t\t//则该element是可以强转为表示方法的ExecutableElement\n\t\tExecutableElement method = （ExecutableElement）element;\n\t\t//如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n\t\t//但有例外情况，我们稍后列举\n\t\tTypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n\t}\n\nElement的子类有：\n\n- ExecutableElement\n\t\n\t表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n\t\n\t对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)\n\n- PackageElement;\n\n\t表示一个包程序元素。提供对有关包极其成员的信息访问。\n\t\n\t对应@Target(ElementType.PACKAGE)\n\n- TypeElement;\n\n\t表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。\n\t\n\t对应@Target(ElementType.TYPE)\n\t\n\t**注意：枚举类型是一种类，而注解类型是一种接口。**\n\n- TypeParameterElement;\n\n\t表示一般类、接口、方法或构造方法元素的类型参数。\n\t\n\t对应@Target(ElementType.PARAMETER)\n\n- VariableElement;\n\n\t表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。\n\t\n\t对应@Target(ElementType.LOCAL_VARIABLE)\n\t\n例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：\n\nElement 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n\t\tExecutableElement method = (ExecutableElement)element;\n\t}\n\n\n接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。\n\n### 修饰方法的注解和ExecutableElement\n\n当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。\n\n如何获取：\n\n\t//OnceClick.class 以 @Target(ElementType.METHOD)修饰\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n\t\t//对于Element直接强转\n        ExecutableElement executableElement = (ExecutableElement) element;\n        \n        //非对应的Element，通过getEnclosingElement转换获取\n        TypeElement classElement = (TypeElement) element\n                    .getEnclosingElement();\n                    \n        //当(ExecutableElement) element成立时，使用(PackageElement) element\n        //            .getEnclosingElement();将报错。\n        //需要使用elementUtils来获取\n        Elements elementUtils = processingEnv.getElementUtils();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\t\t\n\t\t//全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //方法名\n        String methodName = executableElement.getSimpleName().toString();\n\n\t\t//取得方法参数列表\n\t\tList<? extends VariableElement> methodParameters = executableElement.getParameters();\n\t\t//参数类型列表\n\t\tList<String> types = new ArrayList<>();\n        for (VariableElement variableElement : methodParameters) {\n            TypeMirror methodParameterType = variableElement.asType();\n            if (methodParameterType instanceof TypeVariable) {\n                TypeVariable typeVariable = (TypeVariable) methodParameterType;\n                methodParameterType = typeVariable.getUpperBound();\n                \n            }\n            //参数名\n            String parameterName = variableElement.getSimpleName().toString();\n            //参数类型\n            String parameteKind = methodParameterType.toString();\n            types.add(methodParameterType.toString());\n        }\n\t}\n\n\n### 修饰属性、类成员的注解和VariableElement\n\n\n当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名\n\n如何获取：\n\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n\t\t//ElementType.FIELD注解可以直接强转VariableElement\n\t\tVariableElement variableElement = (VariableElement) element;\n\t\t\n        TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n        PackageElement packageElement = elementUtils.getPackageOf(classElement);\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n        //类成员名\n        String variableName = variableElement.getSimpleName().toString();\n        \n        //类成员类型\n        TypeMirror typeMirror = variableElement.asType();\n        String type = typeMirror.toString();\n        \n\t}\n\t\n\t\n### 修饰类的注解和TypeElement\n\n\n当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。\n\n那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。\n\n如何获取：\n\n\tfor (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n\t\t//ElementType.TYPE注解可以直接强转TypeElement\n        TypeElement classElement = (TypeElement) element;\n        \n        PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n                    \n        //全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        //类名\n        String className = classElement.getSimpleName().toString();\n        //包名\n        String packageName = packageElement.getQualifiedName().toString();\n \t\t//父类名\n \t\tString superClassName = classElement.getSuperclass().toString();\n        \n\t}\n\t\n\t\n<br/>\n\n-------------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n《Android编译时注解框架-语法讲解》\n\n\n\t\n","slug":"apt-Grammar-explanation","published":1,"updated":"2017-01-16T05:13:11.000Z","_id":"cixzmux3b0008q4chwm72lz03","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……</p>\n<p>这里对猜对的结果进行一个总结，让后来者可以更快的上手。</p>\n<a id=\"more\"></a>\n<p>第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。</p>\n<h3 id=\"自定义注解相关\"><a href=\"#自定义注解相关\" class=\"headerlink\" title=\"自定义注解相关\"></a>自定义注解相关</h3><p>定义注解格式：   public @interface 注解名 {定义体}</p>\n<p>Annotation里面的参数该设定: </p>\n<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　</p>\n<p>第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1,name = &quot;asd&quot;)\nclass Test{\n}\n</code></pre><p>如果只有一个参数，建议设置为value</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Println {\n    int value();\n}\n\n//使用\n@Println(1)\nclass Test{\n}\n</code></pre><p>参数为value时，可以直接写入参数,使用时不在需要key=value写法。<br>但当有多个参数时，不可以再使用value。</p>\n<h4 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h4><p>这个在第一章有讲。申明该注解属于什么类型注解</p>\n<ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  运行时注解，一般在运行时通过反射去识别的注解。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  编译时注解，在编译时处理。</p>\n</li>\n</ul>\n<h4 id=\"Target-ElementType-TYPE\"><a href=\"#Target-ElementType-TYPE\" class=\"headerlink\" title=\"@Target(ElementType.TYPE)\"></a>@Target(ElementType.TYPE)</h4><p>表示该注解用来修饰哪些元素。并可以修饰多个</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\npublic @interface GetMsg {\n    int id();\n    String name() default &quot;default&quot;;\n}\n</code></pre><p>例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。</p>\n<pre><code>@GetMsg(1)\npublic void printError(){\n    //TODO ~\n}\n\n@GetMsg(1)  //编译器会报错\nclass Test{\n     //TODO ~\n}\n</code></pre><ul>\n<li><p>@Target(ElementType.TYPE)</p>\n<p>  接口、类、枚举、注解</p>\n</li>\n<li><p>@Target(ElementType.FIELD) </p>\n<p>  字段、枚举的常量</p>\n</li>\n<li><p>@Target(ElementType.METHOD) </p>\n<p>  方法</p>\n</li>\n<li><p>@Target(ElementType.PARAMETER)</p>\n<p>  方法参数 </p>\n</li>\n<li><p>@Target(ElementType.CONSTRUCTOR) </p>\n<p>  构造函数 </p>\n</li>\n<li><p>@Target(ElementType.LOCAL_VARIABLE)</p>\n<p>  局部变量 </p>\n</li>\n<li><p>@Target(ElementType.ANNOTATION_TYPE)</p>\n<p>  注解 </p>\n</li>\n<li><p>@Target(ElementType.package) </p>\n<p>  包 </p>\n</li>\n</ul>\n<h4 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h4><p>该注解的字面意识是继承，但你要知道<strong>注解是不可以继承的</strong>。</p>\n<p>@Inherited是在继承结构中使用的注解。</p>\n<p>如果你的注解是这样定义的：</p>\n<pre><code>@Inherited\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Test {\n    //...\n}\n</code></pre><p>当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。</p>\n<p><em>这里感谢 豪哥 @刘志豪 的排疑解惑~</em></p>\n<h4 id=\"注解的默认值\"><a href=\"#注解的默认值\" class=\"headerlink\" title=\"注解的默认值\"></a>注解的默认值</h4><p>注解可以设置默认值，有默认值的参数可以不写。</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1) //name有默认值可以不写\nclass Test{\n}\n</code></pre><h4 id=\"“注解的继承”（依赖倒置？）\"><a href=\"#“注解的继承”（依赖倒置？）\" class=\"headerlink\" title=\"“注解的继承”（依赖倒置？）\"></a>“注解的继承”（依赖倒置？）</h4><p>这里讲的继承并不是通过@Inherited修饰的注解。</p>\n<p>这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。</p>\n<p>先看代码。</p>\n<pre><code>@Target(METHOD)\n@Retention(CLASS)\n@ListenerClass(\n    targetType = &quot;android.view.View&quot;,\n    setter = &quot;setOnClickListener&quot;,\n    type = &quot;butterknife.internal.DebouncingOnClickListener&quot;,\n    method = @ListenerMethod(\n        name = &quot;doClick&quot;,\n        parameters = &quot;android.view.View&quot;\n    )\n)\npublic @interface OnClick {\n      /** View IDs to which the method will be bound. */\n      int[] value() default { View.NO_ID };\n}\n</code></pre><p>这是ButterKnife的OnClick 注解。特殊的地方在于<strong>@OnClick修饰了注解@ListenerClass</strong>，并且设置了一些只属于@OnClick的属性。</p>\n<p>那这样的作用是什么呢？</p>\n<p>凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。</p>\n<p>这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。</p>\n<h3 id=\"处理器类Processor编写\"><a href=\"#处理器类Processor编写\" class=\"headerlink\" title=\"处理器类Processor编写\"></a>处理器类Processor编写</h3><p>自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。</p>\n<p>AbstractProcessor有两个重要的方法需要重写。</p>\n<p><img src=\"http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg\" alt=\"\"></p>\n<h4 id=\"重写getSupportedAnnotationTypes方法：\"><a href=\"#重写getSupportedAnnotationTypes方法：\" class=\"headerlink\" title=\"重写getSupportedAnnotationTypes方法：\"></a>重写getSupportedAnnotationTypes方法：</h4><p>通过重写该方法，告知Processor哪些注解需要处理。</p>\n<p>返回一个Set集合，集合内容为自定义注解的包名+类名。</p>\n<p>建议项目中这样编写：</p>\n<pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    //需要全类名\n    types.add(GetMsg.class.getCanonicalName()); \n    types.add(Println.class.getCanonicalName());\n    return types;\n}\n</code></pre><p>另外如果注解数量很少的话，可以通过另一种方式实现：</p>\n<pre><code>//在只有一到两个注解需要处理时，可以这样编写：\n@SupportedAnnotationTypes(&quot;com.example.annotation.SetContentView&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class ContentViewProcessor extends AbstractProcessor {\n\n}\n</code></pre><h4 id=\"重写process方法：\"><a href=\"#重写process方法：\" class=\"headerlink\" title=\"重写process方法：\"></a>重写process方法：</h4><p>所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n\n\n    return false;\n}\n</code></pre><p>先简单解释下这个方法的参数和返回值。</p>\n<p><strong>参数</strong> <em>Set&lt;? extends TypeElement&gt; annotations</em> ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）<br><strong>参数</strong> <em>RoundEnvironment roundEnv</em> ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。</p>\n<p>例：        </p>\n<pre><code>for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n    //所有被使用的@GetMsg\n}\n</code></pre><p><strong>返回值</strong> 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理</p>\n<h3 id=\"输出Log\"><a href=\"#输出Log\" class=\"headerlink\" title=\"输出Log\"></a>输出Log</h3><p>虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。</p>\n<p><strong>Processor日志输出的位置在编译器下方的Messages窗口中。</strong></p>\n<p>Processor支持最基础的System.out方法。</p>\n<p>同样Processor也有自己的Log输出工具: Messager。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n\n    //取得Messager对象\n    Messager messager = processingEnv.getMessager();\n\n    //输出日志\n    messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + element.getSimpleName().toString());\n    }\n</code></pre><p>同Log类似，Messager也有日志级别的选择。</p>\n<ul>\n<li>Diagnostic.Kind.ERROR </li>\n<li>Diagnostic.Kind.WARNING </li>\n<li>Diagnostic.Kind.MANDATORY_WARNING </li>\n<li>Diagnostic.Kind.NOTE </li>\n<li>Diagnostic.Kind.OTHER </li>\n</ul>\n<p>他们的输出样式如图：</p>\n<p><img src=\"http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg\" alt=\"\"></p>\n<p><strong>注意：当没有属于该Process处理的注解被使用时，process不会执行。</strong></p>\n<p><strong>注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。</strong></p>\n<p>这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？</p>\n<h3 id=\"用生成的代码来生成代码\"><a href=\"#用生成的代码来生成代码\" class=\"headerlink\" title=\"用生成的代码来生成代码\"></a>用生成的代码来生成代码</h3><p>APT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？</p>\n<p>同样可以被扫描到，并且用于代码生成。其过程如下：</p>\n<p>APT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。</p>\n<p>同样你肯定也会发现一个问题，这不很容易会变成死循环吗？</p>\n<p><strong>没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！</strong></p>\n<h3 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h3><p>Element也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。</p>\n<p>Element的官方注释：</p>\n<p>Represents a program element such as a package, class, or method.<br>Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).</p>\n<p>表示一个程序元素，比如包、类或者方法。</p>\n<p>例如：取得所有修饰了@OnceClick的元素。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    //OnceClick.class是@Target(METHOD)\n    //则该element是可以强转为表示方法的ExecutableElement\n    ExecutableElement method = （ExecutableElement）element;\n    //如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n    //但有例外情况，我们稍后列举\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n}\n</code></pre><p>Element的子类有：</p>\n<ul>\n<li><p>ExecutableElement</p>\n<p>  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</p>\n<p>  对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)</p>\n</li>\n<li><p>PackageElement;</p>\n<p>  表示一个包程序元素。提供对有关包极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.PACKAGE)</p>\n</li>\n<li><p>TypeElement;</p>\n<p>  表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.TYPE)</p>\n<p>  <strong>注意：枚举类型是一种类，而注解类型是一种接口。</strong></p>\n</li>\n<li><p>TypeParameterElement;</p>\n<p>  表示一般类、接口、方法或构造方法元素的类型参数。</p>\n<p>  对应@Target(ElementType.PARAMETER)</p>\n</li>\n<li><p>VariableElement;</p>\n<p>  表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。</p>\n<p>  对应@Target(ElementType.LOCAL_VARIABLE)</p>\n</li>\n</ul>\n<p>例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：</p>\n<p>Element 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    ExecutableElement method = (ExecutableElement)element;\n}\n</code></pre><p>接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。</p>\n<h3 id=\"修饰方法的注解和ExecutableElement\"><a href=\"#修饰方法的注解和ExecutableElement\" class=\"headerlink\" title=\"修饰方法的注解和ExecutableElement\"></a>修饰方法的注解和ExecutableElement</h3><p>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。</p>\n<p>如何获取：</p>\n<pre><code>//OnceClick.class 以 @Target(ElementType.METHOD)修饰\nfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n    //对于Element直接强转\n    ExecutableElement executableElement = (ExecutableElement) element;\n\n    //非对应的Element，通过getEnclosingElement转换获取\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n\n    //当(ExecutableElement) element成立时，使用(PackageElement) element\n    //            .getEnclosingElement();将报错。\n    //需要使用elementUtils来获取\n    Elements elementUtils = processingEnv.getElementUtils();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //方法名\n    String methodName = executableElement.getSimpleName().toString();\n\n    //取得方法参数列表\n    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();\n    //参数类型列表\n    List&lt;String&gt; types = new ArrayList&lt;&gt;();\n    for (VariableElement variableElement : methodParameters) {\n        TypeMirror methodParameterType = variableElement.asType();\n        if (methodParameterType instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) methodParameterType;\n            methodParameterType = typeVariable.getUpperBound();\n\n        }\n        //参数名\n        String parameterName = variableElement.getSimpleName().toString();\n        //参数类型\n        String parameteKind = methodParameterType.toString();\n        types.add(methodParameterType.toString());\n    }\n}\n</code></pre><h3 id=\"修饰属性、类成员的注解和VariableElement\"><a href=\"#修饰属性、类成员的注解和VariableElement\" class=\"headerlink\" title=\"修饰属性、类成员的注解和VariableElement\"></a>修饰属性、类成员的注解和VariableElement</h3><p>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n    //ElementType.FIELD注解可以直接强转VariableElement\n    VariableElement variableElement = (VariableElement) element;\n\n    TypeElement classElement = (TypeElement) element\n            .getEnclosingElement();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //类成员名\n    String variableName = variableElement.getSimpleName().toString();\n\n    //类成员类型\n    TypeMirror typeMirror = variableElement.asType();\n    String type = typeMirror.toString();\n\n}\n</code></pre><h3 id=\"修饰类的注解和TypeElement\"><a href=\"#修饰类的注解和TypeElement\" class=\"headerlink\" title=\"修饰类的注解和TypeElement\"></a>修饰类的注解和TypeElement</h3><p>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n    //ElementType.TYPE注解可以直接强转TypeElement\n    TypeElement classElement = (TypeElement) element;\n\n    PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n     //父类名\n     String superClassName = classElement.getSuperclass().toString();\n\n}\n</code></pre><p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p>《Android编译时注解框架-语法讲解》</p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本章内容主要对APT一些语法进行简单讲解。apt的学习资料真的太少了，我的学习方法基本上只能通过看开源库的源码猜、看源码注释猜、自己运行着猜……</p>\n<p>这里对猜对的结果进行一个总结，让后来者可以更快的上手。</p>","more":"<p>第一次写这种类型的博客，总结的可能有些分散，建议结合开源库源码学习。</p>\n<h3 id=\"自定义注解相关\"><a href=\"#自定义注解相关\" class=\"headerlink\" title=\"自定义注解相关\"></a>自定义注解相关</h3><p>定义注解格式：   public @interface 注解名 {定义体}</p>\n<p>Annotation里面的参数该设定: </p>\n<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();不能是private；　 　</p>\n<p>第二,参数只能使用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数类型就为String;　　</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1,name = &quot;asd&quot;)\nclass Test{\n}\n</code></pre><p>如果只有一个参数，建议设置为value</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Println {\n    int value();\n}\n\n//使用\n@Println(1)\nclass Test{\n}\n</code></pre><p>参数为value时，可以直接写入参数,使用时不在需要key=value写法。<br>但当有多个参数时，不可以再使用value。</p>\n<h4 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h4><p>这个在第一章有讲。申明该注解属于什么类型注解</p>\n<ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  源码时注解，一般用来作为编译器标记。就比如Override, Deprecated, SuppressWarnings这样的注解。（这个我们一般都很少自定义的）</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  运行时注解，一般在运行时通过反射去识别的注解。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  编译时注解，在编译时处理。</p>\n</li>\n</ul>\n<h4 id=\"Target-ElementType-TYPE\"><a href=\"#Target-ElementType-TYPE\" class=\"headerlink\" title=\"@Target(ElementType.TYPE)\"></a>@Target(ElementType.TYPE)</h4><p>表示该注解用来修饰哪些元素。并可以修饰多个</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.LOCAL_VARIABLE,ElementType.METHOD})\npublic @interface GetMsg {\n    int id();\n    String name() default &quot;default&quot;;\n}\n</code></pre><p>例如 GetMsg只能用在局部变量和方法上，如果修饰到类上编译器会报错。</p>\n<pre><code>@GetMsg(1)\npublic void printError(){\n    //TODO ~\n}\n\n@GetMsg(1)  //编译器会报错\nclass Test{\n     //TODO ~\n}\n</code></pre><ul>\n<li><p>@Target(ElementType.TYPE)</p>\n<p>  接口、类、枚举、注解</p>\n</li>\n<li><p>@Target(ElementType.FIELD) </p>\n<p>  字段、枚举的常量</p>\n</li>\n<li><p>@Target(ElementType.METHOD) </p>\n<p>  方法</p>\n</li>\n<li><p>@Target(ElementType.PARAMETER)</p>\n<p>  方法参数 </p>\n</li>\n<li><p>@Target(ElementType.CONSTRUCTOR) </p>\n<p>  构造函数 </p>\n</li>\n<li><p>@Target(ElementType.LOCAL_VARIABLE)</p>\n<p>  局部变量 </p>\n</li>\n<li><p>@Target(ElementType.ANNOTATION_TYPE)</p>\n<p>  注解 </p>\n</li>\n<li><p>@Target(ElementType.package) </p>\n<p>  包 </p>\n</li>\n</ul>\n<h4 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h4><p>该注解的字面意识是继承，但你要知道<strong>注解是不可以继承的</strong>。</p>\n<p>@Inherited是在继承结构中使用的注解。</p>\n<p>如果你的注解是这样定义的：</p>\n<pre><code>@Inherited\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface Test {\n    //...\n}\n</code></pre><p>当你的注解定义到类A上，此时，有个B类继承A，且没使用该注解。但是扫描的时候，会把A类设置的注解，扫描到B类上。</p>\n<p><em>这里感谢 豪哥 @刘志豪 的排疑解惑~</em></p>\n<h4 id=\"注解的默认值\"><a href=\"#注解的默认值\" class=\"headerlink\" title=\"注解的默认值\"></a>注解的默认值</h4><p>注解可以设置默认值，有默认值的参数可以不写。</p>\n<pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface GetMsg {\n    int id();  //注解参数\n    String name() default &quot;default&quot;;\n}\n\n//使用\n@GetMsg(id = 1) //name有默认值可以不写\nclass Test{\n}\n</code></pre><h4 id=\"“注解的继承”（依赖倒置？）\"><a href=\"#“注解的继承”（依赖倒置？）\" class=\"headerlink\" title=\"“注解的继承”（依赖倒置？）\"></a>“注解的继承”（依赖倒置？）</h4><p>这里讲的继承并不是通过@Inherited修饰的注解。</p>\n<p>这个“继承”是一个注解的使用技巧，使用上的感觉类似于依赖倒置，来自于ButterKnife源码。</p>\n<p>先看代码。</p>\n<pre><code>@Target(METHOD)\n@Retention(CLASS)\n@ListenerClass(\n    targetType = &quot;android.view.View&quot;,\n    setter = &quot;setOnClickListener&quot;,\n    type = &quot;butterknife.internal.DebouncingOnClickListener&quot;,\n    method = @ListenerMethod(\n        name = &quot;doClick&quot;,\n        parameters = &quot;android.view.View&quot;\n    )\n)\npublic @interface OnClick {\n      /** View IDs to which the method will be bound. */\n      int[] value() default { View.NO_ID };\n}\n</code></pre><p>这是ButterKnife的OnClick 注解。特殊的地方在于<strong>@OnClick修饰了注解@ListenerClass</strong>，并且设置了一些只属于@OnClick的属性。</p>\n<p>那这样的作用是什么呢？</p>\n<p>凡是修饰了@OnClick的地方，也就自动修饰了@ListenerClass。类似于@OnClick是@ListenerClass的子类。而ButterKnife有很多的监听注解@OnItemClick、@OnLongClick等等。</p>\n<p>这样在做代码生成时，不需要再单独考虑每一个监听注解，只需要处理@ListenerClass就OK。</p>\n<h3 id=\"处理器类Processor编写\"><a href=\"#处理器类Processor编写\" class=\"headerlink\" title=\"处理器类Processor编写\"></a>处理器类Processor编写</h3><p>自定义注解后，需要编写Processor类处理注解。Processor继承自AbstractProcessor的类。</p>\n<p>AbstractProcessor有两个重要的方法需要重写。</p>\n<p><img src=\"http://img1.ph.126.net/nIF8CZgyLscGMXPO0UdCkA==/6631820931164553739.jpg\" alt=\"\"></p>\n<h4 id=\"重写getSupportedAnnotationTypes方法：\"><a href=\"#重写getSupportedAnnotationTypes方法：\" class=\"headerlink\" title=\"重写getSupportedAnnotationTypes方法：\"></a>重写getSupportedAnnotationTypes方法：</h4><p>通过重写该方法，告知Processor哪些注解需要处理。</p>\n<p>返回一个Set集合，集合内容为自定义注解的包名+类名。</p>\n<p>建议项目中这样编写：</p>\n<pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    //需要全类名\n    types.add(GetMsg.class.getCanonicalName()); \n    types.add(Println.class.getCanonicalName());\n    return types;\n}\n</code></pre><p>另外如果注解数量很少的话，可以通过另一种方式实现：</p>\n<pre><code>//在只有一到两个注解需要处理时，可以这样编写：\n@SupportedAnnotationTypes(&quot;com.example.annotation.SetContentView&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\npublic class ContentViewProcessor extends AbstractProcessor {\n\n}\n</code></pre><h4 id=\"重写process方法：\"><a href=\"#重写process方法：\" class=\"headerlink\" title=\"重写process方法：\"></a>重写process方法：</h4><p>所有的注解处理都是从这个方法开始的，你可以理解为，当APT找到所有需要处理的注解后，会回调这个方法，你可以通过这个方法的参数，拿到你所需要的信息。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n\n\n    return false;\n}\n</code></pre><p>先简单解释下这个方法的参数和返回值。</p>\n<p><strong>参数</strong> <em>Set&lt;? extends TypeElement&gt; annotations</em> ：将返回所有的由该Processor处理，并待处理的 Annotations。（属于该Processor处理的注解，但并未被使用，不存在与这个集合里）<br><strong>参数</strong> <em>RoundEnvironment roundEnv</em> ：表示当前或是之前的运行环境，可以通过该对象查找找到的注解。</p>\n<p>例：        </p>\n<pre><code>for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n    //所有被使用的@GetMsg\n}\n</code></pre><p><strong>返回值</strong> 表示这组 annotations 是否被这个 Processor 接受，如果接受（true）后续子的 pocessor 不会再对这个 Annotations 进行处理</p>\n<h3 id=\"输出Log\"><a href=\"#输出Log\" class=\"headerlink\" title=\"输出Log\"></a>输出Log</h3><p>虽然是编译时执行Processor,但也是可以输入日志信息用于调试的。</p>\n<p><strong>Processor日志输出的位置在编译器下方的Messages窗口中。</strong></p>\n<p>Processor支持最基础的System.out方法。</p>\n<p>同样Processor也有自己的Log输出工具: Messager。</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n\n    //取得Messager对象\n    Messager messager = processingEnv.getMessager();\n\n    //输出日志\n    messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + element.getSimpleName().toString());\n    }\n</code></pre><p>同Log类似，Messager也有日志级别的选择。</p>\n<ul>\n<li>Diagnostic.Kind.ERROR </li>\n<li>Diagnostic.Kind.WARNING </li>\n<li>Diagnostic.Kind.MANDATORY_WARNING </li>\n<li>Diagnostic.Kind.NOTE </li>\n<li>Diagnostic.Kind.OTHER </li>\n</ul>\n<p>他们的输出样式如图：</p>\n<p><img src=\"http://img2.ph.126.net/Ypp8bT2ykMm35CSoPqO4Lw==/6631566943978535174.jpg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/bdMUDuJ_8US-yfB2JJjQpA==/6631580138118067912.jpg\" alt=\"\"></p>\n<p><strong>注意：当没有属于该Process处理的注解被使用时，process不会执行。</strong></p>\n<p><strong>注意：如果发现替换jar后，apt代码并没有执行，尝试clean项目。</strong></p>\n<p>这里你会发现输出了两次日志信息。其原因在于APT扫描了源码两次，可为什么要扫描两次？</p>\n<h3 id=\"用生成的代码来生成代码\"><a href=\"#用生成的代码来生成代码\" class=\"headerlink\" title=\"用生成的代码来生成代码\"></a>用生成的代码来生成代码</h3><p>APT可以扫描源码中的所有注解，依据这些注解来生成代码，那么生成的代码中如果也有注解呢？</p>\n<p>同样可以被扫描到，并且用于代码生成。其过程如下：</p>\n<p>APT第一次扫描源码中的所有注解，扫描结束后生成代码，之后再扫描一次，以保证生成的代码中的注解也可以被扫描到，第二次扫描到注解后继续生成代码，类似于递归一样的【扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成 - 扫描 - 代码生成】。一直到扫描到的注解为0时停止。</p>\n<p>同样你肯定也会发现一个问题，这不很容易会变成死循环吗？</p>\n<p><strong>没错，所以在生成的代码中一定要慎重出现编译时注解，把控好你的代码逻辑！</strong></p>\n<h3 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h3><p>Element也是APT的重点之一，所有通过注解取得元素都将以Element类型等待处理，也可以理解为Element的子类类型与自定义注解时用到的@Target是有对应关系的。</p>\n<p>Element的官方注释：</p>\n<p>Represents a program element such as a package, class, or method.<br>Each element represents a static, language-level construct (and not, for example, a runtime construct of the virtual machine).</p>\n<p>表示一个程序元素，比如包、类或者方法。</p>\n<p>例如：取得所有修饰了@OnceClick的元素。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    //OnceClick.class是@Target(METHOD)\n    //则该element是可以强转为表示方法的ExecutableElement\n    ExecutableElement method = （ExecutableElement）element;\n    //如果需要用到其他类型的Element，则不可以直接强转，需要通过下面方法转换\n    //但有例外情况，我们稍后列举\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n}\n</code></pre><p>Element的子类有：</p>\n<ul>\n<li><p>ExecutableElement</p>\n<p>  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</p>\n<p>  对应@Target(ElementType.METHOD) @Target(ElementType.CONSTRUCTOR)</p>\n</li>\n<li><p>PackageElement;</p>\n<p>  表示一个包程序元素。提供对有关包极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.PACKAGE)</p>\n</li>\n<li><p>TypeElement;</p>\n<p>  表示一个类或接口程序元素。提供对有关类型极其成员的信息访问。</p>\n<p>  对应@Target(ElementType.TYPE)</p>\n<p>  <strong>注意：枚举类型是一种类，而注解类型是一种接口。</strong></p>\n</li>\n<li><p>TypeParameterElement;</p>\n<p>  表示一般类、接口、方法或构造方法元素的类型参数。</p>\n<p>  对应@Target(ElementType.PARAMETER)</p>\n</li>\n<li><p>VariableElement;</p>\n<p>  表示一个字段、enum常量、方法或构造方法参数、局部变量或异常参数。</p>\n<p>  对应@Target(ElementType.LOCAL_VARIABLE)</p>\n</li>\n</ul>\n<p>例如：@OnceClick的@Target(METHOD)。其修饰方法，那么在这个情况下：</p>\n<p>Element 可以直接强制转换为ExecutableElement。而其他类型的Element不能直接强制转，需要其他办法。</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)){\n    ExecutableElement method = (ExecutableElement)element;\n}\n</code></pre><p>接下来我们将以@Target()分类进行讲解，不同Element的信息获取方式不同。</p>\n<h3 id=\"修饰方法的注解和ExecutableElement\"><a href=\"#修饰方法的注解和ExecutableElement\" class=\"headerlink\" title=\"修饰方法的注解和ExecutableElement\"></a>修饰方法的注解和ExecutableElement</h3><p>当你有一个注解是以@Target(ElementType.METHOD)定义时，表示该注解只能修饰方法。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、方法名、参数类型、返回值。</p>\n<p>如何获取：</p>\n<pre><code>//OnceClick.class 以 @Target(ElementType.METHOD)修饰\nfor (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\n    //对于Element直接强转\n    ExecutableElement executableElement = (ExecutableElement) element;\n\n    //非对应的Element，通过getEnclosingElement转换获取\n    TypeElement classElement = (TypeElement) element\n                .getEnclosingElement();\n\n    //当(ExecutableElement) element成立时，使用(PackageElement) element\n    //            .getEnclosingElement();将报错。\n    //需要使用elementUtils来获取\n    Elements elementUtils = processingEnv.getElementUtils();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //方法名\n    String methodName = executableElement.getSimpleName().toString();\n\n    //取得方法参数列表\n    List&lt;? extends VariableElement&gt; methodParameters = executableElement.getParameters();\n    //参数类型列表\n    List&lt;String&gt; types = new ArrayList&lt;&gt;();\n    for (VariableElement variableElement : methodParameters) {\n        TypeMirror methodParameterType = variableElement.asType();\n        if (methodParameterType instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) methodParameterType;\n            methodParameterType = typeVariable.getUpperBound();\n\n        }\n        //参数名\n        String parameterName = variableElement.getSimpleName().toString();\n        //参数类型\n        String parameteKind = methodParameterType.toString();\n        types.add(methodParameterType.toString());\n    }\n}\n</code></pre><h3 id=\"修饰属性、类成员的注解和VariableElement\"><a href=\"#修饰属性、类成员的注解和VariableElement\" class=\"headerlink\" title=\"修饰属性、类成员的注解和VariableElement\"></a>修饰属性、类成员的注解和VariableElement</h3><p>当你有一个注解是以@Target(ElementType.FIELD)定义时，表示该注解只能修饰属性、类成员。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、类成员类型、类成员名</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(IdProperty.class)) {\n    //ElementType.FIELD注解可以直接强转VariableElement\n    VariableElement variableElement = (VariableElement) element;\n\n    TypeElement classElement = (TypeElement) element\n            .getEnclosingElement();\n    PackageElement packageElement = elementUtils.getPackageOf(classElement);\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n    //类成员名\n    String variableName = variableElement.getSimpleName().toString();\n\n    //类成员类型\n    TypeMirror typeMirror = variableElement.asType();\n    String type = typeMirror.toString();\n\n}\n</code></pre><h3 id=\"修饰类的注解和TypeElement\"><a href=\"#修饰类的注解和TypeElement\" class=\"headerlink\" title=\"修饰类的注解和TypeElement\"></a>修饰类的注解和TypeElement</h3><p>当你有一个注解是以@Target(ElementType.TYPE)定义时，表示该注解只能修饰类、接口、枚举。</p>\n<p>那么这个时候你为了生成代码，而需要获取一些基本信息：包名、类名、全类名、父类。</p>\n<p>如何获取：</p>\n<pre><code>for (Element element : roundEnv.getElementsAnnotatedWith(xxx.class)) {\n    //ElementType.TYPE注解可以直接强转TypeElement\n    TypeElement classElement = (TypeElement) element;\n\n    PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n    //全类名\n    String fullClassName = classElement.getQualifiedName().toString();\n    //类名\n    String className = classElement.getSimpleName().toString();\n    //包名\n    String packageName = packageElement.getQualifiedName().toString();\n     //父类名\n     String superClassName = classElement.getSuperclass().toString();\n\n}\n</code></pre><p><br/></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p>《Android编译时注解框架-语法讲解》</p>"},{"title":"Android编译时注解框架系列2-Run Demo","date":"2016-07-17T07:50:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。\n\n正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。\n\n<!-- more -->\n\n以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。\n\n所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！\n\n**在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。**\n\n\n### Running\n\n#### 项目搭建\n\n首先创建一个Android项目\n\n![](http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg)\n\n\n然后给我们的项目增加一个module,一定要记得是Java Library.\n\n因为APT需要用到jdk下的 【 *javax.~ *】包下的类，这在AndroidSdk中是没有的。\n\n\n![](http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg)\n\n\n![](http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg)\n\n\n#### 自定义注解\n\n新建一个类，GetMsg。就是我们自定义的注解。\n\n![](http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg)\n\n这是一个编译时注解，用*@Retention(RetentionPolicy.CLASS)*修饰。\n\n这个注解只能修饰方法。用*@Target(ElementType.METHOD)*修饰。\n\n且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 \n\n\n#### 创建Processor\n\nProcessor是用来处理Annotation的类。继承自AbstractProcessor。\n\n![](http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg)\n\n复写AbstractProcessor两个最重要的方法。\n\n*process*方法是用来处理注解的，我们一会写。\n\n*getSupportedAnnotationTypes*用来表示该Processor处理哪些注解。这里我们只有一个*GetMsg*注解需要处理。\n\n\n#### 重写process方法\n\n我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n            //获取该注解所在类的包名\n            String packageName = packageElement.getQualifiedName().toString();\n            TypeElement classElement = (TypeElement) element;\n            //获取该注解所在类的类名\n            String className = classElement.getSimpleName().toString();\n            //获取该注解所在类的全类名\n            String fullClassName = classElement.getQualifiedName().toString();\n            VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n            //获取方法名\n            String methodName = variableElement.getSimpleName().toString();\n            //获取该注解的值\n            int id = classElement.getAnnotation(GetMsg.class).id();\n            String name = classElement.getAnnotation(GetMsg.class).name();\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : packageName = \" + packageName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + className);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : fullClassName = \" + fullClassName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : methodName = \" + methodName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : id = \" + id + \"  name = \" + name);\n        }\n        return true;\n    }\n\n\n\n简单介绍一下代码：\n\n1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~\n\n2.用for循环遍历所有的 GetMsg注解，然后进行处理。\n\n3.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。\n\n4.return true;表示该Process已经处理了，其他的Process不需要再处理了。\n\n#### 配置\n\n一定不能忘记的文件配置。\n\n在main文件夹下创建一个resources.META-INF.services文件夹，创建文件\n\njavax.annotation.processing.Processor\n\n![](http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg)\n\n文件内容是Process类的包名+类名\n\n![](http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg)\n\n忘记这个配置文件的后果就是，注解无法生效。\n\n#### 编译jar\n\n这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）\n\n而如何单独编译这个java Module呢？\n\n在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。\n\n![](http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg)\n\n\n代码没有问题编译通过的话，会有BUILD SUCCESS提示\n\n![](http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg)\n\n生成的jar包在 apt 下的build目录下的libs下\n\n![](http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg)\n\n将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.\n\n![](http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg)\n\n![](http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg)\n\n在APP项目中使用该注解GetMsg。运行。\n\n![](http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg)\n\n\n**当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法**\n\n\n#### 运行结果\n\n![](http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg)\n\n\n### 总结\n\n\n这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。\n\n整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》\n\n这个Demo的代码我放到了GitHub:\n\n[https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao](https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao)\n\n</br>\n \n------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n《Android编译时注解框架-Run Demo》\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n","source":"_posts/apt-run_demo.md","raw":"---\ntitle: Android编译时注解框架系列2-Run Demo\ndate: 2016-07-17 15:50:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。\n\n正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。\n\n<!-- more -->\n\n以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。\n\n所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！\n\n**在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。**\n\n\n### Running\n\n#### 项目搭建\n\n首先创建一个Android项目\n\n![](http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg)\n\n\n然后给我们的项目增加一个module,一定要记得是Java Library.\n\n因为APT需要用到jdk下的 【 *javax.~ *】包下的类，这在AndroidSdk中是没有的。\n\n\n![](http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg)\n\n\n![](http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg)\n\n\n#### 自定义注解\n\n新建一个类，GetMsg。就是我们自定义的注解。\n\n![](http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg)\n\n这是一个编译时注解，用*@Retention(RetentionPolicy.CLASS)*修饰。\n\n这个注解只能修饰方法。用*@Target(ElementType.METHOD)*修饰。\n\n且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 \n\n\n#### 创建Processor\n\nProcessor是用来处理Annotation的类。继承自AbstractProcessor。\n\n![](http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg)\n\n复写AbstractProcessor两个最重要的方法。\n\n*process*方法是用来处理注解的，我们一会写。\n\n*getSupportedAnnotationTypes*用来表示该Processor处理哪些注解。这里我们只有一个*GetMsg*注解需要处理。\n\n\n#### 重写process方法\n\n我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n            //获取该注解所在类的包名\n            String packageName = packageElement.getQualifiedName().toString();\n            TypeElement classElement = (TypeElement) element;\n            //获取该注解所在类的类名\n            String className = classElement.getSimpleName().toString();\n            //获取该注解所在类的全类名\n            String fullClassName = classElement.getQualifiedName().toString();\n            VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n            //获取方法名\n            String methodName = variableElement.getSimpleName().toString();\n            //获取该注解的值\n            int id = classElement.getAnnotation(GetMsg.class).id();\n            String name = classElement.getAnnotation(GetMsg.class).name();\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : packageName = \" + packageName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : className = \" + className);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : fullClassName = \" + fullClassName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : methodName = \" + methodName);\n            messager.printMessage(Diagnostic.Kind.NOTE,\n                    \"Annotation class : id = \" + id + \"  name = \" + name);\n        }\n        return true;\n    }\n\n\n\n简单介绍一下代码：\n\n1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~\n\n2.用for循环遍历所有的 GetMsg注解，然后进行处理。\n\n3.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。\n\n4.return true;表示该Process已经处理了，其他的Process不需要再处理了。\n\n#### 配置\n\n一定不能忘记的文件配置。\n\n在main文件夹下创建一个resources.META-INF.services文件夹，创建文件\n\njavax.annotation.processing.Processor\n\n![](http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg)\n\n文件内容是Process类的包名+类名\n\n![](http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg)\n\n忘记这个配置文件的后果就是，注解无法生效。\n\n#### 编译jar\n\n这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）\n\n而如何单独编译这个java Module呢？\n\n在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。\n\n![](http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg)\n\n\n代码没有问题编译通过的话，会有BUILD SUCCESS提示\n\n![](http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg)\n\n生成的jar包在 apt 下的build目录下的libs下\n\n![](http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg)\n\n将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.\n\n![](http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg)\n\n![](http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg)\n\n在APP项目中使用该注解GetMsg。运行。\n\n![](http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg)\n\n\n**当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法**\n\n\n#### 运行结果\n\n![](http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg)\n\n\n### 总结\n\n\n这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。\n\n整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》\n\n这个Demo的代码我放到了GitHub:\n\n[https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao](https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao)\n\n</br>\n \n------\n\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n《Android编译时注解框架-Run Demo》\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n","slug":"apt-run_demo","published":1,"updated":"2017-01-16T05:13:05.000Z","_id":"cixzmux3f000aq4chej2fjj0d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。</p>\n<p>正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。</p>\n<a id=\"more\"></a>\n<p>以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。</p>\n<p>所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！</p>\n<p><strong>在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。</strong></p>\n<h3 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>首先创建一个Android项目</p>\n<p><img src=\"http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg\" alt=\"\"></p>\n<p>然后给我们的项目增加一个module,一定要记得是Java Library.</p>\n<p>因为APT需要用到jdk下的 【 <em>javax.~ </em>】包下的类，这在AndroidSdk中是没有的。</p>\n<p><img src=\"http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg\" alt=\"\"></p>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>新建一个类，GetMsg。就是我们自定义的注解。</p>\n<p><img src=\"http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg\" alt=\"\"></p>\n<p>这是一个编译时注解，用<em>@Retention(RetentionPolicy.CLASS)</em>修饰。</p>\n<p>这个注解只能修饰方法。用<em>@Target(ElementType.METHOD)</em>修饰。</p>\n<p>且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 </p>\n<h4 id=\"创建Processor\"><a href=\"#创建Processor\" class=\"headerlink\" title=\"创建Processor\"></a>创建Processor</h4><p>Processor是用来处理Annotation的类。继承自AbstractProcessor。</p>\n<p><img src=\"http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg\" alt=\"\"></p>\n<p>复写AbstractProcessor两个最重要的方法。</p>\n<p><em>process</em>方法是用来处理注解的，我们一会写。</p>\n<p><em>getSupportedAnnotationTypes</em>用来表示该Processor处理哪些注解。这里我们只有一个<em>GetMsg</em>注解需要处理。</p>\n<h4 id=\"重写process方法\"><a href=\"#重写process方法\" class=\"headerlink\" title=\"重写process方法\"></a>重写process方法</h4><p>我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n        //获取该注解所在类的包名\n        String packageName = packageElement.getQualifiedName().toString();\n        TypeElement classElement = (TypeElement) element;\n        //获取该注解所在类的类名\n        String className = classElement.getSimpleName().toString();\n        //获取该注解所在类的全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n        //获取方法名\n        String methodName = variableElement.getSimpleName().toString();\n        //获取该注解的值\n        int id = classElement.getAnnotation(GetMsg.class).id();\n        String name = classElement.getAnnotation(GetMsg.class).name();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : packageName = &quot; + packageName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + className);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : fullClassName = &quot; + fullClassName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : methodName = &quot; + methodName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : id = &quot; + id + &quot;  name = &quot; + name);\n    }\n    return true;\n}\n</code></pre><p>简单介绍一下代码：</p>\n<p>1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~</p>\n<p>2.用for循环遍历所有的 GetMsg注解，然后进行处理。</p>\n<p>3.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。</p>\n<p>4.return true;表示该Process已经处理了，其他的Process不需要再处理了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>一定不能忘记的文件配置。</p>\n<p>在main文件夹下创建一个resources.META-INF.services文件夹，创建文件</p>\n<p>javax.annotation.processing.Processor</p>\n<p><img src=\"http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg\" alt=\"\"></p>\n<p>文件内容是Process类的包名+类名</p>\n<p><img src=\"http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg\" alt=\"\"></p>\n<p>忘记这个配置文件的后果就是，注解无法生效。</p>\n<h4 id=\"编译jar\"><a href=\"#编译jar\" class=\"headerlink\" title=\"编译jar\"></a>编译jar</h4><p>这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）</p>\n<p>而如何单独编译这个java Module呢？</p>\n<p>在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。</p>\n<p><img src=\"http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg\" alt=\"\"></p>\n<p>代码没有问题编译通过的话，会有BUILD SUCCESS提示</p>\n<p><img src=\"http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg\" alt=\"\"></p>\n<p>生成的jar包在 apt 下的build目录下的libs下</p>\n<p><img src=\"http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg\" alt=\"\"></p>\n<p>将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.</p>\n<p><img src=\"http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg\" alt=\"\"></p>\n<p>在APP项目中使用该注解GetMsg。运行。</p>\n<p><img src=\"http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg\" alt=\"\"></p>\n<p><strong>当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法</strong></p>\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。</p>\n<p>整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》</p>\n<p>这个Demo的代码我放到了GitHub:</p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao</a></p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p>《Android编译时注解框架-Run Demo》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先讲一下编写《Android编译时注解框架》的初衷吧，APT其实并不难，可以说是简单且高效，但关于APT的资料却并不多，甚至很多人都不知道这么一个技术。国内关于APT的博客屈指可数，唯二找到的几篇初级讲解一个是用Eclipse写得，一个是用AndroidStudio加Intellij。刚开始着实踩了不少坑，但事实是，APT完全可以用AndroidStudio单独实现。光是项目搭建就如此麻烦了，更别提语法讲解了。资料匮乏无疑提高了APT的入门门槛。</p>\n<p>正因为如此，这个系列博客就这样诞生啦~现在就教你用AndroidStudio一步步打造自己的APT框架。</p>","more":"<p>以我自己的学习习惯来讲，比起前期大量枯燥的基础知识积累，我更喜欢先把项目跑起来再说，虽然会不明所以，但反而会促进学习兴趣，并且在有结果的场景下一步步深入。</p>\n<p>所以作为《Android编译时注解框架》系列的第二篇，我们不管三七二十一，先把APT跑起来再说，看看这到底是个什么东西。跑起来，就入门啦！</p>\n<p><strong>在Running的过程中，有很多语法，我们都暂时一并跳过，都放到《Android编译时注解框架-语法讲解》统一讲。</strong></p>\n<h3 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>首先创建一个Android项目</p>\n<p><img src=\"http://img1.ph.126.net/u57VJi5uksh4duN6yMFxOA==/6631542754722720703.jpeg\" alt=\"\"></p>\n<p>然后给我们的项目增加一个module,一定要记得是Java Library.</p>\n<p>因为APT需要用到jdk下的 【 <em>javax.~ </em>】包下的类，这在AndroidSdk中是没有的。</p>\n<p><img src=\"http://img0.ph.126.net/UhzqKVMFfwu3ty-OxxyMCg==/6631790144838976047.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img1.ph.126.net/F8_ZnOElNPV06vSCsJnvFw==/6631658203443642814.jpeg\" alt=\"\"></p>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><p>新建一个类，GetMsg。就是我们自定义的注解。</p>\n<p><img src=\"http://img2.ph.126.net/cc1rbYqrXAfXk9lzz4dP8g==/6631577939094811679.jpeg\" alt=\"\"></p>\n<p>这是一个编译时注解，用<em>@Retention(RetentionPolicy.CLASS)</em>修饰。</p>\n<p>这个注解只能修饰方法。用<em>@Target(ElementType.METHOD)</em>修饰。</p>\n<p>且这个注解可以设置两个值。id和name。name是有默认值的，可以不设置。 </p>\n<h4 id=\"创建Processor\"><a href=\"#创建Processor\" class=\"headerlink\" title=\"创建Processor\"></a>创建Processor</h4><p>Processor是用来处理Annotation的类。继承自AbstractProcessor。</p>\n<p><img src=\"http://img0.ph.126.net/JcFdC1YgKtkFQGqozEa_iw==/6631616422001785860.jpeg\" alt=\"\"></p>\n<p>复写AbstractProcessor两个最重要的方法。</p>\n<p><em>process</em>方法是用来处理注解的，我们一会写。</p>\n<p><em>getSupportedAnnotationTypes</em>用来表示该Processor处理哪些注解。这里我们只有一个<em>GetMsg</em>注解需要处理。</p>\n<h4 id=\"重写process方法\"><a href=\"#重写process方法\" class=\"headerlink\" title=\"重写process方法\"></a>重写process方法</h4><p>我们的目的呢，是获取修饰了GetMsg注解的方法所有信息，只有获得了这些信息，才有依据生成代码不是吗?</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    for (Element element : env.getElementsAnnotatedWith(GetMsg.class)) {\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n        //获取该注解所在类的包名\n        String packageName = packageElement.getQualifiedName().toString();\n        TypeElement classElement = (TypeElement) element;\n        //获取该注解所在类的类名\n        String className = classElement.getSimpleName().toString();\n        //获取该注解所在类的全类名\n        String fullClassName = classElement.getQualifiedName().toString();\n        VariableElement variableElement = (VariableElement) element.getEnclosingElement();\n        //获取方法名\n        String methodName = variableElement.getSimpleName().toString();\n        //获取该注解的值\n        int id = classElement.getAnnotation(GetMsg.class).id();\n        String name = classElement.getAnnotation(GetMsg.class).name();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : packageName = &quot; + packageName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : className = &quot; + className);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : fullClassName = &quot; + fullClassName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : methodName = &quot; + methodName);\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                &quot;Annotation class : id = &quot; + id + &quot;  name = &quot; + name);\n    }\n    return true;\n}\n</code></pre><p>简单介绍一下代码：</p>\n<p>1.Messager 用来输出。就像我们平时用的System.out.pringln()和Log.d。输出位置在编译器下方的Messages窗口。这里System.out也是可以用的哦~</p>\n<p>2.用for循环遍历所有的 GetMsg注解，然后进行处理。</p>\n<p>3.Diagnostic.Kind.NOTE 类似于Log.d Log.e这样的等级。</p>\n<p>4.return true;表示该Process已经处理了，其他的Process不需要再处理了。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>一定不能忘记的文件配置。</p>\n<p>在main文件夹下创建一个resources.META-INF.services文件夹，创建文件</p>\n<p>javax.annotation.processing.Processor</p>\n<p><img src=\"http://img1.ph.126.net/ODbgMyTTqIym9R-XzgPoWA==/6631704382932005509.jpeg\" alt=\"\"></p>\n<p>文件内容是Process类的包名+类名</p>\n<p><img src=\"http://img0.ph.126.net/Q4hJNglipWrhbm8BCEXaWg==/6631701084397122195.jpeg\" alt=\"\"></p>\n<p>忘记这个配置文件的后果就是，注解无法生效。</p>\n<h4 id=\"编译jar\"><a href=\"#编译jar\" class=\"headerlink\" title=\"编译jar\"></a>编译jar</h4><p>这里有一个坑，我们的主Module是不可以直接引用这个java Module的。（直接引用，可以成功运行一次~修改代码以后就不能运行了）</p>\n<p>而如何单独编译这个java Module呢？</p>\n<p>在编译器Gradle视图里，找到Module apt下的build目录下的Build按钮。双击运行。</p>\n<p><img src=\"http://img0.ph.126.net/VhQ-R3WDsxyN0Jj-tjlbOw==/6631456992815762880.jpeg\" alt=\"\"></p>\n<p>代码没有问题编译通过的话，会有BUILD SUCCESS提示</p>\n<p><img src=\"http://img1.ph.126.net/aLdtGF6QzHmAx9RgQA9xUg==/6631790144838976048.jpeg\" alt=\"\"></p>\n<p>生成的jar包在 apt 下的build目录下的libs下</p>\n<p><img src=\"http://img2.ph.126.net/RpZ7TNvkMhh16qZw1Mickg==/6631662601490157227.jpeg\" alt=\"\"></p>\n<p>将apt.jar拷贝到app下的libs目录，右键该jar，点击Add as Library，添加Library.</p>\n<p><img src=\"http://img2.ph.126.net/j5zjxfuq-5c7iitXiRIyvA==/6631606526397135920.jpeg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/BG1Js3oL3cgWFoiqyK2gGQ==/6631701084397122194.jpeg\" alt=\"\"></p>\n<p>在APP项目中使用该注解GetMsg。运行。</p>\n<p><img src=\"http://img2.ph.126.net/Qy8xMkNkIv20akzOwLwqpA==/6631748363397120041.jpegg\" alt=\"\"></p>\n<p><strong>当你apt这个包的代码有修改时，需要重复2.6这个步骤。这是比较烦的，但是没办法</strong></p>\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"http://img1.ph.126.net/TdCL0wMyvStVQ_yBDMst8Q==/6631771453141303831.jpeg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个Demo只是使用了注解，并且根据注解得到一些必要的信息。没有做代码生成的操作，生成代码的具体操作我们放到后面开始写框架时再讲。</p>\n<p>整个项目跑起来，遇到了比较多的坑，我们在下一章讲《Android编译时注解框架-爬坑》</p>\n<p>这个Demo的代码我放到了GitHub:</p>\n<p><a href=\"https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao\">https://github.com/lizhaoxuan/Android-APT-Framework/tree/master/run-demo/CakeDao</a></p>\n<p></br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p>《Android编译时注解框架-Run Demo》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架3-Run Project:OnceClick","date":"2016-07-17T07:40:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。\n\n本章将以生成代码为重点进行一个案例讲解。\n\n\n<!-- more -->\n\n\n### 框架名称：OnceClick\n\n**框架功能：**功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。\n\n**框架背景：**从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。\n\n**使用及项目引用地址：**[https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)\n\nOK，这是一个功能非常简单的小型类库。下面我们来实现它。\n\n\n### 项目搭建\n\n具体的项目搭建细节前一章已经有了介绍，这里不再讲述。\n\n**需要说明的是：**我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。\n\n项目目录结构如图：\n\nModule职责：\n\napp：Demo\n\napt：java Library.负责代码生成。编译成apt-jar包供外部使用\n\nonceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包\n\n![](http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg)\n\n\n\n### OnceClick使用\n\n\tpublic class MainActivity extends AppCompatActivity {\n\n    \tprivate TextView text;\n    \tprivate int num;\n\n    \t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n    \t    super.onCreate(savedInstanceState);\n    \t    setContentView(R.layout.activity_main);\n        \t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n    \t    OnceInit.once(this,2000);\n    \t    text = (TextView)findViewById(R.id.textView);\n    \t}\n\n    \t@OnceClick(R.id.btn)\n    \tpublic void once(){\n    \t    text.setText(\"click\"+num++);\n    \t    Log.d(\"tag\",\"once\");\n    \t}\n\n    \t@OnceClick(R.id.btn2)\n    \tpublic void onceMe(View v){\n    \t    ((Button)v).setText(\"click\"+num++);\n     \t   Log.d(\"tag\",\"onceMe\");\n    \t}\n\t}\n\t\n在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。\n\t\n![](http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg)\n\n\n### 生成后代码\n\n\t// Generated code from OnceClick. Do not modify!\n\tpackage com.lizhaoxuan.onceclickdemo;\n\n\timport android.view.View;\n\n\timport com.lizhaoxuan.onceclick.Finder;\n\timport com.lizhaoxuan.onceclick.AbstractInjector;\n\n\tpublic class MainActivity$$PROXY<T extends MainActivity> implements AbstractInjector<T> {\n\t\t//间隔多久可以执行一次点击事件\n    \tpublic long intervalTime;\n\n    \t@Override\n    \tpublic void setIntervalTime(long time) {\n    \t    intervalTime = time;\n    \t}\n\t\t\n    \t@Override\n    \tpublic void inject(final Finder finder, final T target, Object source) {\n        \tView view;\n        \tview = finder.findViewById(source, 2131492945);\n        \tif (view != null) {\n            \tview.setOnClickListener(new View.OnClickListener() {\n                \tlong time = 0L;\n                \t@Override\n                \tpublic void onClick(View v) {\n                    \tlong temp = System.currentTimeMillis();\n                    \tif (temp - time >= intervalTime) {\n                        \ttime = temp;\n                        \ttarget.once();\n                    \t}\n                \t}\n            \t});\n        \t}\n\t        view = finder.findViewById(source, 2131492946);\n\t        if (view != null) {\n\t            view.setOnClickListener(new View.OnClickListener() {\n\t                long time = 0L;\n\t                @Override\n\t                public void onClick(View v) {\n\t                    long temp = System.currentTimeMillis();\n\t                    if (temp - time >= intervalTime) {\n\t                        time = temp;\n\t                        target.onceMe(v);\n\t\t                    }\n\t                }\n            \t});\n        \t}\n    \t}\n\t}\n\n这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。\n\n================\n\n### OnceClick Module\n\n#### OnceInit.once\n\n看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下*OnceInit.java*一目了然，我在注释中做讲解:\n\n\tpublic class OnceInit {\n    \tprivate static final Map<Class<?>, AbstractInjector<Object>> INJECTORS = new LinkedHashMap<Class<?>, AbstractInjector<Object>>();\n\n    \tprivate static final long INTERVAL_TIME = 2000;\n\n    \tpublic static void once(Activity activity, long intervalTime) {\n    \t\t//生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n    \t    AbstractInjector<Object> injector = findInjector(activity);\n    \t    //执行生成代码中的inject方法\n    \t    //Finder是枚举，这里用Activity类型\n    \t    injector.inject(Finder.ACTIVITY, activity, activity);\n    \t    //设置间隔时间\n    \t    injector.setIntervalTime(intervalTime);\n    \t}\n\t\t\n\t\t//其他几个重载方法\n    \tpublic static void once(View view, long intervalTime) {\n    \t    AbstractInjector<Object> injector = findInjector(view);\n    \t    //Finder是枚举，这里用VIEW类型\n        \tinjector.inject(Finder.VIEW, view, view);\n        \tinjector.setIntervalTime(intervalTime);\n    \t}\n    \tpublic static void once(Activity activity) {\n        \tonce(activity, INTERVAL_TIME);\n    \t}\n    \tpublic static void once(View view) {\n        \tonce(view, INTERVAL_TIME);\n    \t}\n\t\t\n\t\t//查找生成的代码\n    \tprivate static AbstractInjector<Object> findInjector(Object activity) {\n        \tClass<?> clazz = activity.getClass();\n        \t//使用Map缓存一下，避免重复查找\n        \tAbstractInjector<Object> injector = INJECTORS.get(clazz);\n        \tif (injector == null) {\n            \ttry {\n            \t\t//生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                \tClass injectorClazz = Class.forName(clazz.getName() + \"$$\"\n                        + ProxyInfo.PROXY);\n                \tinjector = (AbstractInjector<Object>) injectorClazz\n                        .newInstance();\n                \tINJECTORS.put(clazz, injector);\n            \t} catch (Exception e) {\n                \te.printStackTrace();\n            \t}\n        \t}\n        \treturn injector;\n    \t}\n\t}\n\n\n\n#### AbstractInjector\n代理类接口，所有生成代码类都要实现这个接口。\n\ninject方法用于实现代理代码。\n\nsetIntervalTime设置点击事件执行间隔时间。\n\n\tpublic interface AbstractInjector<T> {\n\n    \tvoid inject(Finder finder, T target, Object source);\n\t\n    \tvoid setIntervalTime(long time);\n\t}\n\n\n#### Finder\n\nFinder的作用是根据不同的类型，去实现不同的findViewById方法。\n\n\tpublic enum Finder {\n    \tVIEW {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((View) source).findViewById(id);\n        \t}\n    \t},\n    \tACTIVITY {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((Activity) source).findViewById(id);\n        \t}\n    \t};\n    \tpublic abstract View findViewById(Object source, int id);\n\t}\n\n================\n\n### APT MODULE\n\n#### 自定义注解\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.METHOD)\n\tpublic @interface OnceClick {\n\n    \tint value();\n\t}\n\nOnceClick只有一个默认参数，用来设置View的Id。\n\n\n#### 配置文件\n\n编写文件javax.annotation.processing.Processor。\n\n\tcom.example.OnceClickProcessor\n\t\n![](http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg)\n\n\n#### Process类-getSupportedAnnotationTypes\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        types.add(OnceClick.class.getCanonicalName());\n        return types;\n    }\n    \n\n#### Process类-process方法\n\n重点来啦。这里需要讲一个概念。\n\n当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。\n\n所以，一个代理类可能有多个需要处理的View。\n\n先看process代码：\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //获取proxyMap\n        Map<String, ProxyInfo> proxyMap = getProxyMap(roundEnv);\n        //遍历proxyMap，并生成代码\n        for (String key : proxyMap.keySet()) {\n            ProxyInfo proxyInfo = proxyMap.get(key);\n            writeCode(proxyInfo);\n        }\n        return true;\n    }\n\n**ProxyInfo对象**：存放生成代理类的必要信息，并生成代码。\n\n**getProxyMap方法**：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。\n\n**writeCode方法**：真正生成代码的方法。\n\n\n总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。\n\n#### ProxyInfo代理类\n\n其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<OnceMethod> methods保存。**然后根据这些信息生成类。**\n\n\n\tpublic class ProxyInfo {\n\t    private String packageName;\n\t    private String targetClassName;\n\t    private String proxyClassName;\n\t    private TypeElement typeElement;\n\n\t    private List<OnceMethod> methods;\n\n\t    public static final String PROXY = \"PROXY\";\n\n\t    ProxyInfo(String packageName, String className) {\n\t        this.packageName = packageName;\n\t        this.targetClassName = className;\n\t        this.proxyClassName = className + \"$$\" + PROXY;\n\t    }\n\n\t    String getProxyClassFullName() {\n\t        return packageName + \".\" + proxyClassName;\n\t    }\n\n\t    String generateJavaCode() throws OnceClickException {\n\n\t        StringBuilder builder = new StringBuilder();\n\t        builder.append(\"// Generated code from OnceClick. Do not modify!\\n\");\n\t        builder.append(\"package \").append(packageName).append(\";\\n\\n\");\n\n\t        builder.append(\"import android.view.View;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.Finder;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.AbstractInjector;\\n\");\n\t        builder.append('\\n');\n\n\t        builder.append(\"public class \").append(proxyClassName);\n\t        builder.append(\"<T extends \").append(getTargetClassName()).append(\">\");\n\t        builder.append(\" implements AbstractInjector<T>\");\n\t        builder.append(\" {\\n\");\n\n\t        generateInjectMethod(builder);\n\t        builder.append('\\n');\n\n\t        builder.append(\"}\\n\");\n\t        return builder.toString();\n\n\t    }\n\n\t    private String getTargetClassName() {\n\t        return targetClassName.replace(\"$\", \".\");\n\t    }\n\n\t    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n\t        builder.append(\"public long intervalTime; \\n\");\n\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void setIntervalTime(long time) {\\n\")\n\t                .append(\"intervalTime = time;\\n     } \\n\");\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void inject(final Finder finder, final T target, Object source) {\\n\");\n\t        builder.append(\"View view;\");\n\n\t        for (OnceMethod method : getMethods()) {\n\t            builder.append(\"    view = \")\n\t                    .append(\"finder.findViewById(source, \")\n\t                    .append(method.getId())\n\t                    .append(\");\\n\");\n\t            builder.append(\"if(view != null){\")\n\t                    .append(\"view.setOnClickListener(new View.OnClickListener() {\\n\")\n\t                    .append(\"long time = 0L;\");\n\t            builder.append(\"@Override\\n\")\n\t                    .append(\"public void onClick(View v) {\");\n\t            builder.append(\"long temp = System.currentTimeMillis();\\n\")\n\t                    .append(\"if (temp - time >= intervalTime) {\\n\" +\n\t                            \t\"time = temp;\\n\");\n            \tif (method.getMethodParametersSize() == 1) {\n                \tif (method.getMethodParameters().get(0).equals(\"android.view.View\")) {\n                    \tbuilder.append(\"target.\").append(method.getMethodName()).append(\"(v);\");\n                \t} else {\n                    \tthrow new OnceClickException(\"Parameters must be android.view.View\");\n                \t}\n            \t} else if (method.getMethodParametersSize() == 0) {\n                builder.append(\"target.\").append(method.getMethodName()).append(\"();\");\n            \t} else {\n                \tthrow new OnceClickException(\"Does not support more than one parameter\");\n            \t}\n            \tbuilder.append(\"\\n}\")\n            \t        .append(\"    }\\n\")\n            \t        .append(\"        });\\n}\");\n        \t}\n\n        \tbuilder.append(\"  }\\n\");\n    \t}\n\n    \tTypeElement getTypeElement() {\n    \t    return typeElement;\n    \t}\n\n    \tvoid setTypeElement(TypeElement typeElement) {\n    \t    this.typeElement = typeElement;\n    \t}\n\n    \tList<OnceMethod> getMethods() {\n    \t    return methods == null ? new ArrayList<OnceMethod>() : methods;\n    \t}\n\n    \tvoid addMethod(OnceMethod onceMethod) {\n        \tif (methods == null) {\n            \tmethods = new ArrayList<>();\n        \t}\n        \tmethods.add(onceMethod);\n    \t}\n\t}\n\n\n#### OnceMethod类\n\n需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:\n\n\tpublic class OnceMethod {\n    \n        private int id;\n        private String methodName;\n        private List<String> methodParameters;\n    \n        OnceMethod(int id, String methodName, List<String> methodParameters) {\n            this.id = id;\n            this.methodName = methodName;\n            this.methodParameters = methodParameters;\n        }\n    \n        int getMethodParametersSize() {\n            return methodParameters == null ? 0 : methodParameters.size();\n        }\n    \n        int getId() {\n            return id;\n        }\n    \n        String getMethodName() {\n            return methodName;\n        }\n    \n        List<String> getMethodParameters() {\n            return methodParameters;\n        }\n    \n    }\n\n#### getProxyMap方法\n\ngetProxyMap其实也很简单的。通过注释就可以理解。\n\n比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。\n\n\tprivate Map<String, ProxyInfo> getProxyMap( RoundEnvironment roundEnv){\n        Map<String, ProxyInfo> proxyMap = new HashMap<>();\n        //遍历项目中所有的@OnceClick注解\n        for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\t\t\t\n        \t//获取基本的类名、包名\n            TypeElement classElement = (TypeElement) element;\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n\n            String fullClassName = classElement.getQualifiedName().toString();\n            String className = classElement.getSimpleName().toString();\n            String packageName = packageElement.getQualifiedName().toString();\n            //获取注解参数\n            int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n            ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n            //如果以创建该代理类，就只add viewId\n            if (proxyInfo != null) {\n                proxyInfo.addLayoutId(viewId);\n            } else {\n                proxyInfo = new ProxyInfo(packageName, className);\n                proxyInfo.setTypeElement(classElement);\n                proxyInfo.addLayoutId(viewId);\n                proxyMap.put(fullClassName, proxyInfo);\n            }\n        }\n        return proxyMap;\n    }\n\n#### writeCode方法\n\nwriteCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。\n\n需要注意的是 *writer.write(proxyInfo.generateJavaCode());*。需要生成的代码以字符串形式传给writer。\n\n\tprivate void writeCode(ProxyInfo proxyInfo){\n        try {\n            JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                    proxyInfo.getProxyClassFullName(),\n                    proxyInfo.getTypeElement());\n            Writer writer = jfo.openWriter();\n            writer.write(proxyInfo.generateJavaCode());\n            writer.flush();\n            writer.close();\n        } catch (IOException e) {\n            error(proxyInfo.getTypeElement(),\n                    \"Unable to write injector for type %s: %s\",\n                    proxyInfo.getTypeElement(), e.getMessage());\n        }\n    }\n    \n    //两个日志输出方法。\n    private void print(String message){\n        messager.printMessage(Diagnostic.Kind.NOTE, message);\n    }\n\n    private void error(Element element, String message, Object... args) {\n        if (args.length > 0) {\n            message = String.format(message, args);\n        }\n        messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n    }\n\n\n\n### 结论\n\n这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？\n\n\t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n\tOnceInit.once(this,2000);\n\t\n技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。\n\n每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：\n\n\t@OnceClick(R.id.btn)\n如果有两个属性，就必须要带名字了 \n\n\t@OnceClick(id = R.id.btn)\n\n最后在把源码地址再放一下 [https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)。看着Demo学习会更快！\n\n</br>\n\n--------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n《Android编译时注解框架-Run Project：OnceClick》\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n","source":"_posts/apt-run_project.md","raw":"\n---\ntitle: Android编译时注解框架3-Run Project:OnceClick\ndate: 2016-07-17 15:40:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。\n\n本章将以生成代码为重点进行一个案例讲解。\n\n\n<!-- more -->\n\n\n### 框架名称：OnceClick\n\n**框架功能：**功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。\n\n**框架背景：**从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。\n\n**使用及项目引用地址：**[https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)\n\nOK，这是一个功能非常简单的小型类库。下面我们来实现它。\n\n\n### 项目搭建\n\n具体的项目搭建细节前一章已经有了介绍，这里不再讲述。\n\n**需要说明的是：**我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。\n\n项目目录结构如图：\n\nModule职责：\n\napp：Demo\n\napt：java Library.负责代码生成。编译成apt-jar包供外部使用\n\nonceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包\n\n![](http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg)\n\n\n\n### OnceClick使用\n\n\tpublic class MainActivity extends AppCompatActivity {\n\n    \tprivate TextView text;\n    \tprivate int num;\n\n    \t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n    \t    super.onCreate(savedInstanceState);\n    \t    setContentView(R.layout.activity_main);\n        \t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n    \t    OnceInit.once(this,2000);\n    \t    text = (TextView)findViewById(R.id.textView);\n    \t}\n\n    \t@OnceClick(R.id.btn)\n    \tpublic void once(){\n    \t    text.setText(\"click\"+num++);\n    \t    Log.d(\"tag\",\"once\");\n    \t}\n\n    \t@OnceClick(R.id.btn2)\n    \tpublic void onceMe(View v){\n    \t    ((Button)v).setText(\"click\"+num++);\n     \t   Log.d(\"tag\",\"onceMe\");\n    \t}\n\t}\n\t\n在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。\n\t\n![](http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg)\n\n\n### 生成后代码\n\n\t// Generated code from OnceClick. Do not modify!\n\tpackage com.lizhaoxuan.onceclickdemo;\n\n\timport android.view.View;\n\n\timport com.lizhaoxuan.onceclick.Finder;\n\timport com.lizhaoxuan.onceclick.AbstractInjector;\n\n\tpublic class MainActivity$$PROXY<T extends MainActivity> implements AbstractInjector<T> {\n\t\t//间隔多久可以执行一次点击事件\n    \tpublic long intervalTime;\n\n    \t@Override\n    \tpublic void setIntervalTime(long time) {\n    \t    intervalTime = time;\n    \t}\n\t\t\n    \t@Override\n    \tpublic void inject(final Finder finder, final T target, Object source) {\n        \tView view;\n        \tview = finder.findViewById(source, 2131492945);\n        \tif (view != null) {\n            \tview.setOnClickListener(new View.OnClickListener() {\n                \tlong time = 0L;\n                \t@Override\n                \tpublic void onClick(View v) {\n                    \tlong temp = System.currentTimeMillis();\n                    \tif (temp - time >= intervalTime) {\n                        \ttime = temp;\n                        \ttarget.once();\n                    \t}\n                \t}\n            \t});\n        \t}\n\t        view = finder.findViewById(source, 2131492946);\n\t        if (view != null) {\n\t            view.setOnClickListener(new View.OnClickListener() {\n\t                long time = 0L;\n\t                @Override\n\t                public void onClick(View v) {\n\t                    long temp = System.currentTimeMillis();\n\t                    if (temp - time >= intervalTime) {\n\t                        time = temp;\n\t                        target.onceMe(v);\n\t\t                    }\n\t                }\n            \t});\n        \t}\n    \t}\n\t}\n\n这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。\n\n================\n\n### OnceClick Module\n\n#### OnceInit.once\n\n看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下*OnceInit.java*一目了然，我在注释中做讲解:\n\n\tpublic class OnceInit {\n    \tprivate static final Map<Class<?>, AbstractInjector<Object>> INJECTORS = new LinkedHashMap<Class<?>, AbstractInjector<Object>>();\n\n    \tprivate static final long INTERVAL_TIME = 2000;\n\n    \tpublic static void once(Activity activity, long intervalTime) {\n    \t\t//生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n    \t    AbstractInjector<Object> injector = findInjector(activity);\n    \t    //执行生成代码中的inject方法\n    \t    //Finder是枚举，这里用Activity类型\n    \t    injector.inject(Finder.ACTIVITY, activity, activity);\n    \t    //设置间隔时间\n    \t    injector.setIntervalTime(intervalTime);\n    \t}\n\t\t\n\t\t//其他几个重载方法\n    \tpublic static void once(View view, long intervalTime) {\n    \t    AbstractInjector<Object> injector = findInjector(view);\n    \t    //Finder是枚举，这里用VIEW类型\n        \tinjector.inject(Finder.VIEW, view, view);\n        \tinjector.setIntervalTime(intervalTime);\n    \t}\n    \tpublic static void once(Activity activity) {\n        \tonce(activity, INTERVAL_TIME);\n    \t}\n    \tpublic static void once(View view) {\n        \tonce(view, INTERVAL_TIME);\n    \t}\n\t\t\n\t\t//查找生成的代码\n    \tprivate static AbstractInjector<Object> findInjector(Object activity) {\n        \tClass<?> clazz = activity.getClass();\n        \t//使用Map缓存一下，避免重复查找\n        \tAbstractInjector<Object> injector = INJECTORS.get(clazz);\n        \tif (injector == null) {\n            \ttry {\n            \t\t//生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                \tClass injectorClazz = Class.forName(clazz.getName() + \"$$\"\n                        + ProxyInfo.PROXY);\n                \tinjector = (AbstractInjector<Object>) injectorClazz\n                        .newInstance();\n                \tINJECTORS.put(clazz, injector);\n            \t} catch (Exception e) {\n                \te.printStackTrace();\n            \t}\n        \t}\n        \treturn injector;\n    \t}\n\t}\n\n\n\n#### AbstractInjector\n代理类接口，所有生成代码类都要实现这个接口。\n\ninject方法用于实现代理代码。\n\nsetIntervalTime设置点击事件执行间隔时间。\n\n\tpublic interface AbstractInjector<T> {\n\n    \tvoid inject(Finder finder, T target, Object source);\n\t\n    \tvoid setIntervalTime(long time);\n\t}\n\n\n#### Finder\n\nFinder的作用是根据不同的类型，去实现不同的findViewById方法。\n\n\tpublic enum Finder {\n    \tVIEW {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((View) source).findViewById(id);\n        \t}\n    \t},\n    \tACTIVITY {\n        \t@Override\n        \tpublic View findViewById(Object source, int id) {\n            \treturn ((Activity) source).findViewById(id);\n        \t}\n    \t};\n    \tpublic abstract View findViewById(Object source, int id);\n\t}\n\n================\n\n### APT MODULE\n\n#### 自定义注解\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@Target(ElementType.METHOD)\n\tpublic @interface OnceClick {\n\n    \tint value();\n\t}\n\nOnceClick只有一个默认参数，用来设置View的Id。\n\n\n#### 配置文件\n\n编写文件javax.annotation.processing.Processor。\n\n\tcom.example.OnceClickProcessor\n\t\n![](http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg)\n\n\n#### Process类-getSupportedAnnotationTypes\n\n\t@Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> types = new LinkedHashSet<>();\n        types.add(OnceClick.class.getCanonicalName());\n        return types;\n    }\n    \n\n#### Process类-process方法\n\n重点来啦。这里需要讲一个概念。\n\n当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。\n\n所以，一个代理类可能有多个需要处理的View。\n\n先看process代码：\n\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //获取proxyMap\n        Map<String, ProxyInfo> proxyMap = getProxyMap(roundEnv);\n        //遍历proxyMap，并生成代码\n        for (String key : proxyMap.keySet()) {\n            ProxyInfo proxyInfo = proxyMap.get(key);\n            writeCode(proxyInfo);\n        }\n        return true;\n    }\n\n**ProxyInfo对象**：存放生成代理类的必要信息，并生成代码。\n\n**getProxyMap方法**：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。\n\n**writeCode方法**：真正生成代码的方法。\n\n\n总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。\n\n#### ProxyInfo代理类\n\n其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<OnceMethod> methods保存。**然后根据这些信息生成类。**\n\n\n\tpublic class ProxyInfo {\n\t    private String packageName;\n\t    private String targetClassName;\n\t    private String proxyClassName;\n\t    private TypeElement typeElement;\n\n\t    private List<OnceMethod> methods;\n\n\t    public static final String PROXY = \"PROXY\";\n\n\t    ProxyInfo(String packageName, String className) {\n\t        this.packageName = packageName;\n\t        this.targetClassName = className;\n\t        this.proxyClassName = className + \"$$\" + PROXY;\n\t    }\n\n\t    String getProxyClassFullName() {\n\t        return packageName + \".\" + proxyClassName;\n\t    }\n\n\t    String generateJavaCode() throws OnceClickException {\n\n\t        StringBuilder builder = new StringBuilder();\n\t        builder.append(\"// Generated code from OnceClick. Do not modify!\\n\");\n\t        builder.append(\"package \").append(packageName).append(\";\\n\\n\");\n\n\t        builder.append(\"import android.view.View;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.Finder;\\n\");\n\t        builder.append(\"import com.lizhaoxuan.onceclick.AbstractInjector;\\n\");\n\t        builder.append('\\n');\n\n\t        builder.append(\"public class \").append(proxyClassName);\n\t        builder.append(\"<T extends \").append(getTargetClassName()).append(\">\");\n\t        builder.append(\" implements AbstractInjector<T>\");\n\t        builder.append(\" {\\n\");\n\n\t        generateInjectMethod(builder);\n\t        builder.append('\\n');\n\n\t        builder.append(\"}\\n\");\n\t        return builder.toString();\n\n\t    }\n\n\t    private String getTargetClassName() {\n\t        return targetClassName.replace(\"$\", \".\");\n\t    }\n\n\t    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n\t        builder.append(\"public long intervalTime; \\n\");\n\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void setIntervalTime(long time) {\\n\")\n\t                .append(\"intervalTime = time;\\n     } \\n\");\n\t        builder.append(\"  @Override \")\n\t                .append(\"public void inject(final Finder finder, final T target, Object source) {\\n\");\n\t        builder.append(\"View view;\");\n\n\t        for (OnceMethod method : getMethods()) {\n\t            builder.append(\"    view = \")\n\t                    .append(\"finder.findViewById(source, \")\n\t                    .append(method.getId())\n\t                    .append(\");\\n\");\n\t            builder.append(\"if(view != null){\")\n\t                    .append(\"view.setOnClickListener(new View.OnClickListener() {\\n\")\n\t                    .append(\"long time = 0L;\");\n\t            builder.append(\"@Override\\n\")\n\t                    .append(\"public void onClick(View v) {\");\n\t            builder.append(\"long temp = System.currentTimeMillis();\\n\")\n\t                    .append(\"if (temp - time >= intervalTime) {\\n\" +\n\t                            \t\"time = temp;\\n\");\n            \tif (method.getMethodParametersSize() == 1) {\n                \tif (method.getMethodParameters().get(0).equals(\"android.view.View\")) {\n                    \tbuilder.append(\"target.\").append(method.getMethodName()).append(\"(v);\");\n                \t} else {\n                    \tthrow new OnceClickException(\"Parameters must be android.view.View\");\n                \t}\n            \t} else if (method.getMethodParametersSize() == 0) {\n                builder.append(\"target.\").append(method.getMethodName()).append(\"();\");\n            \t} else {\n                \tthrow new OnceClickException(\"Does not support more than one parameter\");\n            \t}\n            \tbuilder.append(\"\\n}\")\n            \t        .append(\"    }\\n\")\n            \t        .append(\"        });\\n}\");\n        \t}\n\n        \tbuilder.append(\"  }\\n\");\n    \t}\n\n    \tTypeElement getTypeElement() {\n    \t    return typeElement;\n    \t}\n\n    \tvoid setTypeElement(TypeElement typeElement) {\n    \t    this.typeElement = typeElement;\n    \t}\n\n    \tList<OnceMethod> getMethods() {\n    \t    return methods == null ? new ArrayList<OnceMethod>() : methods;\n    \t}\n\n    \tvoid addMethod(OnceMethod onceMethod) {\n        \tif (methods == null) {\n            \tmethods = new ArrayList<>();\n        \t}\n        \tmethods.add(onceMethod);\n    \t}\n\t}\n\n\n#### OnceMethod类\n\n需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:\n\n\tpublic class OnceMethod {\n    \n        private int id;\n        private String methodName;\n        private List<String> methodParameters;\n    \n        OnceMethod(int id, String methodName, List<String> methodParameters) {\n            this.id = id;\n            this.methodName = methodName;\n            this.methodParameters = methodParameters;\n        }\n    \n        int getMethodParametersSize() {\n            return methodParameters == null ? 0 : methodParameters.size();\n        }\n    \n        int getId() {\n            return id;\n        }\n    \n        String getMethodName() {\n            return methodName;\n        }\n    \n        List<String> getMethodParameters() {\n            return methodParameters;\n        }\n    \n    }\n\n#### getProxyMap方法\n\ngetProxyMap其实也很简单的。通过注释就可以理解。\n\n比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。\n\n\tprivate Map<String, ProxyInfo> getProxyMap( RoundEnvironment roundEnv){\n        Map<String, ProxyInfo> proxyMap = new HashMap<>();\n        //遍历项目中所有的@OnceClick注解\n        for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {\t\t\t\n        \t//获取基本的类名、包名\n            TypeElement classElement = (TypeElement) element;\n            PackageElement packageElement = (PackageElement) element\n                    .getEnclosingElement();\n\n            String fullClassName = classElement.getQualifiedName().toString();\n            String className = classElement.getSimpleName().toString();\n            String packageName = packageElement.getQualifiedName().toString();\n            //获取注解参数\n            int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n            ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n            //如果以创建该代理类，就只add viewId\n            if (proxyInfo != null) {\n                proxyInfo.addLayoutId(viewId);\n            } else {\n                proxyInfo = new ProxyInfo(packageName, className);\n                proxyInfo.setTypeElement(classElement);\n                proxyInfo.addLayoutId(viewId);\n                proxyMap.put(fullClassName, proxyInfo);\n            }\n        }\n        return proxyMap;\n    }\n\n#### writeCode方法\n\nwriteCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。\n\n需要注意的是 *writer.write(proxyInfo.generateJavaCode());*。需要生成的代码以字符串形式传给writer。\n\n\tprivate void writeCode(ProxyInfo proxyInfo){\n        try {\n            JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                    proxyInfo.getProxyClassFullName(),\n                    proxyInfo.getTypeElement());\n            Writer writer = jfo.openWriter();\n            writer.write(proxyInfo.generateJavaCode());\n            writer.flush();\n            writer.close();\n        } catch (IOException e) {\n            error(proxyInfo.getTypeElement(),\n                    \"Unable to write injector for type %s: %s\",\n                    proxyInfo.getTypeElement(), e.getMessage());\n        }\n    }\n    \n    //两个日志输出方法。\n    private void print(String message){\n        messager.printMessage(Diagnostic.Kind.NOTE, message);\n    }\n\n    private void error(Element element, String message, Object... args) {\n        if (args.length > 0) {\n            message = String.format(message, args);\n        }\n        messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n    }\n\n\n\n### 结论\n\n这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？\n\n\t//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n\tOnceInit.once(this,2000);\n\t\n技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。\n\n每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：\n\n\t@OnceClick(R.id.btn)\n如果有两个属性，就必须要带名字了 \n\n\t@OnceClick(id = R.id.btn)\n\n最后在把源码地址再放一下 [https://github.com/lizhaoxuan/OnceClick](https://github.com/lizhaoxuan/OnceClick)。看着Demo学习会更快！\n\n</br>\n\n--------\n\n\n[《Android编译时注解框架-什么是编译时注解》](https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/)\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n《Android编译时注解框架-Run Project：OnceClick》\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n","slug":"apt-run_project","published":1,"updated":"2017-01-16T05:12:58.000Z","_id":"cixzmux3g000cq4ch7v01ookx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。</p>\n<p>本章将以生成代码为重点进行一个案例讲解。</p>\n<a id=\"more\"></a>\n<h3 id=\"框架名称：OnceClick\"><a href=\"#框架名称：OnceClick\" class=\"headerlink\" title=\"框架名称：OnceClick\"></a>框架名称：OnceClick</h3><p><strong>框架功能：</strong>功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。</p>\n<p><strong>框架背景：</strong>从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。</p>\n<p><strong>使用及项目引用地址：</strong><a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/OnceClick</a></p>\n<p>OK，这是一个功能非常简单的小型类库。下面我们来实现它。</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><p>具体的项目搭建细节前一章已经有了介绍，这里不再讲述。</p>\n<p><strong>需要说明的是：</strong>我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。</p>\n<p>项目目录结构如图：</p>\n<p>Module职责：</p>\n<p>app：Demo</p>\n<p>apt：java Library.负责代码生成。编译成apt-jar包供外部使用</p>\n<p>onceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包</p>\n<p><img src=\"http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg\" alt=\"\"></p>\n<h3 id=\"OnceClick使用\"><a href=\"#OnceClick使用\" class=\"headerlink\" title=\"OnceClick使用\"></a>OnceClick使用</h3><pre><code>public class MainActivity extends AppCompatActivity {\n\n    private TextView text;\n    private int num;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        //类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n        OnceInit.once(this,2000);\n        text = (TextView)findViewById(R.id.textView);\n    }\n\n    @OnceClick(R.id.btn)\n    public void once(){\n        text.setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;once&quot;);\n    }\n\n    @OnceClick(R.id.btn2)\n    public void onceMe(View v){\n        ((Button)v).setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;onceMe&quot;);\n    }\n}\n</code></pre><p>在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。</p>\n<p><img src=\"http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg\" alt=\"\"></p>\n<h3 id=\"生成后代码\"><a href=\"#生成后代码\" class=\"headerlink\" title=\"生成后代码\"></a>生成后代码</h3><pre><code>// Generated code from OnceClick. Do not modify!\npackage com.lizhaoxuan.onceclickdemo;\n\nimport android.view.View;\n\nimport com.lizhaoxuan.onceclick.Finder;\nimport com.lizhaoxuan.onceclick.AbstractInjector;\n\npublic class MainActivity$$PROXY&lt;T extends MainActivity&gt; implements AbstractInjector&lt;T&gt; {\n    //间隔多久可以执行一次点击事件\n    public long intervalTime;\n\n    @Override\n    public void setIntervalTime(long time) {\n        intervalTime = time;\n    }\n\n    @Override\n    public void inject(final Finder finder, final T target, Object source) {\n        View view;\n        view = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n        view = finder.findViewById(source, 2131492946);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.onceMe(v);\n                        }\n                }\n            });\n        }\n    }\n}\n</code></pre><p>这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。</p>\n<p>================</p>\n<h3 id=\"OnceClick-Module\"><a href=\"#OnceClick-Module\" class=\"headerlink\" title=\"OnceClick Module\"></a>OnceClick Module</h3><h4 id=\"OnceInit-once\"><a href=\"#OnceInit-once\" class=\"headerlink\" title=\"OnceInit.once\"></a>OnceInit.once</h4><p>看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下<em>OnceInit.java</em>一目了然，我在注释中做讲解:</p>\n<pre><code>public class OnceInit {\n    private static final Map&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt; INJECTORS = new LinkedHashMap&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt;();\n\n    private static final long INTERVAL_TIME = 2000;\n\n    public static void once(Activity activity, long intervalTime) {\n        //生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n        AbstractInjector&lt;Object&gt; injector = findInjector(activity);\n        //执行生成代码中的inject方法\n        //Finder是枚举，这里用Activity类型\n        injector.inject(Finder.ACTIVITY, activity, activity);\n        //设置间隔时间\n        injector.setIntervalTime(intervalTime);\n    }\n\n    //其他几个重载方法\n    public static void once(View view, long intervalTime) {\n        AbstractInjector&lt;Object&gt; injector = findInjector(view);\n        //Finder是枚举，这里用VIEW类型\n        injector.inject(Finder.VIEW, view, view);\n        injector.setIntervalTime(intervalTime);\n    }\n    public static void once(Activity activity) {\n        once(activity, INTERVAL_TIME);\n    }\n    public static void once(View view) {\n        once(view, INTERVAL_TIME);\n    }\n\n    //查找生成的代码\n    private static AbstractInjector&lt;Object&gt; findInjector(Object activity) {\n        Class&lt;?&gt; clazz = activity.getClass();\n        //使用Map缓存一下，避免重复查找\n        AbstractInjector&lt;Object&gt; injector = INJECTORS.get(clazz);\n        if (injector == null) {\n            try {\n                //生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                Class injectorClazz = Class.forName(clazz.getName() + &quot;$$&quot;\n                    + ProxyInfo.PROXY);\n                injector = (AbstractInjector&lt;Object&gt;) injectorClazz\n                    .newInstance();\n                INJECTORS.put(clazz, injector);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return injector;\n    }\n}\n</code></pre><h4 id=\"AbstractInjector\"><a href=\"#AbstractInjector\" class=\"headerlink\" title=\"AbstractInjector\"></a>AbstractInjector</h4><p>代理类接口，所有生成代码类都要实现这个接口。</p>\n<p>inject方法用于实现代理代码。</p>\n<p>setIntervalTime设置点击事件执行间隔时间。</p>\n<pre><code>public interface AbstractInjector&lt;T&gt; {\n\n    void inject(Finder finder, T target, Object source);\n\n    void setIntervalTime(long time);\n}\n</code></pre><h4 id=\"Finder\"><a href=\"#Finder\" class=\"headerlink\" title=\"Finder\"></a>Finder</h4><p>Finder的作用是根据不同的类型，去实现不同的findViewById方法。</p>\n<pre><code>public enum Finder {\n    VIEW {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((View) source).findViewById(id);\n        }\n    },\n    ACTIVITY {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((Activity) source).findViewById(id);\n        }\n    };\n    public abstract View findViewById(Object source, int id);\n}\n</code></pre><p>================</p>\n<h3 id=\"APT-MODULE\"><a href=\"#APT-MODULE\" class=\"headerlink\" title=\"APT MODULE\"></a>APT MODULE</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\npublic @interface OnceClick {\n\n    int value();\n}\n</code></pre><p>OnceClick只有一个默认参数，用来设置View的Id。</p>\n<h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>编写文件javax.annotation.processing.Processor。</p>\n<pre><code>com.example.OnceClickProcessor\n</code></pre><p><img src=\"http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg\" alt=\"\"></p>\n<h4 id=\"Process类-getSupportedAnnotationTypes\"><a href=\"#Process类-getSupportedAnnotationTypes\" class=\"headerlink\" title=\"Process类-getSupportedAnnotationTypes\"></a>Process类-getSupportedAnnotationTypes</h4><pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    types.add(OnceClick.class.getCanonicalName());\n    return types;\n}\n</code></pre><h4 id=\"Process类-process方法\"><a href=\"#Process类-process方法\" class=\"headerlink\" title=\"Process类-process方法\"></a>Process类-process方法</h4><p>重点来啦。这里需要讲一个概念。</p>\n<p>当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。</p>\n<p>所以，一个代理类可能有多个需要处理的View。</p>\n<p>先看process代码：</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    //获取proxyMap\n    Map&lt;String, ProxyInfo&gt; proxyMap = getProxyMap(roundEnv);\n    //遍历proxyMap，并生成代码\n    for (String key : proxyMap.keySet()) {\n        ProxyInfo proxyInfo = proxyMap.get(key);\n        writeCode(proxyInfo);\n    }\n    return true;\n}\n</code></pre><p><strong>ProxyInfo对象</strong>：存放生成代理类的必要信息，并生成代码。</p>\n<p><strong>getProxyMap方法</strong>：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。</p>\n<p><strong>writeCode方法</strong>：真正生成代码的方法。</p>\n<p>总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。</p>\n<h4 id=\"ProxyInfo代理类\"><a href=\"#ProxyInfo代理类\" class=\"headerlink\" title=\"ProxyInfo代理类\"></a>ProxyInfo代理类</h4><p>其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<oncemethod> methods保存。<strong>然后根据这些信息生成类。</strong></oncemethod></p>\n<pre><code>public class ProxyInfo {\n    private String packageName;\n    private String targetClassName;\n    private String proxyClassName;\n    private TypeElement typeElement;\n\n    private List&lt;OnceMethod&gt; methods;\n\n    public static final String PROXY = &quot;PROXY&quot;;\n\n    ProxyInfo(String packageName, String className) {\n        this.packageName = packageName;\n        this.targetClassName = className;\n        this.proxyClassName = className + &quot;$$&quot; + PROXY;\n    }\n\n    String getProxyClassFullName() {\n        return packageName + &quot;.&quot; + proxyClassName;\n    }\n\n    String generateJavaCode() throws OnceClickException {\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(&quot;// Generated code from OnceClick. Do not modify!\\n&quot;);\n        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\\n\\n&quot;);\n\n        builder.append(&quot;import android.view.View;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.Finder;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.AbstractInjector;\\n&quot;);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;public class &quot;).append(proxyClassName);\n        builder.append(&quot;&lt;T extends &quot;).append(getTargetClassName()).append(&quot;&gt;&quot;);\n        builder.append(&quot; implements AbstractInjector&lt;T&gt;&quot;);\n        builder.append(&quot; {\\n&quot;);\n\n        generateInjectMethod(builder);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;}\\n&quot;);\n        return builder.toString();\n\n    }\n\n    private String getTargetClassName() {\n        return targetClassName.replace(&quot;$&quot;, &quot;.&quot;);\n    }\n\n    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n        builder.append(&quot;public long intervalTime; \\n&quot;);\n\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void setIntervalTime(long time) {\\n&quot;)\n                .append(&quot;intervalTime = time;\\n     } \\n&quot;);\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void inject(final Finder finder, final T target, Object source) {\\n&quot;);\n        builder.append(&quot;View view;&quot;);\n\n        for (OnceMethod method : getMethods()) {\n            builder.append(&quot;    view = &quot;)\n                    .append(&quot;finder.findViewById(source, &quot;)\n                    .append(method.getId())\n                    .append(&quot;);\\n&quot;);\n            builder.append(&quot;if(view != null){&quot;)\n                    .append(&quot;view.setOnClickListener(new View.OnClickListener() {\\n&quot;)\n                    .append(&quot;long time = 0L;&quot;);\n            builder.append(&quot;@Override\\n&quot;)\n                    .append(&quot;public void onClick(View v) {&quot;);\n            builder.append(&quot;long temp = System.currentTimeMillis();\\n&quot;)\n                    .append(&quot;if (temp - time &gt;= intervalTime) {\\n&quot; +\n                                &quot;time = temp;\\n&quot;);\n            if (method.getMethodParametersSize() == 1) {\n                if (method.getMethodParameters().get(0).equals(&quot;android.view.View&quot;)) {\n                    builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;(v);&quot;);\n                } else {\n                    throw new OnceClickException(&quot;Parameters must be android.view.View&quot;);\n                }\n            } else if (method.getMethodParametersSize() == 0) {\n            builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;();&quot;);\n            } else {\n                throw new OnceClickException(&quot;Does not support more than one parameter&quot;);\n            }\n            builder.append(&quot;\\n}&quot;)\n                    .append(&quot;    }\\n&quot;)\n                    .append(&quot;        });\\n}&quot;);\n        }\n\n        builder.append(&quot;  }\\n&quot;);\n    }\n\n    TypeElement getTypeElement() {\n        return typeElement;\n    }\n\n    void setTypeElement(TypeElement typeElement) {\n        this.typeElement = typeElement;\n    }\n\n    List&lt;OnceMethod&gt; getMethods() {\n        return methods == null ? new ArrayList&lt;OnceMethod&gt;() : methods;\n    }\n\n    void addMethod(OnceMethod onceMethod) {\n        if (methods == null) {\n            methods = new ArrayList&lt;&gt;();\n        }\n        methods.add(onceMethod);\n    }\n}\n</code></pre><h4 id=\"OnceMethod类\"><a href=\"#OnceMethod类\" class=\"headerlink\" title=\"OnceMethod类\"></a>OnceMethod类</h4><p>需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:</p>\n<pre><code>public class OnceMethod {\n\n    private int id;\n    private String methodName;\n    private List&lt;String&gt; methodParameters;\n\n    OnceMethod(int id, String methodName, List&lt;String&gt; methodParameters) {\n        this.id = id;\n        this.methodName = methodName;\n        this.methodParameters = methodParameters;\n    }\n\n    int getMethodParametersSize() {\n        return methodParameters == null ? 0 : methodParameters.size();\n    }\n\n    int getId() {\n        return id;\n    }\n\n    String getMethodName() {\n        return methodName;\n    }\n\n    List&lt;String&gt; getMethodParameters() {\n        return methodParameters;\n    }\n\n}\n</code></pre><h4 id=\"getProxyMap方法\"><a href=\"#getProxyMap方法\" class=\"headerlink\" title=\"getProxyMap方法\"></a>getProxyMap方法</h4><p>getProxyMap其实也很简单的。通过注释就可以理解。</p>\n<p>比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。</p>\n<pre><code>private Map&lt;String, ProxyInfo&gt; getProxyMap( RoundEnvironment roundEnv){\n    Map&lt;String, ProxyInfo&gt; proxyMap = new HashMap&lt;&gt;();\n    //遍历项目中所有的@OnceClick注解\n    for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {            \n        //获取基本的类名、包名\n        TypeElement classElement = (TypeElement) element;\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n        String fullClassName = classElement.getQualifiedName().toString();\n        String className = classElement.getSimpleName().toString();\n        String packageName = packageElement.getQualifiedName().toString();\n        //获取注解参数\n        int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n        ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n        //如果以创建该代理类，就只add viewId\n        if (proxyInfo != null) {\n            proxyInfo.addLayoutId(viewId);\n        } else {\n            proxyInfo = new ProxyInfo(packageName, className);\n            proxyInfo.setTypeElement(classElement);\n            proxyInfo.addLayoutId(viewId);\n            proxyMap.put(fullClassName, proxyInfo);\n        }\n    }\n    return proxyMap;\n}\n</code></pre><h4 id=\"writeCode方法\"><a href=\"#writeCode方法\" class=\"headerlink\" title=\"writeCode方法\"></a>writeCode方法</h4><p>writeCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。</p>\n<p>需要注意的是 <em>writer.write(proxyInfo.generateJavaCode());</em>。需要生成的代码以字符串形式传给writer。</p>\n<pre><code>private void writeCode(ProxyInfo proxyInfo){\n    try {\n        JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                proxyInfo.getProxyClassFullName(),\n                proxyInfo.getTypeElement());\n        Writer writer = jfo.openWriter();\n        writer.write(proxyInfo.generateJavaCode());\n        writer.flush();\n        writer.close();\n    } catch (IOException e) {\n        error(proxyInfo.getTypeElement(),\n                &quot;Unable to write injector for type %s: %s&quot;,\n                proxyInfo.getTypeElement(), e.getMessage());\n    }\n}\n\n//两个日志输出方法。\nprivate void print(String message){\n    messager.printMessage(Diagnostic.Kind.NOTE, message);\n}\n\nprivate void error(Element element, String message, Object... args) {\n    if (args.length &gt; 0) {\n        message = String.format(message, args);\n    }\n    messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n}\n</code></pre><h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？</p>\n<pre><code>//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\nOnceInit.once(this,2000);\n</code></pre><p>技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。</p>\n<p>每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：</p>\n<pre><code>@OnceClick(R.id.btn)\n</code></pre><p>如果有两个属性，就必须要带名字了 </p>\n<pre><code>@OnceClick(id = R.id.btn)\n</code></pre><p>最后在把源码地址再放一下 <a href=\"https://github.com/lizhaoxuan/OnceClick\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/OnceClick</a>。看着Demo学习会更快！</p>\n<p><br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p>《Android编译时注解框架-Run Project：OnceClick》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>因为编译时注解框架前期项目搭建部分需要较多的图文讲解，所以前一章《Android编译时注解框架-Run Demo》只是实现了最简单应用，或许注解信息，并没有生成代码。</p>\n<p>本章将以生成代码为重点进行一个案例讲解。</p>","more":"<h3 id=\"框架名称：OnceClick\"><a href=\"#框架名称：OnceClick\" class=\"headerlink\" title=\"框架名称：OnceClick\"></a>框架名称：OnceClick</h3><p><strong>框架功能：</strong>功能就是它的名字：在一定时间内，按钮点击事件只能执行一次。未到指定时间，不执行点击事件。</p>\n<p><strong>框架背景：</strong>从用户的角度，在使用应用的过程中，因为低端机性能原因、Web页面性能问题，导致点击按钮后程序卡顿，按钮事件延迟执行。造成的后果就是，卡顿后，继续多次点击非常容易导致事件多次执行，造成不可预知的Bug，且影响用户体验。</p>\n<p><strong>使用及项目引用地址：</strong><a href=\"https://github.com/lizhaoxuan/OnceClick\">https://github.com/lizhaoxuan/OnceClick</a></p>\n<p>OK，这是一个功能非常简单的小型类库。下面我们来实现它。</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><p>具体的项目搭建细节前一章已经有了介绍，这里不再讲述。</p>\n<p><strong>需要说明的是：</strong>我们的目的是写一个Android库，APT Moudle是java Library，不能使用Android API。所以还需要创建一个Android Library，负责框架主体部分. 然后由Android Library引用APT jar包。</p>\n<p>项目目录结构如图：</p>\n<p>Module职责：</p>\n<p>app：Demo</p>\n<p>apt：java Library.负责代码生成。编译成apt-jar包供外部使用</p>\n<p>onceclick：Android Library. OnceClick是我们真正对外发布并交由第三方使用的库，它引用了apt-jar包</p>\n<p><img src=\"http://img0.ph.126.net/vHtdAVys2C-kIyWETwdaOw==/6631583436652950849.jpeg\" alt=\"\"></p>\n<h3 id=\"OnceClick使用\"><a href=\"#OnceClick使用\" class=\"headerlink\" title=\"OnceClick使用\"></a>OnceClick使用</h3><pre><code>public class MainActivity extends AppCompatActivity {\n\n    private TextView text;\n    private int num;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        //类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\n        OnceInit.once(this,2000);\n        text = (TextView)findViewById(R.id.textView);\n    }\n\n    @OnceClick(R.id.btn)\n    public void once(){\n        text.setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;once&quot;);\n    }\n\n    @OnceClick(R.id.btn2)\n    public void onceMe(View v){\n        ((Button)v).setText(&quot;click&quot;+num++);\n        Log.d(&quot;tag&quot;,&quot;onceMe&quot;);\n    }\n}\n</code></pre><p>在我连续点击按钮的情况下，可以看到日志一定是要2秒以上才会执行点击事件。</p>\n<p><img src=\"http://img0.ph.126.net/fiUsxAgW_ezfR7CEntOavw==/6631599929327368401.jpeg\" alt=\"\"></p>\n<h3 id=\"生成后代码\"><a href=\"#生成后代码\" class=\"headerlink\" title=\"生成后代码\"></a>生成后代码</h3><pre><code>// Generated code from OnceClick. Do not modify!\npackage com.lizhaoxuan.onceclickdemo;\n\nimport android.view.View;\n\nimport com.lizhaoxuan.onceclick.Finder;\nimport com.lizhaoxuan.onceclick.AbstractInjector;\n\npublic class MainActivity$$PROXY&lt;T extends MainActivity&gt; implements AbstractInjector&lt;T&gt; {\n    //间隔多久可以执行一次点击事件\n    public long intervalTime;\n\n    @Override\n    public void setIntervalTime(long time) {\n        intervalTime = time;\n    }\n\n    @Override\n    public void inject(final Finder finder, final T target, Object source) {\n        View view;\n        view = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n        view = finder.findViewById(source, 2131492946);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time &gt;= intervalTime) {\n                        time = temp;\n                        target.onceMe(v);\n                        }\n                }\n            });\n        }\n    }\n}\n</code></pre><p>这个就是自动生成的代码，生成代码的位置我们之前的篇章有讲过，代码也很简单，就不做过多解释了。</p>\n<p>================</p>\n<h3 id=\"OnceClick-Module\"><a href=\"#OnceClick-Module\" class=\"headerlink\" title=\"OnceClick Module\"></a>OnceClick Module</h3><h4 id=\"OnceInit-once\"><a href=\"#OnceInit-once\" class=\"headerlink\" title=\"OnceInit.once\"></a>OnceInit.once</h4><p>看到OnceClick的使用和生成后的代码你可能会有一点疑惑他们之间是如何联系在一起的。看下<em>OnceInit.java</em>一目了然，我在注释中做讲解:</p>\n<pre><code>public class OnceInit {\n    private static final Map&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt; INJECTORS = new LinkedHashMap&lt;Class&lt;?&gt;, AbstractInjector&lt;Object&gt;&gt;();\n\n    private static final long INTERVAL_TIME = 2000;\n\n    public static void once(Activity activity, long intervalTime) {\n        //生成的代码实现了AbstractInjector。我们通过activity找到生成的代码\n        AbstractInjector&lt;Object&gt; injector = findInjector(activity);\n        //执行生成代码中的inject方法\n        //Finder是枚举，这里用Activity类型\n        injector.inject(Finder.ACTIVITY, activity, activity);\n        //设置间隔时间\n        injector.setIntervalTime(intervalTime);\n    }\n\n    //其他几个重载方法\n    public static void once(View view, long intervalTime) {\n        AbstractInjector&lt;Object&gt; injector = findInjector(view);\n        //Finder是枚举，这里用VIEW类型\n        injector.inject(Finder.VIEW, view, view);\n        injector.setIntervalTime(intervalTime);\n    }\n    public static void once(Activity activity) {\n        once(activity, INTERVAL_TIME);\n    }\n    public static void once(View view) {\n        once(view, INTERVAL_TIME);\n    }\n\n    //查找生成的代码\n    private static AbstractInjector&lt;Object&gt; findInjector(Object activity) {\n        Class&lt;?&gt; clazz = activity.getClass();\n        //使用Map缓存一下，避免重复查找\n        AbstractInjector&lt;Object&gt; injector = INJECTORS.get(clazz);\n        if (injector == null) {\n            try {\n                //生成代码的类名是有格式的，className$$PROXY.所以我们可以通过字符串找到类，并初始化它。\n                Class injectorClazz = Class.forName(clazz.getName() + &quot;$$&quot;\n                    + ProxyInfo.PROXY);\n                injector = (AbstractInjector&lt;Object&gt;) injectorClazz\n                    .newInstance();\n                INJECTORS.put(clazz, injector);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return injector;\n    }\n}\n</code></pre><h4 id=\"AbstractInjector\"><a href=\"#AbstractInjector\" class=\"headerlink\" title=\"AbstractInjector\"></a>AbstractInjector</h4><p>代理类接口，所有生成代码类都要实现这个接口。</p>\n<p>inject方法用于实现代理代码。</p>\n<p>setIntervalTime设置点击事件执行间隔时间。</p>\n<pre><code>public interface AbstractInjector&lt;T&gt; {\n\n    void inject(Finder finder, T target, Object source);\n\n    void setIntervalTime(long time);\n}\n</code></pre><h4 id=\"Finder\"><a href=\"#Finder\" class=\"headerlink\" title=\"Finder\"></a>Finder</h4><p>Finder的作用是根据不同的类型，去实现不同的findViewById方法。</p>\n<pre><code>public enum Finder {\n    VIEW {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((View) source).findViewById(id);\n        }\n    },\n    ACTIVITY {\n        @Override\n        public View findViewById(Object source, int id) {\n            return ((Activity) source).findViewById(id);\n        }\n    };\n    public abstract View findViewById(Object source, int id);\n}\n</code></pre><p>================</p>\n<h3 id=\"APT-MODULE\"><a href=\"#APT-MODULE\" class=\"headerlink\" title=\"APT MODULE\"></a>APT MODULE</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre><code>@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\npublic @interface OnceClick {\n\n    int value();\n}\n</code></pre><p>OnceClick只有一个默认参数，用来设置View的Id。</p>\n<h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>编写文件javax.annotation.processing.Processor。</p>\n<pre><code>com.example.OnceClickProcessor\n</code></pre><p><img src=\"http://img0.ph.126.net/Fjmfygapp7D_zJXmxjru3A==/6631569143001790392.jpeg\" alt=\"\"></p>\n<h4 id=\"Process类-getSupportedAnnotationTypes\"><a href=\"#Process类-getSupportedAnnotationTypes\" class=\"headerlink\" title=\"Process类-getSupportedAnnotationTypes\"></a>Process类-getSupportedAnnotationTypes</h4><pre><code>@Override\npublic Set&lt;String&gt; getSupportedAnnotationTypes() {\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    types.add(OnceClick.class.getCanonicalName());\n    return types;\n}\n</code></pre><h4 id=\"Process类-process方法\"><a href=\"#Process类-process方法\" class=\"headerlink\" title=\"Process类-process方法\"></a>Process类-process方法</h4><p>重点来啦。这里需要讲一个概念。</p>\n<p>当某个类Activity使用了@OnceClick注解之后，我们就应该为其生成一个对应的代理类，代理类实现我们框架的功能：为某个View设置点击事件，并且这个点击事件一定时间内只能执行一次。</p>\n<p>所以，一个代理类可能有多个需要处理的View。</p>\n<p>先看process代码：</p>\n<pre><code>@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    //获取proxyMap\n    Map&lt;String, ProxyInfo&gt; proxyMap = getProxyMap(roundEnv);\n    //遍历proxyMap，并生成代码\n    for (String key : proxyMap.keySet()) {\n        ProxyInfo proxyInfo = proxyMap.get(key);\n        writeCode(proxyInfo);\n    }\n    return true;\n}\n</code></pre><p><strong>ProxyInfo对象</strong>：存放生成代理类的必要信息，并生成代码。</p>\n<p><strong>getProxyMap方法</strong>：使用参数roundEnv，遍历所有@OnceClick注解，并生成代理类ProxyInfo的Map。</p>\n<p><strong>writeCode方法</strong>：真正生成代码的方法。</p>\n<p>总结一下：编译时，取得所有需要生成的代理类信息。遍历代理类集合，根据代理类信息，生成代码。</p>\n<h4 id=\"ProxyInfo代理类\"><a href=\"#ProxyInfo代理类\" class=\"headerlink\" title=\"ProxyInfo代理类\"></a>ProxyInfo代理类</h4><p>其实这个类，才是这个框架的重中之重，因为生成什么代码，全靠这个类说了算。这个类也没什么好讲的，就是用StringBuidler拼出一个类来。ProxyInfo保存的是类信息，方法信息我们用List<OnceMethod> methods保存。<strong>然后根据这些信息生成类。</strong></p>\n<pre><code>public class ProxyInfo {\n    private String packageName;\n    private String targetClassName;\n    private String proxyClassName;\n    private TypeElement typeElement;\n\n    private List&lt;OnceMethod&gt; methods;\n\n    public static final String PROXY = &quot;PROXY&quot;;\n\n    ProxyInfo(String packageName, String className) {\n        this.packageName = packageName;\n        this.targetClassName = className;\n        this.proxyClassName = className + &quot;$$&quot; + PROXY;\n    }\n\n    String getProxyClassFullName() {\n        return packageName + &quot;.&quot; + proxyClassName;\n    }\n\n    String generateJavaCode() throws OnceClickException {\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(&quot;// Generated code from OnceClick. Do not modify!\\n&quot;);\n        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\\n\\n&quot;);\n\n        builder.append(&quot;import android.view.View;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.Finder;\\n&quot;);\n        builder.append(&quot;import com.lizhaoxuan.onceclick.AbstractInjector;\\n&quot;);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;public class &quot;).append(proxyClassName);\n        builder.append(&quot;&lt;T extends &quot;).append(getTargetClassName()).append(&quot;&gt;&quot;);\n        builder.append(&quot; implements AbstractInjector&lt;T&gt;&quot;);\n        builder.append(&quot; {\\n&quot;);\n\n        generateInjectMethod(builder);\n        builder.append(&apos;\\n&apos;);\n\n        builder.append(&quot;}\\n&quot;);\n        return builder.toString();\n\n    }\n\n    private String getTargetClassName() {\n        return targetClassName.replace(&quot;$&quot;, &quot;.&quot;);\n    }\n\n    private void generateInjectMethod(StringBuilder builder) throws OnceClickException {\n\n        builder.append(&quot;public long intervalTime; \\n&quot;);\n\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void setIntervalTime(long time) {\\n&quot;)\n                .append(&quot;intervalTime = time;\\n     } \\n&quot;);\n        builder.append(&quot;  @Override &quot;)\n                .append(&quot;public void inject(final Finder finder, final T target, Object source) {\\n&quot;);\n        builder.append(&quot;View view;&quot;);\n\n        for (OnceMethod method : getMethods()) {\n            builder.append(&quot;    view = &quot;)\n                    .append(&quot;finder.findViewById(source, &quot;)\n                    .append(method.getId())\n                    .append(&quot;);\\n&quot;);\n            builder.append(&quot;if(view != null){&quot;)\n                    .append(&quot;view.setOnClickListener(new View.OnClickListener() {\\n&quot;)\n                    .append(&quot;long time = 0L;&quot;);\n            builder.append(&quot;@Override\\n&quot;)\n                    .append(&quot;public void onClick(View v) {&quot;);\n            builder.append(&quot;long temp = System.currentTimeMillis();\\n&quot;)\n                    .append(&quot;if (temp - time &gt;= intervalTime) {\\n&quot; +\n                                &quot;time = temp;\\n&quot;);\n            if (method.getMethodParametersSize() == 1) {\n                if (method.getMethodParameters().get(0).equals(&quot;android.view.View&quot;)) {\n                    builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;(v);&quot;);\n                } else {\n                    throw new OnceClickException(&quot;Parameters must be android.view.View&quot;);\n                }\n            } else if (method.getMethodParametersSize() == 0) {\n            builder.append(&quot;target.&quot;).append(method.getMethodName()).append(&quot;();&quot;);\n            } else {\n                throw new OnceClickException(&quot;Does not support more than one parameter&quot;);\n            }\n            builder.append(&quot;\\n}&quot;)\n                    .append(&quot;    }\\n&quot;)\n                    .append(&quot;        });\\n}&quot;);\n        }\n\n        builder.append(&quot;  }\\n&quot;);\n    }\n\n    TypeElement getTypeElement() {\n        return typeElement;\n    }\n\n    void setTypeElement(TypeElement typeElement) {\n        this.typeElement = typeElement;\n    }\n\n    List&lt;OnceMethod&gt; getMethods() {\n        return methods == null ? new ArrayList&lt;OnceMethod&gt;() : methods;\n    }\n\n    void addMethod(OnceMethod onceMethod) {\n        if (methods == null) {\n            methods = new ArrayList&lt;&gt;();\n        }\n        methods.add(onceMethod);\n    }\n}\n</code></pre><h4 id=\"OnceMethod类\"><a href=\"#OnceMethod类\" class=\"headerlink\" title=\"OnceMethod类\"></a>OnceMethod类</h4><p>需要讲的一点是，每一个使用了@OnceClick注解的Activity或View，都会为其生成一个代理类，而一个代理中有可能有很多个@OnceClick修饰的方法，所以我们专门为每个方法有创建了一个javaBean用于保存方法信息:</p>\n<pre><code>public class OnceMethod {\n\n    private int id;\n    private String methodName;\n    private List&lt;String&gt; methodParameters;\n\n    OnceMethod(int id, String methodName, List&lt;String&gt; methodParameters) {\n        this.id = id;\n        this.methodName = methodName;\n        this.methodParameters = methodParameters;\n    }\n\n    int getMethodParametersSize() {\n        return methodParameters == null ? 0 : methodParameters.size();\n    }\n\n    int getId() {\n        return id;\n    }\n\n    String getMethodName() {\n        return methodName;\n    }\n\n    List&lt;String&gt; getMethodParameters() {\n        return methodParameters;\n    }\n\n}\n</code></pre><h4 id=\"getProxyMap方法\"><a href=\"#getProxyMap方法\" class=\"headerlink\" title=\"getProxyMap方法\"></a>getProxyMap方法</h4><p>getProxyMap其实也很简单的。通过注释就可以理解。</p>\n<p>比较不容易理解的是TypeElement、PackageElement的处理。这方面语法还请看《Android编译时注解框架-语法讲解》。</p>\n<pre><code>private Map&lt;String, ProxyInfo&gt; getProxyMap( RoundEnvironment roundEnv){\n    Map&lt;String, ProxyInfo&gt; proxyMap = new HashMap&lt;&gt;();\n    //遍历项目中所有的@OnceClick注解\n    for (Element element : roundEnv.getElementsAnnotatedWith(OnceClick.class)) {            \n        //获取基本的类名、包名\n        TypeElement classElement = (TypeElement) element;\n        PackageElement packageElement = (PackageElement) element\n                .getEnclosingElement();\n\n        String fullClassName = classElement.getQualifiedName().toString();\n        String className = classElement.getSimpleName().toString();\n        String packageName = packageElement.getQualifiedName().toString();\n        //获取注解参数\n        int viewId = classElement.getAnnotation(OnceClick.class).value();\n\n        ProxyInfo proxyInfo = proxyMap.get(fullClassName);\n        //如果以创建该代理类，就只add viewId\n        if (proxyInfo != null) {\n            proxyInfo.addLayoutId(viewId);\n        } else {\n            proxyInfo = new ProxyInfo(packageName, className);\n            proxyInfo.setTypeElement(classElement);\n            proxyInfo.addLayoutId(viewId);\n            proxyMap.put(fullClassName, proxyInfo);\n        }\n    }\n    return proxyMap;\n}\n</code></pre><h4 id=\"writeCode方法\"><a href=\"#writeCode方法\" class=\"headerlink\" title=\"writeCode方法\"></a>writeCode方法</h4><p>writeCode方法用来生成代码文件，这个方法的代码相对固定，基本不用该，就是这样的。</p>\n<p>需要注意的是 <em>writer.write(proxyInfo.generateJavaCode());</em>。需要生成的代码以字符串形式传给writer。</p>\n<pre><code>private void writeCode(ProxyInfo proxyInfo){\n    try {\n        JavaFileObject jfo = processingEnv.getFiler().createSourceFile(\n                proxyInfo.getProxyClassFullName(),\n                proxyInfo.getTypeElement());\n        Writer writer = jfo.openWriter();\n        writer.write(proxyInfo.generateJavaCode());\n        writer.flush();\n        writer.close();\n    } catch (IOException e) {\n        error(proxyInfo.getTypeElement(),\n                &quot;Unable to write injector for type %s: %s&quot;,\n                proxyInfo.getTypeElement(), e.getMessage());\n    }\n}\n\n//两个日志输出方法。\nprivate void print(String message){\n    messager.printMessage(Diagnostic.Kind.NOTE, message);\n}\n\nprivate void error(Element element, String message, Object... args) {\n    if (args.length &gt; 0) {\n        message = String.format(message, args);\n    }\n    messager.printMessage(Diagnostic.Kind.ERROR, message, element);\n}\n</code></pre><h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>这里可能会有一个疑问，一个Activity里不同的按钮不可以设置不同的点击事件间隔时间么？</p>\n<pre><code>//类似于ButterKnife的Bind方法。初始化OnceClick,并设置点击事件间隔是2秒\nOnceInit.once(this,2000);\n</code></pre><p>技术上是可以实现的，但作为一个第三方框架，一个不能忽视的因素就是使用体验。</p>\n<p>每一个控件单独设值的体验并不是很好，因为注解只有一个属性的时候可以直接这样用：</p>\n<pre><code>@OnceClick(R.id.btn)\n</code></pre><p>如果有两个属性，就必须要带名字了 </p>\n<pre><code>@OnceClick(id = R.id.btn)\n</code></pre><p>最后在把源码地址再放一下 <a href=\"https://github.com/lizhaoxuan/OnceClick\">https://github.com/lizhaoxuan/OnceClick</a>。看着Demo学习会更快！</p>\n<p></br></p>\n<hr>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-wathapt/\">《Android编译时注解框架-什么是编译时注解》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p>《Android编译时注解框架-Run Project：OnceClick》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架系列1-什么是编译时注解","date":"2016-07-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n**Android编译时注解框架从入门到项目实践**。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。\n\n提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。\n\n但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题...\n\n\n\n<!-- more -->\n\n\n今天我们要讲的是，不会对性能有任何影响的黑科技：**编译时注解**。也有人叫它**代码生成**，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool\n\n得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。\n\n本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。\n\n- 什么是注解\n\n- 运行时注解的简单使用\n\n- 编译时注解框架ButterKnife源码初探\n\n\n\n### 什么是注解\n\n注解你一定不会陌生，这就是我们最常见的注解：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg)\n\n\n首先注解分为三类：\n\n- 标准 Annotation\n\n\t包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，\n\t不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。\n\n- 元 Annotation\n\n\t@Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。\n\t\n- 自定义 Annotation\n\t\n\t根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。\n\t\n\n同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：\n\n这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释\n\n\t/**\n     * Annotation is only available in the source code.\n     */\n    SOURCE,\n    /**\n     * Annotation is available in the source code and in the class file, but not\n     * at runtime. This is the default policy.\n     */\n    CLASS,\n    /**\n     * Annotation is available in the source code, the class file and is\n     * available at runtime.\n     */\n    RUNTIME\n\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t该注解仅用于源码阶段，就是我们编写的java文件。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。\n\t\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t该注解用于源码、类文件和运行时阶段。\n\t\n\t\n可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。\n\nRetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。\n修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。\n\n那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？\n\n没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。\n\nRetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。\n\n**请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环**\n\n\n\n### 运行时注解的简单使用\n\n\n运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。\n\n下面展示一个Demo。其功能是通过注解实现布局文件的设置。\n\n之前我们是这样设置布局文件的：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_home);\n    }\n    \n如果使用注解，我们就可以这样设置布局了\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\t\n我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。\n\n那么这样的注解是怎么实现的呢？很简单，往下看。\n\n#### 创建一个注解\n\t\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE})\n\tpublic @interface ContentView {\n    \tint value();\n\t}\n\n\n**第一行:@Retention(RetentionPolicy.RUNTIME)**\n\n@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。\n\n**第二行：@Target({ElementType.TYPE})**\n\n@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。\n\n**第三行：public @interface ContentView**\n\n这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）\n\n\t/** Class, interface (including annotation type), or enum declaration */\n\tTYPE,\n\n**第四行：int value();**\n\n返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的\n\n\t@ContentView(R.layout.activity_home)\n\t\nR.layout.activity_home实质是一个int型id，如果这样用就会报错：\n\n\t@ContentView(“string”)\n\t\n\n**关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中**\n\n\n#### 注解解析\n\n注解申明好了，但具体是怎么识别这个注解并使用的呢？\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\n注解的解析就在BaseActivity中。我们看一下BaseActivity代码\n\n\tpublic class BaseActivity extends AppCompatActivity {\n\t\n\t\t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //注解解析\n\t\tfor (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n            ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n            if (annotation != null) {\n                try {\n                    this.setContentView(annotation.value());\n                } catch (RuntimeException e) {\n                    e.printStackTrace();\n                }\n                return;\n            }\n        }\n\t}\n\n\n\t\n第一步：遍历所有的子类\n\n第二步：找到修饰了注解ContentView的类\n\n第三步：获取ContentView的属性值。\n\n第四步：为Activity设置布局。\n\n#### 总结\n\n相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。\n\n你可能会觉得*setContentView(R.layout.activity_home)*和*@ContentView(R.layout.activity_home)*没什么区别，用了注解反而还增加了性能问题。\n\n但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。\n\n因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。\n\n\n\n\n\n\n### 编译时注解框架ButterKnife源码初探\n\nButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg)\n\n你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。\n\n秘密在这里，编译工程后，打开你的项目app目录下的build目录：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg)\n\n你可以看到一些带有*$$ViewBinder*后缀的类文件。这个就是ButterKnife生成的代码我们打开它：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg)\n\n\n\n\n上面有一条注释：\n// Generated code from Butter Knife. Do not modify!\n\n1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：\n\n\tpackage com.zhaoxuan.wehome.view.activity;\n\t\n同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：\n\n\t\t//accountEdit是ForgetActivity当中定义的控件\n\t    target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n所以你也应该知道了为什么当使用private时会报错了吧？\n\n2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。\n\n\t@Override\n    public void bind(final Finder finder, final T target, Object source) {\n        //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n        View view;\n        \n        //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n        view = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n        \n        //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n        target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n        \n        view = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n        target.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n        \n        //给view设置一个点击事件\n        view.setOnClickListener(\n                new butterknife.internal.DebouncingOnClickListener() {\n                    @Override\n                    public void doClick(android.view.View p0) {\n                    \n                    \t//forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                       target.forgetOnClick();\n                       \n                    }\n                });\n    }\n\nOK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：\n\n1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。\n\n2.Finder到底是个什么东西？凭什么它可以找到view。\n\n不着急不着急，慢慢看。\n#### 注解: @Bind的定义\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg)\n\n我们可以解读的信息如下：\n\n1. Bind是编译时注解\n\n2. 只能修饰属性\n\n3. 属性值是一个int型的数组。\n\n\n创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。\n\n#### Finder类\n\n通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg)\n\n根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。\n\n另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： *finder.findRequiredView* 和 *finder.castView*\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg)\n\n\nfindRequiredView 方法调用了 findOptionalView 方法\n\nfindOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）\n\nfindView取得view后，又交给了castView做一些容错处理。\n\ncastView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。\n\n\n\n#### ButterKnife.bind(this)方法\n\n*ButterKnife.bind(this)*这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~\n\nbind有几个重载方法，但最终调的都是下面这个方法。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg)\n\n参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。\n\n首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：*ForgetActivity$$ViewBinder*。\n\n然后调用ForgetActivity$$ViewBinder的bind方法。\n\n然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。\n\n\n#### ButterKnifeProcessor\n\n你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg)\n\nAbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg)\n\n重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。\n\n第一个最明显的就是Bind注解啦。\n\n而所有的注解处理，都是在process中执行的：\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg)\n\n通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。\n\nJavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。\n\n这里我们只关注最重要的一句话\n\n\twriter.write(bindingClass.brewJava());\n\t\nForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。\n\n\n#### bindingClass.brewJava方法\n\n哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……\n\n我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……\n\n既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。\n\n由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg)\n\n\n### 总结\n\n当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。\n\n但这不正是学习的魅力么？\n\n好了，总结一下。\n\n1. 编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。\n\n2. 代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。\n\n3. APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~\n\n4. ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：**写一个框架最难的不是技术实现，而是稳定！**\n\n5. ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。\n\nAPT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。\n\n后续篇章我将会陆续推出几款以Cake命名的APT框架。\n\n\n\n<br/>\n\n《Android编译时注解框架-什么是编译时注解》\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n\n\n\n","source":"_posts/apt-wathapt.md","raw":"---\ntitle: Android编译时注解框架系列1-什么是编译时注解\ndate: 2016-07-17 16:20:58\nauthor : 暴打小女孩\n\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n**Android编译时注解框架从入门到项目实践**。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。\n\n提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。\n\n但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题...\n\n\n\n<!-- more -->\n\n\n今天我们要讲的是，不会对性能有任何影响的黑科技：**编译时注解**。也有人叫它**代码生成**，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool\n\n得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。\n\n本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。\n\n- 什么是注解\n\n- 运行时注解的简单使用\n\n- 编译时注解框架ButterKnife源码初探\n\n\n\n### 什么是注解\n\n注解你一定不会陌生，这就是我们最常见的注解：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg)\n\n\n首先注解分为三类：\n\n- 标准 Annotation\n\n\t包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，\n\t不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。\n\n- 元 Annotation\n\n\t@Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。\n\t\n- 自定义 Annotation\n\t\n\t根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。\n\t\n\n同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：\n\n这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释\n\n\t/**\n     * Annotation is only available in the source code.\n     */\n    SOURCE,\n    /**\n     * Annotation is available in the source code and in the class file, but not\n     * at runtime. This is the default policy.\n     */\n    CLASS,\n    /**\n     * Annotation is available in the source code, the class file and is\n     * available at runtime.\n     */\n    RUNTIME\n\n\n- @Retention(RetentionPolicy.SOURCE)\n\n\t该注解仅用于源码阶段，就是我们编写的java文件。\n\n- @Retention(RetentionPolicy.CLASS)\n\n\t该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。\n\t\t\n- @Retention(RetentionPolicy.RUNTIME)\n\n\t该注解用于源码、类文件和运行时阶段。\n\t\n\t\n可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。\n\nRetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。\n修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。\n\n那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？\n\n没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。\n\nRetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。\n\n**请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环**\n\n\n\n### 运行时注解的简单使用\n\n\n运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。\n\n下面展示一个Demo。其功能是通过注解实现布局文件的设置。\n\n之前我们是这样设置布局文件的：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_home);\n    }\n    \n如果使用注解，我们就可以这样设置布局了\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\t\n我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。\n\n那么这样的注解是怎么实现的呢？很简单，往下看。\n\n#### 创建一个注解\n\t\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE})\n\tpublic @interface ContentView {\n    \tint value();\n\t}\n\n\n**第一行:@Retention(RetentionPolicy.RUNTIME)**\n\n@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。\n\n**第二行：@Target({ElementType.TYPE})**\n\n@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。\n\n**第三行：public @interface ContentView**\n\n这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）\n\n\t/** Class, interface (including annotation type), or enum declaration */\n\tTYPE,\n\n**第四行：int value();**\n\n返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的\n\n\t@ContentView(R.layout.activity_home)\n\t\nR.layout.activity_home实质是一个int型id，如果这样用就会报错：\n\n\t@ContentView(“string”)\n\t\n\n**关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中**\n\n\n#### 注解解析\n\n注解申明好了，但具体是怎么识别这个注解并使用的呢？\n\n\t@ContentView(R.layout.activity_home)\n\tpublic class HomeActivity extends BaseActivity {\n\t\t。。。\n\t}\n\n注解的解析就在BaseActivity中。我们看一下BaseActivity代码\n\n\tpublic class BaseActivity extends AppCompatActivity {\n\t\n\t\t@Override\n    \tprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //注解解析\n\t\tfor (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n            ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n            if (annotation != null) {\n                try {\n                    this.setContentView(annotation.value());\n                } catch (RuntimeException e) {\n                    e.printStackTrace();\n                }\n                return;\n            }\n        }\n\t}\n\n\n\t\n第一步：遍历所有的子类\n\n第二步：找到修饰了注解ContentView的类\n\n第三步：获取ContentView的属性值。\n\n第四步：为Activity设置布局。\n\n#### 总结\n\n相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。\n\n你可能会觉得*setContentView(R.layout.activity_home)*和*@ContentView(R.layout.activity_home)*没什么区别，用了注解反而还增加了性能问题。\n\n但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。\n\n因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。\n\n\n\n\n\n\n### 编译时注解框架ButterKnife源码初探\n\nButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg)\n\n你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。\n\n秘密在这里，编译工程后，打开你的项目app目录下的build目录：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg)\n\n你可以看到一些带有*$$ViewBinder*后缀的类文件。这个就是ButterKnife生成的代码我们打开它：\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg)\n\n\n\n\n上面有一条注释：\n// Generated code from Butter Knife. Do not modify!\n\n1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：\n\n\tpackage com.zhaoxuan.wehome.view.activity;\n\t\n同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：\n\n\t\t//accountEdit是ForgetActivity当中定义的控件\n\t    target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n所以你也应该知道了为什么当使用private时会报错了吧？\n\n2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。\n\n\t@Override\n    public void bind(final Finder finder, final T target, Object source) {\n        //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n        View view;\n        \n        //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n        view = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n        \n        //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n        target.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n        \n        view = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n        target.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n        \n        //给view设置一个点击事件\n        view.setOnClickListener(\n                new butterknife.internal.DebouncingOnClickListener() {\n                    @Override\n                    public void doClick(android.view.View p0) {\n                    \n                    \t//forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                       target.forgetOnClick();\n                       \n                    }\n                });\n    }\n\nOK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：\n\n1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。\n\n2.Finder到底是个什么东西？凭什么它可以找到view。\n\n不着急不着急，慢慢看。\n#### 注解: @Bind的定义\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg)\n\n我们可以解读的信息如下：\n\n1. Bind是编译时注解\n\n2. 只能修饰属性\n\n3. 属性值是一个int型的数组。\n\n\n创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。\n\n#### Finder类\n\n通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg)\n\n根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。\n\n另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： *finder.findRequiredView* 和 *finder.castView*\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg)\n\n\nfindRequiredView 方法调用了 findOptionalView 方法\n\nfindOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）\n\nfindView取得view后，又交给了castView做一些容错处理。\n\ncastView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。\n\n\n\n#### ButterKnife.bind(this)方法\n\n*ButterKnife.bind(this)*这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~\n\nbind有几个重载方法，但最终调的都是下面这个方法。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg)\n\n参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。\n\n首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：*ForgetActivity$$ViewBinder*。\n\n然后调用ForgetActivity$$ViewBinder的bind方法。\n\n然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。\n\n\n#### ButterKnifeProcessor\n\n你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg)\n\nAbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg)\n\n重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。\n\n第一个最明显的就是Bind注解啦。\n\n而所有的注解处理，都是在process中执行的：\n\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg)\n\n通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。\n\nJavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。\n\n这里我们只关注最重要的一句话\n\n\twriter.write(bindingClass.brewJava());\n\t\nForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。\n\n\n#### bindingClass.brewJava方法\n\n哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……\n\n我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……\n\n既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。\n\n由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~\n\n![](http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg)\n\n\n### 总结\n\n当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。\n\n但这不正是学习的魅力么？\n\n好了，总结一下。\n\n1. 编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。\n\n2. 代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。\n\n3. APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~\n\n4. ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：**写一个框架最难的不是技术实现，而是稳定！**\n\n5. ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。\n\nAPT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。\n\n后续篇章我将会陆续推出几款以Cake命名的APT框架。\n\n\n\n<br/>\n\n《Android编译时注解框架-什么是编译时注解》\n\n[《Android编译时注解框架-Run Demo》](https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/)\n\n[《Android编译时注解框架-Run Project：OnceClick》](https://lizhaoxuan.github.io/2016/07/17/apt-run_project/)\n\n[《Android编译时注解框架-爬坑》](https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/)\n\n[《Android编译时注解框架-语法讲解》](https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/)\n\n\n\n\n\n\n","slug":"apt-wathapt","published":1,"updated":"2017-01-16T05:12:52.000Z","_id":"cixzmux3i000eq4chyk15jcx3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><strong>Android编译时注解框架从入门到项目实践</strong>。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。</p>\n<p>提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。</p>\n<p>但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题…</p>\n<a id=\"more\"></a>\n<p>今天我们要讲的是，不会对性能有任何影响的黑科技：<strong>编译时注解</strong>。也有人叫它<strong>代码生成</strong>，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool</p>\n<p>得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。</p>\n<p>本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。</p>\n<ul>\n<li><p>什么是注解</p>\n</li>\n<li><p>运行时注解的简单使用</p>\n</li>\n<li><p>编译时注解框架ButterKnife源码初探</p>\n</li>\n</ul>\n<h3 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h3><p>注解你一定不会陌生，这就是我们最常见的注解：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg\" alt=\"\"></p>\n<p>首先注解分为三类：</p>\n<ul>\n<li><p>标准 Annotation</p>\n<p>  包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，<br>  不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。</p>\n</li>\n<li><p>元 Annotation</p>\n<p>  @Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。</p>\n</li>\n<li><p>自定义 Annotation</p>\n<p>  根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。</p>\n</li>\n</ul>\n<p>同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：</p>\n<p>这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释</p>\n<pre><code>/**\n * Annotation is only available in the source code.\n */\nSOURCE,\n/**\n * Annotation is available in the source code and in the class file, but not\n * at runtime. This is the default policy.\n */\nCLASS,\n/**\n * Annotation is available in the source code, the class file and is\n * available at runtime.\n */\nRUNTIME\n</code></pre><ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  该注解仅用于源码阶段，就是我们编写的java文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  该注解用于源码、类文件和运行时阶段。</p>\n</li>\n</ul>\n<p>可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。</p>\n<p>RetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。<br>修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。</p>\n<p>那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？</p>\n<p>没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。</p>\n<p>RetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。</p>\n<p><strong>请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环</strong></p>\n<h3 id=\"运行时注解的简单使用\"><a href=\"#运行时注解的简单使用\" class=\"headerlink\" title=\"运行时注解的简单使用\"></a>运行时注解的简单使用</h3><p>运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。</p>\n<p>下面展示一个Demo。其功能是通过注解实现布局文件的设置。</p>\n<p>之前我们是这样设置布局文件的：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_home);\n}\n</code></pre><p>如果使用注解，我们就可以这样设置布局了</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。</p>\n<p>那么这样的注解是怎么实现的呢？很简单，往下看。</p>\n<h4 id=\"创建一个注解\"><a href=\"#创建一个注解\" class=\"headerlink\" title=\"创建一个注解\"></a>创建一个注解</h4><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface ContentView {\n    int value();\n}\n</code></pre><p><strong>第一行:@Retention(RetentionPolicy.RUNTIME)</strong></p>\n<p>@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。</p>\n<p><strong>第二行：@Target({ElementType.TYPE})</strong></p>\n<p>@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。</p>\n<p><strong>第三行：public @interface ContentView</strong></p>\n<p>这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）</p>\n<pre><code>/** Class, interface (including annotation type), or enum declaration */\nTYPE,\n</code></pre><p><strong>第四行：int value();</strong></p>\n<p>返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的</p>\n<pre><code>@ContentView(R.layout.activity_home)\n</code></pre><p>R.layout.activity_home实质是一个int型id，如果这样用就会报错：</p>\n<pre><code>@ContentView(“string”)\n</code></pre><p><strong>关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中</strong></p>\n<h4 id=\"注解解析\"><a href=\"#注解解析\" class=\"headerlink\" title=\"注解解析\"></a>注解解析</h4><p>注解申明好了，但具体是怎么识别这个注解并使用的呢？</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>注解的解析就在BaseActivity中。我们看一下BaseActivity代码</p>\n<pre><code>public class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //注解解析\n    for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n        ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n        if (annotation != null) {\n            try {\n                this.setContentView(annotation.value());\n            } catch (RuntimeException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n    }\n}\n</code></pre><p>第一步：遍历所有的子类</p>\n<p>第二步：找到修饰了注解ContentView的类</p>\n<p>第三步：获取ContentView的属性值。</p>\n<p>第四步：为Activity设置布局。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。</p>\n<p>你可能会觉得<em>setContentView(R.layout.activity_home)</em>和<em>@ContentView(R.layout.activity_home)</em>没什么区别，用了注解反而还增加了性能问题。</p>\n<p>但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。</p>\n<p>因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。</p>\n<h3 id=\"编译时注解框架ButterKnife源码初探\"><a href=\"#编译时注解框架ButterKnife源码初探\" class=\"headerlink\" title=\"编译时注解框架ButterKnife源码初探\"></a>编译时注解框架ButterKnife源码初探</h3><p>ButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg\" alt=\"\"></p>\n<p>你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。</p>\n<p>秘密在这里，编译工程后，打开你的项目app目录下的build目录：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg\" alt=\"\"></p>\n<p>你可以看到一些带有<em>$$ViewBinder</em>后缀的类文件。这个就是ButterKnife生成的代码我们打开它：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg\" alt=\"\"></p>\n<p>上面有一条注释：<br>// Generated code from Butter Knife. Do not modify!</p>\n<p>1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：</p>\n<pre><code>package com.zhaoxuan.wehome.view.activity;\n</code></pre><p>同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：</p>\n<pre><code>//accountEdit是ForgetActivity当中定义的控件\ntarget.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n</code></pre><p>所以你也应该知道了为什么当使用private时会报错了吧？</p>\n<p>2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。</p>\n<pre><code>@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n}\n</code></pre><p>OK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：</p>\n<p>1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。</p>\n<p>2.Finder到底是个什么东西？凭什么它可以找到view。</p>\n<p>不着急不着急，慢慢看。</p>\n<h4 id=\"注解-Bind的定义\"><a href=\"#注解-Bind的定义\" class=\"headerlink\" title=\"注解: @Bind的定义\"></a>注解: @Bind的定义</h4><p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg\" alt=\"\"></p>\n<p>我们可以解读的信息如下：</p>\n<ol>\n<li><p>Bind是编译时注解</p>\n</li>\n<li><p>只能修饰属性</p>\n</li>\n<li><p>属性值是一个int型的数组。</p>\n</li>\n</ol>\n<p>创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。</p>\n<h4 id=\"Finder类\"><a href=\"#Finder类\" class=\"headerlink\" title=\"Finder类\"></a>Finder类</h4><p>通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg\" alt=\"\"></p>\n<p>根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。</p>\n<p>另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： <em>finder.findRequiredView</em> 和 <em>finder.castView</em></p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg\" alt=\"\"></p>\n<p>findRequiredView 方法调用了 findOptionalView 方法</p>\n<p>findOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）</p>\n<p>findView取得view后，又交给了castView做一些容错处理。</p>\n<p>castView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。</p>\n<h4 id=\"ButterKnife-bind-this-方法\"><a href=\"#ButterKnife-bind-this-方法\" class=\"headerlink\" title=\"ButterKnife.bind(this)方法\"></a>ButterKnife.bind(this)方法</h4><p><em>ButterKnife.bind(this)</em>这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~</p>\n<p>bind有几个重载方法，但最终调的都是下面这个方法。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg\" alt=\"\"></p>\n<p>参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。</p>\n<p>首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：<em>ForgetActivity$$ViewBinder</em>。</p>\n<p>然后调用ForgetActivity$$ViewBinder的bind方法。</p>\n<p>然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。</p>\n<h4 id=\"ButterKnifeProcessor\"><a href=\"#ButterKnifeProcessor\" class=\"headerlink\" title=\"ButterKnifeProcessor\"></a>ButterKnifeProcessor</h4><p>你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg\" alt=\"\"></p>\n<p>AbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg\" alt=\"\"></p>\n<p>重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。</p>\n<p>第一个最明显的就是Bind注解啦。</p>\n<p>而所有的注解处理，都是在process中执行的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg\" alt=\"\"></p>\n<p>通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。</p>\n<p>JavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。</p>\n<p>这里我们只关注最重要的一句话</p>\n<pre><code>writer.write(bindingClass.brewJava());\n</code></pre><p>ForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。</p>\n<h4 id=\"bindingClass-brewJava方法\"><a href=\"#bindingClass-brewJava方法\" class=\"headerlink\" title=\"bindingClass.brewJava方法\"></a>bindingClass.brewJava方法</h4><p>哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……</p>\n<p>我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……</p>\n<p>既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。</p>\n<p>由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg\" alt=\"\"></p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。</p>\n<p>但这不正是学习的魅力么？</p>\n<p>好了，总结一下。</p>\n<ol>\n<li><p>编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。</p>\n</li>\n<li><p>代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。</p>\n</li>\n<li><p>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~</p>\n</li>\n<li><p>ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：<strong>写一个框架最难的不是技术实现，而是稳定！</strong></p>\n</li>\n<li><p>ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。</p>\n</li>\n</ol>\n<p>APT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。</p>\n<p>后续篇章我将会陆续推出几款以Cake命名的APT框架。</p>\n<p><br></p>\n<p>《Android编译时注解框架-什么是编译时注解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><strong>Android编译时注解框架从入门到项目实践</strong>。该系列将通过5篇博客一步步教你打造一个属于自己的编译时注解框架，并在之后开源出基于APT的编译时注解框架。</p>\n<p>提到注解，普遍都会有两种态度：黑科技、低性能。而使用注解往往可以实现用非常少的代码作出匪夷所思的事情，比如这些框架：ButterKnife、Retrofit。</p>\n<p>但一直被人诟病的是，运行时注解会因为java反射而引起较为严重的性能问题…</p>","more":"<p>今天我们要讲的是，不会对性能有任何影响的黑科技：<strong>编译时注解</strong>。也有人叫它<strong>代码生成</strong>，其实他们还是有些区别的，在编译时对注解做处理，通过注解，获取必要信息，在项目中生成代码，运行时调用，和直接运行手写代码没有任何区别。而更准确的叫法：APT - Annotation Processing Tool</p>\n<p>得当的使用编译时注解，可以极大的提高开发效率，避免编写重复、易错的代码。大部分时候编译时注解都可以代替java反射，利用可以直接调用的代码代替反射，极大的提升运行效率。</p>\n<p>本章作为《Android编译时注解框架》系列的第一章，将分三个部分让你简单认识注解框架。之后我们会一步步的创建属于自己的编译时注解框架。</p>\n<ul>\n<li><p>什么是注解</p>\n</li>\n<li><p>运行时注解的简单使用</p>\n</li>\n<li><p>编译时注解框架ButterKnife源码初探</p>\n</li>\n</ul>\n<h3 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h3><p>注解你一定不会陌生，这就是我们最常见的注解：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/1.jpeg\" alt=\"\"></p>\n<p>首先注解分为三类：</p>\n<ul>\n<li><p>标准 Annotation</p>\n<p>  包括 Override, Deprecated, SuppressWarnings，是java自带的几个注解，他们由编译器来识别，不会进行编译，<br>  不影响代码运行，至于他们的含义不是这篇博客的重点，这里不再讲述。</p>\n</li>\n<li><p>元 Annotation</p>\n<p>  @Retention, @Target, @Inherited, @Documented，它们是用来定义 Annotation 的 Annotation。也就是当我们要自定义注解时，需要使用它们。</p>\n</li>\n<li><p>自定义 Annotation</p>\n<p>  根据需要，自定义的Annotation。而自定义的方式，下面我们会讲到。</p>\n</li>\n</ul>\n<p>同样，自定义的注解也分为三类，通过元Annotation - @Retention 定义：</p>\n<p>这要要感谢大神@fw提醒，之前一直对RetentionPolicy.SOURCE，RetentionPolicy.RUNTIME，RetentionPolicy.CLASS三个元Annotation理解有误。我们先看一下官方注释</p>\n<pre><code>/**\n * Annotation is only available in the source code.\n */\nSOURCE,\n/**\n * Annotation is available in the source code and in the class file, but not\n * at runtime. This is the default policy.\n */\nCLASS,\n/**\n * Annotation is available in the source code, the class file and is\n * available at runtime.\n */\nRUNTIME\n</code></pre><ul>\n<li><p>@Retention(RetentionPolicy.SOURCE)</p>\n<p>  该注解仅用于源码阶段，就是我们编写的java文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.CLASS)</p>\n<p>  该注解用于源码、类文件阶段。就是我们编写java文件和编译后产生的class文件。</p>\n</li>\n<li><p>@Retention(RetentionPolicy.RUNTIME)</p>\n<p>  该注解用于源码、类文件和运行时阶段。</p>\n</li>\n</ul>\n<p>可能说到这里你还不太明白他们的区别。首先RetentionPolicy类型是一种包含关系。另外什么阶段的RetentionPolicy就表示你可以在什么阶段处理他们。</p>\n<p>RetentionPolicy.SOURCE修饰的注解可以在源码阶段时处理，但在编译成class文件或运行中以后，APT就没有办法对他进行处理了。<br>修饰了RetentionPolicy.RUNTIME的注解则是优先级最大的，你可以在任何时候对他进行处理。</p>\n<p>那么可能你就会问了，那这样的话，不管我是用于编译时代码生成还是运行时反射处理，我直接对所有注解申明RetentionPolicy.RUNTIME不就好了吗？或者即使我想在编译时代码生成我也用RetentionPolicy.SOURCE，也是可以的吧？</p>\n<p>没错，RetentionPolicy.RUNTIME是优先级最大的修饰，但为什么不建议呢？这个的原因同修饰类成员时用的private还是public得道理一样。</p>\n<p>RetentionPolicy.SOURCE同样可以用于编译时代码生成，但他是有缺点的，编译时代码生成有一个技巧，“在生成的代码中，我们也是可以继续将我们的注解写上去的，APT会二次扫描，并且对其进行处理”。那么这里如果使用了RetentionPolicy.SOURCE就会产生一个问题，编译时生成的代码是class文件，RetentionPolicy.SOURCE在此时是不会被APT识别使用的。</p>\n<p><strong>请谨慎使用在生成代码中继续使用你的注解，这类似一种递归，处理不当易导致死循环</strong></p>\n<h3 id=\"运行时注解的简单使用\"><a href=\"#运行时注解的简单使用\" class=\"headerlink\" title=\"运行时注解的简单使用\"></a>运行时注解的简单使用</h3><p>运行时注解的实质是，在代码中通过注解进行标记，运行时通过反射寻找标记进行某种处理。而运行时注解一直以来被呕病的原因便是反射的低效。</p>\n<p>下面展示一个Demo。其功能是通过注解实现布局文件的设置。</p>\n<p>之前我们是这样设置布局文件的：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_home);\n}\n</code></pre><p>如果使用注解，我们就可以这样设置布局了</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>我们先不讲这两种方式哪个好哪个坏，我们只谈技术不谈需求。</p>\n<p>那么这样的注解是怎么实现的呢？很简单，往下看。</p>\n<h4 id=\"创建一个注解\"><a href=\"#创建一个注解\" class=\"headerlink\" title=\"创建一个注解\"></a>创建一个注解</h4><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface ContentView {\n    int value();\n}\n</code></pre><p><strong>第一行:@Retention(RetentionPolicy.RUNTIME)</strong></p>\n<p>@Retention用来修饰这是一个什么类型的注解。这里表示该注解是一个运行时注解。这样APT就知道啥时候处理这个注解了。</p>\n<p><strong>第二行：@Target({ElementType.TYPE})</strong></p>\n<p>@Target用来表示这个注解可以使用在哪些地方。比如：类、方法、属性、接口等等。这里ElementType.TYPE 表示这个注解可以用来修饰：Class, interface or enum declaration。当你用ContentView修饰一个方法时，编译器会提示错误。</p>\n<p><strong>第三行：public @interface ContentView</strong></p>\n<p>这里的interface并不是说ContentView是一个接口。就像申明类用关键字class。申明枚举用enum。申明注解用的就是@interface。（值得注意的是：在ElementType的分类中，class、interface、Annotation、enum同属一类为Type，并且从官方注解来看，似乎interface是包含@interface的）</p>\n<pre><code>/** Class, interface (including annotation type), or enum declaration */\nTYPE,\n</code></pre><p><strong>第四行：int value();</strong></p>\n<p>返回值表示这个注解里可以存放什么类型值。比如我们是这样使用的</p>\n<pre><code>@ContentView(R.layout.activity_home)\n</code></pre><p>R.layout.activity_home实质是一个int型id，如果这样用就会报错：</p>\n<pre><code>@ContentView(“string”)\n</code></pre><p><strong>关于注解的具体语法，这篇不在详述，统一放到《Android编译时注解框架-语法讲解》中</strong></p>\n<h4 id=\"注解解析\"><a href=\"#注解解析\" class=\"headerlink\" title=\"注解解析\"></a>注解解析</h4><p>注解申明好了，但具体是怎么识别这个注解并使用的呢？</p>\n<pre><code>@ContentView(R.layout.activity_home)\npublic class HomeActivity extends BaseActivity {\n    。。。\n}\n</code></pre><p>注解的解析就在BaseActivity中。我们看一下BaseActivity代码</p>\n<pre><code>public class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //注解解析\n    for (Class c = this.getClass(); c != Context.class; c = c.getSuperclass()) {\n        ContentView annotation = (ContentView) c.getAnnotation(ContentView.class);\n        if (annotation != null) {\n            try {\n                this.setContentView(annotation.value());\n            } catch (RuntimeException e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n    }\n}\n</code></pre><p>第一步：遍历所有的子类</p>\n<p>第二步：找到修饰了注解ContentView的类</p>\n<p>第三步：获取ContentView的属性值。</p>\n<p>第四步：为Activity设置布局。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>相信你现在对运行时注解的使用一定有了一些理解了。也知道了运行时注解被人呕病的地方在哪了。</p>\n<p>你可能会觉得<em>setContentView(R.layout.activity_home)</em>和<em>@ContentView(R.layout.activity_home)</em>没什么区别，用了注解反而还增加了性能问题。</p>\n<p>但你要知道，这只是注解最简单的应用方式。举一个例子：AndroidEventBus的注解是运行时注解，虽然会有一点性能问题，但是在开发效率上是有提高的。</p>\n<p>因为这篇博客的重点不是运行时注解，所以我们不对其源码进行解析。有兴趣的可以去github搜一下看看哦~话说AndroidEventBus还是我一个学长写得，haha~。</p>\n<h3 id=\"编译时注解框架ButterKnife源码初探\"><a href=\"#编译时注解框架ButterKnife源码初探\" class=\"headerlink\" title=\"编译时注解框架ButterKnife源码初探\"></a>编译时注解框架ButterKnife源码初探</h3><p>ButterKnife大家应该都很熟悉的吧，9000多颗start，让我们彻底告别了枯燥的findViewbyId。它的使用方式是这样的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/2.jpeg\" alt=\"\"></p>\n<p>你难道就没有好奇过，它是怎么实现的吗？嘿嘿，这就是编译时注解-代码生成的黑科技所在了。</p>\n<p>秘密在这里，编译工程后，打开你的项目app目录下的build目录：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/3.jpeg\" alt=\"\"></p>\n<p>你可以看到一些带有<em>$$ViewBinder</em>后缀的类文件。这个就是ButterKnife生成的代码我们打开它：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/5.jpeg\" alt=\"\"></p>\n<p>上面有一条注释：<br>// Generated code from Butter Knife. Do not modify!</p>\n<p>1.ForgetActivity$$ViewBinder 和 我们的 ForgetActivity同在一个包下：</p>\n<pre><code>package com.zhaoxuan.wehome.view.activity;\n</code></pre><p>同在一个包下的意义是什么呢？ForgetActivity$$ViewBinder 可以直接使用 ForgetActivity protected级别以上的属性方法。就像这样：</p>\n<pre><code>//accountEdit是ForgetActivity当中定义的控件\ntarget.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n</code></pre><p>所以你也应该知道了为什么当使用private时会报错了吧？</p>\n<p>2.我们不去管细节，只是大概看一下这段生成的代码是什么意思。我把解析写在注释里。</p>\n<pre><code>@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n}\n</code></pre><p>OK，现在你大致明白了ButterKnife的秘密了吧？通过自动生成代码的方式来代替我们去写findViewById这样繁琐的代码。现在你一定在疑惑两个问题：</p>\n<p>1.这个bind方法什么时候被调用？我们的代码里并没有ForgetActivity$$ViewBinder 这种奇怪的类引用呀。</p>\n<p>2.Finder到底是个什么东西？凭什么它可以找到view。</p>\n<p>不着急不着急，慢慢看。</p>\n<h4 id=\"注解-Bind的定义\"><a href=\"#注解-Bind的定义\" class=\"headerlink\" title=\"注解: @Bind的定义\"></a>注解: @Bind的定义</h4><p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/6.jpeg\" alt=\"\"></p>\n<p>我们可以解读的信息如下：</p>\n<ol>\n<li><p>Bind是编译时注解</p>\n</li>\n<li><p>只能修饰属性</p>\n</li>\n<li><p>属性值是一个int型的数组。</p>\n</li>\n</ol>\n<p>创建好自定义注解，之后我们就可以通过APT去识别解析到这些注解，并且可以通过这些注解得到注解的值、注解所修饰的类的类型、名称。注解所在类的名称等等信息。</p>\n<h4 id=\"Finder类\"><a href=\"#Finder类\" class=\"headerlink\" title=\"Finder类\"></a>Finder类</h4><p>通过上面生成的代码，你一定奇怪，Finder到底是个什么东西。Finder实际是一个枚举。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/8.jpeg\" alt=\"\"></p>\n<p>根据不同类型的，提供了不同实现的findView和getContext方法。这里你终于看到了熟悉的findViewById了吧，哈哈，秘密就在这里。</p>\n<p>另外Finder还有两个重要的方法，也是刚才没有介绍清楚的： <em>finder.findRequiredView</em> 和 <em>finder.castView</em></p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/9.jpeg\" alt=\"\"></p>\n<p>findRequiredView 方法调用了 findOptionalView 方法</p>\n<p>findOptionalView调用了不同枚举类实现的findView方法（实际上就是findViewById啦~）</p>\n<p>findView取得view后，又交给了castView做一些容错处理。</p>\n<p>castView上来啥都不干直接强转并return。如果发生异常，就执行catch方法，只是抛出异常而已，我们就不看了。</p>\n<h4 id=\"ButterKnife-bind-this-方法\"><a href=\"#ButterKnife-bind-this-方法\" class=\"headerlink\" title=\"ButterKnife.bind(this)方法\"></a>ButterKnife.bind(this)方法</h4><p><em>ButterKnife.bind(this)</em>这个方法我们通常都在BaseActivity的onCreate方法中调用，似乎所有的findViewById方法，都被这一个bind方法化解了~</p>\n<p>bind有几个重载方法，但最终调的都是下面这个方法。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/7.jpeg\" alt=\"\"></p>\n<p>参数target一般是我们的Activity，source是用来获取Context查找资源的。当target是activity时，Finder是Finder.ACTIVITY。</p>\n<p>首先取得target，（也就是Activity）的Class对象，根据Class对象找到生成的类，例如：<em>ForgetActivity$$ViewBinder</em>。</p>\n<p>然后调用ForgetActivity$$ViewBinder的bind方法。</p>\n<p>然后就没有啦~看到这里你就大致明白了在程序运行过程中ButterKnife的实现原理了。下面上重头戏，ButterKnife编译时所做的工作。</p>\n<h4 id=\"ButterKnifeProcessor\"><a href=\"#ButterKnifeProcessor\" class=\"headerlink\" title=\"ButterKnifeProcessor\"></a>ButterKnifeProcessor</h4><p>你可能在疑惑，ButterKnife是如何识别注解的，又是如何生成代码的。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/10.jpeg\" alt=\"\"></p>\n<p>AbstractProcessor是APT的核心类，所有的黑科技，都产生在这里。AbstractProcessor只有两个最重要的方法process 和 getSupportedAnnotationTypes。</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/11.jpeg\" alt=\"\"></p>\n<p>重写getSupportedAnnotationTypes方法，用来表示该AbstractProcessor类处理哪些注解。</p>\n<p>第一个最明显的就是Bind注解啦。</p>\n<p>而所有的注解处理，都是在process中执行的：</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/12.jpeg\" alt=\"\"></p>\n<p>通过findAndParseTargets方法拿到所有需要被处理的注解集合。然后对其进行遍历。</p>\n<p>JavaFileObject是我们代码生成的关键对象，它的作用是写java文件。ForgetActivity$$ViewBinder这种奇怪的类文件，就是用JavaFileObject来生成的。</p>\n<p>这里我们只关注最重要的一句话</p>\n<pre><code>writer.write(bindingClass.brewJava());\n</code></pre><p>ForgetActivity$$ViewBinder中所有代码，都是通过bindingClass.brewJava方法拼出来的。</p>\n<h4 id=\"bindingClass-brewJava方法\"><a href=\"#bindingClass-brewJava方法\" class=\"headerlink\" title=\"bindingClass.brewJava方法\"></a>bindingClass.brewJava方法</h4><p>哎，我不知道你看到这个代码时候，是什么感觉。反正我看到这个时候脑袋里只有一句话：好low啊……</p>\n<p>我根本没想到这么黑科技高大上的东西居然是这么写出来的。一行代码一行代码往出拼啊……</p>\n<p>既然知道是字符串拼接起来的，就没有看下去的心思了，这里就不放完整代码了。</p>\n<p>由此，你也知道了之前看生成的代码，为什么是用了偷懒的方法写了吧~</p>\n<p><img src=\"http://7o4zmy.com1.z0.glb.clouddn.com/13.jpeg\" alt=\"\"></p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你揭开一个不熟悉领域的面纱后，黑科技好像也不过如此，甚至用字符串拼接出来的代码感觉lowlow的。</p>\n<p>但这不正是学习的魅力么？</p>\n<p>好了，总结一下。</p>\n<ol>\n<li><p>编译时注解的魅力在于：编译时按照一定策略生成代码，避免编写重复代码，提高开发效率，且不影响性能。</p>\n</li>\n<li><p>代码生成与代码插入（Aspectj）是有区别的。代码插入面向切面，是在代码运行前后插入代码，新产生的代码是由原有代码触发的。而代码生成只是自动产生一套独立的代码，代码的执行还是需要主动调用才可以。</p>\n</li>\n<li><p>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计~</p>\n</li>\n<li><p>ButterKnife的原理其实很简单，可是为什么这么简单的功能，却写了那么多代码呢？因为ButterKnife作为一个外部依赖框架，做了大量的容错和效验来保证运行稳定。所以：<strong>写一个框架最难的不是技术实现，而是稳定！</strong></p>\n</li>\n<li><p>ButterKnife有一个非常值得借鉴的地方，就是如何用生成的代码对已有的代码进行代理执行。这个如果你在研究有代理功能的APT框架的话，应该好好研究一下。</p>\n</li>\n</ol>\n<p>APT就好像一块蛋糕摆在你面前，就看你如何优雅的吃了。</p>\n<p>后续篇章我将会陆续推出几款以Cake命名的APT框架。</p>\n<p><br/></p>\n<p>《Android编译时注解框架-什么是编译时注解》</p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_demo/\">《Android编译时注解框架-Run Demo》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-run_project/\">《Android编译时注解框架-Run Project：OnceClick》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Climbed-out-of-the-pit/\">《Android编译时注解框架-爬坑》</a></p>\n<p><a href=\"https://lizhaoxuan.github.io/2016/07/17/apt-Grammar-explanation/\">《Android编译时注解框架-语法讲解》</a></p>"},{"title":"Android编译时注解框架6-APT的优缺点与应用","date":"2016-08-26T07:30:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？\n\n但就像我前面提到过的，**APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！** \n\nAPT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~\n\n（**本系列所讲APT均泛指编译时注解+代码生成**，虽然运行时注解也属APT）\n\n<!-- more -->\n\n### APT优点\n\n- 对代码进行标记，在编译时收集信息，并做处理。\n\n- 生成一套独立代码，辅助代码运行\n\n- 生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便\n\n- 更为可靠的自动代码生成\n\n- 自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率\n\n\n### APT缺点\n\n- APT往往容易被误解可以实现代码插入，然而事实是并不可以\n\n- APT可以自动生成代码，但在运行时却需要主动调用\n\n- 与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板\n\n\n### APT容易被你忽视的点\n\n一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。\n\n产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。\n\n事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。\n\n说白了，编译时注解你也完全可以当反射来理解。\n\nAPT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~**一定要放大你的脑洞！！！**\n\n### 应用场景-信息收集与统计\n\n\n注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~\n\n#### 编译时代码检查或统计\n\n统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~\n\n\t//示例代码  类统计\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                \"Annotation class size = \" + size);\n    }\n\n代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？\n\n这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~\n\n（此处有点瞎扯淡了，一般代码检查都不会这么干）\n\n\t\n#### 运行时数据收集与统计\n\n通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。\n\n手写代码容易出错，交给APT来实现便可以将错误率降到最低。\n\n另外还有一个灵感来源于一个你不陌生的类：BuildConfig.\n\n在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。\n\n同理，APT也可以实现这样的功能。\n\n\n### 应用场景-事件代理\n\n此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。\n\n\t//示例代码\n\t@Override\n\tpublic void bind(final Finder finder, final T target, Object source) {\n    \t//定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    \tView view;\n\n    \t//暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    \tview = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n\n    \t//target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    \ttarget.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n    \tview = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n    \ttarget.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n\n    \t//给view设置一个点击事件\n    \tview.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n\t}\n\t\n\n#### ButterKnife扩展\n\nButterKnife绑定View的同时，我们也可以附加一些操作。\n\n一个典型案例就是 前面博客提到的OnceClick\n\n在给View设置监听事件时，添加一些自定操作。\n\n\tview = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time >= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n\n\n#### 其他属性（跨域）初始化\\赋值\n\nButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。\n\n举一个列子：\n\nIntent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。\n\nActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。\n\n### 应用场景-代理执行 or \"代码插入\"\n\n虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。\n\n####代理执行\n\n用注解修饰一系列方法，由APT来代理执行。\n\n此部分参考[CakeRun](https://github.com/lizhaoxuan/CakeRun)\n\n\tpublic class CrashApplication extends Application {\n\t\n\t\t@Override\n    \tpublic void onCreate() {\n        \tsuper.onCreate();\n        \t//初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        \t//某种程度实现了代码插入\n        \tCakeRun.getInstance().applicationInit();\n    \t}\n\t\n\t\t@AppInit(tag = 1, canSkip = true)\n    \tprotected void init1() {\n        \tLog.d(\"TAG\", \"init1()  将引起crash。非关键路径可以跳过\");\n        \tString s = null;\n        \tLog.d(\"TAG\", s);\n    \t}\n\n    \t@AsyncInit(tag = 2, packageName = {\"com.lizhaoxuan.cakerundemo.Lib1\", \"other packageName\"})\n    \tprotected void init2() {\n        \tLog.d(\"TAG\", \"AsyncInit2() 引起Crash ,关键路径不可跳过\");\n        \tLib1.AsyncInit();\n    \t}\n\n    \t@AppInit(tag = 3)\n    \tprotected void init3() {\n        \tLog.d(\"TAG\", \"init3() 未引起crash\");\n    \t}\n\n    \t@AppInit(tag = 4)\n    \tprotected void init4() {\n        \tLog.d(\"TAG\", \"init4() 未引起crash\");\n    \t}\n\t}\n\t\nAPT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。\n\n#### 代码插入AOP\n\n使用APT实现AOP\n\n因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick\n\t \n\t@CrashClick(id = R.id.btn, target = HomeActivity)\n\tpublic void startActivity() {\n  \t\t...\n        this.startActivity(intent);\n    }\n    \n但对于普通方法，可能就需要这样调用\n\n    protected void onCreate(Bundle savedInstanceState) {\n    \n    \t//...\n    \t\n    \t//原本是这样调用方法的\n        startHomeActivity();\n\n        //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n        //就需要这样调用\n        AptClient.doMethod(this,\"startHomeActivity\");\n\n    }\n\n    @DemoTest(method = \"startHomeActivity\")\n    protected void startHomeActivity() {\n\n    }\n\n\nAPT生成代码样式：\n\n\tpublic void doMethod(Object target){\n\t\tint temp;\n\t\tif(//一些逻辑条件){\n\t\t\t//执行前做一些操作，比如记录\n\t\t\ttemp = 2; \n\t\t\t//执行真正的方法\n\t\t\ttarget.startHomeActivity();\n\t\t}else{\n\t\t\t//这个方法有些问题不能执行\n\t\t}\n\t}\n\n\n### 应用场景-反射优化\n\n编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。\n\n#### EventBus优化\n\nEventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。\n\nAPT优化:\n\n- 使用编译时注解标记Event接收方法。\n\n- 通过APT+代码生成，生成对应代理类，并提取所有Event接收方法\n\n- 每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。\n\n\n### 应用场景-让代码返璞归真\n\n实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。\n\n运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。\n\n以ORM数据库框架为例。\n\n细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。\n\nOrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。\n\n而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！\n\n但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。\n\n**那么通过APT，则是一个很好的技术方案：CakeDao**\n\n[https://github.com/lizhaoxuan/CakeDao](https://github.com/lizhaoxuan/CakeDao)\n\n与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\t\n\n\n\n\n\n\n\n\n","source":"_posts/apt_usage_scenario.md","raw":"---\ntitle: Android编译时注解框架6-APT的优缺点与应用\ndate: 2016-08-26 15:30:58\nauthor : 暴打小女孩\ntags: APT\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n### 概述\n\n如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？\n\n但就像我前面提到过的，**APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！** \n\nAPT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~\n\n（**本系列所讲APT均泛指编译时注解+代码生成**，虽然运行时注解也属APT）\n\n<!-- more -->\n\n### APT优点\n\n- 对代码进行标记，在编译时收集信息，并做处理。\n\n- 生成一套独立代码，辅助代码运行\n\n- 生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便\n\n- 更为可靠的自动代码生成\n\n- 自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率\n\n\n### APT缺点\n\n- APT往往容易被误解可以实现代码插入，然而事实是并不可以\n\n- APT可以自动生成代码，但在运行时却需要主动调用\n\n- 与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板\n\n\n### APT容易被你忽视的点\n\n一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。\n\n产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。\n\n事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。\n\n说白了，编译时注解你也完全可以当反射来理解。\n\nAPT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~**一定要放大你的脑洞！！！**\n\n### 应用场景-信息收集与统计\n\n\n注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~\n\n#### 编译时代码检查或统计\n\n统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~\n\n\t//示例代码  类统计\n\t@Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {\n        Messager messager = processingEnv.getMessager();\n        int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n        messager.printMessage(Diagnostic.Kind.NOTE,\n                \"Annotation class size = \" + size);\n    }\n\n代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？\n\n这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~\n\n（此处有点瞎扯淡了，一般代码检查都不会这么干）\n\n\t\n#### 运行时数据收集与统计\n\n通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。\n\n手写代码容易出错，交给APT来实现便可以将错误率降到最低。\n\n另外还有一个灵感来源于一个你不陌生的类：BuildConfig.\n\n在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。\n\n同理，APT也可以实现这样的功能。\n\n\n### 应用场景-事件代理\n\n此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。\n\n\t//示例代码\n\t@Override\n\tpublic void bind(final Finder finder, final T target, Object source) {\n    \t//定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    \tView view;\n\n    \t//暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    \tview = finder.findRequiredView(source, 2131558541, \"field 'accountEdit'\");\n\n    \t//target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    \ttarget.accountEdit = finder.castView(view, 2131558541, \"field 'accountEdit'\");\n\n    \tview = finder.findRequiredView(source, 2131558543, \"field 'forgetBtn' and method 'forgetOnClick'\");\n    \ttarget.forgetBtn = finder.castView(view, 2131558543, \"field 'forgetBtn'\");\n\n    \t//给view设置一个点击事件\n    \tview.setOnClickListener(\n            new butterknife.internal.DebouncingOnClickListener() {\n                @Override\n                public void doClick(android.view.View p0) {\n\n                    //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n                   target.forgetOnClick();\n\n                }\n            });\n\t}\n\t\n\n#### ButterKnife扩展\n\nButterKnife绑定View的同时，我们也可以附加一些操作。\n\n一个典型案例就是 前面博客提到的OnceClick\n\n在给View设置监听事件时，添加一些自定操作。\n\n\tview = finder.findViewById(source, 2131492945);\n        if (view != null) {\n            view.setOnClickListener(new View.OnClickListener() {\n                long time = 0L;\n                @Override\n                public void onClick(View v) {\n                    long temp = System.currentTimeMillis();\n                    if (temp - time >= intervalTime) {\n                        time = temp;\n                        target.once();\n                    }\n                }\n            });\n        }\n\n\n#### 其他属性（跨域）初始化\\赋值\n\nButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。\n\n举一个列子：\n\nIntent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。\n\nActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。\n\n### 应用场景-代理执行 or \"代码插入\"\n\n虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。\n\n####代理执行\n\n用注解修饰一系列方法，由APT来代理执行。\n\n此部分参考[CakeRun](https://github.com/lizhaoxuan/CakeRun)\n\n\tpublic class CrashApplication extends Application {\n\t\n\t\t@Override\n    \tpublic void onCreate() {\n        \tsuper.onCreate();\n        \t//初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        \t//某种程度实现了代码插入\n        \tCakeRun.getInstance().applicationInit();\n    \t}\n\t\n\t\t@AppInit(tag = 1, canSkip = true)\n    \tprotected void init1() {\n        \tLog.d(\"TAG\", \"init1()  将引起crash。非关键路径可以跳过\");\n        \tString s = null;\n        \tLog.d(\"TAG\", s);\n    \t}\n\n    \t@AsyncInit(tag = 2, packageName = {\"com.lizhaoxuan.cakerundemo.Lib1\", \"other packageName\"})\n    \tprotected void init2() {\n        \tLog.d(\"TAG\", \"AsyncInit2() 引起Crash ,关键路径不可跳过\");\n        \tLib1.AsyncInit();\n    \t}\n\n    \t@AppInit(tag = 3)\n    \tprotected void init3() {\n        \tLog.d(\"TAG\", \"init3() 未引起crash\");\n    \t}\n\n    \t@AppInit(tag = 4)\n    \tprotected void init4() {\n        \tLog.d(\"TAG\", \"init4() 未引起crash\");\n    \t}\n\t}\n\t\nAPT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。\n\n#### 代码插入AOP\n\n使用APT实现AOP\n\n因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick\n\t \n\t@CrashClick(id = R.id.btn, target = HomeActivity)\n\tpublic void startActivity() {\n  \t\t...\n        this.startActivity(intent);\n    }\n    \n但对于普通方法，可能就需要这样调用\n\n    protected void onCreate(Bundle savedInstanceState) {\n    \n    \t//...\n    \t\n    \t//原本是这样调用方法的\n        startHomeActivity();\n\n        //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n        //就需要这样调用\n        AptClient.doMethod(this,\"startHomeActivity\");\n\n    }\n\n    @DemoTest(method = \"startHomeActivity\")\n    protected void startHomeActivity() {\n\n    }\n\n\nAPT生成代码样式：\n\n\tpublic void doMethod(Object target){\n\t\tint temp;\n\t\tif(//一些逻辑条件){\n\t\t\t//执行前做一些操作，比如记录\n\t\t\ttemp = 2; \n\t\t\t//执行真正的方法\n\t\t\ttarget.startHomeActivity();\n\t\t}else{\n\t\t\t//这个方法有些问题不能执行\n\t\t}\n\t}\n\n\n### 应用场景-反射优化\n\n编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。\n\n#### EventBus优化\n\nEventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。\n\nAPT优化:\n\n- 使用编译时注解标记Event接收方法。\n\n- 通过APT+代码生成，生成对应代理类，并提取所有Event接收方法\n\n- 每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。\n\n\n### 应用场景-让代码返璞归真\n\n实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。\n\n运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。\n\n以ORM数据库框架为例。\n\n细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。\n\nOrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。\n\n而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！\n\n但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。\n\n**那么通过APT，则是一个很好的技术方案：CakeDao**\n\n[https://github.com/lizhaoxuan/CakeDao](https://github.com/lizhaoxuan/CakeDao)\n\n与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\t\n\n\n\n\n\n\n\n\n","slug":"apt_usage_scenario","published":1,"updated":"2017-01-16T05:13:24.000Z","_id":"cixzmux3j000gq4chv89hi8dm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？</p>\n<p>但就像我前面提到过的，<strong>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！</strong> </p>\n<p>APT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~</p>\n<p>（<strong>本系列所讲APT均泛指编译时注解+代码生成</strong>，虽然运行时注解也属APT）</p>\n<a id=\"more\"></a>\n<h3 id=\"APT优点\"><a href=\"#APT优点\" class=\"headerlink\" title=\"APT优点\"></a>APT优点</h3><ul>\n<li><p>对代码进行标记，在编译时收集信息，并做处理。</p>\n</li>\n<li><p>生成一套独立代码，辅助代码运行</p>\n</li>\n<li><p>生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便</p>\n</li>\n<li><p>更为可靠的自动代码生成</p>\n</li>\n<li><p>自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率</p>\n</li>\n</ul>\n<h3 id=\"APT缺点\"><a href=\"#APT缺点\" class=\"headerlink\" title=\"APT缺点\"></a>APT缺点</h3><ul>\n<li><p>APT往往容易被误解可以实现代码插入，然而事实是并不可以</p>\n</li>\n<li><p>APT可以自动生成代码，但在运行时却需要主动调用</p>\n</li>\n<li><p>与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板</p>\n</li>\n</ul>\n<h3 id=\"APT容易被你忽视的点\"><a href=\"#APT容易被你忽视的点\" class=\"headerlink\" title=\"APT容易被你忽视的点\"></a>APT容易被你忽视的点</h3><p>一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。</p>\n<p>产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。</p>\n<p>事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。</p>\n<p>说白了，编译时注解你也完全可以当反射来理解。</p>\n<p>APT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~<strong>一定要放大你的脑洞！！！</strong></p>\n<h3 id=\"应用场景-信息收集与统计\"><a href=\"#应用场景-信息收集与统计\" class=\"headerlink\" title=\"应用场景-信息收集与统计\"></a>应用场景-信息收集与统计</h3><p>注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~</p>\n<h4 id=\"编译时代码检查或统计\"><a href=\"#编译时代码检查或统计\" class=\"headerlink\" title=\"编译时代码检查或统计\"></a>编译时代码检查或统计</h4><p>统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~</p>\n<pre><code>//示例代码  类统计\n@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n    messager.printMessage(Diagnostic.Kind.NOTE,\n            &quot;Annotation class size = &quot; + size);\n}\n</code></pre><p>代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？</p>\n<p>这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~</p>\n<p>（此处有点瞎扯淡了，一般代码检查都不会这么干）</p>\n<h4 id=\"运行时数据收集与统计\"><a href=\"#运行时数据收集与统计\" class=\"headerlink\" title=\"运行时数据收集与统计\"></a>运行时数据收集与统计</h4><p>通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。</p>\n<p>手写代码容易出错，交给APT来实现便可以将错误率降到最低。</p>\n<p>另外还有一个灵感来源于一个你不陌生的类：BuildConfig.</p>\n<p>在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。</p>\n<p>同理，APT也可以实现这样的功能。</p>\n<h3 id=\"应用场景-事件代理\"><a href=\"#应用场景-事件代理\" class=\"headerlink\" title=\"应用场景-事件代理\"></a>应用场景-事件代理</h3><p>此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。</p>\n<pre><code>//示例代码\n@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n        new butterknife.internal.DebouncingOnClickListener() {\n            @Override\n            public void doClick(android.view.View p0) {\n\n                //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n               target.forgetOnClick();\n\n            }\n        });\n}\n</code></pre><h4 id=\"ButterKnife扩展\"><a href=\"#ButterKnife扩展\" class=\"headerlink\" title=\"ButterKnife扩展\"></a>ButterKnife扩展</h4><p>ButterKnife绑定View的同时，我们也可以附加一些操作。</p>\n<p>一个典型案例就是 前面博客提到的OnceClick</p>\n<p>在给View设置监听事件时，添加一些自定操作。</p>\n<pre><code>view = finder.findViewById(source, 2131492945);\n    if (view != null) {\n        view.setOnClickListener(new View.OnClickListener() {\n            long time = 0L;\n            @Override\n            public void onClick(View v) {\n                long temp = System.currentTimeMillis();\n                if (temp - time &gt;= intervalTime) {\n                    time = temp;\n                    target.once();\n                }\n            }\n        });\n    }\n</code></pre><h4 id=\"其他属性（跨域）初始化-赋值\"><a href=\"#其他属性（跨域）初始化-赋值\" class=\"headerlink\" title=\"其他属性（跨域）初始化\\赋值\"></a>其他属性（跨域）初始化\\赋值</h4><p>ButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。</p>\n<p>举一个列子：</p>\n<p>Intent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。</p>\n<p>ActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。</p>\n<h3 id=\"应用场景-代理执行-or-“代码插入”\"><a href=\"#应用场景-代理执行-or-“代码插入”\" class=\"headerlink\" title=\"应用场景-代理执行 or “代码插入”\"></a>应用场景-代理执行 or “代码插入”</h3><p>虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。</p>\n<p>####代理执行</p>\n<p>用注解修饰一系列方法，由APT来代理执行。</p>\n<p>此部分参考<a href=\"https://github.com/lizhaoxuan/CakeRun\" target=\"_blank\" rel=\"external\">CakeRun</a></p>\n<pre><code>public class CrashApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        //某种程度实现了代码插入\n        CakeRun.getInstance().applicationInit();\n    }\n\n    @AppInit(tag = 1, canSkip = true)\n    protected void init1() {\n        Log.d(&quot;TAG&quot;, &quot;init1()  将引起crash。非关键路径可以跳过&quot;);\n        String s = null;\n        Log.d(&quot;TAG&quot;, s);\n    }\n\n    @AsyncInit(tag = 2, packageName = {&quot;com.lizhaoxuan.cakerundemo.Lib1&quot;, &quot;other packageName&quot;})\n    protected void init2() {\n        Log.d(&quot;TAG&quot;, &quot;AsyncInit2() 引起Crash ,关键路径不可跳过&quot;);\n        Lib1.AsyncInit();\n    }\n\n    @AppInit(tag = 3)\n    protected void init3() {\n        Log.d(&quot;TAG&quot;, &quot;init3() 未引起crash&quot;);\n    }\n\n    @AppInit(tag = 4)\n    protected void init4() {\n        Log.d(&quot;TAG&quot;, &quot;init4() 未引起crash&quot;);\n    }\n}\n</code></pre><p>APT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。</p>\n<h4 id=\"代码插入AOP\"><a href=\"#代码插入AOP\" class=\"headerlink\" title=\"代码插入AOP\"></a>代码插入AOP</h4><p>使用APT实现AOP</p>\n<p>因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick</p>\n<pre><code>@CrashClick(id = R.id.btn, target = HomeActivity)\npublic void startActivity() {\n      ...\n    this.startActivity(intent);\n}\n</code></pre><p>但对于普通方法，可能就需要这样调用</p>\n<pre><code>protected void onCreate(Bundle savedInstanceState) {\n\n    //...\n\n    //原本是这样调用方法的\n    startHomeActivity();\n\n    //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n    //就需要这样调用\n    AptClient.doMethod(this,&quot;startHomeActivity&quot;);\n\n}\n\n@DemoTest(method = &quot;startHomeActivity&quot;)\nprotected void startHomeActivity() {\n\n}\n</code></pre><p>APT生成代码样式：</p>\n<pre><code>public void doMethod(Object target){\n    int temp;\n    if(//一些逻辑条件){\n        //执行前做一些操作，比如记录\n        temp = 2; \n        //执行真正的方法\n        target.startHomeActivity();\n    }else{\n        //这个方法有些问题不能执行\n    }\n}\n</code></pre><h3 id=\"应用场景-反射优化\"><a href=\"#应用场景-反射优化\" class=\"headerlink\" title=\"应用场景-反射优化\"></a>应用场景-反射优化</h3><p>编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。</p>\n<h4 id=\"EventBus优化\"><a href=\"#EventBus优化\" class=\"headerlink\" title=\"EventBus优化\"></a>EventBus优化</h4><p>EventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。</p>\n<p>APT优化:</p>\n<ul>\n<li><p>使用编译时注解标记Event接收方法。</p>\n</li>\n<li><p>通过APT+代码生成，生成对应代理类，并提取所有Event接收方法</p>\n</li>\n<li><p>每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。</p>\n</li>\n</ul>\n<h3 id=\"应用场景-让代码返璞归真\"><a href=\"#应用场景-让代码返璞归真\" class=\"headerlink\" title=\"应用场景-让代码返璞归真\"></a>应用场景-让代码返璞归真</h3><p>实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。</p>\n<p>运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。</p>\n<p>以ORM数据库框架为例。</p>\n<p>细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。</p>\n<p>OrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。</p>\n<p>而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！</p>\n<p>但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。</p>\n<p><strong>那么通过APT，则是一个很好的技术方案：CakeDao</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/CakeDao\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/CakeDao</a></p>\n<p>与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。</p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>如果你已经读完了前面的5章博客，相信你已经对APT整体已经比较熟悉了，所以，APT真的很简单对嘛？</p>\n<p>但就像我前面提到过的，<strong>APT是一套非常强大的机制，它唯一的限制在于你天马行空的设计！</strong> </p>\n<p>APT有着非常简单的技术实现，但其应用场景却着实有点尴尬。我一直期望可以探索出ButterKnife和EventBus以外的应用场景，却始终未能如愿。姑且把我目前总结的成果列举，共勉~</p>\n<p>（<strong>本系列所讲APT均泛指编译时注解+代码生成</strong>，虽然运行时注解也属APT）</p>","more":"<h3 id=\"APT优点\"><a href=\"#APT优点\" class=\"headerlink\" title=\"APT优点\"></a>APT优点</h3><ul>\n<li><p>对代码进行标记，在编译时收集信息，并做处理。</p>\n</li>\n<li><p>生成一套独立代码，辅助代码运行</p>\n</li>\n<li><p>生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便</p>\n</li>\n<li><p>更为可靠的自动代码生成</p>\n</li>\n<li><p>自动生成的代码可以最大程度的简单粗暴，在不必考虑编写效率的情况下提高运行效率</p>\n</li>\n</ul>\n<h3 id=\"APT缺点\"><a href=\"#APT缺点\" class=\"headerlink\" title=\"APT缺点\"></a>APT缺点</h3><ul>\n<li><p>APT往往容易被误解可以实现代码插入，然而事实是并不可以</p>\n</li>\n<li><p>APT可以自动生成代码，但在运行时却需要主动调用</p>\n</li>\n<li><p>与GreenDao不同，GreenDao代码生成于app目录下，可以在编写时调用并修改。APT代码生成于Build目录，只能在运行时通过接口等方式进行操作。这意味着生成的代码必须要有一套固定的模板</p>\n</li>\n</ul>\n<h3 id=\"APT容易被你忽视的点\"><a href=\"#APT容易被你忽视的点\" class=\"headerlink\" title=\"APT容易被你忽视的点\"></a>APT容易被你忽视的点</h3><p>一个非常容易被你误解的点：只有被注解标记了的类或方法等，才可以被处理或收集信息。或者这样说，想要收集一些信息，只能先用注解修饰它。</p>\n<p>产生这样误解容易引起一个问题：你可能会觉得一个需要大量注解的框架体验不好而决定放弃。</p>\n<p>事实是怎么样呢？想一下同源的运行时注解+反射。反射可以通过一个类名便获取一个类的所有信息（方法、属性、方法参数等等等）。编译时注解也是可以的。当你修饰一个类时，可以通过类的Element获得类的属性和方法的Element,通过属性的Element可以获得属性所属类的信息，通过方法的Element可以获得所属类和其参数的信息。</p>\n<p>说白了，编译时注解你也完全可以当反射来理解。</p>\n<p>APT的优缺点都非常明显，优点足够了，缺点也不致命，只是让你在设计你的框架，选择技术方案时注意就好了。那么基于上面列出的几点，几个通用的应用场景就可以被设想了~<strong>一定要放大你的脑洞！！！</strong></p>\n<h3 id=\"应用场景-信息收集与统计\"><a href=\"#应用场景-信息收集与统计\" class=\"headerlink\" title=\"应用场景-信息收集与统计\"></a>应用场景-信息收集与统计</h3><p>注解的主要作用就是用于标记，所以最基础的应用就是信息收集与统计。可能你还是有点懵懵懂懂，没关系，举例子嘛~</p>\n<h4 id=\"编译时代码检查或统计\"><a href=\"#编译时代码检查或统计\" class=\"headerlink\" title=\"编译时代码检查或统计\"></a>编译时代码检查或统计</h4><p>统计可能会一点奇怪：看看我这次写了多少个方法呀，多少个类呀。回头可以给BOSS说一下，以后KPI用方法数来计算？抱歉我的脑洞也就这样了，你再扩展一下~</p>\n<pre><code>//示例代码  类统计\n@Override\npublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {\n    Messager messager = processingEnv.getMessager();\n    int size = env.getElementsAnnotatedWith(GetMsg.class).size();\n    messager.printMessage(Diagnostic.Kind.NOTE,\n            &quot;Annotation class size = &quot; + size);\n}\n</code></pre><p>代码检查就比较靠谱一点了：类名是不是首字母大写的驼峰式啊？方法名有没有问题呀？常量是不是全大写啊？</p>\n<p>这里你可能比较好奇，我怎么检查啊，难道要给每个类都加一个注解嘛？不不不，你看刚刚我们才讲了：【APT容易被你忽视的点】，只需要一个就够了~</p>\n<p>（此处有点瞎扯淡了，一般代码检查都不会这么干）</p>\n<h4 id=\"运行时数据收集与统计\"><a href=\"#运行时数据收集与统计\" class=\"headerlink\" title=\"运行时数据收集与统计\"></a>运行时数据收集与统计</h4><p>通常来说，最容易想到的一个应用方向就是生成一个类似于字符串到类的对应Map结构。</p>\n<p>手写代码容易出错，交给APT来实现便可以将错误率降到最低。</p>\n<p>另外还有一个灵感来源于一个你不陌生的类：BuildConfig.</p>\n<p>在BuildConfig中存放着一些静态属性，而这些静态属性值是Grandle编译时赋予的。可能这里你最常用的就是 BuildConfig.DEBUG了。</p>\n<p>同理，APT也可以实现这样的功能。</p>\n<h3 id=\"应用场景-事件代理\"><a href=\"#应用场景-事件代理\" class=\"headerlink\" title=\"应用场景-事件代理\"></a>应用场景-事件代理</h3><p>此类应用场景的标志框架是ButterKnife。通过生成的代码代理实现View绑定。</p>\n<pre><code>//示例代码\n@Override\npublic void bind(final Finder finder, final T target, Object source) {\n    //定义了一个View对象引用，这个对象引用被重复使用了（这可是一个偷懒的写法哦~）\n    View view;\n\n    //暂时不管Finder是个什么东西，反正就是一种类似于findViewById的操作。\n    view = finder.findRequiredView(source, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    //target就是我们的ForgetActivity，为ForgetActivity中的accountEdit赋值\n    target.accountEdit = finder.castView(view, 2131558541, &quot;field &apos;accountEdit&apos;&quot;);\n\n    view = finder.findRequiredView(source, 2131558543, &quot;field &apos;forgetBtn&apos; and method &apos;forgetOnClick&apos;&quot;);\n    target.forgetBtn = finder.castView(view, 2131558543, &quot;field &apos;forgetBtn&apos;&quot;);\n\n    //给view设置一个点击事件\n    view.setOnClickListener(\n        new butterknife.internal.DebouncingOnClickListener() {\n            @Override\n            public void doClick(android.view.View p0) {\n\n                //forgetOnClick()就是我们在ForgetActivity中写得事件方法。\n               target.forgetOnClick();\n\n            }\n        });\n}\n</code></pre><h4 id=\"ButterKnife扩展\"><a href=\"#ButterKnife扩展\" class=\"headerlink\" title=\"ButterKnife扩展\"></a>ButterKnife扩展</h4><p>ButterKnife绑定View的同时，我们也可以附加一些操作。</p>\n<p>一个典型案例就是 前面博客提到的OnceClick</p>\n<p>在给View设置监听事件时，添加一些自定操作。</p>\n<pre><code>view = finder.findViewById(source, 2131492945);\n    if (view != null) {\n        view.setOnClickListener(new View.OnClickListener() {\n            long time = 0L;\n            @Override\n            public void onClick(View v) {\n                long temp = System.currentTimeMillis();\n                if (temp - time &gt;= intervalTime) {\n                    time = temp;\n                    target.once();\n                }\n            }\n        });\n    }\n</code></pre><h4 id=\"其他属性（跨域）初始化-赋值\"><a href=\"#其他属性（跨域）初始化-赋值\" class=\"headerlink\" title=\"其他属性（跨域）初始化\\赋值\"></a>其他属性（跨域）初始化\\赋值</h4><p>ButterKnife的核心便是View的初始化操作，View可以初始化，其他对象的初始化当然也不在话下。</p>\n<p>举一个列子：</p>\n<p>Intent不能传输过大的数据量，那么在跳转Activity时有这大数据量传输的需求怎么办? APT遍可以解决。其核心原理通ButterKnife相同。</p>\n<p>ActivityA向ActivityB的代理类ProxyB赋值，ProxyB初始化ActivityB的属性。</p>\n<h3 id=\"应用场景-代理执行-or-“代码插入”\"><a href=\"#应用场景-代理执行-or-“代码插入”\" class=\"headerlink\" title=\"应用场景-代理执行 or “代码插入”\"></a>应用场景-代理执行 or “代码插入”</h3><p>虽然前面有说过APT并不能像Aspectj一样实现代码插入，但是可以使用某种变种方式实现，就是使用上怪怪的。</p>\n<p>####代理执行</p>\n<p>用注解修饰一系列方法，由APT来代理执行。</p>\n<p>此部分参考<a href=\"https://github.com/lizhaoxuan/CakeRun\">CakeRun</a></p>\n<pre><code>public class CrashApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //初始化APT框架，由Apt代理类来调用下列init方法，并在其中做些处理\n        //某种程度实现了代码插入\n        CakeRun.getInstance().applicationInit();\n    }\n\n    @AppInit(tag = 1, canSkip = true)\n    protected void init1() {\n        Log.d(&quot;TAG&quot;, &quot;init1()  将引起crash。非关键路径可以跳过&quot;);\n        String s = null;\n        Log.d(&quot;TAG&quot;, s);\n    }\n\n    @AsyncInit(tag = 2, packageName = {&quot;com.lizhaoxuan.cakerundemo.Lib1&quot;, &quot;other packageName&quot;})\n    protected void init2() {\n        Log.d(&quot;TAG&quot;, &quot;AsyncInit2() 引起Crash ,关键路径不可跳过&quot;);\n        Lib1.AsyncInit();\n    }\n\n    @AppInit(tag = 3)\n    protected void init3() {\n        Log.d(&quot;TAG&quot;, &quot;init3() 未引起crash&quot;);\n    }\n\n    @AppInit(tag = 4)\n    protected void init4() {\n        Log.d(&quot;TAG&quot;, &quot;init4() 未引起crash&quot;);\n    }\n}\n</code></pre><p>APT生成的代理类按照一定次序依次执行修饰了注解的初始化方法，并且在其中增加了一些逻辑判断，来决定是否要执行这个方法。从而绕过发生Crash的类。</p>\n<h4 id=\"代码插入AOP\"><a href=\"#代码插入AOP\" class=\"headerlink\" title=\"代码插入AOP\"></a>代码插入AOP</h4><p>使用APT实现AOP</p>\n<p>因为APT限制，通过click事件做切面，是最简单的，就是我们上面讲的 OnceClick</p>\n<pre><code>@CrashClick(id = R.id.btn, target = HomeActivity)\npublic void startActivity() {\n      ...\n    this.startActivity(intent);\n}\n</code></pre><p>但对于普通方法，可能就需要这样调用</p>\n<pre><code>protected void onCreate(Bundle savedInstanceState) {\n\n    //...\n\n    //原本是这样调用方法的\n    startHomeActivity();\n\n    //使用了APT，需要在调用方法时插入一些逻辑，比如做AOP切面\n    //就需要这样调用\n    AptClient.doMethod(this,&quot;startHomeActivity&quot;);\n\n}\n\n@DemoTest(method = &quot;startHomeActivity&quot;)\nprotected void startHomeActivity() {\n\n}\n</code></pre><p>APT生成代码样式：</p>\n<pre><code>public void doMethod(Object target){\n    int temp;\n    if(//一些逻辑条件){\n        //执行前做一些操作，比如记录\n        temp = 2; \n        //执行真正的方法\n        target.startHomeActivity();\n    }else{\n        //这个方法有些问题不能执行\n    }\n}\n</code></pre><h3 id=\"应用场景-反射优化\"><a href=\"#应用场景-反射优化\" class=\"headerlink\" title=\"应用场景-反射优化\"></a>应用场景-反射优化</h3><p>编译时注解与反射异曲同工，只不过反射是在运行时获取类信息，编译时注解是在编译时获取类信息。所以反射可以做到事情，APT也是可以做到的。</p>\n<h4 id=\"EventBus优化\"><a href=\"#EventBus优化\" class=\"headerlink\" title=\"EventBus优化\"></a>EventBus优化</h4><p>EventBus效率的桎梏点在于需要通过反射遍历类中的Event接收方法，虽然做了缓存优化，但对效率的影响还是比较严重的。如果使用APT进行优化，EventBus最大的缺点就被解决了。</p>\n<p>APT优化:</p>\n<ul>\n<li><p>使用编译时注解标记Event接收方法。</p>\n</li>\n<li><p>通过APT+代码生成，生成对应代理类，并提取所有Event接收方法</p>\n</li>\n<li><p>每次注册不在需要在原本的类里寻找Event接收方法，而是直接注册代理类。</p>\n</li>\n</ul>\n<h3 id=\"应用场景-让代码返璞归真\"><a href=\"#应用场景-让代码返璞归真\" class=\"headerlink\" title=\"应用场景-让代码返璞归真\"></a>应用场景-让代码返璞归真</h3><p>实际项目开发中，往往为了提高开发效率，会牺牲一点性能。最简单的例子就是运行时注解的大量使用。</p>\n<p>运行时注解的大量使用减少了很多代码的编写，但谁都知道这是有性能损耗的。不过权衡利弊下，我们选择了妥协。</p>\n<p>以ORM数据库框架为例。</p>\n<p>细数目前Android主流的数据库框架：GreenDao、OrmLite、Active Android 。</p>\n<p>OrmLite、Active Android均使用了运行时注解作为辅助从而实现了ORM。极大地简化了数据库操作，在使用上是非常轻松便捷的。但也因为使用运行时注解，用到了反射，导致了数据库操作性能的下降。</p>\n<p>而作为数据库操作速度最快的GreenDao，它的原理是通过java工程替我们在项目中写了一套代码，一套返璞归真的数据库操作代码。没有反射的影响，采用最普通的方式操作数据库，它的速度是最快的！</p>\n<p>但缺点是GreenDao的使用太奇葩了……导致初学GreenDao很痛苦。这是一个很致命的缺点。</p>\n<p><strong>那么通过APT，则是一个很好的技术方案：CakeDao</strong></p>\n<p><a href=\"https://github.com/lizhaoxuan/CakeDao\">https://github.com/lizhaoxuan/CakeDao</a></p>\n<p>与GreenDao同理，自动生成最普通的数据库操作代码，从而提高数据库操作效率。但因为APT是在编译时自动进行的，所以他的学习成本是非常小的。</p>"},{"title":"小米神隐模式破解（反系统息屏后网络中断）","date":"2016-01-17T08:20:58.000Z","author":"暴打小女孩","_content":"\n转载请注明出处：https://lizhaoxuan.github.io\n\n*android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓*\n\n### 背景\n\n  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。\n  \n  在手机息屏后，未加入白名单的应用将会被禁止访问网络。\n  \n  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。\n  \n  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!\n  \n  <!-- more -->\n  \n  \"我们联系下MIUI官方，把我们默认加白名单行不行？\"\t\n  \n  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”\n  \n  “让设计做引导页”\n  \n  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”\n  \n  \n  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）\n  \n **完了，你说怎么办吧？**\n \n **注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！**\n \n **所以我们这里讨论的是，使用alarmManager做定时任务的情况**\n \n### 解决思路\n\n#### 方案1\n\n提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！\n\n额~既然这么简单，那还叫问题吗？\n\n事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。\n\n\n\n#### 方案2\n\nOK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？\n\n1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。\n\n2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。  \n\t点亮代码是这个：\n\t\n\t\tPowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n                AliveApplication.getContext().POWER_SERVICE);\n    \tPowerManager.WakeLock mWakelock = pm.newWakeLock(\n                PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, \"target\");\n    \tmWakelock.acquire();\n    \tmWakelock.release();\n\n\t\t//记得权限\n\t\t<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n\n\t没错，还是PowerManager ，但换了一个参数：\n\n\t\tPowerManager.SCREEN_DIM_WAKE_LOCK\n\t\n\t奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n\n3 ： PowerManager的几个参数及解释：\n\n\t\t//保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    \tPARTIAL_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    \tSCREEN_DIM_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    \tSCREEN_BRIGHT_WAKE_LOCK\n    \t//保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    \tFULL_WAKE_LOCK\n    \t/**\n     \t * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n     \t * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n     \t * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n     \t */\n    \tACQUIRE_CAUSES_WAKEUP\n    \t/**\n     \t * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n     \t * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n    \t */\n    \tON_AFTER_RELEASE\n\n\t结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n\t\n4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！\n\n最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 \n\t\n一个有趣的现象，不知道是系统差别还是Android版本差别。\n\t\n魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。\n\t\n酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。\n\t\n暂时只测试了这两款机器。\n\t\n到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了\n\t\n### 保证用户体验下的解决方案\n- 1.监听网络请求失败后做点亮准备。注意是**“准备“**”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。\n\n- 2.准备后，先做请求积累，当到一个**临界值**时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。\n\n- 3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，**监听屏幕点亮广播**，在用户手动点亮、其他应用点亮时做网络请求\n\n- 4.如果你的请求真的很急切，且**略有些频繁**，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。\n\n- 5.如果你的需求迫切到，**必须定时定点**，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。\n\n- 6.**白名单导航页**还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。\n\n- 7.**公关**也是要的，如果可以直接被系统默认收进白名单皆大欢喜\n\n- 8.记得**区分**是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！\n\n- 9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。\n\n- 10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！\n\n\n\n### 示例代码\n\n最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~\n\n[https://github.com/lizhaoxuan/IamAlive](https://github.com/lizhaoxuan/IamAlive)\n\n对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^\n\n\n\n\n\n\n\n\n\n\n \n","source":"_posts/shenyingpojie.md","raw":"---\ntitle: 小米神隐模式破解（反系统息屏后网络中断）\ndate: 2016-01-17 16:20:58\nauthor : 暴打小女孩\n\ntags: 开发经验\n---\n\n转载请注明出处：https://lizhaoxuan.github.io\n\n*android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓*\n\n### 背景\n\n  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。\n  \n  在手机息屏后，未加入白名单的应用将会被禁止访问网络。\n  \n  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。\n  \n  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!\n  \n  <!-- more -->\n  \n  \"我们联系下MIUI官方，把我们默认加白名单行不行？\"\t\n  \n  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”\n  \n  “让设计做引导页”\n  \n  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”\n  \n  \n  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）\n  \n **完了，你说怎么办吧？**\n \n **注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！**\n \n **所以我们这里讨论的是，使用alarmManager做定时任务的情况**\n \n### 解决思路\n\n#### 方案1\n\n提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！\n\n额~既然这么简单，那还叫问题吗？\n\n事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。\n\n\n\n#### 方案2\n\nOK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？\n\n1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。\n\n2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。  \n\t点亮代码是这个：\n\t\n\t\tPowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n                AliveApplication.getContext().POWER_SERVICE);\n    \tPowerManager.WakeLock mWakelock = pm.newWakeLock(\n                PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, \"target\");\n    \tmWakelock.acquire();\n    \tmWakelock.release();\n\n\t\t//记得权限\n\t\t<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n\n\t没错，还是PowerManager ，但换了一个参数：\n\n\t\tPowerManager.SCREEN_DIM_WAKE_LOCK\n\t\n\t奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n\n3 ： PowerManager的几个参数及解释：\n\n\t\t//保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    \tPARTIAL_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    \tSCREEN_DIM_WAKE_LOCK\n    \t//保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    \tSCREEN_BRIGHT_WAKE_LOCK\n    \t//保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    \tFULL_WAKE_LOCK\n    \t/**\n     \t * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n     \t * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n     \t * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n     \t */\n    \tACQUIRE_CAUSES_WAKEUP\n    \t/**\n     \t * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n     \t * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n    \t */\n    \tON_AFTER_RELEASE\n\n\t结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n\t\n4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！\n\n最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 \n\t\n一个有趣的现象，不知道是系统差别还是Android版本差别。\n\t\n魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。\n\t\n酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。\n\t\n暂时只测试了这两款机器。\n\t\n到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了\n\t\n### 保证用户体验下的解决方案\n- 1.监听网络请求失败后做点亮准备。注意是**“准备“**”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。\n\n- 2.准备后，先做请求积累，当到一个**临界值**时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。\n\n- 3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，**监听屏幕点亮广播**，在用户手动点亮、其他应用点亮时做网络请求\n\n- 4.如果你的请求真的很急切，且**略有些频繁**，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。\n\n- 5.如果你的需求迫切到，**必须定时定点**，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。\n\n- 6.**白名单导航页**还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。\n\n- 7.**公关**也是要的，如果可以直接被系统默认收进白名单皆大欢喜\n\n- 8.记得**区分**是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！\n\n- 9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。\n\n- 10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！\n\n\n\n### 示例代码\n\n最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~\n\n[https://github.com/lizhaoxuan/IamAlive](https://github.com/lizhaoxuan/IamAlive)\n\n对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^\n\n\n\n\n\n\n\n\n\n\n \n","slug":"shenyingpojie","published":1,"updated":"2017-01-16T05:12:47.000Z","_id":"cixzmux3k000hq4chd2jdkwo5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p><em>android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓</em></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。</p>\n<p>  在手机息屏后，未加入白名单的应用将会被禁止访问网络。</p>\n<p>  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。</p>\n<p>  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!</p>\n  <a id=\"more\"></a>\n<p>  “我们联系下MIUI官方，把我们默认加白名单行不行？”    </p>\n<p>  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”</p>\n<p>  “让设计做引导页”</p>\n<p>  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”</p>\n<p>  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）</p>\n<p> <strong>完了，你说怎么办吧？</strong></p>\n<p> <strong>注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！</strong></p>\n<p> <strong>所以我们这里讨论的是，使用alarmManager做定时任务的情况</strong></p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h4><p>提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！</p>\n<p>额~既然这么简单，那还叫问题吗？</p>\n<p>事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h4><p>OK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？</p>\n<p>1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。</p>\n<p>2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。<br>    点亮代码是这个：</p>\n<pre><code>    PowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n            AliveApplication.getContext().POWER_SERVICE);\n    PowerManager.WakeLock mWakelock = pm.newWakeLock(\n            PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;target&quot;);\n    mWakelock.acquire();\n    mWakelock.release();\n\n    //记得权限\n    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;\n\n没错，还是PowerManager ，但换了一个参数：\n\n    PowerManager.SCREEN_DIM_WAKE_LOCK\n\n奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n</code></pre><p>3 ： PowerManager的几个参数及解释：</p>\n<pre><code>    //保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    PARTIAL_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    SCREEN_DIM_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    SCREEN_BRIGHT_WAKE_LOCK\n    //保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    FULL_WAKE_LOCK\n    /**\n      * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n      * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n      * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n      */\n    ACQUIRE_CAUSES_WAKEUP\n    /**\n      * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n      * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n     */\n    ON_AFTER_RELEASE\n\n结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n</code></pre><p>4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！</p>\n<p>最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 </p>\n<p>一个有趣的现象，不知道是系统差别还是Android版本差别。</p>\n<p>魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。</p>\n<p>酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。</p>\n<p>暂时只测试了这两款机器。</p>\n<p>到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了</p>\n<h3 id=\"保证用户体验下的解决方案\"><a href=\"#保证用户体验下的解决方案\" class=\"headerlink\" title=\"保证用户体验下的解决方案\"></a>保证用户体验下的解决方案</h3><ul>\n<li><p>1.监听网络请求失败后做点亮准备。注意是<strong>“准备“</strong>”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。</p>\n</li>\n<li><p>2.准备后，先做请求积累，当到一个<strong>临界值</strong>时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。</p>\n</li>\n<li><p>3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，<strong>监听屏幕点亮广播</strong>，在用户手动点亮、其他应用点亮时做网络请求</p>\n</li>\n<li><p>4.如果你的请求真的很急切，且<strong>略有些频繁</strong>，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。</p>\n</li>\n<li><p>5.如果你的需求迫切到，<strong>必须定时定点</strong>，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。</p>\n</li>\n<li><p>6.<strong>白名单导航页</strong>还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。</p>\n</li>\n<li><p>7.<strong>公关</strong>也是要的，如果可以直接被系统默认收进白名单皆大欢喜</p>\n</li>\n<li><p>8.记得<strong>区分</strong>是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！</p>\n</li>\n<li><p>9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。</p>\n</li>\n<li><p>10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！</p>\n</li>\n</ul>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~</p>\n<p><a href=\"https://github.com/lizhaoxuan/IamAlive\" target=\"_blank\" rel=\"external\">https://github.com/lizhaoxuan/IamAlive</a></p>\n<p>对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^</p>\n","excerpt":"<p>转载请注明出处：<a href=\"https://lizhaoxuan.github.io\">https://lizhaoxuan.github.io</a></p>\n<p><em>android真的被玩坏了，android界有一场永远停不下来的攻防战，攻和防都流氓</em></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>  做为用户，你肯定抱怨过手机上有太多杀不死的应用浪费你的内存，浪费内存就算了，他们还跑你的流量。OK，为了提供更好的用户体验，以MIUI为首的神隐模式（因为我只知道MIUI的叫神隐……就先以他为首吧，有了解谁先出的快告诉我），各个系统厂商都推出自己的XX模式。</p>\n<p>  在手机息屏后，未加入白名单的应用将会被禁止访问网络。</p>\n<p>  嗯……这个做的好！用户这回开心了呀:-D。（虽然好像有人抱怨神隐有Bug）。</p>\n<p>  可是开发者哭了啊，老板一定要让我完成这个需求啊，隔段时间上传或获取个数据呀，你给我断网了我咋办？系统级屏蔽的啊这是，我没法搞了啊……联系运营产品公关还有各种大BOSS!</p>","more":"<p>  “我们联系下MIUI官方，把我们默认加白名单行不行？”    </p>\n<p>  “先不说MIUI给不给，除了MIUI还有别家系统啊，而且谁都联系都能加白名单，这模式还有啥用”</p>\n<p>  “让设计做引导页”</p>\n<p>  “系统真的是太多了啊……同一个系统不同版本还有差别啊……”</p>\n<p>  （题外话，话说360电脑版，打开USB调试的引导页真心很屌啊，大部分手机不同型号好像都做了。）</p>\n<p> <strong>完了，你说怎么办吧？</strong></p>\n<p> <strong>注：息屏后不能访问网络的实质是，系统休眠后，应用唤醒无法访问网络，所以用轮询执行任务的，是不会出现这种现象的，因为轮询不会让系统休眠，似乎问题解决了是吗？哼哼，你就等着被用户卸载吧，电量哗哗往下掉啊！</strong></p>\n<p> <strong>所以我们这里讨论的是，使用alarmManager做定时任务的情况</strong></p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h4><p>提到息屏后访问不了网络，你第一个想到肯定是系统休眠了，这个简单啊，唤醒不就好了么。PowerManager有个啥属性来着？用这个就可以了！！</p>\n<p>额~既然这么简单，那还叫问题吗？</p>\n<p>事实是，系统是唤醒了，但是网络就是被中断了，同时被中断的还有GPS，还有什么被禁止的就不清楚了，感兴趣的自己试一下。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h4><p>OK，默默的“偷”流量是不行了，我们回归本源想想，问题是息屏后~息屏后~息屏后~诶？同时，leader还提供了一个信息，息屏后收不到推送，但是点亮后，推送都过来了。那我们亮屏了试试？</p>\n<p>1 ： 时刻关注Log日志，在网络请求失败后，我们手动点亮屏幕。结果是： 请求成功了~原来问题在这里。</p>\n<p>2 ： 可是手动点亮屏幕不是我们的需求啊，怎么才能自动点亮呢？前段时间做新通知点亮屏幕了，用这个试试。try catch 里，当访问失败进入catch时，我们点亮屏幕并重新请求。<br>    点亮代码是这个：</p>\n<pre><code>    PowerManager pm = (PowerManager) AliveApplication.getContext().getSystemService(\n            AliveApplication.getContext().POWER_SERVICE);\n    PowerManager.WakeLock mWakelock = pm.newWakeLock(\n            PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;target&quot;);\n    mWakelock.acquire();\n    mWakelock.release();\n\n    //记得权限\n    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;\n\n没错，还是PowerManager ，但换了一个参数：\n\n    PowerManager.SCREEN_DIM_WAKE_LOCK\n\n奇迹发生了，点亮屏幕后，网络请求成功了。看来这条路没错,要是可以在用户不知情的情况下做就好了，PowerManager还有好几个参数，我们换别的试试？\n</code></pre><p>3 ： PowerManager的几个参数及解释：</p>\n<pre><code>    //保持CPU 运转，屏幕和键盘灯有可能是关闭的。\n    PARTIAL_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯\n    SCREEN_DIM_WAKE_LOCK\n    //保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯\n    SCREEN_BRIGHT_WAKE_LOCK\n    //保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度\n    FULL_WAKE_LOCK\n    /**\n      * 正常唤醒锁实际上并不打开照明。相反，一旦打开他们会一直仍然保持(例如来世user的activity)。\n      * 当获得wakelock，这个标志会使屏幕或/和键盘立即打开。\n      * 一个典型的使用就是可以立即看到那些对用户重要的通知。\n      */\n    ACQUIRE_CAUSES_WAKEUP\n    /**\n      * 设置了这个标志，当wakelock释放时用户activity计时器会被重置，导致照明持续一段时间。\n      * 如果你在wacklock条件中循环，这个可以用来减少闪烁\n     */\n    ON_AFTER_RELEASE\n\n结果是令人失望的，似乎只有在屏幕点亮后网络才能恢复。再换个思路试试。\n</code></pre><p>4 ： 监听屏幕点亮与关闭广播，在点亮前，先将屏幕亮度调到0，息屏后，再恢复正常。似乎很可行啊！！</p>\n<p>最后的结果失败的，所以这里也不放调节屏幕亮度的代码了。 </p>\n<p>一个有趣的现象，不知道是系统差别还是Android版本差别。</p>\n<p>魅族5.0上，可以实现亮度为0点亮，但是息屏后亮度恢复，屏幕又一下亮了。</p>\n<p>酷派 4.1 上，点亮屏幕和调整屏幕亮度没有关系，点亮后依然以之前设置亮度为准。</p>\n<p>暂时只测试了这两款机器。</p>\n<p>到这里，基本上就已经放弃“暗”的方案了。只能“明”着来了。那这样就要考虑用户体验了</p>\n<h3 id=\"保证用户体验下的解决方案\"><a href=\"#保证用户体验下的解决方案\" class=\"headerlink\" title=\"保证用户体验下的解决方案\"></a>保证用户体验下的解决方案</h3><ul>\n<li><p>1.监听网络请求失败后做点亮准备。注意是<strong>“准备“</strong>”，并不是失败后立马点亮，这个太吓人了，手机放那了不停闪来闪去。</p>\n</li>\n<li><p>2.准备后，先做请求积累，当到一个<strong>临界值</strong>时，临界值依具体业务需求而定，依然无法请求，再点亮屏幕一次性发送。</p>\n</li>\n<li><p>3.利用一切可以利用的资源，点亮屏幕的操作并不是只有你的APP会做，<strong>监听屏幕点亮广播</strong>，在用户手动点亮、其他应用点亮时做网络请求</p>\n</li>\n<li><p>4.如果你的请求真的很急切，且<strong>略有些频繁</strong>，可以加入适当掩饰。比如弹一个本地已经缓存好的通知出来。如果通知并不是很重要，息屏后建议自动清除。</p>\n</li>\n<li><p>5.如果你的需求迫切到，<strong>必须定时定点</strong>，那么我的建议是向用户坦白，在什么工作情况下，您的屏幕将会自动被点亮。</p>\n</li>\n<li><p>6.<strong>白名单导航页</strong>还是要做的，毕竟进了白名单就没有那么多事了。点亮屏幕只是一个缓冲之计。</p>\n</li>\n<li><p>7.<strong>公关</strong>也是要的，如果可以直接被系统默认收进白名单皆大欢喜</p>\n</li>\n<li><p>8.记得<strong>区分</strong>是当前无网络还是被屏蔽了，如果用户就是没开数据和wifi，你不停的在闪屏幕，不卸载才怪！</p>\n</li>\n<li><p>9.并不会息屏后立刻断网，还可以活2-3分钟，有时候5-7分钟也是有可能的，所以事情情况并没有那么严峻。</p>\n</li>\n<li><p>10.无论是Timer还是线程Sleep，都可以保证系统一直在唤醒状态，但强烈不建议这样做，手机时刻保持唤醒状态，是非常非常耗电的！</p>\n</li>\n</ul>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>最后，废话说了这么多，直接上Demo代码啦。代码很简单，里面都写好了注释，具体用户体验逻辑还要Developers 自己添加哦~</p>\n<p><a href=\"https://github.com/lizhaoxuan/IamAlive\">https://github.com/lizhaoxuan/IamAlive</a></p>\n<p>对了，还要感谢我的Android组Leader本篇文章的最大贡献者 锦洋大哥 ^.^</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cixzmux2s0000q4chvmenediw","tag_id":"cixzmux330002q4chwn3dkpr1","_id":"cixzmux3a0007q4chx5t8go3r"},{"post_id":"cixzmux2x0001q4chtp1qazq2","tag_id":"cixzmux330002q4chwn3dkpr1","_id":"cixzmux3g000bq4ch651miimp"},{"post_id":"cixzmux350003q4ch5zg378sh","tag_id":"cixzmux330002q4chwn3dkpr1","_id":"cixzmux3j000fq4chl37718qz"},{"post_id":"cixzmux360004q4chuuaml16z","tag_id":"cixzmux3h000dq4chfvfdqh6y","_id":"cixzmux3m000jq4chhnkhxr8r"},{"post_id":"cixzmux380006q4chllhwxoyo","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3o000lq4ch0bnws3mg"},{"post_id":"cixzmux3b0008q4chwm72lz03","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3p000nq4chbv1blm2t"},{"post_id":"cixzmux3f000aq4chej2fjj0d","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3t000pq4chay974uvz"},{"post_id":"cixzmux3g000cq4ch7v01ookx","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3v000rq4chyo6poci7"},{"post_id":"cixzmux3i000eq4chyk15jcx3","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3x000tq4choakksrmf"},{"post_id":"cixzmux3j000gq4chv89hi8dm","tag_id":"cixzmux3l000iq4ch289jly58","_id":"cixzmux3x000vq4chralf9lyq"},{"post_id":"cixzmux3k000hq4chd2jdkwo5","tag_id":"cixzmux3x000uq4chvvhsdlgq","_id":"cixzmux3y000wq4ch89zk0ies"}],"Tag":[{"name":"性能优化","_id":"cixzmux330002q4chwn3dkpr1"},{"name":"GC","_id":"cixzmux3h000dq4chfvfdqh6y"},{"name":"APT","_id":"cixzmux3l000iq4ch289jly58"},{"name":"开发经验","_id":"cixzmux3x000uq4chvvhsdlgq"}]}}